// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/NpoolPlatform/kunman/middleware/billing/db/ent/generated/addon"
	"github.com/NpoolPlatform/kunman/middleware/billing/db/ent/generated/exchange"
	"github.com/NpoolPlatform/kunman/middleware/billing/db/ent/generated/predicate"
	"github.com/NpoolPlatform/kunman/middleware/billing/db/ent/generated/subscription"
	"github.com/NpoolPlatform/kunman/middleware/billing/db/ent/generated/usercreditrecord"
	"github.com/NpoolPlatform/kunman/middleware/billing/db/ent/generated/usersubscription"
	"github.com/NpoolPlatform/kunman/middleware/billing/db/ent/generated/usersubscriptionchange"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddon                  = "Addon"
	TypeExchange               = "Exchange"
	TypeSubscription           = "Subscription"
	TypeUserCreditRecord       = "UserCreditRecord"
	TypeUserSubscription       = "UserSubscription"
	TypeUserSubscriptionChange = "UserSubscriptionChange"
)

// AddonMutation represents an operation that mutates the Addon nodes in the graph.
type AddonMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	usd_price     *decimal.Decimal
	credit        *uint32
	addcredit     *int32
	sort_order    *uint32
	addsort_order *int32
	enabled       *bool
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Addon, error)
	predicates    []predicate.Addon
}

var _ ent.Mutation = (*AddonMutation)(nil)

// addonOption allows management of the mutation configuration using functional options.
type addonOption func(*AddonMutation)

// newAddonMutation creates new mutation for the Addon entity.
func newAddonMutation(c config, op Op, opts ...addonOption) *AddonMutation {
	m := &AddonMutation{
		config:        c,
		op:            op,
		typ:           TypeAddon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddonID sets the ID field of the mutation.
func withAddonID(id uint32) addonOption {
	return func(m *AddonMutation) {
		var (
			err   error
			once  sync.Once
			value *Addon
		)
		m.oldValue = func(ctx context.Context) (*Addon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Addon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddon sets the old Addon of the mutation.
func withAddon(node *Addon) addonOption {
	return func(m *AddonMutation) {
		m.oldValue = func(context.Context) (*Addon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Addon entities.
func (m *AddonMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddonMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddonMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Addon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AddonMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AddonMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AddonMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AddonMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AddonMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AddonMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[addon.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AddonMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[addon.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AddonMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, addon.FieldAppID)
}

// SetUsdPrice sets the "usd_price" field.
func (m *AddonMutation) SetUsdPrice(d decimal.Decimal) {
	m.usd_price = &d
}

// UsdPrice returns the value of the "usd_price" field in the mutation.
func (m *AddonMutation) UsdPrice() (r decimal.Decimal, exists bool) {
	v := m.usd_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdPrice returns the old "usd_price" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldUsdPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdPrice: %w", err)
	}
	return oldValue.UsdPrice, nil
}

// ClearUsdPrice clears the value of the "usd_price" field.
func (m *AddonMutation) ClearUsdPrice() {
	m.usd_price = nil
	m.clearedFields[addon.FieldUsdPrice] = struct{}{}
}

// UsdPriceCleared returns if the "usd_price" field was cleared in this mutation.
func (m *AddonMutation) UsdPriceCleared() bool {
	_, ok := m.clearedFields[addon.FieldUsdPrice]
	return ok
}

// ResetUsdPrice resets all changes to the "usd_price" field.
func (m *AddonMutation) ResetUsdPrice() {
	m.usd_price = nil
	delete(m.clearedFields, addon.FieldUsdPrice)
}

// SetCredit sets the "credit" field.
func (m *AddonMutation) SetCredit(u uint32) {
	m.credit = &u
	m.addcredit = nil
}

// Credit returns the value of the "credit" field in the mutation.
func (m *AddonMutation) Credit() (r uint32, exists bool) {
	v := m.credit
	if v == nil {
		return
	}
	return *v, true
}

// OldCredit returns the old "credit" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldCredit(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredit: %w", err)
	}
	return oldValue.Credit, nil
}

// AddCredit adds u to the "credit" field.
func (m *AddonMutation) AddCredit(u int32) {
	if m.addcredit != nil {
		*m.addcredit += u
	} else {
		m.addcredit = &u
	}
}

// AddedCredit returns the value that was added to the "credit" field in this mutation.
func (m *AddonMutation) AddedCredit() (r int32, exists bool) {
	v := m.addcredit
	if v == nil {
		return
	}
	return *v, true
}

// ClearCredit clears the value of the "credit" field.
func (m *AddonMutation) ClearCredit() {
	m.credit = nil
	m.addcredit = nil
	m.clearedFields[addon.FieldCredit] = struct{}{}
}

// CreditCleared returns if the "credit" field was cleared in this mutation.
func (m *AddonMutation) CreditCleared() bool {
	_, ok := m.clearedFields[addon.FieldCredit]
	return ok
}

// ResetCredit resets all changes to the "credit" field.
func (m *AddonMutation) ResetCredit() {
	m.credit = nil
	m.addcredit = nil
	delete(m.clearedFields, addon.FieldCredit)
}

// SetSortOrder sets the "sort_order" field.
func (m *AddonMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *AddonMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldSortOrder(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *AddonMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *AddonMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *AddonMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[addon.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *AddonMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[addon.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *AddonMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, addon.FieldSortOrder)
}

// SetEnabled sets the "enabled" field.
func (m *AddonMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AddonMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *AddonMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[addon.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *AddonMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[addon.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AddonMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, addon.FieldEnabled)
}

// SetDescription sets the "description" field.
func (m *AddonMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AddonMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AddonMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[addon.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AddonMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[addon.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AddonMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, addon.FieldDescription)
}

// Where appends a list predicates to the AddonMutation builder.
func (m *AddonMutation) Where(ps ...predicate.Addon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Addon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Addon).
func (m *AddonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddonMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, addon.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, addon.FieldAppID)
	}
	if m.usd_price != nil {
		fields = append(fields, addon.FieldUsdPrice)
	}
	if m.credit != nil {
		fields = append(fields, addon.FieldCredit)
	}
	if m.sort_order != nil {
		fields = append(fields, addon.FieldSortOrder)
	}
	if m.enabled != nil {
		fields = append(fields, addon.FieldEnabled)
	}
	if m.description != nil {
		fields = append(fields, addon.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case addon.FieldEntID:
		return m.EntID()
	case addon.FieldAppID:
		return m.AppID()
	case addon.FieldUsdPrice:
		return m.UsdPrice()
	case addon.FieldCredit:
		return m.Credit()
	case addon.FieldSortOrder:
		return m.SortOrder()
	case addon.FieldEnabled:
		return m.Enabled()
	case addon.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case addon.FieldEntID:
		return m.OldEntID(ctx)
	case addon.FieldAppID:
		return m.OldAppID(ctx)
	case addon.FieldUsdPrice:
		return m.OldUsdPrice(ctx)
	case addon.FieldCredit:
		return m.OldCredit(ctx)
	case addon.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case addon.FieldEnabled:
		return m.OldEnabled(ctx)
	case addon.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Addon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case addon.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case addon.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case addon.FieldUsdPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdPrice(v)
		return nil
	case addon.FieldCredit:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredit(v)
		return nil
	case addon.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case addon.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case addon.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Addon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddonMutation) AddedFields() []string {
	var fields []string
	if m.addcredit != nil {
		fields = append(fields, addon.FieldCredit)
	}
	if m.addsort_order != nil {
		fields = append(fields, addon.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case addon.FieldCredit:
		return m.AddedCredit()
	case addon.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case addon.FieldCredit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCredit(v)
		return nil
	case addon.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Addon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(addon.FieldAppID) {
		fields = append(fields, addon.FieldAppID)
	}
	if m.FieldCleared(addon.FieldUsdPrice) {
		fields = append(fields, addon.FieldUsdPrice)
	}
	if m.FieldCleared(addon.FieldCredit) {
		fields = append(fields, addon.FieldCredit)
	}
	if m.FieldCleared(addon.FieldSortOrder) {
		fields = append(fields, addon.FieldSortOrder)
	}
	if m.FieldCleared(addon.FieldEnabled) {
		fields = append(fields, addon.FieldEnabled)
	}
	if m.FieldCleared(addon.FieldDescription) {
		fields = append(fields, addon.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddonMutation) ClearField(name string) error {
	switch name {
	case addon.FieldAppID:
		m.ClearAppID()
		return nil
	case addon.FieldUsdPrice:
		m.ClearUsdPrice()
		return nil
	case addon.FieldCredit:
		m.ClearCredit()
		return nil
	case addon.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case addon.FieldEnabled:
		m.ClearEnabled()
		return nil
	case addon.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Addon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddonMutation) ResetField(name string) error {
	switch name {
	case addon.FieldEntID:
		m.ResetEntID()
		return nil
	case addon.FieldAppID:
		m.ResetAppID()
		return nil
	case addon.FieldUsdPrice:
		m.ResetUsdPrice()
		return nil
	case addon.FieldCredit:
		m.ResetCredit()
		return nil
	case addon.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case addon.FieldEnabled:
		m.ResetEnabled()
		return nil
	case addon.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Addon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddonMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddonMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddonMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddonMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Addon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddonMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Addon edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	ent_id                *uuid.UUID
	app_id                *uuid.UUID
	usage_type            *string
	credit                *uint32
	addcredit             *int32
	exchange_threshold    *uint32
	addexchange_threshold *int32
	_path                 *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Exchange, error)
	predicates            []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id uint32) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exchange entities.
func (m *ExchangeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *ExchangeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *ExchangeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *ExchangeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *ExchangeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ExchangeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *ExchangeMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[exchange.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *ExchangeMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ExchangeMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, exchange.FieldAppID)
}

// SetUsageType sets the "usage_type" field.
func (m *ExchangeMutation) SetUsageType(s string) {
	m.usage_type = &s
}

// UsageType returns the value of the "usage_type" field in the mutation.
func (m *ExchangeMutation) UsageType() (r string, exists bool) {
	v := m.usage_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageType returns the old "usage_type" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUsageType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageType: %w", err)
	}
	return oldValue.UsageType, nil
}

// ClearUsageType clears the value of the "usage_type" field.
func (m *ExchangeMutation) ClearUsageType() {
	m.usage_type = nil
	m.clearedFields[exchange.FieldUsageType] = struct{}{}
}

// UsageTypeCleared returns if the "usage_type" field was cleared in this mutation.
func (m *ExchangeMutation) UsageTypeCleared() bool {
	_, ok := m.clearedFields[exchange.FieldUsageType]
	return ok
}

// ResetUsageType resets all changes to the "usage_type" field.
func (m *ExchangeMutation) ResetUsageType() {
	m.usage_type = nil
	delete(m.clearedFields, exchange.FieldUsageType)
}

// SetCredit sets the "credit" field.
func (m *ExchangeMutation) SetCredit(u uint32) {
	m.credit = &u
	m.addcredit = nil
}

// Credit returns the value of the "credit" field in the mutation.
func (m *ExchangeMutation) Credit() (r uint32, exists bool) {
	v := m.credit
	if v == nil {
		return
	}
	return *v, true
}

// OldCredit returns the old "credit" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCredit(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredit: %w", err)
	}
	return oldValue.Credit, nil
}

// AddCredit adds u to the "credit" field.
func (m *ExchangeMutation) AddCredit(u int32) {
	if m.addcredit != nil {
		*m.addcredit += u
	} else {
		m.addcredit = &u
	}
}

// AddedCredit returns the value that was added to the "credit" field in this mutation.
func (m *ExchangeMutation) AddedCredit() (r int32, exists bool) {
	v := m.addcredit
	if v == nil {
		return
	}
	return *v, true
}

// ClearCredit clears the value of the "credit" field.
func (m *ExchangeMutation) ClearCredit() {
	m.credit = nil
	m.addcredit = nil
	m.clearedFields[exchange.FieldCredit] = struct{}{}
}

// CreditCleared returns if the "credit" field was cleared in this mutation.
func (m *ExchangeMutation) CreditCleared() bool {
	_, ok := m.clearedFields[exchange.FieldCredit]
	return ok
}

// ResetCredit resets all changes to the "credit" field.
func (m *ExchangeMutation) ResetCredit() {
	m.credit = nil
	m.addcredit = nil
	delete(m.clearedFields, exchange.FieldCredit)
}

// SetExchangeThreshold sets the "exchange_threshold" field.
func (m *ExchangeMutation) SetExchangeThreshold(u uint32) {
	m.exchange_threshold = &u
	m.addexchange_threshold = nil
}

// ExchangeThreshold returns the value of the "exchange_threshold" field in the mutation.
func (m *ExchangeMutation) ExchangeThreshold() (r uint32, exists bool) {
	v := m.exchange_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeThreshold returns the old "exchange_threshold" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldExchangeThreshold(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeThreshold: %w", err)
	}
	return oldValue.ExchangeThreshold, nil
}

// AddExchangeThreshold adds u to the "exchange_threshold" field.
func (m *ExchangeMutation) AddExchangeThreshold(u int32) {
	if m.addexchange_threshold != nil {
		*m.addexchange_threshold += u
	} else {
		m.addexchange_threshold = &u
	}
}

// AddedExchangeThreshold returns the value that was added to the "exchange_threshold" field in this mutation.
func (m *ExchangeMutation) AddedExchangeThreshold() (r int32, exists bool) {
	v := m.addexchange_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ClearExchangeThreshold clears the value of the "exchange_threshold" field.
func (m *ExchangeMutation) ClearExchangeThreshold() {
	m.exchange_threshold = nil
	m.addexchange_threshold = nil
	m.clearedFields[exchange.FieldExchangeThreshold] = struct{}{}
}

// ExchangeThresholdCleared returns if the "exchange_threshold" field was cleared in this mutation.
func (m *ExchangeMutation) ExchangeThresholdCleared() bool {
	_, ok := m.clearedFields[exchange.FieldExchangeThreshold]
	return ok
}

// ResetExchangeThreshold resets all changes to the "exchange_threshold" field.
func (m *ExchangeMutation) ResetExchangeThreshold() {
	m.exchange_threshold = nil
	m.addexchange_threshold = nil
	delete(m.clearedFields, exchange.FieldExchangeThreshold)
}

// SetPath sets the "path" field.
func (m *ExchangeMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ExchangeMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *ExchangeMutation) ClearPath() {
	m._path = nil
	m.clearedFields[exchange.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *ExchangeMutation) PathCleared() bool {
	_, ok := m.clearedFields[exchange.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *ExchangeMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, exchange.FieldPath)
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExchangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExchangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exchange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExchangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.ent_id != nil {
		fields = append(fields, exchange.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, exchange.FieldAppID)
	}
	if m.usage_type != nil {
		fields = append(fields, exchange.FieldUsageType)
	}
	if m.credit != nil {
		fields = append(fields, exchange.FieldCredit)
	}
	if m.exchange_threshold != nil {
		fields = append(fields, exchange.FieldExchangeThreshold)
	}
	if m._path != nil {
		fields = append(fields, exchange.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldEntID:
		return m.EntID()
	case exchange.FieldAppID:
		return m.AppID()
	case exchange.FieldUsageType:
		return m.UsageType()
	case exchange.FieldCredit:
		return m.Credit()
	case exchange.FieldExchangeThreshold:
		return m.ExchangeThreshold()
	case exchange.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldEntID:
		return m.OldEntID(ctx)
	case exchange.FieldAppID:
		return m.OldAppID(ctx)
	case exchange.FieldUsageType:
		return m.OldUsageType(ctx)
	case exchange.FieldCredit:
		return m.OldCredit(ctx)
	case exchange.FieldExchangeThreshold:
		return m.OldExchangeThreshold(ctx)
	case exchange.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case exchange.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case exchange.FieldUsageType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageType(v)
		return nil
	case exchange.FieldCredit:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredit(v)
		return nil
	case exchange.FieldExchangeThreshold:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeThreshold(v)
		return nil
	case exchange.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	var fields []string
	if m.addcredit != nil {
		fields = append(fields, exchange.FieldCredit)
	}
	if m.addexchange_threshold != nil {
		fields = append(fields, exchange.FieldExchangeThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldCredit:
		return m.AddedCredit()
	case exchange.FieldExchangeThreshold:
		return m.AddedExchangeThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldCredit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCredit(v)
		return nil
	case exchange.FieldExchangeThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExchangeThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldAppID) {
		fields = append(fields, exchange.FieldAppID)
	}
	if m.FieldCleared(exchange.FieldUsageType) {
		fields = append(fields, exchange.FieldUsageType)
	}
	if m.FieldCleared(exchange.FieldCredit) {
		fields = append(fields, exchange.FieldCredit)
	}
	if m.FieldCleared(exchange.FieldExchangeThreshold) {
		fields = append(fields, exchange.FieldExchangeThreshold)
	}
	if m.FieldCleared(exchange.FieldPath) {
		fields = append(fields, exchange.FieldPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldAppID:
		m.ClearAppID()
		return nil
	case exchange.FieldUsageType:
		m.ClearUsageType()
		return nil
	case exchange.FieldCredit:
		m.ClearCredit()
		return nil
	case exchange.FieldExchangeThreshold:
		m.ClearExchangeThreshold()
		return nil
	case exchange.FieldPath:
		m.ClearPath()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldEntID:
		m.ResetEntID()
		return nil
	case exchange.FieldAppID:
		m.ResetAppID()
		return nil
	case exchange.FieldUsageType:
		m.ResetUsageType()
		return nil
	case exchange.FieldCredit:
		m.ResetCredit()
		return nil
	case exchange.FieldExchangeThreshold:
		m.ResetExchangeThreshold()
		return nil
	case exchange.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	package_name  *string
	usd_price     *decimal.Decimal
	description   *string
	sort_order    *uint32
	addsort_order *int32
	package_type  *string
	credit        *uint32
	addcredit     *int32
	reset_type    *string
	qps_limit     *uint32
	addqps_limit  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Subscription, error)
	predicates    []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id uint32) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *SubscriptionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *SubscriptionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *SubscriptionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *SubscriptionMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *SubscriptionMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *SubscriptionMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[subscription.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *SubscriptionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *SubscriptionMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, subscription.FieldAppID)
}

// SetPackageName sets the "package_name" field.
func (m *SubscriptionMutation) SetPackageName(s string) {
	m.package_name = &s
}

// PackageName returns the value of the "package_name" field in the mutation.
func (m *SubscriptionMutation) PackageName() (r string, exists bool) {
	v := m.package_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageName returns the old "package_name" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPackageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageName: %w", err)
	}
	return oldValue.PackageName, nil
}

// ClearPackageName clears the value of the "package_name" field.
func (m *SubscriptionMutation) ClearPackageName() {
	m.package_name = nil
	m.clearedFields[subscription.FieldPackageName] = struct{}{}
}

// PackageNameCleared returns if the "package_name" field was cleared in this mutation.
func (m *SubscriptionMutation) PackageNameCleared() bool {
	_, ok := m.clearedFields[subscription.FieldPackageName]
	return ok
}

// ResetPackageName resets all changes to the "package_name" field.
func (m *SubscriptionMutation) ResetPackageName() {
	m.package_name = nil
	delete(m.clearedFields, subscription.FieldPackageName)
}

// SetUsdPrice sets the "usd_price" field.
func (m *SubscriptionMutation) SetUsdPrice(d decimal.Decimal) {
	m.usd_price = &d
}

// UsdPrice returns the value of the "usd_price" field in the mutation.
func (m *SubscriptionMutation) UsdPrice() (r decimal.Decimal, exists bool) {
	v := m.usd_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdPrice returns the old "usd_price" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUsdPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdPrice: %w", err)
	}
	return oldValue.UsdPrice, nil
}

// ClearUsdPrice clears the value of the "usd_price" field.
func (m *SubscriptionMutation) ClearUsdPrice() {
	m.usd_price = nil
	m.clearedFields[subscription.FieldUsdPrice] = struct{}{}
}

// UsdPriceCleared returns if the "usd_price" field was cleared in this mutation.
func (m *SubscriptionMutation) UsdPriceCleared() bool {
	_, ok := m.clearedFields[subscription.FieldUsdPrice]
	return ok
}

// ResetUsdPrice resets all changes to the "usd_price" field.
func (m *SubscriptionMutation) ResetUsdPrice() {
	m.usd_price = nil
	delete(m.clearedFields, subscription.FieldUsdPrice)
}

// SetDescription sets the "description" field.
func (m *SubscriptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubscriptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubscriptionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subscription.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubscriptionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubscriptionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subscription.FieldDescription)
}

// SetSortOrder sets the "sort_order" field.
func (m *SubscriptionMutation) SetSortOrder(u uint32) {
	m.sort_order = &u
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *SubscriptionMutation) SortOrder() (r uint32, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldSortOrder(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds u to the "sort_order" field.
func (m *SubscriptionMutation) AddSortOrder(u int32) {
	if m.addsort_order != nil {
		*m.addsort_order += u
	} else {
		m.addsort_order = &u
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *SubscriptionMutation) AddedSortOrder() (r int32, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *SubscriptionMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[subscription.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *SubscriptionMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[subscription.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *SubscriptionMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, subscription.FieldSortOrder)
}

// SetPackageType sets the "package_type" field.
func (m *SubscriptionMutation) SetPackageType(s string) {
	m.package_type = &s
}

// PackageType returns the value of the "package_type" field in the mutation.
func (m *SubscriptionMutation) PackageType() (r string, exists bool) {
	v := m.package_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageType returns the old "package_type" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPackageType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageType: %w", err)
	}
	return oldValue.PackageType, nil
}

// ClearPackageType clears the value of the "package_type" field.
func (m *SubscriptionMutation) ClearPackageType() {
	m.package_type = nil
	m.clearedFields[subscription.FieldPackageType] = struct{}{}
}

// PackageTypeCleared returns if the "package_type" field was cleared in this mutation.
func (m *SubscriptionMutation) PackageTypeCleared() bool {
	_, ok := m.clearedFields[subscription.FieldPackageType]
	return ok
}

// ResetPackageType resets all changes to the "package_type" field.
func (m *SubscriptionMutation) ResetPackageType() {
	m.package_type = nil
	delete(m.clearedFields, subscription.FieldPackageType)
}

// SetCredit sets the "credit" field.
func (m *SubscriptionMutation) SetCredit(u uint32) {
	m.credit = &u
	m.addcredit = nil
}

// Credit returns the value of the "credit" field in the mutation.
func (m *SubscriptionMutation) Credit() (r uint32, exists bool) {
	v := m.credit
	if v == nil {
		return
	}
	return *v, true
}

// OldCredit returns the old "credit" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCredit(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredit: %w", err)
	}
	return oldValue.Credit, nil
}

// AddCredit adds u to the "credit" field.
func (m *SubscriptionMutation) AddCredit(u int32) {
	if m.addcredit != nil {
		*m.addcredit += u
	} else {
		m.addcredit = &u
	}
}

// AddedCredit returns the value that was added to the "credit" field in this mutation.
func (m *SubscriptionMutation) AddedCredit() (r int32, exists bool) {
	v := m.addcredit
	if v == nil {
		return
	}
	return *v, true
}

// ClearCredit clears the value of the "credit" field.
func (m *SubscriptionMutation) ClearCredit() {
	m.credit = nil
	m.addcredit = nil
	m.clearedFields[subscription.FieldCredit] = struct{}{}
}

// CreditCleared returns if the "credit" field was cleared in this mutation.
func (m *SubscriptionMutation) CreditCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCredit]
	return ok
}

// ResetCredit resets all changes to the "credit" field.
func (m *SubscriptionMutation) ResetCredit() {
	m.credit = nil
	m.addcredit = nil
	delete(m.clearedFields, subscription.FieldCredit)
}

// SetResetType sets the "reset_type" field.
func (m *SubscriptionMutation) SetResetType(s string) {
	m.reset_type = &s
}

// ResetType returns the value of the "reset_type" field in the mutation.
func (m *SubscriptionMutation) ResetType() (r string, exists bool) {
	v := m.reset_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResetType returns the old "reset_type" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldResetType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetType: %w", err)
	}
	return oldValue.ResetType, nil
}

// ClearResetType clears the value of the "reset_type" field.
func (m *SubscriptionMutation) ClearResetType() {
	m.reset_type = nil
	m.clearedFields[subscription.FieldResetType] = struct{}{}
}

// ResetTypeCleared returns if the "reset_type" field was cleared in this mutation.
func (m *SubscriptionMutation) ResetTypeCleared() bool {
	_, ok := m.clearedFields[subscription.FieldResetType]
	return ok
}

// ResetResetType resets all changes to the "reset_type" field.
func (m *SubscriptionMutation) ResetResetType() {
	m.reset_type = nil
	delete(m.clearedFields, subscription.FieldResetType)
}

// SetQPSLimit sets the "qps_limit" field.
func (m *SubscriptionMutation) SetQPSLimit(u uint32) {
	m.qps_limit = &u
	m.addqps_limit = nil
}

// QPSLimit returns the value of the "qps_limit" field in the mutation.
func (m *SubscriptionMutation) QPSLimit() (r uint32, exists bool) {
	v := m.qps_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldQPSLimit returns the old "qps_limit" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldQPSLimit(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQPSLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQPSLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQPSLimit: %w", err)
	}
	return oldValue.QPSLimit, nil
}

// AddQPSLimit adds u to the "qps_limit" field.
func (m *SubscriptionMutation) AddQPSLimit(u int32) {
	if m.addqps_limit != nil {
		*m.addqps_limit += u
	} else {
		m.addqps_limit = &u
	}
}

// AddedQPSLimit returns the value that was added to the "qps_limit" field in this mutation.
func (m *SubscriptionMutation) AddedQPSLimit() (r int32, exists bool) {
	v := m.addqps_limit
	if v == nil {
		return
	}
	return *v, true
}

// ClearQPSLimit clears the value of the "qps_limit" field.
func (m *SubscriptionMutation) ClearQPSLimit() {
	m.qps_limit = nil
	m.addqps_limit = nil
	m.clearedFields[subscription.FieldQPSLimit] = struct{}{}
}

// QPSLimitCleared returns if the "qps_limit" field was cleared in this mutation.
func (m *SubscriptionMutation) QPSLimitCleared() bool {
	_, ok := m.clearedFields[subscription.FieldQPSLimit]
	return ok
}

// ResetQPSLimit resets all changes to the "qps_limit" field.
func (m *SubscriptionMutation) ResetQPSLimit() {
	m.qps_limit = nil
	m.addqps_limit = nil
	delete(m.clearedFields, subscription.FieldQPSLimit)
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ent_id != nil {
		fields = append(fields, subscription.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, subscription.FieldAppID)
	}
	if m.package_name != nil {
		fields = append(fields, subscription.FieldPackageName)
	}
	if m.usd_price != nil {
		fields = append(fields, subscription.FieldUsdPrice)
	}
	if m.description != nil {
		fields = append(fields, subscription.FieldDescription)
	}
	if m.sort_order != nil {
		fields = append(fields, subscription.FieldSortOrder)
	}
	if m.package_type != nil {
		fields = append(fields, subscription.FieldPackageType)
	}
	if m.credit != nil {
		fields = append(fields, subscription.FieldCredit)
	}
	if m.reset_type != nil {
		fields = append(fields, subscription.FieldResetType)
	}
	if m.qps_limit != nil {
		fields = append(fields, subscription.FieldQPSLimit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldEntID:
		return m.EntID()
	case subscription.FieldAppID:
		return m.AppID()
	case subscription.FieldPackageName:
		return m.PackageName()
	case subscription.FieldUsdPrice:
		return m.UsdPrice()
	case subscription.FieldDescription:
		return m.Description()
	case subscription.FieldSortOrder:
		return m.SortOrder()
	case subscription.FieldPackageType:
		return m.PackageType()
	case subscription.FieldCredit:
		return m.Credit()
	case subscription.FieldResetType:
		return m.ResetType()
	case subscription.FieldQPSLimit:
		return m.QPSLimit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldEntID:
		return m.OldEntID(ctx)
	case subscription.FieldAppID:
		return m.OldAppID(ctx)
	case subscription.FieldPackageName:
		return m.OldPackageName(ctx)
	case subscription.FieldUsdPrice:
		return m.OldUsdPrice(ctx)
	case subscription.FieldDescription:
		return m.OldDescription(ctx)
	case subscription.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case subscription.FieldPackageType:
		return m.OldPackageType(ctx)
	case subscription.FieldCredit:
		return m.OldCredit(ctx)
	case subscription.FieldResetType:
		return m.OldResetType(ctx)
	case subscription.FieldQPSLimit:
		return m.OldQPSLimit(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case subscription.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case subscription.FieldPackageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageName(v)
		return nil
	case subscription.FieldUsdPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdPrice(v)
		return nil
	case subscription.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subscription.FieldSortOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case subscription.FieldPackageType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageType(v)
		return nil
	case subscription.FieldCredit:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredit(v)
		return nil
	case subscription.FieldResetType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetType(v)
		return nil
	case subscription.FieldQPSLimit:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQPSLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, subscription.FieldSortOrder)
	}
	if m.addcredit != nil {
		fields = append(fields, subscription.FieldCredit)
	}
	if m.addqps_limit != nil {
		fields = append(fields, subscription.FieldQPSLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldSortOrder:
		return m.AddedSortOrder()
	case subscription.FieldCredit:
		return m.AddedCredit()
	case subscription.FieldQPSLimit:
		return m.AddedQPSLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldSortOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case subscription.FieldCredit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCredit(v)
		return nil
	case subscription.FieldQPSLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQPSLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldAppID) {
		fields = append(fields, subscription.FieldAppID)
	}
	if m.FieldCleared(subscription.FieldPackageName) {
		fields = append(fields, subscription.FieldPackageName)
	}
	if m.FieldCleared(subscription.FieldUsdPrice) {
		fields = append(fields, subscription.FieldUsdPrice)
	}
	if m.FieldCleared(subscription.FieldDescription) {
		fields = append(fields, subscription.FieldDescription)
	}
	if m.FieldCleared(subscription.FieldSortOrder) {
		fields = append(fields, subscription.FieldSortOrder)
	}
	if m.FieldCleared(subscription.FieldPackageType) {
		fields = append(fields, subscription.FieldPackageType)
	}
	if m.FieldCleared(subscription.FieldCredit) {
		fields = append(fields, subscription.FieldCredit)
	}
	if m.FieldCleared(subscription.FieldResetType) {
		fields = append(fields, subscription.FieldResetType)
	}
	if m.FieldCleared(subscription.FieldQPSLimit) {
		fields = append(fields, subscription.FieldQPSLimit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldAppID:
		m.ClearAppID()
		return nil
	case subscription.FieldPackageName:
		m.ClearPackageName()
		return nil
	case subscription.FieldUsdPrice:
		m.ClearUsdPrice()
		return nil
	case subscription.FieldDescription:
		m.ClearDescription()
		return nil
	case subscription.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case subscription.FieldPackageType:
		m.ClearPackageType()
		return nil
	case subscription.FieldCredit:
		m.ClearCredit()
		return nil
	case subscription.FieldResetType:
		m.ClearResetType()
		return nil
	case subscription.FieldQPSLimit:
		m.ClearQPSLimit()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldEntID:
		m.ResetEntID()
		return nil
	case subscription.FieldAppID:
		m.ResetAppID()
		return nil
	case subscription.FieldPackageName:
		m.ResetPackageName()
		return nil
	case subscription.FieldUsdPrice:
		m.ResetUsdPrice()
		return nil
	case subscription.FieldDescription:
		m.ResetDescription()
		return nil
	case subscription.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case subscription.FieldPackageType:
		m.ResetPackageType()
		return nil
	case subscription.FieldCredit:
		m.ResetCredit()
		return nil
	case subscription.FieldResetType:
		m.ResetResetType()
		return nil
	case subscription.FieldQPSLimit:
		m.ResetQPSLimit()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// UserCreditRecordMutation represents an operation that mutates the UserCreditRecord nodes in the graph.
type UserCreditRecordMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	ent_id            *uuid.UUID
	app_id            *uuid.UUID
	user_id           *uuid.UUID
	operation_type    *string
	credits_change    *int32
	addcredits_change *int32
	extra             *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*UserCreditRecord, error)
	predicates        []predicate.UserCreditRecord
}

var _ ent.Mutation = (*UserCreditRecordMutation)(nil)

// usercreditrecordOption allows management of the mutation configuration using functional options.
type usercreditrecordOption func(*UserCreditRecordMutation)

// newUserCreditRecordMutation creates new mutation for the UserCreditRecord entity.
func newUserCreditRecordMutation(c config, op Op, opts ...usercreditrecordOption) *UserCreditRecordMutation {
	m := &UserCreditRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCreditRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCreditRecordID sets the ID field of the mutation.
func withUserCreditRecordID(id uint32) usercreditrecordOption {
	return func(m *UserCreditRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCreditRecord
		)
		m.oldValue = func(ctx context.Context) (*UserCreditRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCreditRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCreditRecord sets the old UserCreditRecord of the mutation.
func withUserCreditRecord(node *UserCreditRecord) usercreditrecordOption {
	return func(m *UserCreditRecordMutation) {
		m.oldValue = func(context.Context) (*UserCreditRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCreditRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCreditRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserCreditRecord entities.
func (m *UserCreditRecordMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCreditRecordMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCreditRecordMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCreditRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *UserCreditRecordMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *UserCreditRecordMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the UserCreditRecord entity.
// If the UserCreditRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCreditRecordMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *UserCreditRecordMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *UserCreditRecordMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *UserCreditRecordMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the UserCreditRecord entity.
// If the UserCreditRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCreditRecordMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *UserCreditRecordMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[usercreditrecord.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *UserCreditRecordMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[usercreditrecord.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *UserCreditRecordMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, usercreditrecord.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *UserCreditRecordMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserCreditRecordMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserCreditRecord entity.
// If the UserCreditRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCreditRecordMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserCreditRecordMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[usercreditrecord.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserCreditRecordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usercreditrecord.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserCreditRecordMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, usercreditrecord.FieldUserID)
}

// SetOperationType sets the "operation_type" field.
func (m *UserCreditRecordMutation) SetOperationType(s string) {
	m.operation_type = &s
}

// OperationType returns the value of the "operation_type" field in the mutation.
func (m *UserCreditRecordMutation) OperationType() (r string, exists bool) {
	v := m.operation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationType returns the old "operation_type" field's value of the UserCreditRecord entity.
// If the UserCreditRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCreditRecordMutation) OldOperationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationType: %w", err)
	}
	return oldValue.OperationType, nil
}

// ClearOperationType clears the value of the "operation_type" field.
func (m *UserCreditRecordMutation) ClearOperationType() {
	m.operation_type = nil
	m.clearedFields[usercreditrecord.FieldOperationType] = struct{}{}
}

// OperationTypeCleared returns if the "operation_type" field was cleared in this mutation.
func (m *UserCreditRecordMutation) OperationTypeCleared() bool {
	_, ok := m.clearedFields[usercreditrecord.FieldOperationType]
	return ok
}

// ResetOperationType resets all changes to the "operation_type" field.
func (m *UserCreditRecordMutation) ResetOperationType() {
	m.operation_type = nil
	delete(m.clearedFields, usercreditrecord.FieldOperationType)
}

// SetCreditsChange sets the "credits_change" field.
func (m *UserCreditRecordMutation) SetCreditsChange(i int32) {
	m.credits_change = &i
	m.addcredits_change = nil
}

// CreditsChange returns the value of the "credits_change" field in the mutation.
func (m *UserCreditRecordMutation) CreditsChange() (r int32, exists bool) {
	v := m.credits_change
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditsChange returns the old "credits_change" field's value of the UserCreditRecord entity.
// If the UserCreditRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCreditRecordMutation) OldCreditsChange(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditsChange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditsChange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditsChange: %w", err)
	}
	return oldValue.CreditsChange, nil
}

// AddCreditsChange adds i to the "credits_change" field.
func (m *UserCreditRecordMutation) AddCreditsChange(i int32) {
	if m.addcredits_change != nil {
		*m.addcredits_change += i
	} else {
		m.addcredits_change = &i
	}
}

// AddedCreditsChange returns the value that was added to the "credits_change" field in this mutation.
func (m *UserCreditRecordMutation) AddedCreditsChange() (r int32, exists bool) {
	v := m.addcredits_change
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreditsChange clears the value of the "credits_change" field.
func (m *UserCreditRecordMutation) ClearCreditsChange() {
	m.credits_change = nil
	m.addcredits_change = nil
	m.clearedFields[usercreditrecord.FieldCreditsChange] = struct{}{}
}

// CreditsChangeCleared returns if the "credits_change" field was cleared in this mutation.
func (m *UserCreditRecordMutation) CreditsChangeCleared() bool {
	_, ok := m.clearedFields[usercreditrecord.FieldCreditsChange]
	return ok
}

// ResetCreditsChange resets all changes to the "credits_change" field.
func (m *UserCreditRecordMutation) ResetCreditsChange() {
	m.credits_change = nil
	m.addcredits_change = nil
	delete(m.clearedFields, usercreditrecord.FieldCreditsChange)
}

// SetExtra sets the "extra" field.
func (m *UserCreditRecordMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *UserCreditRecordMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the UserCreditRecord entity.
// If the UserCreditRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCreditRecordMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *UserCreditRecordMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[usercreditrecord.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *UserCreditRecordMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[usercreditrecord.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *UserCreditRecordMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, usercreditrecord.FieldExtra)
}

// Where appends a list predicates to the UserCreditRecordMutation builder.
func (m *UserCreditRecordMutation) Where(ps ...predicate.UserCreditRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCreditRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCreditRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCreditRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCreditRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCreditRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCreditRecord).
func (m *UserCreditRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCreditRecordMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.ent_id != nil {
		fields = append(fields, usercreditrecord.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, usercreditrecord.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, usercreditrecord.FieldUserID)
	}
	if m.operation_type != nil {
		fields = append(fields, usercreditrecord.FieldOperationType)
	}
	if m.credits_change != nil {
		fields = append(fields, usercreditrecord.FieldCreditsChange)
	}
	if m.extra != nil {
		fields = append(fields, usercreditrecord.FieldExtra)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCreditRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercreditrecord.FieldEntID:
		return m.EntID()
	case usercreditrecord.FieldAppID:
		return m.AppID()
	case usercreditrecord.FieldUserID:
		return m.UserID()
	case usercreditrecord.FieldOperationType:
		return m.OperationType()
	case usercreditrecord.FieldCreditsChange:
		return m.CreditsChange()
	case usercreditrecord.FieldExtra:
		return m.Extra()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCreditRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercreditrecord.FieldEntID:
		return m.OldEntID(ctx)
	case usercreditrecord.FieldAppID:
		return m.OldAppID(ctx)
	case usercreditrecord.FieldUserID:
		return m.OldUserID(ctx)
	case usercreditrecord.FieldOperationType:
		return m.OldOperationType(ctx)
	case usercreditrecord.FieldCreditsChange:
		return m.OldCreditsChange(ctx)
	case usercreditrecord.FieldExtra:
		return m.OldExtra(ctx)
	}
	return nil, fmt.Errorf("unknown UserCreditRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCreditRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercreditrecord.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case usercreditrecord.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case usercreditrecord.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usercreditrecord.FieldOperationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationType(v)
		return nil
	case usercreditrecord.FieldCreditsChange:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditsChange(v)
		return nil
	case usercreditrecord.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	}
	return fmt.Errorf("unknown UserCreditRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCreditRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcredits_change != nil {
		fields = append(fields, usercreditrecord.FieldCreditsChange)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCreditRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usercreditrecord.FieldCreditsChange:
		return m.AddedCreditsChange()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCreditRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usercreditrecord.FieldCreditsChange:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditsChange(v)
		return nil
	}
	return fmt.Errorf("unknown UserCreditRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCreditRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usercreditrecord.FieldAppID) {
		fields = append(fields, usercreditrecord.FieldAppID)
	}
	if m.FieldCleared(usercreditrecord.FieldUserID) {
		fields = append(fields, usercreditrecord.FieldUserID)
	}
	if m.FieldCleared(usercreditrecord.FieldOperationType) {
		fields = append(fields, usercreditrecord.FieldOperationType)
	}
	if m.FieldCleared(usercreditrecord.FieldCreditsChange) {
		fields = append(fields, usercreditrecord.FieldCreditsChange)
	}
	if m.FieldCleared(usercreditrecord.FieldExtra) {
		fields = append(fields, usercreditrecord.FieldExtra)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCreditRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCreditRecordMutation) ClearField(name string) error {
	switch name {
	case usercreditrecord.FieldAppID:
		m.ClearAppID()
		return nil
	case usercreditrecord.FieldUserID:
		m.ClearUserID()
		return nil
	case usercreditrecord.FieldOperationType:
		m.ClearOperationType()
		return nil
	case usercreditrecord.FieldCreditsChange:
		m.ClearCreditsChange()
		return nil
	case usercreditrecord.FieldExtra:
		m.ClearExtra()
		return nil
	}
	return fmt.Errorf("unknown UserCreditRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCreditRecordMutation) ResetField(name string) error {
	switch name {
	case usercreditrecord.FieldEntID:
		m.ResetEntID()
		return nil
	case usercreditrecord.FieldAppID:
		m.ResetAppID()
		return nil
	case usercreditrecord.FieldUserID:
		m.ResetUserID()
		return nil
	case usercreditrecord.FieldOperationType:
		m.ResetOperationType()
		return nil
	case usercreditrecord.FieldCreditsChange:
		m.ResetCreditsChange()
		return nil
	case usercreditrecord.FieldExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown UserCreditRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCreditRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCreditRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCreditRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCreditRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCreditRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCreditRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCreditRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserCreditRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCreditRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserCreditRecord edge %s", name)
}

// UserSubscriptionMutation represents an operation that mutates the UserSubscription nodes in the graph.
type UserSubscriptionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint32
	ent_id                 *uuid.UUID
	app_id                 *uuid.UUID
	user_id                *uuid.UUID
	package_id             *uuid.UUID
	start_at               *uint32
	addstart_at            *int32
	end_at                 *uint32
	addend_at              *int32
	usage_state            *string
	subscription_credit    *uint32
	addsubscription_credit *int32
	addon_credit           *uint32
	addaddon_credit        *int32
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*UserSubscription, error)
	predicates             []predicate.UserSubscription
}

var _ ent.Mutation = (*UserSubscriptionMutation)(nil)

// usersubscriptionOption allows management of the mutation configuration using functional options.
type usersubscriptionOption func(*UserSubscriptionMutation)

// newUserSubscriptionMutation creates new mutation for the UserSubscription entity.
func newUserSubscriptionMutation(c config, op Op, opts ...usersubscriptionOption) *UserSubscriptionMutation {
	m := &UserSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSubscriptionID sets the ID field of the mutation.
func withUserSubscriptionID(id uint32) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSubscription
		)
		m.oldValue = func(ctx context.Context) (*UserSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSubscription sets the old UserSubscription of the mutation.
func withUserSubscription(node *UserSubscription) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		m.oldValue = func(context.Context) (*UserSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSubscription entities.
func (m *UserSubscriptionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSubscriptionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSubscriptionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *UserSubscriptionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *UserSubscriptionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *UserSubscriptionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *UserSubscriptionMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *UserSubscriptionMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *UserSubscriptionMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[usersubscription.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *UserSubscriptionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *UserSubscriptionMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, usersubscription.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *UserSubscriptionMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSubscriptionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserSubscriptionMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[usersubscription.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserSubscriptionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSubscriptionMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, usersubscription.FieldUserID)
}

// SetPackageID sets the "package_id" field.
func (m *UserSubscriptionMutation) SetPackageID(u uuid.UUID) {
	m.package_id = &u
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *UserSubscriptionMutation) PackageID() (r uuid.UUID, exists bool) {
	v := m.package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldPackageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *UserSubscriptionMutation) ClearPackageID() {
	m.package_id = nil
	m.clearedFields[usersubscription.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *UserSubscriptionMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *UserSubscriptionMutation) ResetPackageID() {
	m.package_id = nil
	delete(m.clearedFields, usersubscription.FieldPackageID)
}

// SetStartAt sets the "start_at" field.
func (m *UserSubscriptionMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *UserSubscriptionMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *UserSubscriptionMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *UserSubscriptionMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *UserSubscriptionMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[usersubscription.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *UserSubscriptionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *UserSubscriptionMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, usersubscription.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *UserSubscriptionMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *UserSubscriptionMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *UserSubscriptionMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *UserSubscriptionMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *UserSubscriptionMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[usersubscription.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *UserSubscriptionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *UserSubscriptionMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, usersubscription.FieldEndAt)
}

// SetUsageState sets the "usage_state" field.
func (m *UserSubscriptionMutation) SetUsageState(s string) {
	m.usage_state = &s
}

// UsageState returns the value of the "usage_state" field in the mutation.
func (m *UserSubscriptionMutation) UsageState() (r string, exists bool) {
	v := m.usage_state
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageState returns the old "usage_state" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUsageState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageState: %w", err)
	}
	return oldValue.UsageState, nil
}

// ClearUsageState clears the value of the "usage_state" field.
func (m *UserSubscriptionMutation) ClearUsageState() {
	m.usage_state = nil
	m.clearedFields[usersubscription.FieldUsageState] = struct{}{}
}

// UsageStateCleared returns if the "usage_state" field was cleared in this mutation.
func (m *UserSubscriptionMutation) UsageStateCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldUsageState]
	return ok
}

// ResetUsageState resets all changes to the "usage_state" field.
func (m *UserSubscriptionMutation) ResetUsageState() {
	m.usage_state = nil
	delete(m.clearedFields, usersubscription.FieldUsageState)
}

// SetSubscriptionCredit sets the "subscription_credit" field.
func (m *UserSubscriptionMutation) SetSubscriptionCredit(u uint32) {
	m.subscription_credit = &u
	m.addsubscription_credit = nil
}

// SubscriptionCredit returns the value of the "subscription_credit" field in the mutation.
func (m *UserSubscriptionMutation) SubscriptionCredit() (r uint32, exists bool) {
	v := m.subscription_credit
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionCredit returns the old "subscription_credit" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldSubscriptionCredit(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionCredit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionCredit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionCredit: %w", err)
	}
	return oldValue.SubscriptionCredit, nil
}

// AddSubscriptionCredit adds u to the "subscription_credit" field.
func (m *UserSubscriptionMutation) AddSubscriptionCredit(u int32) {
	if m.addsubscription_credit != nil {
		*m.addsubscription_credit += u
	} else {
		m.addsubscription_credit = &u
	}
}

// AddedSubscriptionCredit returns the value that was added to the "subscription_credit" field in this mutation.
func (m *UserSubscriptionMutation) AddedSubscriptionCredit() (r int32, exists bool) {
	v := m.addsubscription_credit
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubscriptionCredit clears the value of the "subscription_credit" field.
func (m *UserSubscriptionMutation) ClearSubscriptionCredit() {
	m.subscription_credit = nil
	m.addsubscription_credit = nil
	m.clearedFields[usersubscription.FieldSubscriptionCredit] = struct{}{}
}

// SubscriptionCreditCleared returns if the "subscription_credit" field was cleared in this mutation.
func (m *UserSubscriptionMutation) SubscriptionCreditCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldSubscriptionCredit]
	return ok
}

// ResetSubscriptionCredit resets all changes to the "subscription_credit" field.
func (m *UserSubscriptionMutation) ResetSubscriptionCredit() {
	m.subscription_credit = nil
	m.addsubscription_credit = nil
	delete(m.clearedFields, usersubscription.FieldSubscriptionCredit)
}

// SetAddonCredit sets the "addon_credit" field.
func (m *UserSubscriptionMutation) SetAddonCredit(u uint32) {
	m.addon_credit = &u
	m.addaddon_credit = nil
}

// AddonCredit returns the value of the "addon_credit" field in the mutation.
func (m *UserSubscriptionMutation) AddonCredit() (r uint32, exists bool) {
	v := m.addon_credit
	if v == nil {
		return
	}
	return *v, true
}

// OldAddonCredit returns the old "addon_credit" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldAddonCredit(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddonCredit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddonCredit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddonCredit: %w", err)
	}
	return oldValue.AddonCredit, nil
}

// AddAddonCredit adds u to the "addon_credit" field.
func (m *UserSubscriptionMutation) AddAddonCredit(u int32) {
	if m.addaddon_credit != nil {
		*m.addaddon_credit += u
	} else {
		m.addaddon_credit = &u
	}
}

// AddedAddonCredit returns the value that was added to the "addon_credit" field in this mutation.
func (m *UserSubscriptionMutation) AddedAddonCredit() (r int32, exists bool) {
	v := m.addaddon_credit
	if v == nil {
		return
	}
	return *v, true
}

// ClearAddonCredit clears the value of the "addon_credit" field.
func (m *UserSubscriptionMutation) ClearAddonCredit() {
	m.addon_credit = nil
	m.addaddon_credit = nil
	m.clearedFields[usersubscription.FieldAddonCredit] = struct{}{}
}

// AddonCreditCleared returns if the "addon_credit" field was cleared in this mutation.
func (m *UserSubscriptionMutation) AddonCreditCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldAddonCredit]
	return ok
}

// ResetAddonCredit resets all changes to the "addon_credit" field.
func (m *UserSubscriptionMutation) ResetAddonCredit() {
	m.addon_credit = nil
	m.addaddon_credit = nil
	delete(m.clearedFields, usersubscription.FieldAddonCredit)
}

// Where appends a list predicates to the UserSubscriptionMutation builder.
func (m *UserSubscriptionMutation) Where(ps ...predicate.UserSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSubscription).
func (m *UserSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.ent_id != nil {
		fields = append(fields, usersubscription.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, usersubscription.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, usersubscription.FieldUserID)
	}
	if m.package_id != nil {
		fields = append(fields, usersubscription.FieldPackageID)
	}
	if m.start_at != nil {
		fields = append(fields, usersubscription.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, usersubscription.FieldEndAt)
	}
	if m.usage_state != nil {
		fields = append(fields, usersubscription.FieldUsageState)
	}
	if m.subscription_credit != nil {
		fields = append(fields, usersubscription.FieldSubscriptionCredit)
	}
	if m.addon_credit != nil {
		fields = append(fields, usersubscription.FieldAddonCredit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldEntID:
		return m.EntID()
	case usersubscription.FieldAppID:
		return m.AppID()
	case usersubscription.FieldUserID:
		return m.UserID()
	case usersubscription.FieldPackageID:
		return m.PackageID()
	case usersubscription.FieldStartAt:
		return m.StartAt()
	case usersubscription.FieldEndAt:
		return m.EndAt()
	case usersubscription.FieldUsageState:
		return m.UsageState()
	case usersubscription.FieldSubscriptionCredit:
		return m.SubscriptionCredit()
	case usersubscription.FieldAddonCredit:
		return m.AddonCredit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersubscription.FieldEntID:
		return m.OldEntID(ctx)
	case usersubscription.FieldAppID:
		return m.OldAppID(ctx)
	case usersubscription.FieldUserID:
		return m.OldUserID(ctx)
	case usersubscription.FieldPackageID:
		return m.OldPackageID(ctx)
	case usersubscription.FieldStartAt:
		return m.OldStartAt(ctx)
	case usersubscription.FieldEndAt:
		return m.OldEndAt(ctx)
	case usersubscription.FieldUsageState:
		return m.OldUsageState(ctx)
	case usersubscription.FieldSubscriptionCredit:
		return m.OldSubscriptionCredit(ctx)
	case usersubscription.FieldAddonCredit:
		return m.OldAddonCredit(ctx)
	}
	return nil, fmt.Errorf("unknown UserSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case usersubscription.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case usersubscription.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersubscription.FieldPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case usersubscription.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case usersubscription.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case usersubscription.FieldUsageState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageState(v)
		return nil
	case usersubscription.FieldSubscriptionCredit:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionCredit(v)
		return nil
	case usersubscription.FieldAddonCredit:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddonCredit(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addstart_at != nil {
		fields = append(fields, usersubscription.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, usersubscription.FieldEndAt)
	}
	if m.addsubscription_credit != nil {
		fields = append(fields, usersubscription.FieldSubscriptionCredit)
	}
	if m.addaddon_credit != nil {
		fields = append(fields, usersubscription.FieldAddonCredit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldStartAt:
		return m.AddedStartAt()
	case usersubscription.FieldEndAt:
		return m.AddedEndAt()
	case usersubscription.FieldSubscriptionCredit:
		return m.AddedSubscriptionCredit()
	case usersubscription.FieldAddonCredit:
		return m.AddedAddonCredit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case usersubscription.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	case usersubscription.FieldSubscriptionCredit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubscriptionCredit(v)
		return nil
	case usersubscription.FieldAddonCredit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAddonCredit(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersubscription.FieldAppID) {
		fields = append(fields, usersubscription.FieldAppID)
	}
	if m.FieldCleared(usersubscription.FieldUserID) {
		fields = append(fields, usersubscription.FieldUserID)
	}
	if m.FieldCleared(usersubscription.FieldPackageID) {
		fields = append(fields, usersubscription.FieldPackageID)
	}
	if m.FieldCleared(usersubscription.FieldStartAt) {
		fields = append(fields, usersubscription.FieldStartAt)
	}
	if m.FieldCleared(usersubscription.FieldEndAt) {
		fields = append(fields, usersubscription.FieldEndAt)
	}
	if m.FieldCleared(usersubscription.FieldUsageState) {
		fields = append(fields, usersubscription.FieldUsageState)
	}
	if m.FieldCleared(usersubscription.FieldSubscriptionCredit) {
		fields = append(fields, usersubscription.FieldSubscriptionCredit)
	}
	if m.FieldCleared(usersubscription.FieldAddonCredit) {
		fields = append(fields, usersubscription.FieldAddonCredit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ClearField(name string) error {
	switch name {
	case usersubscription.FieldAppID:
		m.ClearAppID()
		return nil
	case usersubscription.FieldUserID:
		m.ClearUserID()
		return nil
	case usersubscription.FieldPackageID:
		m.ClearPackageID()
		return nil
	case usersubscription.FieldStartAt:
		m.ClearStartAt()
		return nil
	case usersubscription.FieldEndAt:
		m.ClearEndAt()
		return nil
	case usersubscription.FieldUsageState:
		m.ClearUsageState()
		return nil
	case usersubscription.FieldSubscriptionCredit:
		m.ClearSubscriptionCredit()
		return nil
	case usersubscription.FieldAddonCredit:
		m.ClearAddonCredit()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usersubscription.FieldEntID:
		m.ResetEntID()
		return nil
	case usersubscription.FieldAppID:
		m.ResetAppID()
		return nil
	case usersubscription.FieldUserID:
		m.ResetUserID()
		return nil
	case usersubscription.FieldPackageID:
		m.ResetPackageID()
		return nil
	case usersubscription.FieldStartAt:
		m.ResetStartAt()
		return nil
	case usersubscription.FieldEndAt:
		m.ResetEndAt()
		return nil
	case usersubscription.FieldUsageState:
		m.ResetUsageState()
		return nil
	case usersubscription.FieldSubscriptionCredit:
		m.ResetSubscriptionCredit()
		return nil
	case usersubscription.FieldAddonCredit:
		m.ResetAddonCredit()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSubscriptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSubscriptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSubscriptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSubscriptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserSubscription edge %s", name)
}

// UserSubscriptionChangeMutation represents an operation that mutates the UserSubscriptionChange nodes in the graph.
type UserSubscriptionChangeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	ent_id               *uuid.UUID
	app_id               *uuid.UUID
	user_id              *uuid.UUID
	user_subscription_id *uuid.UUID
	old_package_id       *uuid.UUID
	new_package_id       *uuid.UUID
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*UserSubscriptionChange, error)
	predicates           []predicate.UserSubscriptionChange
}

var _ ent.Mutation = (*UserSubscriptionChangeMutation)(nil)

// usersubscriptionchangeOption allows management of the mutation configuration using functional options.
type usersubscriptionchangeOption func(*UserSubscriptionChangeMutation)

// newUserSubscriptionChangeMutation creates new mutation for the UserSubscriptionChange entity.
func newUserSubscriptionChangeMutation(c config, op Op, opts ...usersubscriptionchangeOption) *UserSubscriptionChangeMutation {
	m := &UserSubscriptionChangeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSubscriptionChange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSubscriptionChangeID sets the ID field of the mutation.
func withUserSubscriptionChangeID(id uint32) usersubscriptionchangeOption {
	return func(m *UserSubscriptionChangeMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSubscriptionChange
		)
		m.oldValue = func(ctx context.Context) (*UserSubscriptionChange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSubscriptionChange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSubscriptionChange sets the old UserSubscriptionChange of the mutation.
func withUserSubscriptionChange(node *UserSubscriptionChange) usersubscriptionchangeOption {
	return func(m *UserSubscriptionChangeMutation) {
		m.oldValue = func(context.Context) (*UserSubscriptionChange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSubscriptionChangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSubscriptionChangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSubscriptionChange entities.
func (m *UserSubscriptionChangeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSubscriptionChangeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSubscriptionChangeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSubscriptionChange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *UserSubscriptionChangeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *UserSubscriptionChangeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the UserSubscriptionChange entity.
// If the UserSubscriptionChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionChangeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *UserSubscriptionChangeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *UserSubscriptionChangeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *UserSubscriptionChangeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the UserSubscriptionChange entity.
// If the UserSubscriptionChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionChangeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *UserSubscriptionChangeMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[usersubscriptionchange.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *UserSubscriptionChangeMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[usersubscriptionchange.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *UserSubscriptionChangeMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, usersubscriptionchange.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *UserSubscriptionChangeMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSubscriptionChangeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSubscriptionChange entity.
// If the UserSubscriptionChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionChangeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserSubscriptionChangeMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[usersubscriptionchange.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserSubscriptionChangeMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usersubscriptionchange.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSubscriptionChangeMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, usersubscriptionchange.FieldUserID)
}

// SetUserSubscriptionID sets the "user_subscription_id" field.
func (m *UserSubscriptionChangeMutation) SetUserSubscriptionID(u uuid.UUID) {
	m.user_subscription_id = &u
}

// UserSubscriptionID returns the value of the "user_subscription_id" field in the mutation.
func (m *UserSubscriptionChangeMutation) UserSubscriptionID() (r uuid.UUID, exists bool) {
	v := m.user_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSubscriptionID returns the old "user_subscription_id" field's value of the UserSubscriptionChange entity.
// If the UserSubscriptionChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionChangeMutation) OldUserSubscriptionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSubscriptionID: %w", err)
	}
	return oldValue.UserSubscriptionID, nil
}

// ClearUserSubscriptionID clears the value of the "user_subscription_id" field.
func (m *UserSubscriptionChangeMutation) ClearUserSubscriptionID() {
	m.user_subscription_id = nil
	m.clearedFields[usersubscriptionchange.FieldUserSubscriptionID] = struct{}{}
}

// UserSubscriptionIDCleared returns if the "user_subscription_id" field was cleared in this mutation.
func (m *UserSubscriptionChangeMutation) UserSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[usersubscriptionchange.FieldUserSubscriptionID]
	return ok
}

// ResetUserSubscriptionID resets all changes to the "user_subscription_id" field.
func (m *UserSubscriptionChangeMutation) ResetUserSubscriptionID() {
	m.user_subscription_id = nil
	delete(m.clearedFields, usersubscriptionchange.FieldUserSubscriptionID)
}

// SetOldPackageID sets the "old_package_id" field.
func (m *UserSubscriptionChangeMutation) SetOldPackageID(u uuid.UUID) {
	m.old_package_id = &u
}

// OldPackageID returns the value of the "old_package_id" field in the mutation.
func (m *UserSubscriptionChangeMutation) OldPackageID() (r uuid.UUID, exists bool) {
	v := m.old_package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOldPackageID returns the old "old_package_id" field's value of the UserSubscriptionChange entity.
// If the UserSubscriptionChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionChangeMutation) OldOldPackageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldPackageID: %w", err)
	}
	return oldValue.OldPackageID, nil
}

// ClearOldPackageID clears the value of the "old_package_id" field.
func (m *UserSubscriptionChangeMutation) ClearOldPackageID() {
	m.old_package_id = nil
	m.clearedFields[usersubscriptionchange.FieldOldPackageID] = struct{}{}
}

// OldPackageIDCleared returns if the "old_package_id" field was cleared in this mutation.
func (m *UserSubscriptionChangeMutation) OldPackageIDCleared() bool {
	_, ok := m.clearedFields[usersubscriptionchange.FieldOldPackageID]
	return ok
}

// ResetOldPackageID resets all changes to the "old_package_id" field.
func (m *UserSubscriptionChangeMutation) ResetOldPackageID() {
	m.old_package_id = nil
	delete(m.clearedFields, usersubscriptionchange.FieldOldPackageID)
}

// SetNewPackageID sets the "new_package_id" field.
func (m *UserSubscriptionChangeMutation) SetNewPackageID(u uuid.UUID) {
	m.new_package_id = &u
}

// NewPackageID returns the value of the "new_package_id" field in the mutation.
func (m *UserSubscriptionChangeMutation) NewPackageID() (r uuid.UUID, exists bool) {
	v := m.new_package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNewPackageID returns the old "new_package_id" field's value of the UserSubscriptionChange entity.
// If the UserSubscriptionChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionChangeMutation) OldNewPackageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewPackageID: %w", err)
	}
	return oldValue.NewPackageID, nil
}

// ClearNewPackageID clears the value of the "new_package_id" field.
func (m *UserSubscriptionChangeMutation) ClearNewPackageID() {
	m.new_package_id = nil
	m.clearedFields[usersubscriptionchange.FieldNewPackageID] = struct{}{}
}

// NewPackageIDCleared returns if the "new_package_id" field was cleared in this mutation.
func (m *UserSubscriptionChangeMutation) NewPackageIDCleared() bool {
	_, ok := m.clearedFields[usersubscriptionchange.FieldNewPackageID]
	return ok
}

// ResetNewPackageID resets all changes to the "new_package_id" field.
func (m *UserSubscriptionChangeMutation) ResetNewPackageID() {
	m.new_package_id = nil
	delete(m.clearedFields, usersubscriptionchange.FieldNewPackageID)
}

// Where appends a list predicates to the UserSubscriptionChangeMutation builder.
func (m *UserSubscriptionChangeMutation) Where(ps ...predicate.UserSubscriptionChange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSubscriptionChangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSubscriptionChangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSubscriptionChange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSubscriptionChangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSubscriptionChangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSubscriptionChange).
func (m *UserSubscriptionChangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSubscriptionChangeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.ent_id != nil {
		fields = append(fields, usersubscriptionchange.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, usersubscriptionchange.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, usersubscriptionchange.FieldUserID)
	}
	if m.user_subscription_id != nil {
		fields = append(fields, usersubscriptionchange.FieldUserSubscriptionID)
	}
	if m.old_package_id != nil {
		fields = append(fields, usersubscriptionchange.FieldOldPackageID)
	}
	if m.new_package_id != nil {
		fields = append(fields, usersubscriptionchange.FieldNewPackageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSubscriptionChangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersubscriptionchange.FieldEntID:
		return m.EntID()
	case usersubscriptionchange.FieldAppID:
		return m.AppID()
	case usersubscriptionchange.FieldUserID:
		return m.UserID()
	case usersubscriptionchange.FieldUserSubscriptionID:
		return m.UserSubscriptionID()
	case usersubscriptionchange.FieldOldPackageID:
		return m.OldPackageID()
	case usersubscriptionchange.FieldNewPackageID:
		return m.NewPackageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSubscriptionChangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersubscriptionchange.FieldEntID:
		return m.OldEntID(ctx)
	case usersubscriptionchange.FieldAppID:
		return m.OldAppID(ctx)
	case usersubscriptionchange.FieldUserID:
		return m.OldUserID(ctx)
	case usersubscriptionchange.FieldUserSubscriptionID:
		return m.OldUserSubscriptionID(ctx)
	case usersubscriptionchange.FieldOldPackageID:
		return m.OldOldPackageID(ctx)
	case usersubscriptionchange.FieldNewPackageID:
		return m.OldNewPackageID(ctx)
	}
	return nil, fmt.Errorf("unknown UserSubscriptionChange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionChangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersubscriptionchange.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case usersubscriptionchange.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case usersubscriptionchange.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersubscriptionchange.FieldUserSubscriptionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSubscriptionID(v)
		return nil
	case usersubscriptionchange.FieldOldPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldPackageID(v)
		return nil
	case usersubscriptionchange.FieldNewPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewPackageID(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscriptionChange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSubscriptionChangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSubscriptionChangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionChangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSubscriptionChange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSubscriptionChangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersubscriptionchange.FieldAppID) {
		fields = append(fields, usersubscriptionchange.FieldAppID)
	}
	if m.FieldCleared(usersubscriptionchange.FieldUserID) {
		fields = append(fields, usersubscriptionchange.FieldUserID)
	}
	if m.FieldCleared(usersubscriptionchange.FieldUserSubscriptionID) {
		fields = append(fields, usersubscriptionchange.FieldUserSubscriptionID)
	}
	if m.FieldCleared(usersubscriptionchange.FieldOldPackageID) {
		fields = append(fields, usersubscriptionchange.FieldOldPackageID)
	}
	if m.FieldCleared(usersubscriptionchange.FieldNewPackageID) {
		fields = append(fields, usersubscriptionchange.FieldNewPackageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSubscriptionChangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSubscriptionChangeMutation) ClearField(name string) error {
	switch name {
	case usersubscriptionchange.FieldAppID:
		m.ClearAppID()
		return nil
	case usersubscriptionchange.FieldUserID:
		m.ClearUserID()
		return nil
	case usersubscriptionchange.FieldUserSubscriptionID:
		m.ClearUserSubscriptionID()
		return nil
	case usersubscriptionchange.FieldOldPackageID:
		m.ClearOldPackageID()
		return nil
	case usersubscriptionchange.FieldNewPackageID:
		m.ClearNewPackageID()
		return nil
	}
	return fmt.Errorf("unknown UserSubscriptionChange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSubscriptionChangeMutation) ResetField(name string) error {
	switch name {
	case usersubscriptionchange.FieldEntID:
		m.ResetEntID()
		return nil
	case usersubscriptionchange.FieldAppID:
		m.ResetAppID()
		return nil
	case usersubscriptionchange.FieldUserID:
		m.ResetUserID()
		return nil
	case usersubscriptionchange.FieldUserSubscriptionID:
		m.ResetUserSubscriptionID()
		return nil
	case usersubscriptionchange.FieldOldPackageID:
		m.ResetOldPackageID()
		return nil
	case usersubscriptionchange.FieldNewPackageID:
		m.ResetNewPackageID()
		return nil
	}
	return fmt.Errorf("unknown UserSubscriptionChange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSubscriptionChangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSubscriptionChangeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSubscriptionChangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSubscriptionChangeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSubscriptionChangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSubscriptionChangeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSubscriptionChangeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserSubscriptionChange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSubscriptionChangeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserSubscriptionChange edge %s", name)
}
