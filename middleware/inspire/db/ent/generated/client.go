// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/achievement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/achievementuser"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/appcommissionconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/appconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/appgoodcommissionconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/appgoodscope"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/cashcontrol"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/coinallocated"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/coinconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/commission"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/coupon"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/couponallocated"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/couponscope"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/creditallocated"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/event"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/eventcoin"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/eventcoupon"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/goodachievement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/goodcoinachievement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/invitationcode"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/orderpaymentstatement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/orderstatement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/registration"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/statement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/taskconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/taskuser"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/usercoinreward"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/userreward"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Achievement is the client for interacting with the Achievement builders.
	Achievement *AchievementClient
	// AchievementUser is the client for interacting with the AchievementUser builders.
	AchievementUser *AchievementUserClient
	// AppCommissionConfig is the client for interacting with the AppCommissionConfig builders.
	AppCommissionConfig *AppCommissionConfigClient
	// AppConfig is the client for interacting with the AppConfig builders.
	AppConfig *AppConfigClient
	// AppGoodCommissionConfig is the client for interacting with the AppGoodCommissionConfig builders.
	AppGoodCommissionConfig *AppGoodCommissionConfigClient
	// AppGoodScope is the client for interacting with the AppGoodScope builders.
	AppGoodScope *AppGoodScopeClient
	// CashControl is the client for interacting with the CashControl builders.
	CashControl *CashControlClient
	// CoinAllocated is the client for interacting with the CoinAllocated builders.
	CoinAllocated *CoinAllocatedClient
	// CoinConfig is the client for interacting with the CoinConfig builders.
	CoinConfig *CoinConfigClient
	// Commission is the client for interacting with the Commission builders.
	Commission *CommissionClient
	// Coupon is the client for interacting with the Coupon builders.
	Coupon *CouponClient
	// CouponAllocated is the client for interacting with the CouponAllocated builders.
	CouponAllocated *CouponAllocatedClient
	// CouponScope is the client for interacting with the CouponScope builders.
	CouponScope *CouponScopeClient
	// CreditAllocated is the client for interacting with the CreditAllocated builders.
	CreditAllocated *CreditAllocatedClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// EventCoin is the client for interacting with the EventCoin builders.
	EventCoin *EventCoinClient
	// EventCoupon is the client for interacting with the EventCoupon builders.
	EventCoupon *EventCouponClient
	// GoodAchievement is the client for interacting with the GoodAchievement builders.
	GoodAchievement *GoodAchievementClient
	// GoodCoinAchievement is the client for interacting with the GoodCoinAchievement builders.
	GoodCoinAchievement *GoodCoinAchievementClient
	// InvitationCode is the client for interacting with the InvitationCode builders.
	InvitationCode *InvitationCodeClient
	// OrderPaymentStatement is the client for interacting with the OrderPaymentStatement builders.
	OrderPaymentStatement *OrderPaymentStatementClient
	// OrderStatement is the client for interacting with the OrderStatement builders.
	OrderStatement *OrderStatementClient
	// Registration is the client for interacting with the Registration builders.
	Registration *RegistrationClient
	// Statement is the client for interacting with the Statement builders.
	Statement *StatementClient
	// TaskConfig is the client for interacting with the TaskConfig builders.
	TaskConfig *TaskConfigClient
	// TaskUser is the client for interacting with the TaskUser builders.
	TaskUser *TaskUserClient
	// UserCoinReward is the client for interacting with the UserCoinReward builders.
	UserCoinReward *UserCoinRewardClient
	// UserReward is the client for interacting with the UserReward builders.
	UserReward *UserRewardClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Achievement = NewAchievementClient(c.config)
	c.AchievementUser = NewAchievementUserClient(c.config)
	c.AppCommissionConfig = NewAppCommissionConfigClient(c.config)
	c.AppConfig = NewAppConfigClient(c.config)
	c.AppGoodCommissionConfig = NewAppGoodCommissionConfigClient(c.config)
	c.AppGoodScope = NewAppGoodScopeClient(c.config)
	c.CashControl = NewCashControlClient(c.config)
	c.CoinAllocated = NewCoinAllocatedClient(c.config)
	c.CoinConfig = NewCoinConfigClient(c.config)
	c.Commission = NewCommissionClient(c.config)
	c.Coupon = NewCouponClient(c.config)
	c.CouponAllocated = NewCouponAllocatedClient(c.config)
	c.CouponScope = NewCouponScopeClient(c.config)
	c.CreditAllocated = NewCreditAllocatedClient(c.config)
	c.Event = NewEventClient(c.config)
	c.EventCoin = NewEventCoinClient(c.config)
	c.EventCoupon = NewEventCouponClient(c.config)
	c.GoodAchievement = NewGoodAchievementClient(c.config)
	c.GoodCoinAchievement = NewGoodCoinAchievementClient(c.config)
	c.InvitationCode = NewInvitationCodeClient(c.config)
	c.OrderPaymentStatement = NewOrderPaymentStatementClient(c.config)
	c.OrderStatement = NewOrderStatementClient(c.config)
	c.Registration = NewRegistrationClient(c.config)
	c.Statement = NewStatementClient(c.config)
	c.TaskConfig = NewTaskConfigClient(c.config)
	c.TaskUser = NewTaskUserClient(c.config)
	c.UserCoinReward = NewUserCoinRewardClient(c.config)
	c.UserReward = NewUserRewardClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("generated: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("generated: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		Achievement:             NewAchievementClient(cfg),
		AchievementUser:         NewAchievementUserClient(cfg),
		AppCommissionConfig:     NewAppCommissionConfigClient(cfg),
		AppConfig:               NewAppConfigClient(cfg),
		AppGoodCommissionConfig: NewAppGoodCommissionConfigClient(cfg),
		AppGoodScope:            NewAppGoodScopeClient(cfg),
		CashControl:             NewCashControlClient(cfg),
		CoinAllocated:           NewCoinAllocatedClient(cfg),
		CoinConfig:              NewCoinConfigClient(cfg),
		Commission:              NewCommissionClient(cfg),
		Coupon:                  NewCouponClient(cfg),
		CouponAllocated:         NewCouponAllocatedClient(cfg),
		CouponScope:             NewCouponScopeClient(cfg),
		CreditAllocated:         NewCreditAllocatedClient(cfg),
		Event:                   NewEventClient(cfg),
		EventCoin:               NewEventCoinClient(cfg),
		EventCoupon:             NewEventCouponClient(cfg),
		GoodAchievement:         NewGoodAchievementClient(cfg),
		GoodCoinAchievement:     NewGoodCoinAchievementClient(cfg),
		InvitationCode:          NewInvitationCodeClient(cfg),
		OrderPaymentStatement:   NewOrderPaymentStatementClient(cfg),
		OrderStatement:          NewOrderStatementClient(cfg),
		Registration:            NewRegistrationClient(cfg),
		Statement:               NewStatementClient(cfg),
		TaskConfig:              NewTaskConfigClient(cfg),
		TaskUser:                NewTaskUserClient(cfg),
		UserCoinReward:          NewUserCoinRewardClient(cfg),
		UserReward:              NewUserRewardClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		Achievement:             NewAchievementClient(cfg),
		AchievementUser:         NewAchievementUserClient(cfg),
		AppCommissionConfig:     NewAppCommissionConfigClient(cfg),
		AppConfig:               NewAppConfigClient(cfg),
		AppGoodCommissionConfig: NewAppGoodCommissionConfigClient(cfg),
		AppGoodScope:            NewAppGoodScopeClient(cfg),
		CashControl:             NewCashControlClient(cfg),
		CoinAllocated:           NewCoinAllocatedClient(cfg),
		CoinConfig:              NewCoinConfigClient(cfg),
		Commission:              NewCommissionClient(cfg),
		Coupon:                  NewCouponClient(cfg),
		CouponAllocated:         NewCouponAllocatedClient(cfg),
		CouponScope:             NewCouponScopeClient(cfg),
		CreditAllocated:         NewCreditAllocatedClient(cfg),
		Event:                   NewEventClient(cfg),
		EventCoin:               NewEventCoinClient(cfg),
		EventCoupon:             NewEventCouponClient(cfg),
		GoodAchievement:         NewGoodAchievementClient(cfg),
		GoodCoinAchievement:     NewGoodCoinAchievementClient(cfg),
		InvitationCode:          NewInvitationCodeClient(cfg),
		OrderPaymentStatement:   NewOrderPaymentStatementClient(cfg),
		OrderStatement:          NewOrderStatementClient(cfg),
		Registration:            NewRegistrationClient(cfg),
		Statement:               NewStatementClient(cfg),
		TaskConfig:              NewTaskConfigClient(cfg),
		TaskUser:                NewTaskUserClient(cfg),
		UserCoinReward:          NewUserCoinRewardClient(cfg),
		UserReward:              NewUserRewardClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Achievement.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Achievement, c.AchievementUser, c.AppCommissionConfig, c.AppConfig,
		c.AppGoodCommissionConfig, c.AppGoodScope, c.CashControl, c.CoinAllocated,
		c.CoinConfig, c.Commission, c.Coupon, c.CouponAllocated, c.CouponScope,
		c.CreditAllocated, c.Event, c.EventCoin, c.EventCoupon, c.GoodAchievement,
		c.GoodCoinAchievement, c.InvitationCode, c.OrderPaymentStatement,
		c.OrderStatement, c.Registration, c.Statement, c.TaskConfig, c.TaskUser,
		c.UserCoinReward, c.UserReward,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Achievement, c.AchievementUser, c.AppCommissionConfig, c.AppConfig,
		c.AppGoodCommissionConfig, c.AppGoodScope, c.CashControl, c.CoinAllocated,
		c.CoinConfig, c.Commission, c.Coupon, c.CouponAllocated, c.CouponScope,
		c.CreditAllocated, c.Event, c.EventCoin, c.EventCoupon, c.GoodAchievement,
		c.GoodCoinAchievement, c.InvitationCode, c.OrderPaymentStatement,
		c.OrderStatement, c.Registration, c.Statement, c.TaskConfig, c.TaskUser,
		c.UserCoinReward, c.UserReward,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AchievementMutation:
		return c.Achievement.mutate(ctx, m)
	case *AchievementUserMutation:
		return c.AchievementUser.mutate(ctx, m)
	case *AppCommissionConfigMutation:
		return c.AppCommissionConfig.mutate(ctx, m)
	case *AppConfigMutation:
		return c.AppConfig.mutate(ctx, m)
	case *AppGoodCommissionConfigMutation:
		return c.AppGoodCommissionConfig.mutate(ctx, m)
	case *AppGoodScopeMutation:
		return c.AppGoodScope.mutate(ctx, m)
	case *CashControlMutation:
		return c.CashControl.mutate(ctx, m)
	case *CoinAllocatedMutation:
		return c.CoinAllocated.mutate(ctx, m)
	case *CoinConfigMutation:
		return c.CoinConfig.mutate(ctx, m)
	case *CommissionMutation:
		return c.Commission.mutate(ctx, m)
	case *CouponMutation:
		return c.Coupon.mutate(ctx, m)
	case *CouponAllocatedMutation:
		return c.CouponAllocated.mutate(ctx, m)
	case *CouponScopeMutation:
		return c.CouponScope.mutate(ctx, m)
	case *CreditAllocatedMutation:
		return c.CreditAllocated.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *EventCoinMutation:
		return c.EventCoin.mutate(ctx, m)
	case *EventCouponMutation:
		return c.EventCoupon.mutate(ctx, m)
	case *GoodAchievementMutation:
		return c.GoodAchievement.mutate(ctx, m)
	case *GoodCoinAchievementMutation:
		return c.GoodCoinAchievement.mutate(ctx, m)
	case *InvitationCodeMutation:
		return c.InvitationCode.mutate(ctx, m)
	case *OrderPaymentStatementMutation:
		return c.OrderPaymentStatement.mutate(ctx, m)
	case *OrderStatementMutation:
		return c.OrderStatement.mutate(ctx, m)
	case *RegistrationMutation:
		return c.Registration.mutate(ctx, m)
	case *StatementMutation:
		return c.Statement.mutate(ctx, m)
	case *TaskConfigMutation:
		return c.TaskConfig.mutate(ctx, m)
	case *TaskUserMutation:
		return c.TaskUser.mutate(ctx, m)
	case *UserCoinRewardMutation:
		return c.UserCoinReward.mutate(ctx, m)
	case *UserRewardMutation:
		return c.UserReward.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("generated: unknown mutation type %T", m)
	}
}

// AchievementClient is a client for the Achievement schema.
type AchievementClient struct {
	config
}

// NewAchievementClient returns a client for the Achievement from the given config.
func NewAchievementClient(c config) *AchievementClient {
	return &AchievementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `achievement.Hooks(f(g(h())))`.
func (c *AchievementClient) Use(hooks ...Hook) {
	c.hooks.Achievement = append(c.hooks.Achievement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `achievement.Intercept(f(g(h())))`.
func (c *AchievementClient) Intercept(interceptors ...Interceptor) {
	c.inters.Achievement = append(c.inters.Achievement, interceptors...)
}

// Create returns a builder for creating a Achievement entity.
func (c *AchievementClient) Create() *AchievementCreate {
	mutation := newAchievementMutation(c.config, OpCreate)
	return &AchievementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Achievement entities.
func (c *AchievementClient) CreateBulk(builders ...*AchievementCreate) *AchievementCreateBulk {
	return &AchievementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AchievementClient) MapCreateBulk(slice any, setFunc func(*AchievementCreate, int)) *AchievementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AchievementCreateBulk{err: fmt.Errorf("calling to AchievementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AchievementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AchievementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Achievement.
func (c *AchievementClient) Update() *AchievementUpdate {
	mutation := newAchievementMutation(c.config, OpUpdate)
	return &AchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AchievementClient) UpdateOne(a *Achievement) *AchievementUpdateOne {
	mutation := newAchievementMutation(c.config, OpUpdateOne, withAchievement(a))
	return &AchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AchievementClient) UpdateOneID(id uint32) *AchievementUpdateOne {
	mutation := newAchievementMutation(c.config, OpUpdateOne, withAchievementID(id))
	return &AchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Achievement.
func (c *AchievementClient) Delete() *AchievementDelete {
	mutation := newAchievementMutation(c.config, OpDelete)
	return &AchievementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AchievementClient) DeleteOne(a *Achievement) *AchievementDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AchievementClient) DeleteOneID(id uint32) *AchievementDeleteOne {
	builder := c.Delete().Where(achievement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AchievementDeleteOne{builder}
}

// Query returns a query builder for Achievement.
func (c *AchievementClient) Query() *AchievementQuery {
	return &AchievementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAchievement},
		inters: c.Interceptors(),
	}
}

// Get returns a Achievement entity by its id.
func (c *AchievementClient) Get(ctx context.Context, id uint32) (*Achievement, error) {
	return c.Query().Where(achievement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AchievementClient) GetX(ctx context.Context, id uint32) *Achievement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AchievementClient) Hooks() []Hook {
	return c.hooks.Achievement
}

// Interceptors returns the client interceptors.
func (c *AchievementClient) Interceptors() []Interceptor {
	return c.inters.Achievement
}

func (c *AchievementClient) mutate(ctx context.Context, m *AchievementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AchievementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AchievementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Achievement mutation op: %q", m.Op())
	}
}

// AchievementUserClient is a client for the AchievementUser schema.
type AchievementUserClient struct {
	config
}

// NewAchievementUserClient returns a client for the AchievementUser from the given config.
func NewAchievementUserClient(c config) *AchievementUserClient {
	return &AchievementUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `achievementuser.Hooks(f(g(h())))`.
func (c *AchievementUserClient) Use(hooks ...Hook) {
	c.hooks.AchievementUser = append(c.hooks.AchievementUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `achievementuser.Intercept(f(g(h())))`.
func (c *AchievementUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AchievementUser = append(c.inters.AchievementUser, interceptors...)
}

// Create returns a builder for creating a AchievementUser entity.
func (c *AchievementUserClient) Create() *AchievementUserCreate {
	mutation := newAchievementUserMutation(c.config, OpCreate)
	return &AchievementUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AchievementUser entities.
func (c *AchievementUserClient) CreateBulk(builders ...*AchievementUserCreate) *AchievementUserCreateBulk {
	return &AchievementUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AchievementUserClient) MapCreateBulk(slice any, setFunc func(*AchievementUserCreate, int)) *AchievementUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AchievementUserCreateBulk{err: fmt.Errorf("calling to AchievementUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AchievementUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AchievementUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AchievementUser.
func (c *AchievementUserClient) Update() *AchievementUserUpdate {
	mutation := newAchievementUserMutation(c.config, OpUpdate)
	return &AchievementUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AchievementUserClient) UpdateOne(au *AchievementUser) *AchievementUserUpdateOne {
	mutation := newAchievementUserMutation(c.config, OpUpdateOne, withAchievementUser(au))
	return &AchievementUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AchievementUserClient) UpdateOneID(id uint32) *AchievementUserUpdateOne {
	mutation := newAchievementUserMutation(c.config, OpUpdateOne, withAchievementUserID(id))
	return &AchievementUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AchievementUser.
func (c *AchievementUserClient) Delete() *AchievementUserDelete {
	mutation := newAchievementUserMutation(c.config, OpDelete)
	return &AchievementUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AchievementUserClient) DeleteOne(au *AchievementUser) *AchievementUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AchievementUserClient) DeleteOneID(id uint32) *AchievementUserDeleteOne {
	builder := c.Delete().Where(achievementuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AchievementUserDeleteOne{builder}
}

// Query returns a query builder for AchievementUser.
func (c *AchievementUserClient) Query() *AchievementUserQuery {
	return &AchievementUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAchievementUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AchievementUser entity by its id.
func (c *AchievementUserClient) Get(ctx context.Context, id uint32) (*AchievementUser, error) {
	return c.Query().Where(achievementuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AchievementUserClient) GetX(ctx context.Context, id uint32) *AchievementUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AchievementUserClient) Hooks() []Hook {
	return c.hooks.AchievementUser
}

// Interceptors returns the client interceptors.
func (c *AchievementUserClient) Interceptors() []Interceptor {
	return c.inters.AchievementUser
}

func (c *AchievementUserClient) mutate(ctx context.Context, m *AchievementUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AchievementUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AchievementUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AchievementUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AchievementUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AchievementUser mutation op: %q", m.Op())
	}
}

// AppCommissionConfigClient is a client for the AppCommissionConfig schema.
type AppCommissionConfigClient struct {
	config
}

// NewAppCommissionConfigClient returns a client for the AppCommissionConfig from the given config.
func NewAppCommissionConfigClient(c config) *AppCommissionConfigClient {
	return &AppCommissionConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appcommissionconfig.Hooks(f(g(h())))`.
func (c *AppCommissionConfigClient) Use(hooks ...Hook) {
	c.hooks.AppCommissionConfig = append(c.hooks.AppCommissionConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appcommissionconfig.Intercept(f(g(h())))`.
func (c *AppCommissionConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppCommissionConfig = append(c.inters.AppCommissionConfig, interceptors...)
}

// Create returns a builder for creating a AppCommissionConfig entity.
func (c *AppCommissionConfigClient) Create() *AppCommissionConfigCreate {
	mutation := newAppCommissionConfigMutation(c.config, OpCreate)
	return &AppCommissionConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppCommissionConfig entities.
func (c *AppCommissionConfigClient) CreateBulk(builders ...*AppCommissionConfigCreate) *AppCommissionConfigCreateBulk {
	return &AppCommissionConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppCommissionConfigClient) MapCreateBulk(slice any, setFunc func(*AppCommissionConfigCreate, int)) *AppCommissionConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppCommissionConfigCreateBulk{err: fmt.Errorf("calling to AppCommissionConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppCommissionConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppCommissionConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppCommissionConfig.
func (c *AppCommissionConfigClient) Update() *AppCommissionConfigUpdate {
	mutation := newAppCommissionConfigMutation(c.config, OpUpdate)
	return &AppCommissionConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppCommissionConfigClient) UpdateOne(acc *AppCommissionConfig) *AppCommissionConfigUpdateOne {
	mutation := newAppCommissionConfigMutation(c.config, OpUpdateOne, withAppCommissionConfig(acc))
	return &AppCommissionConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppCommissionConfigClient) UpdateOneID(id uint32) *AppCommissionConfigUpdateOne {
	mutation := newAppCommissionConfigMutation(c.config, OpUpdateOne, withAppCommissionConfigID(id))
	return &AppCommissionConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppCommissionConfig.
func (c *AppCommissionConfigClient) Delete() *AppCommissionConfigDelete {
	mutation := newAppCommissionConfigMutation(c.config, OpDelete)
	return &AppCommissionConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppCommissionConfigClient) DeleteOne(acc *AppCommissionConfig) *AppCommissionConfigDeleteOne {
	return c.DeleteOneID(acc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppCommissionConfigClient) DeleteOneID(id uint32) *AppCommissionConfigDeleteOne {
	builder := c.Delete().Where(appcommissionconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppCommissionConfigDeleteOne{builder}
}

// Query returns a query builder for AppCommissionConfig.
func (c *AppCommissionConfigClient) Query() *AppCommissionConfigQuery {
	return &AppCommissionConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppCommissionConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a AppCommissionConfig entity by its id.
func (c *AppCommissionConfigClient) Get(ctx context.Context, id uint32) (*AppCommissionConfig, error) {
	return c.Query().Where(appcommissionconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppCommissionConfigClient) GetX(ctx context.Context, id uint32) *AppCommissionConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppCommissionConfigClient) Hooks() []Hook {
	return c.hooks.AppCommissionConfig
}

// Interceptors returns the client interceptors.
func (c *AppCommissionConfigClient) Interceptors() []Interceptor {
	return c.inters.AppCommissionConfig
}

func (c *AppCommissionConfigClient) mutate(ctx context.Context, m *AppCommissionConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppCommissionConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppCommissionConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppCommissionConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppCommissionConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppCommissionConfig mutation op: %q", m.Op())
	}
}

// AppConfigClient is a client for the AppConfig schema.
type AppConfigClient struct {
	config
}

// NewAppConfigClient returns a client for the AppConfig from the given config.
func NewAppConfigClient(c config) *AppConfigClient {
	return &AppConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appconfig.Hooks(f(g(h())))`.
func (c *AppConfigClient) Use(hooks ...Hook) {
	c.hooks.AppConfig = append(c.hooks.AppConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appconfig.Intercept(f(g(h())))`.
func (c *AppConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppConfig = append(c.inters.AppConfig, interceptors...)
}

// Create returns a builder for creating a AppConfig entity.
func (c *AppConfigClient) Create() *AppConfigCreate {
	mutation := newAppConfigMutation(c.config, OpCreate)
	return &AppConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppConfig entities.
func (c *AppConfigClient) CreateBulk(builders ...*AppConfigCreate) *AppConfigCreateBulk {
	return &AppConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppConfigClient) MapCreateBulk(slice any, setFunc func(*AppConfigCreate, int)) *AppConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppConfigCreateBulk{err: fmt.Errorf("calling to AppConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppConfig.
func (c *AppConfigClient) Update() *AppConfigUpdate {
	mutation := newAppConfigMutation(c.config, OpUpdate)
	return &AppConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppConfigClient) UpdateOne(ac *AppConfig) *AppConfigUpdateOne {
	mutation := newAppConfigMutation(c.config, OpUpdateOne, withAppConfig(ac))
	return &AppConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppConfigClient) UpdateOneID(id uint32) *AppConfigUpdateOne {
	mutation := newAppConfigMutation(c.config, OpUpdateOne, withAppConfigID(id))
	return &AppConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppConfig.
func (c *AppConfigClient) Delete() *AppConfigDelete {
	mutation := newAppConfigMutation(c.config, OpDelete)
	return &AppConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppConfigClient) DeleteOne(ac *AppConfig) *AppConfigDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppConfigClient) DeleteOneID(id uint32) *AppConfigDeleteOne {
	builder := c.Delete().Where(appconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppConfigDeleteOne{builder}
}

// Query returns a query builder for AppConfig.
func (c *AppConfigClient) Query() *AppConfigQuery {
	return &AppConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a AppConfig entity by its id.
func (c *AppConfigClient) Get(ctx context.Context, id uint32) (*AppConfig, error) {
	return c.Query().Where(appconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppConfigClient) GetX(ctx context.Context, id uint32) *AppConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppConfigClient) Hooks() []Hook {
	return c.hooks.AppConfig
}

// Interceptors returns the client interceptors.
func (c *AppConfigClient) Interceptors() []Interceptor {
	return c.inters.AppConfig
}

func (c *AppConfigClient) mutate(ctx context.Context, m *AppConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppConfig mutation op: %q", m.Op())
	}
}

// AppGoodCommissionConfigClient is a client for the AppGoodCommissionConfig schema.
type AppGoodCommissionConfigClient struct {
	config
}

// NewAppGoodCommissionConfigClient returns a client for the AppGoodCommissionConfig from the given config.
func NewAppGoodCommissionConfigClient(c config) *AppGoodCommissionConfigClient {
	return &AppGoodCommissionConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgoodcommissionconfig.Hooks(f(g(h())))`.
func (c *AppGoodCommissionConfigClient) Use(hooks ...Hook) {
	c.hooks.AppGoodCommissionConfig = append(c.hooks.AppGoodCommissionConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgoodcommissionconfig.Intercept(f(g(h())))`.
func (c *AppGoodCommissionConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGoodCommissionConfig = append(c.inters.AppGoodCommissionConfig, interceptors...)
}

// Create returns a builder for creating a AppGoodCommissionConfig entity.
func (c *AppGoodCommissionConfigClient) Create() *AppGoodCommissionConfigCreate {
	mutation := newAppGoodCommissionConfigMutation(c.config, OpCreate)
	return &AppGoodCommissionConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGoodCommissionConfig entities.
func (c *AppGoodCommissionConfigClient) CreateBulk(builders ...*AppGoodCommissionConfigCreate) *AppGoodCommissionConfigCreateBulk {
	return &AppGoodCommissionConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodCommissionConfigClient) MapCreateBulk(slice any, setFunc func(*AppGoodCommissionConfigCreate, int)) *AppGoodCommissionConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodCommissionConfigCreateBulk{err: fmt.Errorf("calling to AppGoodCommissionConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodCommissionConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodCommissionConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGoodCommissionConfig.
func (c *AppGoodCommissionConfigClient) Update() *AppGoodCommissionConfigUpdate {
	mutation := newAppGoodCommissionConfigMutation(c.config, OpUpdate)
	return &AppGoodCommissionConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodCommissionConfigClient) UpdateOne(agcc *AppGoodCommissionConfig) *AppGoodCommissionConfigUpdateOne {
	mutation := newAppGoodCommissionConfigMutation(c.config, OpUpdateOne, withAppGoodCommissionConfig(agcc))
	return &AppGoodCommissionConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodCommissionConfigClient) UpdateOneID(id uint32) *AppGoodCommissionConfigUpdateOne {
	mutation := newAppGoodCommissionConfigMutation(c.config, OpUpdateOne, withAppGoodCommissionConfigID(id))
	return &AppGoodCommissionConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGoodCommissionConfig.
func (c *AppGoodCommissionConfigClient) Delete() *AppGoodCommissionConfigDelete {
	mutation := newAppGoodCommissionConfigMutation(c.config, OpDelete)
	return &AppGoodCommissionConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodCommissionConfigClient) DeleteOne(agcc *AppGoodCommissionConfig) *AppGoodCommissionConfigDeleteOne {
	return c.DeleteOneID(agcc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodCommissionConfigClient) DeleteOneID(id uint32) *AppGoodCommissionConfigDeleteOne {
	builder := c.Delete().Where(appgoodcommissionconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodCommissionConfigDeleteOne{builder}
}

// Query returns a query builder for AppGoodCommissionConfig.
func (c *AppGoodCommissionConfigClient) Query() *AppGoodCommissionConfigQuery {
	return &AppGoodCommissionConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGoodCommissionConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGoodCommissionConfig entity by its id.
func (c *AppGoodCommissionConfigClient) Get(ctx context.Context, id uint32) (*AppGoodCommissionConfig, error) {
	return c.Query().Where(appgoodcommissionconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodCommissionConfigClient) GetX(ctx context.Context, id uint32) *AppGoodCommissionConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodCommissionConfigClient) Hooks() []Hook {
	return c.hooks.AppGoodCommissionConfig
}

// Interceptors returns the client interceptors.
func (c *AppGoodCommissionConfigClient) Interceptors() []Interceptor {
	return c.inters.AppGoodCommissionConfig
}

func (c *AppGoodCommissionConfigClient) mutate(ctx context.Context, m *AppGoodCommissionConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodCommissionConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodCommissionConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodCommissionConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodCommissionConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGoodCommissionConfig mutation op: %q", m.Op())
	}
}

// AppGoodScopeClient is a client for the AppGoodScope schema.
type AppGoodScopeClient struct {
	config
}

// NewAppGoodScopeClient returns a client for the AppGoodScope from the given config.
func NewAppGoodScopeClient(c config) *AppGoodScopeClient {
	return &AppGoodScopeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgoodscope.Hooks(f(g(h())))`.
func (c *AppGoodScopeClient) Use(hooks ...Hook) {
	c.hooks.AppGoodScope = append(c.hooks.AppGoodScope, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgoodscope.Intercept(f(g(h())))`.
func (c *AppGoodScopeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGoodScope = append(c.inters.AppGoodScope, interceptors...)
}

// Create returns a builder for creating a AppGoodScope entity.
func (c *AppGoodScopeClient) Create() *AppGoodScopeCreate {
	mutation := newAppGoodScopeMutation(c.config, OpCreate)
	return &AppGoodScopeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGoodScope entities.
func (c *AppGoodScopeClient) CreateBulk(builders ...*AppGoodScopeCreate) *AppGoodScopeCreateBulk {
	return &AppGoodScopeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodScopeClient) MapCreateBulk(slice any, setFunc func(*AppGoodScopeCreate, int)) *AppGoodScopeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodScopeCreateBulk{err: fmt.Errorf("calling to AppGoodScopeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodScopeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodScopeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGoodScope.
func (c *AppGoodScopeClient) Update() *AppGoodScopeUpdate {
	mutation := newAppGoodScopeMutation(c.config, OpUpdate)
	return &AppGoodScopeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodScopeClient) UpdateOne(ags *AppGoodScope) *AppGoodScopeUpdateOne {
	mutation := newAppGoodScopeMutation(c.config, OpUpdateOne, withAppGoodScope(ags))
	return &AppGoodScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodScopeClient) UpdateOneID(id uint32) *AppGoodScopeUpdateOne {
	mutation := newAppGoodScopeMutation(c.config, OpUpdateOne, withAppGoodScopeID(id))
	return &AppGoodScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGoodScope.
func (c *AppGoodScopeClient) Delete() *AppGoodScopeDelete {
	mutation := newAppGoodScopeMutation(c.config, OpDelete)
	return &AppGoodScopeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodScopeClient) DeleteOne(ags *AppGoodScope) *AppGoodScopeDeleteOne {
	return c.DeleteOneID(ags.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodScopeClient) DeleteOneID(id uint32) *AppGoodScopeDeleteOne {
	builder := c.Delete().Where(appgoodscope.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodScopeDeleteOne{builder}
}

// Query returns a query builder for AppGoodScope.
func (c *AppGoodScopeClient) Query() *AppGoodScopeQuery {
	return &AppGoodScopeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGoodScope},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGoodScope entity by its id.
func (c *AppGoodScopeClient) Get(ctx context.Context, id uint32) (*AppGoodScope, error) {
	return c.Query().Where(appgoodscope.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodScopeClient) GetX(ctx context.Context, id uint32) *AppGoodScope {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodScopeClient) Hooks() []Hook {
	return c.hooks.AppGoodScope
}

// Interceptors returns the client interceptors.
func (c *AppGoodScopeClient) Interceptors() []Interceptor {
	return c.inters.AppGoodScope
}

func (c *AppGoodScopeClient) mutate(ctx context.Context, m *AppGoodScopeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodScopeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodScopeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodScopeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGoodScope mutation op: %q", m.Op())
	}
}

// CashControlClient is a client for the CashControl schema.
type CashControlClient struct {
	config
}

// NewCashControlClient returns a client for the CashControl from the given config.
func NewCashControlClient(c config) *CashControlClient {
	return &CashControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cashcontrol.Hooks(f(g(h())))`.
func (c *CashControlClient) Use(hooks ...Hook) {
	c.hooks.CashControl = append(c.hooks.CashControl, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cashcontrol.Intercept(f(g(h())))`.
func (c *CashControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.CashControl = append(c.inters.CashControl, interceptors...)
}

// Create returns a builder for creating a CashControl entity.
func (c *CashControlClient) Create() *CashControlCreate {
	mutation := newCashControlMutation(c.config, OpCreate)
	return &CashControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CashControl entities.
func (c *CashControlClient) CreateBulk(builders ...*CashControlCreate) *CashControlCreateBulk {
	return &CashControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CashControlClient) MapCreateBulk(slice any, setFunc func(*CashControlCreate, int)) *CashControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CashControlCreateBulk{err: fmt.Errorf("calling to CashControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CashControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CashControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CashControl.
func (c *CashControlClient) Update() *CashControlUpdate {
	mutation := newCashControlMutation(c.config, OpUpdate)
	return &CashControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CashControlClient) UpdateOne(cc *CashControl) *CashControlUpdateOne {
	mutation := newCashControlMutation(c.config, OpUpdateOne, withCashControl(cc))
	return &CashControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CashControlClient) UpdateOneID(id uint32) *CashControlUpdateOne {
	mutation := newCashControlMutation(c.config, OpUpdateOne, withCashControlID(id))
	return &CashControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CashControl.
func (c *CashControlClient) Delete() *CashControlDelete {
	mutation := newCashControlMutation(c.config, OpDelete)
	return &CashControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CashControlClient) DeleteOne(cc *CashControl) *CashControlDeleteOne {
	return c.DeleteOneID(cc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CashControlClient) DeleteOneID(id uint32) *CashControlDeleteOne {
	builder := c.Delete().Where(cashcontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CashControlDeleteOne{builder}
}

// Query returns a query builder for CashControl.
func (c *CashControlClient) Query() *CashControlQuery {
	return &CashControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCashControl},
		inters: c.Interceptors(),
	}
}

// Get returns a CashControl entity by its id.
func (c *CashControlClient) Get(ctx context.Context, id uint32) (*CashControl, error) {
	return c.Query().Where(cashcontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CashControlClient) GetX(ctx context.Context, id uint32) *CashControl {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CashControlClient) Hooks() []Hook {
	return c.hooks.CashControl
}

// Interceptors returns the client interceptors.
func (c *CashControlClient) Interceptors() []Interceptor {
	return c.inters.CashControl
}

func (c *CashControlClient) mutate(ctx context.Context, m *CashControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CashControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CashControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CashControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CashControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CashControl mutation op: %q", m.Op())
	}
}

// CoinAllocatedClient is a client for the CoinAllocated schema.
type CoinAllocatedClient struct {
	config
}

// NewCoinAllocatedClient returns a client for the CoinAllocated from the given config.
func NewCoinAllocatedClient(c config) *CoinAllocatedClient {
	return &CoinAllocatedClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `coinallocated.Hooks(f(g(h())))`.
func (c *CoinAllocatedClient) Use(hooks ...Hook) {
	c.hooks.CoinAllocated = append(c.hooks.CoinAllocated, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `coinallocated.Intercept(f(g(h())))`.
func (c *CoinAllocatedClient) Intercept(interceptors ...Interceptor) {
	c.inters.CoinAllocated = append(c.inters.CoinAllocated, interceptors...)
}

// Create returns a builder for creating a CoinAllocated entity.
func (c *CoinAllocatedClient) Create() *CoinAllocatedCreate {
	mutation := newCoinAllocatedMutation(c.config, OpCreate)
	return &CoinAllocatedCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CoinAllocated entities.
func (c *CoinAllocatedClient) CreateBulk(builders ...*CoinAllocatedCreate) *CoinAllocatedCreateBulk {
	return &CoinAllocatedCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CoinAllocatedClient) MapCreateBulk(slice any, setFunc func(*CoinAllocatedCreate, int)) *CoinAllocatedCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CoinAllocatedCreateBulk{err: fmt.Errorf("calling to CoinAllocatedClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CoinAllocatedCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CoinAllocatedCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CoinAllocated.
func (c *CoinAllocatedClient) Update() *CoinAllocatedUpdate {
	mutation := newCoinAllocatedMutation(c.config, OpUpdate)
	return &CoinAllocatedUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CoinAllocatedClient) UpdateOne(ca *CoinAllocated) *CoinAllocatedUpdateOne {
	mutation := newCoinAllocatedMutation(c.config, OpUpdateOne, withCoinAllocated(ca))
	return &CoinAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CoinAllocatedClient) UpdateOneID(id uint32) *CoinAllocatedUpdateOne {
	mutation := newCoinAllocatedMutation(c.config, OpUpdateOne, withCoinAllocatedID(id))
	return &CoinAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CoinAllocated.
func (c *CoinAllocatedClient) Delete() *CoinAllocatedDelete {
	mutation := newCoinAllocatedMutation(c.config, OpDelete)
	return &CoinAllocatedDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CoinAllocatedClient) DeleteOne(ca *CoinAllocated) *CoinAllocatedDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CoinAllocatedClient) DeleteOneID(id uint32) *CoinAllocatedDeleteOne {
	builder := c.Delete().Where(coinallocated.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CoinAllocatedDeleteOne{builder}
}

// Query returns a query builder for CoinAllocated.
func (c *CoinAllocatedClient) Query() *CoinAllocatedQuery {
	return &CoinAllocatedQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCoinAllocated},
		inters: c.Interceptors(),
	}
}

// Get returns a CoinAllocated entity by its id.
func (c *CoinAllocatedClient) Get(ctx context.Context, id uint32) (*CoinAllocated, error) {
	return c.Query().Where(coinallocated.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CoinAllocatedClient) GetX(ctx context.Context, id uint32) *CoinAllocated {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CoinAllocatedClient) Hooks() []Hook {
	return c.hooks.CoinAllocated
}

// Interceptors returns the client interceptors.
func (c *CoinAllocatedClient) Interceptors() []Interceptor {
	return c.inters.CoinAllocated
}

func (c *CoinAllocatedClient) mutate(ctx context.Context, m *CoinAllocatedMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CoinAllocatedCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CoinAllocatedUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CoinAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CoinAllocatedDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CoinAllocated mutation op: %q", m.Op())
	}
}

// CoinConfigClient is a client for the CoinConfig schema.
type CoinConfigClient struct {
	config
}

// NewCoinConfigClient returns a client for the CoinConfig from the given config.
func NewCoinConfigClient(c config) *CoinConfigClient {
	return &CoinConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `coinconfig.Hooks(f(g(h())))`.
func (c *CoinConfigClient) Use(hooks ...Hook) {
	c.hooks.CoinConfig = append(c.hooks.CoinConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `coinconfig.Intercept(f(g(h())))`.
func (c *CoinConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.CoinConfig = append(c.inters.CoinConfig, interceptors...)
}

// Create returns a builder for creating a CoinConfig entity.
func (c *CoinConfigClient) Create() *CoinConfigCreate {
	mutation := newCoinConfigMutation(c.config, OpCreate)
	return &CoinConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CoinConfig entities.
func (c *CoinConfigClient) CreateBulk(builders ...*CoinConfigCreate) *CoinConfigCreateBulk {
	return &CoinConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CoinConfigClient) MapCreateBulk(slice any, setFunc func(*CoinConfigCreate, int)) *CoinConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CoinConfigCreateBulk{err: fmt.Errorf("calling to CoinConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CoinConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CoinConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CoinConfig.
func (c *CoinConfigClient) Update() *CoinConfigUpdate {
	mutation := newCoinConfigMutation(c.config, OpUpdate)
	return &CoinConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CoinConfigClient) UpdateOne(cc *CoinConfig) *CoinConfigUpdateOne {
	mutation := newCoinConfigMutation(c.config, OpUpdateOne, withCoinConfig(cc))
	return &CoinConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CoinConfigClient) UpdateOneID(id uint32) *CoinConfigUpdateOne {
	mutation := newCoinConfigMutation(c.config, OpUpdateOne, withCoinConfigID(id))
	return &CoinConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CoinConfig.
func (c *CoinConfigClient) Delete() *CoinConfigDelete {
	mutation := newCoinConfigMutation(c.config, OpDelete)
	return &CoinConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CoinConfigClient) DeleteOne(cc *CoinConfig) *CoinConfigDeleteOne {
	return c.DeleteOneID(cc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CoinConfigClient) DeleteOneID(id uint32) *CoinConfigDeleteOne {
	builder := c.Delete().Where(coinconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CoinConfigDeleteOne{builder}
}

// Query returns a query builder for CoinConfig.
func (c *CoinConfigClient) Query() *CoinConfigQuery {
	return &CoinConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCoinConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a CoinConfig entity by its id.
func (c *CoinConfigClient) Get(ctx context.Context, id uint32) (*CoinConfig, error) {
	return c.Query().Where(coinconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CoinConfigClient) GetX(ctx context.Context, id uint32) *CoinConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CoinConfigClient) Hooks() []Hook {
	return c.hooks.CoinConfig
}

// Interceptors returns the client interceptors.
func (c *CoinConfigClient) Interceptors() []Interceptor {
	return c.inters.CoinConfig
}

func (c *CoinConfigClient) mutate(ctx context.Context, m *CoinConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CoinConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CoinConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CoinConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CoinConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CoinConfig mutation op: %q", m.Op())
	}
}

// CommissionClient is a client for the Commission schema.
type CommissionClient struct {
	config
}

// NewCommissionClient returns a client for the Commission from the given config.
func NewCommissionClient(c config) *CommissionClient {
	return &CommissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `commission.Hooks(f(g(h())))`.
func (c *CommissionClient) Use(hooks ...Hook) {
	c.hooks.Commission = append(c.hooks.Commission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `commission.Intercept(f(g(h())))`.
func (c *CommissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Commission = append(c.inters.Commission, interceptors...)
}

// Create returns a builder for creating a Commission entity.
func (c *CommissionClient) Create() *CommissionCreate {
	mutation := newCommissionMutation(c.config, OpCreate)
	return &CommissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Commission entities.
func (c *CommissionClient) CreateBulk(builders ...*CommissionCreate) *CommissionCreateBulk {
	return &CommissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommissionClient) MapCreateBulk(slice any, setFunc func(*CommissionCreate, int)) *CommissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommissionCreateBulk{err: fmt.Errorf("calling to CommissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Commission.
func (c *CommissionClient) Update() *CommissionUpdate {
	mutation := newCommissionMutation(c.config, OpUpdate)
	return &CommissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommissionClient) UpdateOne(co *Commission) *CommissionUpdateOne {
	mutation := newCommissionMutation(c.config, OpUpdateOne, withCommission(co))
	return &CommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommissionClient) UpdateOneID(id uint32) *CommissionUpdateOne {
	mutation := newCommissionMutation(c.config, OpUpdateOne, withCommissionID(id))
	return &CommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Commission.
func (c *CommissionClient) Delete() *CommissionDelete {
	mutation := newCommissionMutation(c.config, OpDelete)
	return &CommissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommissionClient) DeleteOne(co *Commission) *CommissionDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommissionClient) DeleteOneID(id uint32) *CommissionDeleteOne {
	builder := c.Delete().Where(commission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommissionDeleteOne{builder}
}

// Query returns a query builder for Commission.
func (c *CommissionClient) Query() *CommissionQuery {
	return &CommissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCommission},
		inters: c.Interceptors(),
	}
}

// Get returns a Commission entity by its id.
func (c *CommissionClient) Get(ctx context.Context, id uint32) (*Commission, error) {
	return c.Query().Where(commission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommissionClient) GetX(ctx context.Context, id uint32) *Commission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CommissionClient) Hooks() []Hook {
	return c.hooks.Commission
}

// Interceptors returns the client interceptors.
func (c *CommissionClient) Interceptors() []Interceptor {
	return c.inters.Commission
}

func (c *CommissionClient) mutate(ctx context.Context, m *CommissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Commission mutation op: %q", m.Op())
	}
}

// CouponClient is a client for the Coupon schema.
type CouponClient struct {
	config
}

// NewCouponClient returns a client for the Coupon from the given config.
func NewCouponClient(c config) *CouponClient {
	return &CouponClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `coupon.Hooks(f(g(h())))`.
func (c *CouponClient) Use(hooks ...Hook) {
	c.hooks.Coupon = append(c.hooks.Coupon, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `coupon.Intercept(f(g(h())))`.
func (c *CouponClient) Intercept(interceptors ...Interceptor) {
	c.inters.Coupon = append(c.inters.Coupon, interceptors...)
}

// Create returns a builder for creating a Coupon entity.
func (c *CouponClient) Create() *CouponCreate {
	mutation := newCouponMutation(c.config, OpCreate)
	return &CouponCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Coupon entities.
func (c *CouponClient) CreateBulk(builders ...*CouponCreate) *CouponCreateBulk {
	return &CouponCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CouponClient) MapCreateBulk(slice any, setFunc func(*CouponCreate, int)) *CouponCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CouponCreateBulk{err: fmt.Errorf("calling to CouponClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CouponCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CouponCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Coupon.
func (c *CouponClient) Update() *CouponUpdate {
	mutation := newCouponMutation(c.config, OpUpdate)
	return &CouponUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CouponClient) UpdateOne(co *Coupon) *CouponUpdateOne {
	mutation := newCouponMutation(c.config, OpUpdateOne, withCoupon(co))
	return &CouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CouponClient) UpdateOneID(id uint32) *CouponUpdateOne {
	mutation := newCouponMutation(c.config, OpUpdateOne, withCouponID(id))
	return &CouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Coupon.
func (c *CouponClient) Delete() *CouponDelete {
	mutation := newCouponMutation(c.config, OpDelete)
	return &CouponDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CouponClient) DeleteOne(co *Coupon) *CouponDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CouponClient) DeleteOneID(id uint32) *CouponDeleteOne {
	builder := c.Delete().Where(coupon.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CouponDeleteOne{builder}
}

// Query returns a query builder for Coupon.
func (c *CouponClient) Query() *CouponQuery {
	return &CouponQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCoupon},
		inters: c.Interceptors(),
	}
}

// Get returns a Coupon entity by its id.
func (c *CouponClient) Get(ctx context.Context, id uint32) (*Coupon, error) {
	return c.Query().Where(coupon.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CouponClient) GetX(ctx context.Context, id uint32) *Coupon {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CouponClient) Hooks() []Hook {
	return c.hooks.Coupon
}

// Interceptors returns the client interceptors.
func (c *CouponClient) Interceptors() []Interceptor {
	return c.inters.Coupon
}

func (c *CouponClient) mutate(ctx context.Context, m *CouponMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CouponCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CouponUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CouponDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Coupon mutation op: %q", m.Op())
	}
}

// CouponAllocatedClient is a client for the CouponAllocated schema.
type CouponAllocatedClient struct {
	config
}

// NewCouponAllocatedClient returns a client for the CouponAllocated from the given config.
func NewCouponAllocatedClient(c config) *CouponAllocatedClient {
	return &CouponAllocatedClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `couponallocated.Hooks(f(g(h())))`.
func (c *CouponAllocatedClient) Use(hooks ...Hook) {
	c.hooks.CouponAllocated = append(c.hooks.CouponAllocated, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `couponallocated.Intercept(f(g(h())))`.
func (c *CouponAllocatedClient) Intercept(interceptors ...Interceptor) {
	c.inters.CouponAllocated = append(c.inters.CouponAllocated, interceptors...)
}

// Create returns a builder for creating a CouponAllocated entity.
func (c *CouponAllocatedClient) Create() *CouponAllocatedCreate {
	mutation := newCouponAllocatedMutation(c.config, OpCreate)
	return &CouponAllocatedCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CouponAllocated entities.
func (c *CouponAllocatedClient) CreateBulk(builders ...*CouponAllocatedCreate) *CouponAllocatedCreateBulk {
	return &CouponAllocatedCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CouponAllocatedClient) MapCreateBulk(slice any, setFunc func(*CouponAllocatedCreate, int)) *CouponAllocatedCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CouponAllocatedCreateBulk{err: fmt.Errorf("calling to CouponAllocatedClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CouponAllocatedCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CouponAllocatedCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CouponAllocated.
func (c *CouponAllocatedClient) Update() *CouponAllocatedUpdate {
	mutation := newCouponAllocatedMutation(c.config, OpUpdate)
	return &CouponAllocatedUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CouponAllocatedClient) UpdateOne(ca *CouponAllocated) *CouponAllocatedUpdateOne {
	mutation := newCouponAllocatedMutation(c.config, OpUpdateOne, withCouponAllocated(ca))
	return &CouponAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CouponAllocatedClient) UpdateOneID(id uint32) *CouponAllocatedUpdateOne {
	mutation := newCouponAllocatedMutation(c.config, OpUpdateOne, withCouponAllocatedID(id))
	return &CouponAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CouponAllocated.
func (c *CouponAllocatedClient) Delete() *CouponAllocatedDelete {
	mutation := newCouponAllocatedMutation(c.config, OpDelete)
	return &CouponAllocatedDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CouponAllocatedClient) DeleteOne(ca *CouponAllocated) *CouponAllocatedDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CouponAllocatedClient) DeleteOneID(id uint32) *CouponAllocatedDeleteOne {
	builder := c.Delete().Where(couponallocated.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CouponAllocatedDeleteOne{builder}
}

// Query returns a query builder for CouponAllocated.
func (c *CouponAllocatedClient) Query() *CouponAllocatedQuery {
	return &CouponAllocatedQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCouponAllocated},
		inters: c.Interceptors(),
	}
}

// Get returns a CouponAllocated entity by its id.
func (c *CouponAllocatedClient) Get(ctx context.Context, id uint32) (*CouponAllocated, error) {
	return c.Query().Where(couponallocated.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CouponAllocatedClient) GetX(ctx context.Context, id uint32) *CouponAllocated {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CouponAllocatedClient) Hooks() []Hook {
	return c.hooks.CouponAllocated
}

// Interceptors returns the client interceptors.
func (c *CouponAllocatedClient) Interceptors() []Interceptor {
	return c.inters.CouponAllocated
}

func (c *CouponAllocatedClient) mutate(ctx context.Context, m *CouponAllocatedMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CouponAllocatedCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CouponAllocatedUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CouponAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CouponAllocatedDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CouponAllocated mutation op: %q", m.Op())
	}
}

// CouponScopeClient is a client for the CouponScope schema.
type CouponScopeClient struct {
	config
}

// NewCouponScopeClient returns a client for the CouponScope from the given config.
func NewCouponScopeClient(c config) *CouponScopeClient {
	return &CouponScopeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `couponscope.Hooks(f(g(h())))`.
func (c *CouponScopeClient) Use(hooks ...Hook) {
	c.hooks.CouponScope = append(c.hooks.CouponScope, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `couponscope.Intercept(f(g(h())))`.
func (c *CouponScopeClient) Intercept(interceptors ...Interceptor) {
	c.inters.CouponScope = append(c.inters.CouponScope, interceptors...)
}

// Create returns a builder for creating a CouponScope entity.
func (c *CouponScopeClient) Create() *CouponScopeCreate {
	mutation := newCouponScopeMutation(c.config, OpCreate)
	return &CouponScopeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CouponScope entities.
func (c *CouponScopeClient) CreateBulk(builders ...*CouponScopeCreate) *CouponScopeCreateBulk {
	return &CouponScopeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CouponScopeClient) MapCreateBulk(slice any, setFunc func(*CouponScopeCreate, int)) *CouponScopeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CouponScopeCreateBulk{err: fmt.Errorf("calling to CouponScopeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CouponScopeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CouponScopeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CouponScope.
func (c *CouponScopeClient) Update() *CouponScopeUpdate {
	mutation := newCouponScopeMutation(c.config, OpUpdate)
	return &CouponScopeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CouponScopeClient) UpdateOne(cs *CouponScope) *CouponScopeUpdateOne {
	mutation := newCouponScopeMutation(c.config, OpUpdateOne, withCouponScope(cs))
	return &CouponScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CouponScopeClient) UpdateOneID(id uint32) *CouponScopeUpdateOne {
	mutation := newCouponScopeMutation(c.config, OpUpdateOne, withCouponScopeID(id))
	return &CouponScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CouponScope.
func (c *CouponScopeClient) Delete() *CouponScopeDelete {
	mutation := newCouponScopeMutation(c.config, OpDelete)
	return &CouponScopeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CouponScopeClient) DeleteOne(cs *CouponScope) *CouponScopeDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CouponScopeClient) DeleteOneID(id uint32) *CouponScopeDeleteOne {
	builder := c.Delete().Where(couponscope.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CouponScopeDeleteOne{builder}
}

// Query returns a query builder for CouponScope.
func (c *CouponScopeClient) Query() *CouponScopeQuery {
	return &CouponScopeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCouponScope},
		inters: c.Interceptors(),
	}
}

// Get returns a CouponScope entity by its id.
func (c *CouponScopeClient) Get(ctx context.Context, id uint32) (*CouponScope, error) {
	return c.Query().Where(couponscope.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CouponScopeClient) GetX(ctx context.Context, id uint32) *CouponScope {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CouponScopeClient) Hooks() []Hook {
	return c.hooks.CouponScope
}

// Interceptors returns the client interceptors.
func (c *CouponScopeClient) Interceptors() []Interceptor {
	return c.inters.CouponScope
}

func (c *CouponScopeClient) mutate(ctx context.Context, m *CouponScopeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CouponScopeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CouponScopeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CouponScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CouponScopeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CouponScope mutation op: %q", m.Op())
	}
}

// CreditAllocatedClient is a client for the CreditAllocated schema.
type CreditAllocatedClient struct {
	config
}

// NewCreditAllocatedClient returns a client for the CreditAllocated from the given config.
func NewCreditAllocatedClient(c config) *CreditAllocatedClient {
	return &CreditAllocatedClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `creditallocated.Hooks(f(g(h())))`.
func (c *CreditAllocatedClient) Use(hooks ...Hook) {
	c.hooks.CreditAllocated = append(c.hooks.CreditAllocated, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `creditallocated.Intercept(f(g(h())))`.
func (c *CreditAllocatedClient) Intercept(interceptors ...Interceptor) {
	c.inters.CreditAllocated = append(c.inters.CreditAllocated, interceptors...)
}

// Create returns a builder for creating a CreditAllocated entity.
func (c *CreditAllocatedClient) Create() *CreditAllocatedCreate {
	mutation := newCreditAllocatedMutation(c.config, OpCreate)
	return &CreditAllocatedCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CreditAllocated entities.
func (c *CreditAllocatedClient) CreateBulk(builders ...*CreditAllocatedCreate) *CreditAllocatedCreateBulk {
	return &CreditAllocatedCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CreditAllocatedClient) MapCreateBulk(slice any, setFunc func(*CreditAllocatedCreate, int)) *CreditAllocatedCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CreditAllocatedCreateBulk{err: fmt.Errorf("calling to CreditAllocatedClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CreditAllocatedCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CreditAllocatedCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CreditAllocated.
func (c *CreditAllocatedClient) Update() *CreditAllocatedUpdate {
	mutation := newCreditAllocatedMutation(c.config, OpUpdate)
	return &CreditAllocatedUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CreditAllocatedClient) UpdateOne(ca *CreditAllocated) *CreditAllocatedUpdateOne {
	mutation := newCreditAllocatedMutation(c.config, OpUpdateOne, withCreditAllocated(ca))
	return &CreditAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CreditAllocatedClient) UpdateOneID(id uint32) *CreditAllocatedUpdateOne {
	mutation := newCreditAllocatedMutation(c.config, OpUpdateOne, withCreditAllocatedID(id))
	return &CreditAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CreditAllocated.
func (c *CreditAllocatedClient) Delete() *CreditAllocatedDelete {
	mutation := newCreditAllocatedMutation(c.config, OpDelete)
	return &CreditAllocatedDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CreditAllocatedClient) DeleteOne(ca *CreditAllocated) *CreditAllocatedDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CreditAllocatedClient) DeleteOneID(id uint32) *CreditAllocatedDeleteOne {
	builder := c.Delete().Where(creditallocated.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CreditAllocatedDeleteOne{builder}
}

// Query returns a query builder for CreditAllocated.
func (c *CreditAllocatedClient) Query() *CreditAllocatedQuery {
	return &CreditAllocatedQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCreditAllocated},
		inters: c.Interceptors(),
	}
}

// Get returns a CreditAllocated entity by its id.
func (c *CreditAllocatedClient) Get(ctx context.Context, id uint32) (*CreditAllocated, error) {
	return c.Query().Where(creditallocated.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CreditAllocatedClient) GetX(ctx context.Context, id uint32) *CreditAllocated {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CreditAllocatedClient) Hooks() []Hook {
	return c.hooks.CreditAllocated
}

// Interceptors returns the client interceptors.
func (c *CreditAllocatedClient) Interceptors() []Interceptor {
	return c.inters.CreditAllocated
}

func (c *CreditAllocatedClient) mutate(ctx context.Context, m *CreditAllocatedMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CreditAllocatedCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CreditAllocatedUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CreditAllocatedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CreditAllocatedDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CreditAllocated mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventClient) MapCreateBulk(slice any, setFunc func(*EventCreate, int)) *EventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCreateBulk{err: fmt.Errorf("calling to EventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id uint32) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id uint32) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id uint32) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id uint32) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Event mutation op: %q", m.Op())
	}
}

// EventCoinClient is a client for the EventCoin schema.
type EventCoinClient struct {
	config
}

// NewEventCoinClient returns a client for the EventCoin from the given config.
func NewEventCoinClient(c config) *EventCoinClient {
	return &EventCoinClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventcoin.Hooks(f(g(h())))`.
func (c *EventCoinClient) Use(hooks ...Hook) {
	c.hooks.EventCoin = append(c.hooks.EventCoin, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventcoin.Intercept(f(g(h())))`.
func (c *EventCoinClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventCoin = append(c.inters.EventCoin, interceptors...)
}

// Create returns a builder for creating a EventCoin entity.
func (c *EventCoinClient) Create() *EventCoinCreate {
	mutation := newEventCoinMutation(c.config, OpCreate)
	return &EventCoinCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventCoin entities.
func (c *EventCoinClient) CreateBulk(builders ...*EventCoinCreate) *EventCoinCreateBulk {
	return &EventCoinCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventCoinClient) MapCreateBulk(slice any, setFunc func(*EventCoinCreate, int)) *EventCoinCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCoinCreateBulk{err: fmt.Errorf("calling to EventCoinClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCoinCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCoinCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventCoin.
func (c *EventCoinClient) Update() *EventCoinUpdate {
	mutation := newEventCoinMutation(c.config, OpUpdate)
	return &EventCoinUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventCoinClient) UpdateOne(ec *EventCoin) *EventCoinUpdateOne {
	mutation := newEventCoinMutation(c.config, OpUpdateOne, withEventCoin(ec))
	return &EventCoinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventCoinClient) UpdateOneID(id uint32) *EventCoinUpdateOne {
	mutation := newEventCoinMutation(c.config, OpUpdateOne, withEventCoinID(id))
	return &EventCoinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventCoin.
func (c *EventCoinClient) Delete() *EventCoinDelete {
	mutation := newEventCoinMutation(c.config, OpDelete)
	return &EventCoinDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventCoinClient) DeleteOne(ec *EventCoin) *EventCoinDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventCoinClient) DeleteOneID(id uint32) *EventCoinDeleteOne {
	builder := c.Delete().Where(eventcoin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventCoinDeleteOne{builder}
}

// Query returns a query builder for EventCoin.
func (c *EventCoinClient) Query() *EventCoinQuery {
	return &EventCoinQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventCoin},
		inters: c.Interceptors(),
	}
}

// Get returns a EventCoin entity by its id.
func (c *EventCoinClient) Get(ctx context.Context, id uint32) (*EventCoin, error) {
	return c.Query().Where(eventcoin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventCoinClient) GetX(ctx context.Context, id uint32) *EventCoin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EventCoinClient) Hooks() []Hook {
	return c.hooks.EventCoin
}

// Interceptors returns the client interceptors.
func (c *EventCoinClient) Interceptors() []Interceptor {
	return c.inters.EventCoin
}

func (c *EventCoinClient) mutate(ctx context.Context, m *EventCoinMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCoinCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventCoinUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventCoinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventCoinDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EventCoin mutation op: %q", m.Op())
	}
}

// EventCouponClient is a client for the EventCoupon schema.
type EventCouponClient struct {
	config
}

// NewEventCouponClient returns a client for the EventCoupon from the given config.
func NewEventCouponClient(c config) *EventCouponClient {
	return &EventCouponClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventcoupon.Hooks(f(g(h())))`.
func (c *EventCouponClient) Use(hooks ...Hook) {
	c.hooks.EventCoupon = append(c.hooks.EventCoupon, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventcoupon.Intercept(f(g(h())))`.
func (c *EventCouponClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventCoupon = append(c.inters.EventCoupon, interceptors...)
}

// Create returns a builder for creating a EventCoupon entity.
func (c *EventCouponClient) Create() *EventCouponCreate {
	mutation := newEventCouponMutation(c.config, OpCreate)
	return &EventCouponCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventCoupon entities.
func (c *EventCouponClient) CreateBulk(builders ...*EventCouponCreate) *EventCouponCreateBulk {
	return &EventCouponCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventCouponClient) MapCreateBulk(slice any, setFunc func(*EventCouponCreate, int)) *EventCouponCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCouponCreateBulk{err: fmt.Errorf("calling to EventCouponClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCouponCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCouponCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventCoupon.
func (c *EventCouponClient) Update() *EventCouponUpdate {
	mutation := newEventCouponMutation(c.config, OpUpdate)
	return &EventCouponUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventCouponClient) UpdateOne(ec *EventCoupon) *EventCouponUpdateOne {
	mutation := newEventCouponMutation(c.config, OpUpdateOne, withEventCoupon(ec))
	return &EventCouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventCouponClient) UpdateOneID(id uint32) *EventCouponUpdateOne {
	mutation := newEventCouponMutation(c.config, OpUpdateOne, withEventCouponID(id))
	return &EventCouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventCoupon.
func (c *EventCouponClient) Delete() *EventCouponDelete {
	mutation := newEventCouponMutation(c.config, OpDelete)
	return &EventCouponDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventCouponClient) DeleteOne(ec *EventCoupon) *EventCouponDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventCouponClient) DeleteOneID(id uint32) *EventCouponDeleteOne {
	builder := c.Delete().Where(eventcoupon.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventCouponDeleteOne{builder}
}

// Query returns a query builder for EventCoupon.
func (c *EventCouponClient) Query() *EventCouponQuery {
	return &EventCouponQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventCoupon},
		inters: c.Interceptors(),
	}
}

// Get returns a EventCoupon entity by its id.
func (c *EventCouponClient) Get(ctx context.Context, id uint32) (*EventCoupon, error) {
	return c.Query().Where(eventcoupon.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventCouponClient) GetX(ctx context.Context, id uint32) *EventCoupon {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EventCouponClient) Hooks() []Hook {
	return c.hooks.EventCoupon
}

// Interceptors returns the client interceptors.
func (c *EventCouponClient) Interceptors() []Interceptor {
	return c.inters.EventCoupon
}

func (c *EventCouponClient) mutate(ctx context.Context, m *EventCouponMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCouponCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventCouponUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventCouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventCouponDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EventCoupon mutation op: %q", m.Op())
	}
}

// GoodAchievementClient is a client for the GoodAchievement schema.
type GoodAchievementClient struct {
	config
}

// NewGoodAchievementClient returns a client for the GoodAchievement from the given config.
func NewGoodAchievementClient(c config) *GoodAchievementClient {
	return &GoodAchievementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goodachievement.Hooks(f(g(h())))`.
func (c *GoodAchievementClient) Use(hooks ...Hook) {
	c.hooks.GoodAchievement = append(c.hooks.GoodAchievement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goodachievement.Intercept(f(g(h())))`.
func (c *GoodAchievementClient) Intercept(interceptors ...Interceptor) {
	c.inters.GoodAchievement = append(c.inters.GoodAchievement, interceptors...)
}

// Create returns a builder for creating a GoodAchievement entity.
func (c *GoodAchievementClient) Create() *GoodAchievementCreate {
	mutation := newGoodAchievementMutation(c.config, OpCreate)
	return &GoodAchievementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoodAchievement entities.
func (c *GoodAchievementClient) CreateBulk(builders ...*GoodAchievementCreate) *GoodAchievementCreateBulk {
	return &GoodAchievementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodAchievementClient) MapCreateBulk(slice any, setFunc func(*GoodAchievementCreate, int)) *GoodAchievementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodAchievementCreateBulk{err: fmt.Errorf("calling to GoodAchievementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodAchievementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodAchievementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoodAchievement.
func (c *GoodAchievementClient) Update() *GoodAchievementUpdate {
	mutation := newGoodAchievementMutation(c.config, OpUpdate)
	return &GoodAchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodAchievementClient) UpdateOne(ga *GoodAchievement) *GoodAchievementUpdateOne {
	mutation := newGoodAchievementMutation(c.config, OpUpdateOne, withGoodAchievement(ga))
	return &GoodAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodAchievementClient) UpdateOneID(id uint32) *GoodAchievementUpdateOne {
	mutation := newGoodAchievementMutation(c.config, OpUpdateOne, withGoodAchievementID(id))
	return &GoodAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoodAchievement.
func (c *GoodAchievementClient) Delete() *GoodAchievementDelete {
	mutation := newGoodAchievementMutation(c.config, OpDelete)
	return &GoodAchievementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodAchievementClient) DeleteOne(ga *GoodAchievement) *GoodAchievementDeleteOne {
	return c.DeleteOneID(ga.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodAchievementClient) DeleteOneID(id uint32) *GoodAchievementDeleteOne {
	builder := c.Delete().Where(goodachievement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodAchievementDeleteOne{builder}
}

// Query returns a query builder for GoodAchievement.
func (c *GoodAchievementClient) Query() *GoodAchievementQuery {
	return &GoodAchievementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoodAchievement},
		inters: c.Interceptors(),
	}
}

// Get returns a GoodAchievement entity by its id.
func (c *GoodAchievementClient) Get(ctx context.Context, id uint32) (*GoodAchievement, error) {
	return c.Query().Where(goodachievement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodAchievementClient) GetX(ctx context.Context, id uint32) *GoodAchievement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodAchievementClient) Hooks() []Hook {
	return c.hooks.GoodAchievement
}

// Interceptors returns the client interceptors.
func (c *GoodAchievementClient) Interceptors() []Interceptor {
	return c.inters.GoodAchievement
}

func (c *GoodAchievementClient) mutate(ctx context.Context, m *GoodAchievementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodAchievementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodAchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodAchievementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GoodAchievement mutation op: %q", m.Op())
	}
}

// GoodCoinAchievementClient is a client for the GoodCoinAchievement schema.
type GoodCoinAchievementClient struct {
	config
}

// NewGoodCoinAchievementClient returns a client for the GoodCoinAchievement from the given config.
func NewGoodCoinAchievementClient(c config) *GoodCoinAchievementClient {
	return &GoodCoinAchievementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goodcoinachievement.Hooks(f(g(h())))`.
func (c *GoodCoinAchievementClient) Use(hooks ...Hook) {
	c.hooks.GoodCoinAchievement = append(c.hooks.GoodCoinAchievement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goodcoinachievement.Intercept(f(g(h())))`.
func (c *GoodCoinAchievementClient) Intercept(interceptors ...Interceptor) {
	c.inters.GoodCoinAchievement = append(c.inters.GoodCoinAchievement, interceptors...)
}

// Create returns a builder for creating a GoodCoinAchievement entity.
func (c *GoodCoinAchievementClient) Create() *GoodCoinAchievementCreate {
	mutation := newGoodCoinAchievementMutation(c.config, OpCreate)
	return &GoodCoinAchievementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoodCoinAchievement entities.
func (c *GoodCoinAchievementClient) CreateBulk(builders ...*GoodCoinAchievementCreate) *GoodCoinAchievementCreateBulk {
	return &GoodCoinAchievementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodCoinAchievementClient) MapCreateBulk(slice any, setFunc func(*GoodCoinAchievementCreate, int)) *GoodCoinAchievementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodCoinAchievementCreateBulk{err: fmt.Errorf("calling to GoodCoinAchievementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodCoinAchievementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodCoinAchievementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoodCoinAchievement.
func (c *GoodCoinAchievementClient) Update() *GoodCoinAchievementUpdate {
	mutation := newGoodCoinAchievementMutation(c.config, OpUpdate)
	return &GoodCoinAchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodCoinAchievementClient) UpdateOne(gca *GoodCoinAchievement) *GoodCoinAchievementUpdateOne {
	mutation := newGoodCoinAchievementMutation(c.config, OpUpdateOne, withGoodCoinAchievement(gca))
	return &GoodCoinAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodCoinAchievementClient) UpdateOneID(id uint32) *GoodCoinAchievementUpdateOne {
	mutation := newGoodCoinAchievementMutation(c.config, OpUpdateOne, withGoodCoinAchievementID(id))
	return &GoodCoinAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoodCoinAchievement.
func (c *GoodCoinAchievementClient) Delete() *GoodCoinAchievementDelete {
	mutation := newGoodCoinAchievementMutation(c.config, OpDelete)
	return &GoodCoinAchievementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodCoinAchievementClient) DeleteOne(gca *GoodCoinAchievement) *GoodCoinAchievementDeleteOne {
	return c.DeleteOneID(gca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodCoinAchievementClient) DeleteOneID(id uint32) *GoodCoinAchievementDeleteOne {
	builder := c.Delete().Where(goodcoinachievement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodCoinAchievementDeleteOne{builder}
}

// Query returns a query builder for GoodCoinAchievement.
func (c *GoodCoinAchievementClient) Query() *GoodCoinAchievementQuery {
	return &GoodCoinAchievementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoodCoinAchievement},
		inters: c.Interceptors(),
	}
}

// Get returns a GoodCoinAchievement entity by its id.
func (c *GoodCoinAchievementClient) Get(ctx context.Context, id uint32) (*GoodCoinAchievement, error) {
	return c.Query().Where(goodcoinachievement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodCoinAchievementClient) GetX(ctx context.Context, id uint32) *GoodCoinAchievement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodCoinAchievementClient) Hooks() []Hook {
	return c.hooks.GoodCoinAchievement
}

// Interceptors returns the client interceptors.
func (c *GoodCoinAchievementClient) Interceptors() []Interceptor {
	return c.inters.GoodCoinAchievement
}

func (c *GoodCoinAchievementClient) mutate(ctx context.Context, m *GoodCoinAchievementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodCoinAchievementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodCoinAchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodCoinAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodCoinAchievementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GoodCoinAchievement mutation op: %q", m.Op())
	}
}

// InvitationCodeClient is a client for the InvitationCode schema.
type InvitationCodeClient struct {
	config
}

// NewInvitationCodeClient returns a client for the InvitationCode from the given config.
func NewInvitationCodeClient(c config) *InvitationCodeClient {
	return &InvitationCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invitationcode.Hooks(f(g(h())))`.
func (c *InvitationCodeClient) Use(hooks ...Hook) {
	c.hooks.InvitationCode = append(c.hooks.InvitationCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invitationcode.Intercept(f(g(h())))`.
func (c *InvitationCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.InvitationCode = append(c.inters.InvitationCode, interceptors...)
}

// Create returns a builder for creating a InvitationCode entity.
func (c *InvitationCodeClient) Create() *InvitationCodeCreate {
	mutation := newInvitationCodeMutation(c.config, OpCreate)
	return &InvitationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InvitationCode entities.
func (c *InvitationCodeClient) CreateBulk(builders ...*InvitationCodeCreate) *InvitationCodeCreateBulk {
	return &InvitationCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvitationCodeClient) MapCreateBulk(slice any, setFunc func(*InvitationCodeCreate, int)) *InvitationCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvitationCodeCreateBulk{err: fmt.Errorf("calling to InvitationCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvitationCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvitationCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InvitationCode.
func (c *InvitationCodeClient) Update() *InvitationCodeUpdate {
	mutation := newInvitationCodeMutation(c.config, OpUpdate)
	return &InvitationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvitationCodeClient) UpdateOne(ic *InvitationCode) *InvitationCodeUpdateOne {
	mutation := newInvitationCodeMutation(c.config, OpUpdateOne, withInvitationCode(ic))
	return &InvitationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvitationCodeClient) UpdateOneID(id uint32) *InvitationCodeUpdateOne {
	mutation := newInvitationCodeMutation(c.config, OpUpdateOne, withInvitationCodeID(id))
	return &InvitationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InvitationCode.
func (c *InvitationCodeClient) Delete() *InvitationCodeDelete {
	mutation := newInvitationCodeMutation(c.config, OpDelete)
	return &InvitationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvitationCodeClient) DeleteOne(ic *InvitationCode) *InvitationCodeDeleteOne {
	return c.DeleteOneID(ic.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvitationCodeClient) DeleteOneID(id uint32) *InvitationCodeDeleteOne {
	builder := c.Delete().Where(invitationcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvitationCodeDeleteOne{builder}
}

// Query returns a query builder for InvitationCode.
func (c *InvitationCodeClient) Query() *InvitationCodeQuery {
	return &InvitationCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvitationCode},
		inters: c.Interceptors(),
	}
}

// Get returns a InvitationCode entity by its id.
func (c *InvitationCodeClient) Get(ctx context.Context, id uint32) (*InvitationCode, error) {
	return c.Query().Where(invitationcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvitationCodeClient) GetX(ctx context.Context, id uint32) *InvitationCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InvitationCodeClient) Hooks() []Hook {
	return c.hooks.InvitationCode
}

// Interceptors returns the client interceptors.
func (c *InvitationCodeClient) Interceptors() []Interceptor {
	return c.inters.InvitationCode
}

func (c *InvitationCodeClient) mutate(ctx context.Context, m *InvitationCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvitationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvitationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvitationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvitationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown InvitationCode mutation op: %q", m.Op())
	}
}

// OrderPaymentStatementClient is a client for the OrderPaymentStatement schema.
type OrderPaymentStatementClient struct {
	config
}

// NewOrderPaymentStatementClient returns a client for the OrderPaymentStatement from the given config.
func NewOrderPaymentStatementClient(c config) *OrderPaymentStatementClient {
	return &OrderPaymentStatementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderpaymentstatement.Hooks(f(g(h())))`.
func (c *OrderPaymentStatementClient) Use(hooks ...Hook) {
	c.hooks.OrderPaymentStatement = append(c.hooks.OrderPaymentStatement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderpaymentstatement.Intercept(f(g(h())))`.
func (c *OrderPaymentStatementClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderPaymentStatement = append(c.inters.OrderPaymentStatement, interceptors...)
}

// Create returns a builder for creating a OrderPaymentStatement entity.
func (c *OrderPaymentStatementClient) Create() *OrderPaymentStatementCreate {
	mutation := newOrderPaymentStatementMutation(c.config, OpCreate)
	return &OrderPaymentStatementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderPaymentStatement entities.
func (c *OrderPaymentStatementClient) CreateBulk(builders ...*OrderPaymentStatementCreate) *OrderPaymentStatementCreateBulk {
	return &OrderPaymentStatementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderPaymentStatementClient) MapCreateBulk(slice any, setFunc func(*OrderPaymentStatementCreate, int)) *OrderPaymentStatementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderPaymentStatementCreateBulk{err: fmt.Errorf("calling to OrderPaymentStatementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderPaymentStatementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderPaymentStatementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderPaymentStatement.
func (c *OrderPaymentStatementClient) Update() *OrderPaymentStatementUpdate {
	mutation := newOrderPaymentStatementMutation(c.config, OpUpdate)
	return &OrderPaymentStatementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderPaymentStatementClient) UpdateOne(ops *OrderPaymentStatement) *OrderPaymentStatementUpdateOne {
	mutation := newOrderPaymentStatementMutation(c.config, OpUpdateOne, withOrderPaymentStatement(ops))
	return &OrderPaymentStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderPaymentStatementClient) UpdateOneID(id uint32) *OrderPaymentStatementUpdateOne {
	mutation := newOrderPaymentStatementMutation(c.config, OpUpdateOne, withOrderPaymentStatementID(id))
	return &OrderPaymentStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderPaymentStatement.
func (c *OrderPaymentStatementClient) Delete() *OrderPaymentStatementDelete {
	mutation := newOrderPaymentStatementMutation(c.config, OpDelete)
	return &OrderPaymentStatementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderPaymentStatementClient) DeleteOne(ops *OrderPaymentStatement) *OrderPaymentStatementDeleteOne {
	return c.DeleteOneID(ops.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderPaymentStatementClient) DeleteOneID(id uint32) *OrderPaymentStatementDeleteOne {
	builder := c.Delete().Where(orderpaymentstatement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderPaymentStatementDeleteOne{builder}
}

// Query returns a query builder for OrderPaymentStatement.
func (c *OrderPaymentStatementClient) Query() *OrderPaymentStatementQuery {
	return &OrderPaymentStatementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderPaymentStatement},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderPaymentStatement entity by its id.
func (c *OrderPaymentStatementClient) Get(ctx context.Context, id uint32) (*OrderPaymentStatement, error) {
	return c.Query().Where(orderpaymentstatement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderPaymentStatementClient) GetX(ctx context.Context, id uint32) *OrderPaymentStatement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderPaymentStatementClient) Hooks() []Hook {
	return c.hooks.OrderPaymentStatement
}

// Interceptors returns the client interceptors.
func (c *OrderPaymentStatementClient) Interceptors() []Interceptor {
	return c.inters.OrderPaymentStatement
}

func (c *OrderPaymentStatementClient) mutate(ctx context.Context, m *OrderPaymentStatementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderPaymentStatementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderPaymentStatementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderPaymentStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderPaymentStatementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrderPaymentStatement mutation op: %q", m.Op())
	}
}

// OrderStatementClient is a client for the OrderStatement schema.
type OrderStatementClient struct {
	config
}

// NewOrderStatementClient returns a client for the OrderStatement from the given config.
func NewOrderStatementClient(c config) *OrderStatementClient {
	return &OrderStatementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderstatement.Hooks(f(g(h())))`.
func (c *OrderStatementClient) Use(hooks ...Hook) {
	c.hooks.OrderStatement = append(c.hooks.OrderStatement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderstatement.Intercept(f(g(h())))`.
func (c *OrderStatementClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderStatement = append(c.inters.OrderStatement, interceptors...)
}

// Create returns a builder for creating a OrderStatement entity.
func (c *OrderStatementClient) Create() *OrderStatementCreate {
	mutation := newOrderStatementMutation(c.config, OpCreate)
	return &OrderStatementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderStatement entities.
func (c *OrderStatementClient) CreateBulk(builders ...*OrderStatementCreate) *OrderStatementCreateBulk {
	return &OrderStatementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderStatementClient) MapCreateBulk(slice any, setFunc func(*OrderStatementCreate, int)) *OrderStatementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderStatementCreateBulk{err: fmt.Errorf("calling to OrderStatementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderStatementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderStatementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderStatement.
func (c *OrderStatementClient) Update() *OrderStatementUpdate {
	mutation := newOrderStatementMutation(c.config, OpUpdate)
	return &OrderStatementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderStatementClient) UpdateOne(os *OrderStatement) *OrderStatementUpdateOne {
	mutation := newOrderStatementMutation(c.config, OpUpdateOne, withOrderStatement(os))
	return &OrderStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderStatementClient) UpdateOneID(id uint32) *OrderStatementUpdateOne {
	mutation := newOrderStatementMutation(c.config, OpUpdateOne, withOrderStatementID(id))
	return &OrderStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderStatement.
func (c *OrderStatementClient) Delete() *OrderStatementDelete {
	mutation := newOrderStatementMutation(c.config, OpDelete)
	return &OrderStatementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderStatementClient) DeleteOne(os *OrderStatement) *OrderStatementDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderStatementClient) DeleteOneID(id uint32) *OrderStatementDeleteOne {
	builder := c.Delete().Where(orderstatement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderStatementDeleteOne{builder}
}

// Query returns a query builder for OrderStatement.
func (c *OrderStatementClient) Query() *OrderStatementQuery {
	return &OrderStatementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderStatement},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderStatement entity by its id.
func (c *OrderStatementClient) Get(ctx context.Context, id uint32) (*OrderStatement, error) {
	return c.Query().Where(orderstatement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderStatementClient) GetX(ctx context.Context, id uint32) *OrderStatement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderStatementClient) Hooks() []Hook {
	return c.hooks.OrderStatement
}

// Interceptors returns the client interceptors.
func (c *OrderStatementClient) Interceptors() []Interceptor {
	return c.inters.OrderStatement
}

func (c *OrderStatementClient) mutate(ctx context.Context, m *OrderStatementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderStatementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderStatementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderStatementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrderStatement mutation op: %q", m.Op())
	}
}

// RegistrationClient is a client for the Registration schema.
type RegistrationClient struct {
	config
}

// NewRegistrationClient returns a client for the Registration from the given config.
func NewRegistrationClient(c config) *RegistrationClient {
	return &RegistrationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `registration.Hooks(f(g(h())))`.
func (c *RegistrationClient) Use(hooks ...Hook) {
	c.hooks.Registration = append(c.hooks.Registration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `registration.Intercept(f(g(h())))`.
func (c *RegistrationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Registration = append(c.inters.Registration, interceptors...)
}

// Create returns a builder for creating a Registration entity.
func (c *RegistrationClient) Create() *RegistrationCreate {
	mutation := newRegistrationMutation(c.config, OpCreate)
	return &RegistrationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Registration entities.
func (c *RegistrationClient) CreateBulk(builders ...*RegistrationCreate) *RegistrationCreateBulk {
	return &RegistrationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RegistrationClient) MapCreateBulk(slice any, setFunc func(*RegistrationCreate, int)) *RegistrationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RegistrationCreateBulk{err: fmt.Errorf("calling to RegistrationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RegistrationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RegistrationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Registration.
func (c *RegistrationClient) Update() *RegistrationUpdate {
	mutation := newRegistrationMutation(c.config, OpUpdate)
	return &RegistrationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RegistrationClient) UpdateOne(r *Registration) *RegistrationUpdateOne {
	mutation := newRegistrationMutation(c.config, OpUpdateOne, withRegistration(r))
	return &RegistrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RegistrationClient) UpdateOneID(id uint32) *RegistrationUpdateOne {
	mutation := newRegistrationMutation(c.config, OpUpdateOne, withRegistrationID(id))
	return &RegistrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Registration.
func (c *RegistrationClient) Delete() *RegistrationDelete {
	mutation := newRegistrationMutation(c.config, OpDelete)
	return &RegistrationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RegistrationClient) DeleteOne(r *Registration) *RegistrationDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RegistrationClient) DeleteOneID(id uint32) *RegistrationDeleteOne {
	builder := c.Delete().Where(registration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RegistrationDeleteOne{builder}
}

// Query returns a query builder for Registration.
func (c *RegistrationClient) Query() *RegistrationQuery {
	return &RegistrationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRegistration},
		inters: c.Interceptors(),
	}
}

// Get returns a Registration entity by its id.
func (c *RegistrationClient) Get(ctx context.Context, id uint32) (*Registration, error) {
	return c.Query().Where(registration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RegistrationClient) GetX(ctx context.Context, id uint32) *Registration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RegistrationClient) Hooks() []Hook {
	return c.hooks.Registration
}

// Interceptors returns the client interceptors.
func (c *RegistrationClient) Interceptors() []Interceptor {
	return c.inters.Registration
}

func (c *RegistrationClient) mutate(ctx context.Context, m *RegistrationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RegistrationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RegistrationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RegistrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RegistrationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Registration mutation op: %q", m.Op())
	}
}

// StatementClient is a client for the Statement schema.
type StatementClient struct {
	config
}

// NewStatementClient returns a client for the Statement from the given config.
func NewStatementClient(c config) *StatementClient {
	return &StatementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statement.Hooks(f(g(h())))`.
func (c *StatementClient) Use(hooks ...Hook) {
	c.hooks.Statement = append(c.hooks.Statement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statement.Intercept(f(g(h())))`.
func (c *StatementClient) Intercept(interceptors ...Interceptor) {
	c.inters.Statement = append(c.inters.Statement, interceptors...)
}

// Create returns a builder for creating a Statement entity.
func (c *StatementClient) Create() *StatementCreate {
	mutation := newStatementMutation(c.config, OpCreate)
	return &StatementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Statement entities.
func (c *StatementClient) CreateBulk(builders ...*StatementCreate) *StatementCreateBulk {
	return &StatementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatementClient) MapCreateBulk(slice any, setFunc func(*StatementCreate, int)) *StatementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatementCreateBulk{err: fmt.Errorf("calling to StatementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Statement.
func (c *StatementClient) Update() *StatementUpdate {
	mutation := newStatementMutation(c.config, OpUpdate)
	return &StatementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatementClient) UpdateOne(s *Statement) *StatementUpdateOne {
	mutation := newStatementMutation(c.config, OpUpdateOne, withStatement(s))
	return &StatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatementClient) UpdateOneID(id uint32) *StatementUpdateOne {
	mutation := newStatementMutation(c.config, OpUpdateOne, withStatementID(id))
	return &StatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Statement.
func (c *StatementClient) Delete() *StatementDelete {
	mutation := newStatementMutation(c.config, OpDelete)
	return &StatementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatementClient) DeleteOne(s *Statement) *StatementDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatementClient) DeleteOneID(id uint32) *StatementDeleteOne {
	builder := c.Delete().Where(statement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatementDeleteOne{builder}
}

// Query returns a query builder for Statement.
func (c *StatementClient) Query() *StatementQuery {
	return &StatementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatement},
		inters: c.Interceptors(),
	}
}

// Get returns a Statement entity by its id.
func (c *StatementClient) Get(ctx context.Context, id uint32) (*Statement, error) {
	return c.Query().Where(statement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatementClient) GetX(ctx context.Context, id uint32) *Statement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StatementClient) Hooks() []Hook {
	return c.hooks.Statement
}

// Interceptors returns the client interceptors.
func (c *StatementClient) Interceptors() []Interceptor {
	return c.inters.Statement
}

func (c *StatementClient) mutate(ctx context.Context, m *StatementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Statement mutation op: %q", m.Op())
	}
}

// TaskConfigClient is a client for the TaskConfig schema.
type TaskConfigClient struct {
	config
}

// NewTaskConfigClient returns a client for the TaskConfig from the given config.
func NewTaskConfigClient(c config) *TaskConfigClient {
	return &TaskConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskconfig.Hooks(f(g(h())))`.
func (c *TaskConfigClient) Use(hooks ...Hook) {
	c.hooks.TaskConfig = append(c.hooks.TaskConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `taskconfig.Intercept(f(g(h())))`.
func (c *TaskConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.TaskConfig = append(c.inters.TaskConfig, interceptors...)
}

// Create returns a builder for creating a TaskConfig entity.
func (c *TaskConfigClient) Create() *TaskConfigCreate {
	mutation := newTaskConfigMutation(c.config, OpCreate)
	return &TaskConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskConfig entities.
func (c *TaskConfigClient) CreateBulk(builders ...*TaskConfigCreate) *TaskConfigCreateBulk {
	return &TaskConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskConfigClient) MapCreateBulk(slice any, setFunc func(*TaskConfigCreate, int)) *TaskConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskConfigCreateBulk{err: fmt.Errorf("calling to TaskConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskConfig.
func (c *TaskConfigClient) Update() *TaskConfigUpdate {
	mutation := newTaskConfigMutation(c.config, OpUpdate)
	return &TaskConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskConfigClient) UpdateOne(tc *TaskConfig) *TaskConfigUpdateOne {
	mutation := newTaskConfigMutation(c.config, OpUpdateOne, withTaskConfig(tc))
	return &TaskConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskConfigClient) UpdateOneID(id uint32) *TaskConfigUpdateOne {
	mutation := newTaskConfigMutation(c.config, OpUpdateOne, withTaskConfigID(id))
	return &TaskConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskConfig.
func (c *TaskConfigClient) Delete() *TaskConfigDelete {
	mutation := newTaskConfigMutation(c.config, OpDelete)
	return &TaskConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskConfigClient) DeleteOne(tc *TaskConfig) *TaskConfigDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskConfigClient) DeleteOneID(id uint32) *TaskConfigDeleteOne {
	builder := c.Delete().Where(taskconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskConfigDeleteOne{builder}
}

// Query returns a query builder for TaskConfig.
func (c *TaskConfigClient) Query() *TaskConfigQuery {
	return &TaskConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTaskConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a TaskConfig entity by its id.
func (c *TaskConfigClient) Get(ctx context.Context, id uint32) (*TaskConfig, error) {
	return c.Query().Where(taskconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskConfigClient) GetX(ctx context.Context, id uint32) *TaskConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TaskConfigClient) Hooks() []Hook {
	return c.hooks.TaskConfig
}

// Interceptors returns the client interceptors.
func (c *TaskConfigClient) Interceptors() []Interceptor {
	return c.inters.TaskConfig
}

func (c *TaskConfigClient) mutate(ctx context.Context, m *TaskConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TaskConfig mutation op: %q", m.Op())
	}
}

// TaskUserClient is a client for the TaskUser schema.
type TaskUserClient struct {
	config
}

// NewTaskUserClient returns a client for the TaskUser from the given config.
func NewTaskUserClient(c config) *TaskUserClient {
	return &TaskUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskuser.Hooks(f(g(h())))`.
func (c *TaskUserClient) Use(hooks ...Hook) {
	c.hooks.TaskUser = append(c.hooks.TaskUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `taskuser.Intercept(f(g(h())))`.
func (c *TaskUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.TaskUser = append(c.inters.TaskUser, interceptors...)
}

// Create returns a builder for creating a TaskUser entity.
func (c *TaskUserClient) Create() *TaskUserCreate {
	mutation := newTaskUserMutation(c.config, OpCreate)
	return &TaskUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskUser entities.
func (c *TaskUserClient) CreateBulk(builders ...*TaskUserCreate) *TaskUserCreateBulk {
	return &TaskUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskUserClient) MapCreateBulk(slice any, setFunc func(*TaskUserCreate, int)) *TaskUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskUserCreateBulk{err: fmt.Errorf("calling to TaskUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskUser.
func (c *TaskUserClient) Update() *TaskUserUpdate {
	mutation := newTaskUserMutation(c.config, OpUpdate)
	return &TaskUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskUserClient) UpdateOne(tu *TaskUser) *TaskUserUpdateOne {
	mutation := newTaskUserMutation(c.config, OpUpdateOne, withTaskUser(tu))
	return &TaskUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskUserClient) UpdateOneID(id uint32) *TaskUserUpdateOne {
	mutation := newTaskUserMutation(c.config, OpUpdateOne, withTaskUserID(id))
	return &TaskUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskUser.
func (c *TaskUserClient) Delete() *TaskUserDelete {
	mutation := newTaskUserMutation(c.config, OpDelete)
	return &TaskUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskUserClient) DeleteOne(tu *TaskUser) *TaskUserDeleteOne {
	return c.DeleteOneID(tu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskUserClient) DeleteOneID(id uint32) *TaskUserDeleteOne {
	builder := c.Delete().Where(taskuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskUserDeleteOne{builder}
}

// Query returns a query builder for TaskUser.
func (c *TaskUserClient) Query() *TaskUserQuery {
	return &TaskUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTaskUser},
		inters: c.Interceptors(),
	}
}

// Get returns a TaskUser entity by its id.
func (c *TaskUserClient) Get(ctx context.Context, id uint32) (*TaskUser, error) {
	return c.Query().Where(taskuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskUserClient) GetX(ctx context.Context, id uint32) *TaskUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TaskUserClient) Hooks() []Hook {
	return c.hooks.TaskUser
}

// Interceptors returns the client interceptors.
func (c *TaskUserClient) Interceptors() []Interceptor {
	return c.inters.TaskUser
}

func (c *TaskUserClient) mutate(ctx context.Context, m *TaskUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TaskUser mutation op: %q", m.Op())
	}
}

// UserCoinRewardClient is a client for the UserCoinReward schema.
type UserCoinRewardClient struct {
	config
}

// NewUserCoinRewardClient returns a client for the UserCoinReward from the given config.
func NewUserCoinRewardClient(c config) *UserCoinRewardClient {
	return &UserCoinRewardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercoinreward.Hooks(f(g(h())))`.
func (c *UserCoinRewardClient) Use(hooks ...Hook) {
	c.hooks.UserCoinReward = append(c.hooks.UserCoinReward, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercoinreward.Intercept(f(g(h())))`.
func (c *UserCoinRewardClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserCoinReward = append(c.inters.UserCoinReward, interceptors...)
}

// Create returns a builder for creating a UserCoinReward entity.
func (c *UserCoinRewardClient) Create() *UserCoinRewardCreate {
	mutation := newUserCoinRewardMutation(c.config, OpCreate)
	return &UserCoinRewardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserCoinReward entities.
func (c *UserCoinRewardClient) CreateBulk(builders ...*UserCoinRewardCreate) *UserCoinRewardCreateBulk {
	return &UserCoinRewardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserCoinRewardClient) MapCreateBulk(slice any, setFunc func(*UserCoinRewardCreate, int)) *UserCoinRewardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCoinRewardCreateBulk{err: fmt.Errorf("calling to UserCoinRewardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCoinRewardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCoinRewardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserCoinReward.
func (c *UserCoinRewardClient) Update() *UserCoinRewardUpdate {
	mutation := newUserCoinRewardMutation(c.config, OpUpdate)
	return &UserCoinRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserCoinRewardClient) UpdateOne(ucr *UserCoinReward) *UserCoinRewardUpdateOne {
	mutation := newUserCoinRewardMutation(c.config, OpUpdateOne, withUserCoinReward(ucr))
	return &UserCoinRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserCoinRewardClient) UpdateOneID(id uint32) *UserCoinRewardUpdateOne {
	mutation := newUserCoinRewardMutation(c.config, OpUpdateOne, withUserCoinRewardID(id))
	return &UserCoinRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserCoinReward.
func (c *UserCoinRewardClient) Delete() *UserCoinRewardDelete {
	mutation := newUserCoinRewardMutation(c.config, OpDelete)
	return &UserCoinRewardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserCoinRewardClient) DeleteOne(ucr *UserCoinReward) *UserCoinRewardDeleteOne {
	return c.DeleteOneID(ucr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserCoinRewardClient) DeleteOneID(id uint32) *UserCoinRewardDeleteOne {
	builder := c.Delete().Where(usercoinreward.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserCoinRewardDeleteOne{builder}
}

// Query returns a query builder for UserCoinReward.
func (c *UserCoinRewardClient) Query() *UserCoinRewardQuery {
	return &UserCoinRewardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserCoinReward},
		inters: c.Interceptors(),
	}
}

// Get returns a UserCoinReward entity by its id.
func (c *UserCoinRewardClient) Get(ctx context.Context, id uint32) (*UserCoinReward, error) {
	return c.Query().Where(usercoinreward.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserCoinRewardClient) GetX(ctx context.Context, id uint32) *UserCoinReward {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserCoinRewardClient) Hooks() []Hook {
	return c.hooks.UserCoinReward
}

// Interceptors returns the client interceptors.
func (c *UserCoinRewardClient) Interceptors() []Interceptor {
	return c.inters.UserCoinReward
}

func (c *UserCoinRewardClient) mutate(ctx context.Context, m *UserCoinRewardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCoinRewardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserCoinRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserCoinRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserCoinRewardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserCoinReward mutation op: %q", m.Op())
	}
}

// UserRewardClient is a client for the UserReward schema.
type UserRewardClient struct {
	config
}

// NewUserRewardClient returns a client for the UserReward from the given config.
func NewUserRewardClient(c config) *UserRewardClient {
	return &UserRewardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userreward.Hooks(f(g(h())))`.
func (c *UserRewardClient) Use(hooks ...Hook) {
	c.hooks.UserReward = append(c.hooks.UserReward, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userreward.Intercept(f(g(h())))`.
func (c *UserRewardClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserReward = append(c.inters.UserReward, interceptors...)
}

// Create returns a builder for creating a UserReward entity.
func (c *UserRewardClient) Create() *UserRewardCreate {
	mutation := newUserRewardMutation(c.config, OpCreate)
	return &UserRewardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserReward entities.
func (c *UserRewardClient) CreateBulk(builders ...*UserRewardCreate) *UserRewardCreateBulk {
	return &UserRewardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRewardClient) MapCreateBulk(slice any, setFunc func(*UserRewardCreate, int)) *UserRewardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRewardCreateBulk{err: fmt.Errorf("calling to UserRewardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRewardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRewardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserReward.
func (c *UserRewardClient) Update() *UserRewardUpdate {
	mutation := newUserRewardMutation(c.config, OpUpdate)
	return &UserRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRewardClient) UpdateOne(ur *UserReward) *UserRewardUpdateOne {
	mutation := newUserRewardMutation(c.config, OpUpdateOne, withUserReward(ur))
	return &UserRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRewardClient) UpdateOneID(id uint32) *UserRewardUpdateOne {
	mutation := newUserRewardMutation(c.config, OpUpdateOne, withUserRewardID(id))
	return &UserRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserReward.
func (c *UserRewardClient) Delete() *UserRewardDelete {
	mutation := newUserRewardMutation(c.config, OpDelete)
	return &UserRewardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRewardClient) DeleteOne(ur *UserReward) *UserRewardDeleteOne {
	return c.DeleteOneID(ur.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRewardClient) DeleteOneID(id uint32) *UserRewardDeleteOne {
	builder := c.Delete().Where(userreward.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRewardDeleteOne{builder}
}

// Query returns a query builder for UserReward.
func (c *UserRewardClient) Query() *UserRewardQuery {
	return &UserRewardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserReward},
		inters: c.Interceptors(),
	}
}

// Get returns a UserReward entity by its id.
func (c *UserRewardClient) Get(ctx context.Context, id uint32) (*UserReward, error) {
	return c.Query().Where(userreward.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRewardClient) GetX(ctx context.Context, id uint32) *UserReward {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserRewardClient) Hooks() []Hook {
	return c.hooks.UserReward
}

// Interceptors returns the client interceptors.
func (c *UserRewardClient) Interceptors() []Interceptor {
	return c.inters.UserReward
}

func (c *UserRewardClient) mutate(ctx context.Context, m *UserRewardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRewardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRewardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserReward mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Achievement, AchievementUser, AppCommissionConfig, AppConfig,
		AppGoodCommissionConfig, AppGoodScope, CashControl, CoinAllocated, CoinConfig,
		Commission, Coupon, CouponAllocated, CouponScope, CreditAllocated, Event,
		EventCoin, EventCoupon, GoodAchievement, GoodCoinAchievement, InvitationCode,
		OrderPaymentStatement, OrderStatement, Registration, Statement, TaskConfig,
		TaskUser, UserCoinReward, UserReward []ent.Hook
	}
	inters struct {
		Achievement, AchievementUser, AppCommissionConfig, AppConfig,
		AppGoodCommissionConfig, AppGoodScope, CashControl, CoinAllocated, CoinConfig,
		Commission, Coupon, CouponAllocated, CouponScope, CreditAllocated, Event,
		EventCoin, EventCoupon, GoodAchievement, GoodCoinAchievement, InvitationCode,
		OrderPaymentStatement, OrderStatement, Registration, Statement, TaskConfig,
		TaskUser, UserCoinReward, UserReward []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
