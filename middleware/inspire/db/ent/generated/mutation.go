// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/achievement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/achievementuser"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/appcommissionconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/appconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/appgoodcommissionconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/appgoodscope"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/cashcontrol"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/coinallocated"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/coinconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/commission"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/coupon"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/couponallocated"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/couponscope"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/creditallocated"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/event"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/eventcoin"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/eventcoupon"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/goodachievement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/goodcoinachievement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/invitationcode"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/orderpaymentstatement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/orderstatement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/predicate"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/registration"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/statement"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/taskconfig"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/taskuser"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/usercoinreward"
	"github.com/NpoolPlatform/kunman/middleware/inspire/db/ent/generated/userreward"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAchievement             = "Achievement"
	TypeAchievementUser         = "AchievementUser"
	TypeAppCommissionConfig     = "AppCommissionConfig"
	TypeAppConfig               = "AppConfig"
	TypeAppGoodCommissionConfig = "AppGoodCommissionConfig"
	TypeAppGoodScope            = "AppGoodScope"
	TypeCashControl             = "CashControl"
	TypeCoinAllocated           = "CoinAllocated"
	TypeCoinConfig              = "CoinConfig"
	TypeCommission              = "Commission"
	TypeCoupon                  = "Coupon"
	TypeCouponAllocated         = "CouponAllocated"
	TypeCouponScope             = "CouponScope"
	TypeCreditAllocated         = "CreditAllocated"
	TypeEvent                   = "Event"
	TypeEventCoin               = "EventCoin"
	TypeEventCoupon             = "EventCoupon"
	TypeGoodAchievement         = "GoodAchievement"
	TypeGoodCoinAchievement     = "GoodCoinAchievement"
	TypeInvitationCode          = "InvitationCode"
	TypeOrderPaymentStatement   = "OrderPaymentStatement"
	TypeOrderStatement          = "OrderStatement"
	TypeRegistration            = "Registration"
	TypeStatement               = "Statement"
	TypeTaskConfig              = "TaskConfig"
	TypeTaskUser                = "TaskUser"
	TypeUserCoinReward          = "UserCoinReward"
	TypeUserReward              = "UserReward"
)

// AchievementMutation represents an operation that mutates the Achievement nodes in the graph.
type AchievementMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	ent_id           *uuid.UUID
	app_id           *uuid.UUID
	user_id          *uuid.UUID
	good_id          *uuid.UUID
	app_good_id      *uuid.UUID
	coin_type_id     *uuid.UUID
	total_units_v1   *decimal.Decimal
	self_units_v1    *decimal.Decimal
	total_amount     *decimal.Decimal
	self_amount      *decimal.Decimal
	total_commission *decimal.Decimal
	self_commission  *decimal.Decimal
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Achievement, error)
	predicates       []predicate.Achievement
}

var _ ent.Mutation = (*AchievementMutation)(nil)

// achievementOption allows management of the mutation configuration using functional options.
type achievementOption func(*AchievementMutation)

// newAchievementMutation creates new mutation for the Achievement entity.
func newAchievementMutation(c config, op Op, opts ...achievementOption) *AchievementMutation {
	m := &AchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAchievementID sets the ID field of the mutation.
func withAchievementID(id uint32) achievementOption {
	return func(m *AchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *Achievement
		)
		m.oldValue = func(ctx context.Context) (*Achievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Achievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAchievement sets the old Achievement of the mutation.
func withAchievement(node *Achievement) achievementOption {
	return func(m *AchievementMutation) {
		m.oldValue = func(context.Context) (*Achievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Achievement entities.
func (m *AchievementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AchievementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AchievementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Achievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AchievementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AchievementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AchievementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AchievementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AchievementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AchievementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AchievementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AchievementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AchievementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AchievementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AchievementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AchievementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AchievementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AchievementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AchievementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AchievementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AchievementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AchievementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AchievementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AchievementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AchievementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[achievement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AchievementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AchievementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, achievement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AchievementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AchievementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AchievementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[achievement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AchievementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AchievementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, achievement.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *AchievementMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AchievementMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *AchievementMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[achievement.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *AchievementMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AchievementMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, achievement.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AchievementMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AchievementMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AchievementMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[achievement.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AchievementMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AchievementMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, achievement.FieldAppGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *AchievementMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *AchievementMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *AchievementMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[achievement.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *AchievementMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *AchievementMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, achievement.FieldCoinTypeID)
}

// SetTotalUnitsV1 sets the "total_units_v1" field.
func (m *AchievementMutation) SetTotalUnitsV1(d decimal.Decimal) {
	m.total_units_v1 = &d
}

// TotalUnitsV1 returns the value of the "total_units_v1" field in the mutation.
func (m *AchievementMutation) TotalUnitsV1() (r decimal.Decimal, exists bool) {
	v := m.total_units_v1
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnitsV1 returns the old "total_units_v1" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldTotalUnitsV1(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnitsV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnitsV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnitsV1: %w", err)
	}
	return oldValue.TotalUnitsV1, nil
}

// ClearTotalUnitsV1 clears the value of the "total_units_v1" field.
func (m *AchievementMutation) ClearTotalUnitsV1() {
	m.total_units_v1 = nil
	m.clearedFields[achievement.FieldTotalUnitsV1] = struct{}{}
}

// TotalUnitsV1Cleared returns if the "total_units_v1" field was cleared in this mutation.
func (m *AchievementMutation) TotalUnitsV1Cleared() bool {
	_, ok := m.clearedFields[achievement.FieldTotalUnitsV1]
	return ok
}

// ResetTotalUnitsV1 resets all changes to the "total_units_v1" field.
func (m *AchievementMutation) ResetTotalUnitsV1() {
	m.total_units_v1 = nil
	delete(m.clearedFields, achievement.FieldTotalUnitsV1)
}

// SetSelfUnitsV1 sets the "self_units_v1" field.
func (m *AchievementMutation) SetSelfUnitsV1(d decimal.Decimal) {
	m.self_units_v1 = &d
}

// SelfUnitsV1 returns the value of the "self_units_v1" field in the mutation.
func (m *AchievementMutation) SelfUnitsV1() (r decimal.Decimal, exists bool) {
	v := m.self_units_v1
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfUnitsV1 returns the old "self_units_v1" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldSelfUnitsV1(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfUnitsV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfUnitsV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfUnitsV1: %w", err)
	}
	return oldValue.SelfUnitsV1, nil
}

// ClearSelfUnitsV1 clears the value of the "self_units_v1" field.
func (m *AchievementMutation) ClearSelfUnitsV1() {
	m.self_units_v1 = nil
	m.clearedFields[achievement.FieldSelfUnitsV1] = struct{}{}
}

// SelfUnitsV1Cleared returns if the "self_units_v1" field was cleared in this mutation.
func (m *AchievementMutation) SelfUnitsV1Cleared() bool {
	_, ok := m.clearedFields[achievement.FieldSelfUnitsV1]
	return ok
}

// ResetSelfUnitsV1 resets all changes to the "self_units_v1" field.
func (m *AchievementMutation) ResetSelfUnitsV1() {
	m.self_units_v1 = nil
	delete(m.clearedFields, achievement.FieldSelfUnitsV1)
}

// SetTotalAmount sets the "total_amount" field.
func (m *AchievementMutation) SetTotalAmount(d decimal.Decimal) {
	m.total_amount = &d
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *AchievementMutation) TotalAmount() (r decimal.Decimal, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldTotalAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// ClearTotalAmount clears the value of the "total_amount" field.
func (m *AchievementMutation) ClearTotalAmount() {
	m.total_amount = nil
	m.clearedFields[achievement.FieldTotalAmount] = struct{}{}
}

// TotalAmountCleared returns if the "total_amount" field was cleared in this mutation.
func (m *AchievementMutation) TotalAmountCleared() bool {
	_, ok := m.clearedFields[achievement.FieldTotalAmount]
	return ok
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *AchievementMutation) ResetTotalAmount() {
	m.total_amount = nil
	delete(m.clearedFields, achievement.FieldTotalAmount)
}

// SetSelfAmount sets the "self_amount" field.
func (m *AchievementMutation) SetSelfAmount(d decimal.Decimal) {
	m.self_amount = &d
}

// SelfAmount returns the value of the "self_amount" field in the mutation.
func (m *AchievementMutation) SelfAmount() (r decimal.Decimal, exists bool) {
	v := m.self_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfAmount returns the old "self_amount" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldSelfAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfAmount: %w", err)
	}
	return oldValue.SelfAmount, nil
}

// ClearSelfAmount clears the value of the "self_amount" field.
func (m *AchievementMutation) ClearSelfAmount() {
	m.self_amount = nil
	m.clearedFields[achievement.FieldSelfAmount] = struct{}{}
}

// SelfAmountCleared returns if the "self_amount" field was cleared in this mutation.
func (m *AchievementMutation) SelfAmountCleared() bool {
	_, ok := m.clearedFields[achievement.FieldSelfAmount]
	return ok
}

// ResetSelfAmount resets all changes to the "self_amount" field.
func (m *AchievementMutation) ResetSelfAmount() {
	m.self_amount = nil
	delete(m.clearedFields, achievement.FieldSelfAmount)
}

// SetTotalCommission sets the "total_commission" field.
func (m *AchievementMutation) SetTotalCommission(d decimal.Decimal) {
	m.total_commission = &d
}

// TotalCommission returns the value of the "total_commission" field in the mutation.
func (m *AchievementMutation) TotalCommission() (r decimal.Decimal, exists bool) {
	v := m.total_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCommission returns the old "total_commission" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldTotalCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCommission: %w", err)
	}
	return oldValue.TotalCommission, nil
}

// ClearTotalCommission clears the value of the "total_commission" field.
func (m *AchievementMutation) ClearTotalCommission() {
	m.total_commission = nil
	m.clearedFields[achievement.FieldTotalCommission] = struct{}{}
}

// TotalCommissionCleared returns if the "total_commission" field was cleared in this mutation.
func (m *AchievementMutation) TotalCommissionCleared() bool {
	_, ok := m.clearedFields[achievement.FieldTotalCommission]
	return ok
}

// ResetTotalCommission resets all changes to the "total_commission" field.
func (m *AchievementMutation) ResetTotalCommission() {
	m.total_commission = nil
	delete(m.clearedFields, achievement.FieldTotalCommission)
}

// SetSelfCommission sets the "self_commission" field.
func (m *AchievementMutation) SetSelfCommission(d decimal.Decimal) {
	m.self_commission = &d
}

// SelfCommission returns the value of the "self_commission" field in the mutation.
func (m *AchievementMutation) SelfCommission() (r decimal.Decimal, exists bool) {
	v := m.self_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfCommission returns the old "self_commission" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldSelfCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfCommission: %w", err)
	}
	return oldValue.SelfCommission, nil
}

// ClearSelfCommission clears the value of the "self_commission" field.
func (m *AchievementMutation) ClearSelfCommission() {
	m.self_commission = nil
	m.clearedFields[achievement.FieldSelfCommission] = struct{}{}
}

// SelfCommissionCleared returns if the "self_commission" field was cleared in this mutation.
func (m *AchievementMutation) SelfCommissionCleared() bool {
	_, ok := m.clearedFields[achievement.FieldSelfCommission]
	return ok
}

// ResetSelfCommission resets all changes to the "self_commission" field.
func (m *AchievementMutation) ResetSelfCommission() {
	m.self_commission = nil
	delete(m.clearedFields, achievement.FieldSelfCommission)
}

// Where appends a list predicates to the AchievementMutation builder.
func (m *AchievementMutation) Where(ps ...predicate.Achievement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AchievementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AchievementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Achievement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AchievementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AchievementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Achievement).
func (m *AchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AchievementMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, achievement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, achievement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, achievement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, achievement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, achievement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, achievement.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, achievement.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, achievement.FieldAppGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, achievement.FieldCoinTypeID)
	}
	if m.total_units_v1 != nil {
		fields = append(fields, achievement.FieldTotalUnitsV1)
	}
	if m.self_units_v1 != nil {
		fields = append(fields, achievement.FieldSelfUnitsV1)
	}
	if m.total_amount != nil {
		fields = append(fields, achievement.FieldTotalAmount)
	}
	if m.self_amount != nil {
		fields = append(fields, achievement.FieldSelfAmount)
	}
	if m.total_commission != nil {
		fields = append(fields, achievement.FieldTotalCommission)
	}
	if m.self_commission != nil {
		fields = append(fields, achievement.FieldSelfCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case achievement.FieldCreatedAt:
		return m.CreatedAt()
	case achievement.FieldUpdatedAt:
		return m.UpdatedAt()
	case achievement.FieldDeletedAt:
		return m.DeletedAt()
	case achievement.FieldEntID:
		return m.EntID()
	case achievement.FieldAppID:
		return m.AppID()
	case achievement.FieldUserID:
		return m.UserID()
	case achievement.FieldGoodID:
		return m.GoodID()
	case achievement.FieldAppGoodID:
		return m.AppGoodID()
	case achievement.FieldCoinTypeID:
		return m.CoinTypeID()
	case achievement.FieldTotalUnitsV1:
		return m.TotalUnitsV1()
	case achievement.FieldSelfUnitsV1:
		return m.SelfUnitsV1()
	case achievement.FieldTotalAmount:
		return m.TotalAmount()
	case achievement.FieldSelfAmount:
		return m.SelfAmount()
	case achievement.FieldTotalCommission:
		return m.TotalCommission()
	case achievement.FieldSelfCommission:
		return m.SelfCommission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case achievement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case achievement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case achievement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case achievement.FieldEntID:
		return m.OldEntID(ctx)
	case achievement.FieldAppID:
		return m.OldAppID(ctx)
	case achievement.FieldUserID:
		return m.OldUserID(ctx)
	case achievement.FieldGoodID:
		return m.OldGoodID(ctx)
	case achievement.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case achievement.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case achievement.FieldTotalUnitsV1:
		return m.OldTotalUnitsV1(ctx)
	case achievement.FieldSelfUnitsV1:
		return m.OldSelfUnitsV1(ctx)
	case achievement.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case achievement.FieldSelfAmount:
		return m.OldSelfAmount(ctx)
	case achievement.FieldTotalCommission:
		return m.OldTotalCommission(ctx)
	case achievement.FieldSelfCommission:
		return m.OldSelfCommission(ctx)
	}
	return nil, fmt.Errorf("unknown Achievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case achievement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case achievement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case achievement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case achievement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case achievement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case achievement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case achievement.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case achievement.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case achievement.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case achievement.FieldTotalUnitsV1:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnitsV1(v)
		return nil
	case achievement.FieldSelfUnitsV1:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfUnitsV1(v)
		return nil
	case achievement.FieldTotalAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case achievement.FieldSelfAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfAmount(v)
		return nil
	case achievement.FieldTotalCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCommission(v)
		return nil
	case achievement.FieldSelfCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfCommission(v)
		return nil
	}
	return fmt.Errorf("unknown Achievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AchievementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, achievement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, achievement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, achievement.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AchievementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case achievement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case achievement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case achievement.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case achievement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case achievement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case achievement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Achievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AchievementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(achievement.FieldAppID) {
		fields = append(fields, achievement.FieldAppID)
	}
	if m.FieldCleared(achievement.FieldUserID) {
		fields = append(fields, achievement.FieldUserID)
	}
	if m.FieldCleared(achievement.FieldGoodID) {
		fields = append(fields, achievement.FieldGoodID)
	}
	if m.FieldCleared(achievement.FieldAppGoodID) {
		fields = append(fields, achievement.FieldAppGoodID)
	}
	if m.FieldCleared(achievement.FieldCoinTypeID) {
		fields = append(fields, achievement.FieldCoinTypeID)
	}
	if m.FieldCleared(achievement.FieldTotalUnitsV1) {
		fields = append(fields, achievement.FieldTotalUnitsV1)
	}
	if m.FieldCleared(achievement.FieldSelfUnitsV1) {
		fields = append(fields, achievement.FieldSelfUnitsV1)
	}
	if m.FieldCleared(achievement.FieldTotalAmount) {
		fields = append(fields, achievement.FieldTotalAmount)
	}
	if m.FieldCleared(achievement.FieldSelfAmount) {
		fields = append(fields, achievement.FieldSelfAmount)
	}
	if m.FieldCleared(achievement.FieldTotalCommission) {
		fields = append(fields, achievement.FieldTotalCommission)
	}
	if m.FieldCleared(achievement.FieldSelfCommission) {
		fields = append(fields, achievement.FieldSelfCommission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AchievementMutation) ClearField(name string) error {
	switch name {
	case achievement.FieldAppID:
		m.ClearAppID()
		return nil
	case achievement.FieldUserID:
		m.ClearUserID()
		return nil
	case achievement.FieldGoodID:
		m.ClearGoodID()
		return nil
	case achievement.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case achievement.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case achievement.FieldTotalUnitsV1:
		m.ClearTotalUnitsV1()
		return nil
	case achievement.FieldSelfUnitsV1:
		m.ClearSelfUnitsV1()
		return nil
	case achievement.FieldTotalAmount:
		m.ClearTotalAmount()
		return nil
	case achievement.FieldSelfAmount:
		m.ClearSelfAmount()
		return nil
	case achievement.FieldTotalCommission:
		m.ClearTotalCommission()
		return nil
	case achievement.FieldSelfCommission:
		m.ClearSelfCommission()
		return nil
	}
	return fmt.Errorf("unknown Achievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AchievementMutation) ResetField(name string) error {
	switch name {
	case achievement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case achievement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case achievement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case achievement.FieldEntID:
		m.ResetEntID()
		return nil
	case achievement.FieldAppID:
		m.ResetAppID()
		return nil
	case achievement.FieldUserID:
		m.ResetUserID()
		return nil
	case achievement.FieldGoodID:
		m.ResetGoodID()
		return nil
	case achievement.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case achievement.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case achievement.FieldTotalUnitsV1:
		m.ResetTotalUnitsV1()
		return nil
	case achievement.FieldSelfUnitsV1:
		m.ResetSelfUnitsV1()
		return nil
	case achievement.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case achievement.FieldSelfAmount:
		m.ResetSelfAmount()
		return nil
	case achievement.FieldTotalCommission:
		m.ResetTotalCommission()
		return nil
	case achievement.FieldSelfCommission:
		m.ResetSelfCommission()
		return nil
	}
	return fmt.Errorf("unknown Achievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AchievementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AchievementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AchievementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AchievementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Achievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AchievementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Achievement edge %s", name)
}

// AchievementUserMutation represents an operation that mutates the AchievementUser nodes in the graph.
type AchievementUserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint32
	created_at             *uint32
	addcreated_at          *int32
	updated_at             *uint32
	addupdated_at          *int32
	deleted_at             *uint32
	adddeleted_at          *int32
	ent_id                 *uuid.UUID
	app_id                 *uuid.UUID
	user_id                *uuid.UUID
	total_commission       *decimal.Decimal
	self_commission        *decimal.Decimal
	direct_consume_amount  *decimal.Decimal
	invitee_consume_amount *decimal.Decimal
	direct_invitees        *uint32
	adddirect_invitees     *int32
	indirect_invitees      *uint32
	addindirect_invitees   *int32
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*AchievementUser, error)
	predicates             []predicate.AchievementUser
}

var _ ent.Mutation = (*AchievementUserMutation)(nil)

// achievementuserOption allows management of the mutation configuration using functional options.
type achievementuserOption func(*AchievementUserMutation)

// newAchievementUserMutation creates new mutation for the AchievementUser entity.
func newAchievementUserMutation(c config, op Op, opts ...achievementuserOption) *AchievementUserMutation {
	m := &AchievementUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAchievementUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAchievementUserID sets the ID field of the mutation.
func withAchievementUserID(id uint32) achievementuserOption {
	return func(m *AchievementUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AchievementUser
		)
		m.oldValue = func(ctx context.Context) (*AchievementUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AchievementUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAchievementUser sets the old AchievementUser of the mutation.
func withAchievementUser(node *AchievementUser) achievementuserOption {
	return func(m *AchievementUserMutation) {
		m.oldValue = func(context.Context) (*AchievementUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AchievementUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AchievementUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AchievementUser entities.
func (m *AchievementUserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AchievementUserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AchievementUserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AchievementUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AchievementUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AchievementUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AchievementUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AchievementUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AchievementUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AchievementUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AchievementUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AchievementUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AchievementUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AchievementUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AchievementUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AchievementUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AchievementUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AchievementUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AchievementUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AchievementUserMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AchievementUserMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AchievementUserMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AchievementUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AchievementUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AchievementUserMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[achievementuser.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AchievementUserMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[achievementuser.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AchievementUserMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, achievementuser.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AchievementUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AchievementUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AchievementUserMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[achievementuser.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AchievementUserMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[achievementuser.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AchievementUserMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, achievementuser.FieldUserID)
}

// SetTotalCommission sets the "total_commission" field.
func (m *AchievementUserMutation) SetTotalCommission(d decimal.Decimal) {
	m.total_commission = &d
}

// TotalCommission returns the value of the "total_commission" field in the mutation.
func (m *AchievementUserMutation) TotalCommission() (r decimal.Decimal, exists bool) {
	v := m.total_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCommission returns the old "total_commission" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldTotalCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCommission: %w", err)
	}
	return oldValue.TotalCommission, nil
}

// ClearTotalCommission clears the value of the "total_commission" field.
func (m *AchievementUserMutation) ClearTotalCommission() {
	m.total_commission = nil
	m.clearedFields[achievementuser.FieldTotalCommission] = struct{}{}
}

// TotalCommissionCleared returns if the "total_commission" field was cleared in this mutation.
func (m *AchievementUserMutation) TotalCommissionCleared() bool {
	_, ok := m.clearedFields[achievementuser.FieldTotalCommission]
	return ok
}

// ResetTotalCommission resets all changes to the "total_commission" field.
func (m *AchievementUserMutation) ResetTotalCommission() {
	m.total_commission = nil
	delete(m.clearedFields, achievementuser.FieldTotalCommission)
}

// SetSelfCommission sets the "self_commission" field.
func (m *AchievementUserMutation) SetSelfCommission(d decimal.Decimal) {
	m.self_commission = &d
}

// SelfCommission returns the value of the "self_commission" field in the mutation.
func (m *AchievementUserMutation) SelfCommission() (r decimal.Decimal, exists bool) {
	v := m.self_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfCommission returns the old "self_commission" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldSelfCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfCommission: %w", err)
	}
	return oldValue.SelfCommission, nil
}

// ClearSelfCommission clears the value of the "self_commission" field.
func (m *AchievementUserMutation) ClearSelfCommission() {
	m.self_commission = nil
	m.clearedFields[achievementuser.FieldSelfCommission] = struct{}{}
}

// SelfCommissionCleared returns if the "self_commission" field was cleared in this mutation.
func (m *AchievementUserMutation) SelfCommissionCleared() bool {
	_, ok := m.clearedFields[achievementuser.FieldSelfCommission]
	return ok
}

// ResetSelfCommission resets all changes to the "self_commission" field.
func (m *AchievementUserMutation) ResetSelfCommission() {
	m.self_commission = nil
	delete(m.clearedFields, achievementuser.FieldSelfCommission)
}

// SetDirectConsumeAmount sets the "direct_consume_amount" field.
func (m *AchievementUserMutation) SetDirectConsumeAmount(d decimal.Decimal) {
	m.direct_consume_amount = &d
}

// DirectConsumeAmount returns the value of the "direct_consume_amount" field in the mutation.
func (m *AchievementUserMutation) DirectConsumeAmount() (r decimal.Decimal, exists bool) {
	v := m.direct_consume_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectConsumeAmount returns the old "direct_consume_amount" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldDirectConsumeAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectConsumeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectConsumeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectConsumeAmount: %w", err)
	}
	return oldValue.DirectConsumeAmount, nil
}

// ClearDirectConsumeAmount clears the value of the "direct_consume_amount" field.
func (m *AchievementUserMutation) ClearDirectConsumeAmount() {
	m.direct_consume_amount = nil
	m.clearedFields[achievementuser.FieldDirectConsumeAmount] = struct{}{}
}

// DirectConsumeAmountCleared returns if the "direct_consume_amount" field was cleared in this mutation.
func (m *AchievementUserMutation) DirectConsumeAmountCleared() bool {
	_, ok := m.clearedFields[achievementuser.FieldDirectConsumeAmount]
	return ok
}

// ResetDirectConsumeAmount resets all changes to the "direct_consume_amount" field.
func (m *AchievementUserMutation) ResetDirectConsumeAmount() {
	m.direct_consume_amount = nil
	delete(m.clearedFields, achievementuser.FieldDirectConsumeAmount)
}

// SetInviteeConsumeAmount sets the "invitee_consume_amount" field.
func (m *AchievementUserMutation) SetInviteeConsumeAmount(d decimal.Decimal) {
	m.invitee_consume_amount = &d
}

// InviteeConsumeAmount returns the value of the "invitee_consume_amount" field in the mutation.
func (m *AchievementUserMutation) InviteeConsumeAmount() (r decimal.Decimal, exists bool) {
	v := m.invitee_consume_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeConsumeAmount returns the old "invitee_consume_amount" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldInviteeConsumeAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeConsumeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeConsumeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeConsumeAmount: %w", err)
	}
	return oldValue.InviteeConsumeAmount, nil
}

// ClearInviteeConsumeAmount clears the value of the "invitee_consume_amount" field.
func (m *AchievementUserMutation) ClearInviteeConsumeAmount() {
	m.invitee_consume_amount = nil
	m.clearedFields[achievementuser.FieldInviteeConsumeAmount] = struct{}{}
}

// InviteeConsumeAmountCleared returns if the "invitee_consume_amount" field was cleared in this mutation.
func (m *AchievementUserMutation) InviteeConsumeAmountCleared() bool {
	_, ok := m.clearedFields[achievementuser.FieldInviteeConsumeAmount]
	return ok
}

// ResetInviteeConsumeAmount resets all changes to the "invitee_consume_amount" field.
func (m *AchievementUserMutation) ResetInviteeConsumeAmount() {
	m.invitee_consume_amount = nil
	delete(m.clearedFields, achievementuser.FieldInviteeConsumeAmount)
}

// SetDirectInvitees sets the "direct_invitees" field.
func (m *AchievementUserMutation) SetDirectInvitees(u uint32) {
	m.direct_invitees = &u
	m.adddirect_invitees = nil
}

// DirectInvitees returns the value of the "direct_invitees" field in the mutation.
func (m *AchievementUserMutation) DirectInvitees() (r uint32, exists bool) {
	v := m.direct_invitees
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectInvitees returns the old "direct_invitees" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldDirectInvitees(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectInvitees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectInvitees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectInvitees: %w", err)
	}
	return oldValue.DirectInvitees, nil
}

// AddDirectInvitees adds u to the "direct_invitees" field.
func (m *AchievementUserMutation) AddDirectInvitees(u int32) {
	if m.adddirect_invitees != nil {
		*m.adddirect_invitees += u
	} else {
		m.adddirect_invitees = &u
	}
}

// AddedDirectInvitees returns the value that was added to the "direct_invitees" field in this mutation.
func (m *AchievementUserMutation) AddedDirectInvitees() (r int32, exists bool) {
	v := m.adddirect_invitees
	if v == nil {
		return
	}
	return *v, true
}

// ClearDirectInvitees clears the value of the "direct_invitees" field.
func (m *AchievementUserMutation) ClearDirectInvitees() {
	m.direct_invitees = nil
	m.adddirect_invitees = nil
	m.clearedFields[achievementuser.FieldDirectInvitees] = struct{}{}
}

// DirectInviteesCleared returns if the "direct_invitees" field was cleared in this mutation.
func (m *AchievementUserMutation) DirectInviteesCleared() bool {
	_, ok := m.clearedFields[achievementuser.FieldDirectInvitees]
	return ok
}

// ResetDirectInvitees resets all changes to the "direct_invitees" field.
func (m *AchievementUserMutation) ResetDirectInvitees() {
	m.direct_invitees = nil
	m.adddirect_invitees = nil
	delete(m.clearedFields, achievementuser.FieldDirectInvitees)
}

// SetIndirectInvitees sets the "indirect_invitees" field.
func (m *AchievementUserMutation) SetIndirectInvitees(u uint32) {
	m.indirect_invitees = &u
	m.addindirect_invitees = nil
}

// IndirectInvitees returns the value of the "indirect_invitees" field in the mutation.
func (m *AchievementUserMutation) IndirectInvitees() (r uint32, exists bool) {
	v := m.indirect_invitees
	if v == nil {
		return
	}
	return *v, true
}

// OldIndirectInvitees returns the old "indirect_invitees" field's value of the AchievementUser entity.
// If the AchievementUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementUserMutation) OldIndirectInvitees(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndirectInvitees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndirectInvitees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndirectInvitees: %w", err)
	}
	return oldValue.IndirectInvitees, nil
}

// AddIndirectInvitees adds u to the "indirect_invitees" field.
func (m *AchievementUserMutation) AddIndirectInvitees(u int32) {
	if m.addindirect_invitees != nil {
		*m.addindirect_invitees += u
	} else {
		m.addindirect_invitees = &u
	}
}

// AddedIndirectInvitees returns the value that was added to the "indirect_invitees" field in this mutation.
func (m *AchievementUserMutation) AddedIndirectInvitees() (r int32, exists bool) {
	v := m.addindirect_invitees
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndirectInvitees clears the value of the "indirect_invitees" field.
func (m *AchievementUserMutation) ClearIndirectInvitees() {
	m.indirect_invitees = nil
	m.addindirect_invitees = nil
	m.clearedFields[achievementuser.FieldIndirectInvitees] = struct{}{}
}

// IndirectInviteesCleared returns if the "indirect_invitees" field was cleared in this mutation.
func (m *AchievementUserMutation) IndirectInviteesCleared() bool {
	_, ok := m.clearedFields[achievementuser.FieldIndirectInvitees]
	return ok
}

// ResetIndirectInvitees resets all changes to the "indirect_invitees" field.
func (m *AchievementUserMutation) ResetIndirectInvitees() {
	m.indirect_invitees = nil
	m.addindirect_invitees = nil
	delete(m.clearedFields, achievementuser.FieldIndirectInvitees)
}

// Where appends a list predicates to the AchievementUserMutation builder.
func (m *AchievementUserMutation) Where(ps ...predicate.AchievementUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AchievementUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AchievementUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AchievementUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AchievementUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AchievementUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AchievementUser).
func (m *AchievementUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AchievementUserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, achievementuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, achievementuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, achievementuser.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, achievementuser.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, achievementuser.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, achievementuser.FieldUserID)
	}
	if m.total_commission != nil {
		fields = append(fields, achievementuser.FieldTotalCommission)
	}
	if m.self_commission != nil {
		fields = append(fields, achievementuser.FieldSelfCommission)
	}
	if m.direct_consume_amount != nil {
		fields = append(fields, achievementuser.FieldDirectConsumeAmount)
	}
	if m.invitee_consume_amount != nil {
		fields = append(fields, achievementuser.FieldInviteeConsumeAmount)
	}
	if m.direct_invitees != nil {
		fields = append(fields, achievementuser.FieldDirectInvitees)
	}
	if m.indirect_invitees != nil {
		fields = append(fields, achievementuser.FieldIndirectInvitees)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AchievementUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case achievementuser.FieldCreatedAt:
		return m.CreatedAt()
	case achievementuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case achievementuser.FieldDeletedAt:
		return m.DeletedAt()
	case achievementuser.FieldEntID:
		return m.EntID()
	case achievementuser.FieldAppID:
		return m.AppID()
	case achievementuser.FieldUserID:
		return m.UserID()
	case achievementuser.FieldTotalCommission:
		return m.TotalCommission()
	case achievementuser.FieldSelfCommission:
		return m.SelfCommission()
	case achievementuser.FieldDirectConsumeAmount:
		return m.DirectConsumeAmount()
	case achievementuser.FieldInviteeConsumeAmount:
		return m.InviteeConsumeAmount()
	case achievementuser.FieldDirectInvitees:
		return m.DirectInvitees()
	case achievementuser.FieldIndirectInvitees:
		return m.IndirectInvitees()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AchievementUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case achievementuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case achievementuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case achievementuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case achievementuser.FieldEntID:
		return m.OldEntID(ctx)
	case achievementuser.FieldAppID:
		return m.OldAppID(ctx)
	case achievementuser.FieldUserID:
		return m.OldUserID(ctx)
	case achievementuser.FieldTotalCommission:
		return m.OldTotalCommission(ctx)
	case achievementuser.FieldSelfCommission:
		return m.OldSelfCommission(ctx)
	case achievementuser.FieldDirectConsumeAmount:
		return m.OldDirectConsumeAmount(ctx)
	case achievementuser.FieldInviteeConsumeAmount:
		return m.OldInviteeConsumeAmount(ctx)
	case achievementuser.FieldDirectInvitees:
		return m.OldDirectInvitees(ctx)
	case achievementuser.FieldIndirectInvitees:
		return m.OldIndirectInvitees(ctx)
	}
	return nil, fmt.Errorf("unknown AchievementUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case achievementuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case achievementuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case achievementuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case achievementuser.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case achievementuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case achievementuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case achievementuser.FieldTotalCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCommission(v)
		return nil
	case achievementuser.FieldSelfCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfCommission(v)
		return nil
	case achievementuser.FieldDirectConsumeAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectConsumeAmount(v)
		return nil
	case achievementuser.FieldInviteeConsumeAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeConsumeAmount(v)
		return nil
	case achievementuser.FieldDirectInvitees:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectInvitees(v)
		return nil
	case achievementuser.FieldIndirectInvitees:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndirectInvitees(v)
		return nil
	}
	return fmt.Errorf("unknown AchievementUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AchievementUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, achievementuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, achievementuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, achievementuser.FieldDeletedAt)
	}
	if m.adddirect_invitees != nil {
		fields = append(fields, achievementuser.FieldDirectInvitees)
	}
	if m.addindirect_invitees != nil {
		fields = append(fields, achievementuser.FieldIndirectInvitees)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AchievementUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case achievementuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case achievementuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case achievementuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	case achievementuser.FieldDirectInvitees:
		return m.AddedDirectInvitees()
	case achievementuser.FieldIndirectInvitees:
		return m.AddedIndirectInvitees()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case achievementuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case achievementuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case achievementuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case achievementuser.FieldDirectInvitees:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDirectInvitees(v)
		return nil
	case achievementuser.FieldIndirectInvitees:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndirectInvitees(v)
		return nil
	}
	return fmt.Errorf("unknown AchievementUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AchievementUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(achievementuser.FieldAppID) {
		fields = append(fields, achievementuser.FieldAppID)
	}
	if m.FieldCleared(achievementuser.FieldUserID) {
		fields = append(fields, achievementuser.FieldUserID)
	}
	if m.FieldCleared(achievementuser.FieldTotalCommission) {
		fields = append(fields, achievementuser.FieldTotalCommission)
	}
	if m.FieldCleared(achievementuser.FieldSelfCommission) {
		fields = append(fields, achievementuser.FieldSelfCommission)
	}
	if m.FieldCleared(achievementuser.FieldDirectConsumeAmount) {
		fields = append(fields, achievementuser.FieldDirectConsumeAmount)
	}
	if m.FieldCleared(achievementuser.FieldInviteeConsumeAmount) {
		fields = append(fields, achievementuser.FieldInviteeConsumeAmount)
	}
	if m.FieldCleared(achievementuser.FieldDirectInvitees) {
		fields = append(fields, achievementuser.FieldDirectInvitees)
	}
	if m.FieldCleared(achievementuser.FieldIndirectInvitees) {
		fields = append(fields, achievementuser.FieldIndirectInvitees)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AchievementUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AchievementUserMutation) ClearField(name string) error {
	switch name {
	case achievementuser.FieldAppID:
		m.ClearAppID()
		return nil
	case achievementuser.FieldUserID:
		m.ClearUserID()
		return nil
	case achievementuser.FieldTotalCommission:
		m.ClearTotalCommission()
		return nil
	case achievementuser.FieldSelfCommission:
		m.ClearSelfCommission()
		return nil
	case achievementuser.FieldDirectConsumeAmount:
		m.ClearDirectConsumeAmount()
		return nil
	case achievementuser.FieldInviteeConsumeAmount:
		m.ClearInviteeConsumeAmount()
		return nil
	case achievementuser.FieldDirectInvitees:
		m.ClearDirectInvitees()
		return nil
	case achievementuser.FieldIndirectInvitees:
		m.ClearIndirectInvitees()
		return nil
	}
	return fmt.Errorf("unknown AchievementUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AchievementUserMutation) ResetField(name string) error {
	switch name {
	case achievementuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case achievementuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case achievementuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case achievementuser.FieldEntID:
		m.ResetEntID()
		return nil
	case achievementuser.FieldAppID:
		m.ResetAppID()
		return nil
	case achievementuser.FieldUserID:
		m.ResetUserID()
		return nil
	case achievementuser.FieldTotalCommission:
		m.ResetTotalCommission()
		return nil
	case achievementuser.FieldSelfCommission:
		m.ResetSelfCommission()
		return nil
	case achievementuser.FieldDirectConsumeAmount:
		m.ResetDirectConsumeAmount()
		return nil
	case achievementuser.FieldInviteeConsumeAmount:
		m.ResetInviteeConsumeAmount()
		return nil
	case achievementuser.FieldDirectInvitees:
		m.ResetDirectInvitees()
		return nil
	case achievementuser.FieldIndirectInvitees:
		m.ResetIndirectInvitees()
		return nil
	}
	return fmt.Errorf("unknown AchievementUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AchievementUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AchievementUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AchievementUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AchievementUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AchievementUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AchievementUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AchievementUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AchievementUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AchievementUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AchievementUser edge %s", name)
}

// AppCommissionConfigMutation represents an operation that mutates the AppCommissionConfig nodes in the graph.
type AppCommissionConfigMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	ent_id            *uuid.UUID
	app_id            *uuid.UUID
	level             *uint32
	addlevel          *int32
	threshold_amount  *decimal.Decimal
	amount_or_percent *decimal.Decimal
	start_at          *uint32
	addstart_at       *int32
	end_at            *uint32
	addend_at         *int32
	invites           *uint32
	addinvites        *int32
	settle_type       *string
	disabled          *bool
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*AppCommissionConfig, error)
	predicates        []predicate.AppCommissionConfig
}

var _ ent.Mutation = (*AppCommissionConfigMutation)(nil)

// appcommissionconfigOption allows management of the mutation configuration using functional options.
type appcommissionconfigOption func(*AppCommissionConfigMutation)

// newAppCommissionConfigMutation creates new mutation for the AppCommissionConfig entity.
func newAppCommissionConfigMutation(c config, op Op, opts ...appcommissionconfigOption) *AppCommissionConfigMutation {
	m := &AppCommissionConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeAppCommissionConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppCommissionConfigID sets the ID field of the mutation.
func withAppCommissionConfigID(id uint32) appcommissionconfigOption {
	return func(m *AppCommissionConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *AppCommissionConfig
		)
		m.oldValue = func(ctx context.Context) (*AppCommissionConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppCommissionConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppCommissionConfig sets the old AppCommissionConfig of the mutation.
func withAppCommissionConfig(node *AppCommissionConfig) appcommissionconfigOption {
	return func(m *AppCommissionConfigMutation) {
		m.oldValue = func(context.Context) (*AppCommissionConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppCommissionConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppCommissionConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppCommissionConfig entities.
func (m *AppCommissionConfigMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppCommissionConfigMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppCommissionConfigMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppCommissionConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppCommissionConfigMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppCommissionConfigMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppCommissionConfigMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppCommissionConfigMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppCommissionConfigMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppCommissionConfigMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppCommissionConfigMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppCommissionConfigMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppCommissionConfigMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppCommissionConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppCommissionConfigMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppCommissionConfigMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppCommissionConfigMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppCommissionConfigMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppCommissionConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppCommissionConfigMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppCommissionConfigMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppCommissionConfigMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppCommissionConfigMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppCommissionConfigMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppCommissionConfigMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appcommissionconfig.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppCommissionConfigMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appcommissionconfig.FieldAppID)
}

// SetLevel sets the "level" field.
func (m *AppCommissionConfigMutation) SetLevel(u uint32) {
	m.level = &u
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *AppCommissionConfigMutation) Level() (r uint32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldLevel(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds u to the "level" field.
func (m *AppCommissionConfigMutation) AddLevel(u int32) {
	if m.addlevel != nil {
		*m.addlevel += u
	} else {
		m.addlevel = &u
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *AppCommissionConfigMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *AppCommissionConfigMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[appcommissionconfig.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) LevelCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *AppCommissionConfigMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, appcommissionconfig.FieldLevel)
}

// SetThresholdAmount sets the "threshold_amount" field.
func (m *AppCommissionConfigMutation) SetThresholdAmount(d decimal.Decimal) {
	m.threshold_amount = &d
}

// ThresholdAmount returns the value of the "threshold_amount" field in the mutation.
func (m *AppCommissionConfigMutation) ThresholdAmount() (r decimal.Decimal, exists bool) {
	v := m.threshold_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldThresholdAmount returns the old "threshold_amount" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldThresholdAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThresholdAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThresholdAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThresholdAmount: %w", err)
	}
	return oldValue.ThresholdAmount, nil
}

// ClearThresholdAmount clears the value of the "threshold_amount" field.
func (m *AppCommissionConfigMutation) ClearThresholdAmount() {
	m.threshold_amount = nil
	m.clearedFields[appcommissionconfig.FieldThresholdAmount] = struct{}{}
}

// ThresholdAmountCleared returns if the "threshold_amount" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) ThresholdAmountCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldThresholdAmount]
	return ok
}

// ResetThresholdAmount resets all changes to the "threshold_amount" field.
func (m *AppCommissionConfigMutation) ResetThresholdAmount() {
	m.threshold_amount = nil
	delete(m.clearedFields, appcommissionconfig.FieldThresholdAmount)
}

// SetAmountOrPercent sets the "amount_or_percent" field.
func (m *AppCommissionConfigMutation) SetAmountOrPercent(d decimal.Decimal) {
	m.amount_or_percent = &d
}

// AmountOrPercent returns the value of the "amount_or_percent" field in the mutation.
func (m *AppCommissionConfigMutation) AmountOrPercent() (r decimal.Decimal, exists bool) {
	v := m.amount_or_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountOrPercent returns the old "amount_or_percent" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldAmountOrPercent(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountOrPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountOrPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountOrPercent: %w", err)
	}
	return oldValue.AmountOrPercent, nil
}

// ClearAmountOrPercent clears the value of the "amount_or_percent" field.
func (m *AppCommissionConfigMutation) ClearAmountOrPercent() {
	m.amount_or_percent = nil
	m.clearedFields[appcommissionconfig.FieldAmountOrPercent] = struct{}{}
}

// AmountOrPercentCleared returns if the "amount_or_percent" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) AmountOrPercentCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldAmountOrPercent]
	return ok
}

// ResetAmountOrPercent resets all changes to the "amount_or_percent" field.
func (m *AppCommissionConfigMutation) ResetAmountOrPercent() {
	m.amount_or_percent = nil
	delete(m.clearedFields, appcommissionconfig.FieldAmountOrPercent)
}

// SetStartAt sets the "start_at" field.
func (m *AppCommissionConfigMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *AppCommissionConfigMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *AppCommissionConfigMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *AppCommissionConfigMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *AppCommissionConfigMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[appcommissionconfig.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *AppCommissionConfigMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, appcommissionconfig.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *AppCommissionConfigMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *AppCommissionConfigMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *AppCommissionConfigMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *AppCommissionConfigMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *AppCommissionConfigMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[appcommissionconfig.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *AppCommissionConfigMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, appcommissionconfig.FieldEndAt)
}

// SetInvites sets the "invites" field.
func (m *AppCommissionConfigMutation) SetInvites(u uint32) {
	m.invites = &u
	m.addinvites = nil
}

// Invites returns the value of the "invites" field in the mutation.
func (m *AppCommissionConfigMutation) Invites() (r uint32, exists bool) {
	v := m.invites
	if v == nil {
		return
	}
	return *v, true
}

// OldInvites returns the old "invites" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldInvites(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvites is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvites requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvites: %w", err)
	}
	return oldValue.Invites, nil
}

// AddInvites adds u to the "invites" field.
func (m *AppCommissionConfigMutation) AddInvites(u int32) {
	if m.addinvites != nil {
		*m.addinvites += u
	} else {
		m.addinvites = &u
	}
}

// AddedInvites returns the value that was added to the "invites" field in this mutation.
func (m *AppCommissionConfigMutation) AddedInvites() (r int32, exists bool) {
	v := m.addinvites
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvites clears the value of the "invites" field.
func (m *AppCommissionConfigMutation) ClearInvites() {
	m.invites = nil
	m.addinvites = nil
	m.clearedFields[appcommissionconfig.FieldInvites] = struct{}{}
}

// InvitesCleared returns if the "invites" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) InvitesCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldInvites]
	return ok
}

// ResetInvites resets all changes to the "invites" field.
func (m *AppCommissionConfigMutation) ResetInvites() {
	m.invites = nil
	m.addinvites = nil
	delete(m.clearedFields, appcommissionconfig.FieldInvites)
}

// SetSettleType sets the "settle_type" field.
func (m *AppCommissionConfigMutation) SetSettleType(s string) {
	m.settle_type = &s
}

// SettleType returns the value of the "settle_type" field in the mutation.
func (m *AppCommissionConfigMutation) SettleType() (r string, exists bool) {
	v := m.settle_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleType returns the old "settle_type" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldSettleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleType: %w", err)
	}
	return oldValue.SettleType, nil
}

// ClearSettleType clears the value of the "settle_type" field.
func (m *AppCommissionConfigMutation) ClearSettleType() {
	m.settle_type = nil
	m.clearedFields[appcommissionconfig.FieldSettleType] = struct{}{}
}

// SettleTypeCleared returns if the "settle_type" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) SettleTypeCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldSettleType]
	return ok
}

// ResetSettleType resets all changes to the "settle_type" field.
func (m *AppCommissionConfigMutation) ResetSettleType() {
	m.settle_type = nil
	delete(m.clearedFields, appcommissionconfig.FieldSettleType)
}

// SetDisabled sets the "disabled" field.
func (m *AppCommissionConfigMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *AppCommissionConfigMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the AppCommissionConfig entity.
// If the AppCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCommissionConfigMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *AppCommissionConfigMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[appcommissionconfig.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *AppCommissionConfigMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[appcommissionconfig.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *AppCommissionConfigMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, appcommissionconfig.FieldDisabled)
}

// Where appends a list predicates to the AppCommissionConfigMutation builder.
func (m *AppCommissionConfigMutation) Where(ps ...predicate.AppCommissionConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppCommissionConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppCommissionConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppCommissionConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppCommissionConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppCommissionConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppCommissionConfig).
func (m *AppCommissionConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppCommissionConfigMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, appcommissionconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appcommissionconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appcommissionconfig.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appcommissionconfig.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appcommissionconfig.FieldAppID)
	}
	if m.level != nil {
		fields = append(fields, appcommissionconfig.FieldLevel)
	}
	if m.threshold_amount != nil {
		fields = append(fields, appcommissionconfig.FieldThresholdAmount)
	}
	if m.amount_or_percent != nil {
		fields = append(fields, appcommissionconfig.FieldAmountOrPercent)
	}
	if m.start_at != nil {
		fields = append(fields, appcommissionconfig.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, appcommissionconfig.FieldEndAt)
	}
	if m.invites != nil {
		fields = append(fields, appcommissionconfig.FieldInvites)
	}
	if m.settle_type != nil {
		fields = append(fields, appcommissionconfig.FieldSettleType)
	}
	if m.disabled != nil {
		fields = append(fields, appcommissionconfig.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppCommissionConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcommissionconfig.FieldCreatedAt:
		return m.CreatedAt()
	case appcommissionconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcommissionconfig.FieldDeletedAt:
		return m.DeletedAt()
	case appcommissionconfig.FieldEntID:
		return m.EntID()
	case appcommissionconfig.FieldAppID:
		return m.AppID()
	case appcommissionconfig.FieldLevel:
		return m.Level()
	case appcommissionconfig.FieldThresholdAmount:
		return m.ThresholdAmount()
	case appcommissionconfig.FieldAmountOrPercent:
		return m.AmountOrPercent()
	case appcommissionconfig.FieldStartAt:
		return m.StartAt()
	case appcommissionconfig.FieldEndAt:
		return m.EndAt()
	case appcommissionconfig.FieldInvites:
		return m.Invites()
	case appcommissionconfig.FieldSettleType:
		return m.SettleType()
	case appcommissionconfig.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppCommissionConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcommissionconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appcommissionconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcommissionconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appcommissionconfig.FieldEntID:
		return m.OldEntID(ctx)
	case appcommissionconfig.FieldAppID:
		return m.OldAppID(ctx)
	case appcommissionconfig.FieldLevel:
		return m.OldLevel(ctx)
	case appcommissionconfig.FieldThresholdAmount:
		return m.OldThresholdAmount(ctx)
	case appcommissionconfig.FieldAmountOrPercent:
		return m.OldAmountOrPercent(ctx)
	case appcommissionconfig.FieldStartAt:
		return m.OldStartAt(ctx)
	case appcommissionconfig.FieldEndAt:
		return m.OldEndAt(ctx)
	case appcommissionconfig.FieldInvites:
		return m.OldInvites(ctx)
	case appcommissionconfig.FieldSettleType:
		return m.OldSettleType(ctx)
	case appcommissionconfig.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown AppCommissionConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCommissionConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcommissionconfig.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appcommissionconfig.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcommissionconfig.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appcommissionconfig.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appcommissionconfig.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appcommissionconfig.FieldLevel:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case appcommissionconfig.FieldThresholdAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThresholdAmount(v)
		return nil
	case appcommissionconfig.FieldAmountOrPercent:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountOrPercent(v)
		return nil
	case appcommissionconfig.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case appcommissionconfig.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case appcommissionconfig.FieldInvites:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvites(v)
		return nil
	case appcommissionconfig.FieldSettleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleType(v)
		return nil
	case appcommissionconfig.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown AppCommissionConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppCommissionConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appcommissionconfig.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appcommissionconfig.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appcommissionconfig.FieldDeletedAt)
	}
	if m.addlevel != nil {
		fields = append(fields, appcommissionconfig.FieldLevel)
	}
	if m.addstart_at != nil {
		fields = append(fields, appcommissionconfig.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, appcommissionconfig.FieldEndAt)
	}
	if m.addinvites != nil {
		fields = append(fields, appcommissionconfig.FieldInvites)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppCommissionConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appcommissionconfig.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appcommissionconfig.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appcommissionconfig.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appcommissionconfig.FieldLevel:
		return m.AddedLevel()
	case appcommissionconfig.FieldStartAt:
		return m.AddedStartAt()
	case appcommissionconfig.FieldEndAt:
		return m.AddedEndAt()
	case appcommissionconfig.FieldInvites:
		return m.AddedInvites()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCommissionConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appcommissionconfig.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appcommissionconfig.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appcommissionconfig.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appcommissionconfig.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case appcommissionconfig.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case appcommissionconfig.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	case appcommissionconfig.FieldInvites:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvites(v)
		return nil
	}
	return fmt.Errorf("unknown AppCommissionConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppCommissionConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appcommissionconfig.FieldAppID) {
		fields = append(fields, appcommissionconfig.FieldAppID)
	}
	if m.FieldCleared(appcommissionconfig.FieldLevel) {
		fields = append(fields, appcommissionconfig.FieldLevel)
	}
	if m.FieldCleared(appcommissionconfig.FieldThresholdAmount) {
		fields = append(fields, appcommissionconfig.FieldThresholdAmount)
	}
	if m.FieldCleared(appcommissionconfig.FieldAmountOrPercent) {
		fields = append(fields, appcommissionconfig.FieldAmountOrPercent)
	}
	if m.FieldCleared(appcommissionconfig.FieldStartAt) {
		fields = append(fields, appcommissionconfig.FieldStartAt)
	}
	if m.FieldCleared(appcommissionconfig.FieldEndAt) {
		fields = append(fields, appcommissionconfig.FieldEndAt)
	}
	if m.FieldCleared(appcommissionconfig.FieldInvites) {
		fields = append(fields, appcommissionconfig.FieldInvites)
	}
	if m.FieldCleared(appcommissionconfig.FieldSettleType) {
		fields = append(fields, appcommissionconfig.FieldSettleType)
	}
	if m.FieldCleared(appcommissionconfig.FieldDisabled) {
		fields = append(fields, appcommissionconfig.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppCommissionConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppCommissionConfigMutation) ClearField(name string) error {
	switch name {
	case appcommissionconfig.FieldAppID:
		m.ClearAppID()
		return nil
	case appcommissionconfig.FieldLevel:
		m.ClearLevel()
		return nil
	case appcommissionconfig.FieldThresholdAmount:
		m.ClearThresholdAmount()
		return nil
	case appcommissionconfig.FieldAmountOrPercent:
		m.ClearAmountOrPercent()
		return nil
	case appcommissionconfig.FieldStartAt:
		m.ClearStartAt()
		return nil
	case appcommissionconfig.FieldEndAt:
		m.ClearEndAt()
		return nil
	case appcommissionconfig.FieldInvites:
		m.ClearInvites()
		return nil
	case appcommissionconfig.FieldSettleType:
		m.ClearSettleType()
		return nil
	case appcommissionconfig.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown AppCommissionConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppCommissionConfigMutation) ResetField(name string) error {
	switch name {
	case appcommissionconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appcommissionconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcommissionconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appcommissionconfig.FieldEntID:
		m.ResetEntID()
		return nil
	case appcommissionconfig.FieldAppID:
		m.ResetAppID()
		return nil
	case appcommissionconfig.FieldLevel:
		m.ResetLevel()
		return nil
	case appcommissionconfig.FieldThresholdAmount:
		m.ResetThresholdAmount()
		return nil
	case appcommissionconfig.FieldAmountOrPercent:
		m.ResetAmountOrPercent()
		return nil
	case appcommissionconfig.FieldStartAt:
		m.ResetStartAt()
		return nil
	case appcommissionconfig.FieldEndAt:
		m.ResetEndAt()
		return nil
	case appcommissionconfig.FieldInvites:
		m.ResetInvites()
		return nil
	case appcommissionconfig.FieldSettleType:
		m.ResetSettleType()
		return nil
	case appcommissionconfig.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown AppCommissionConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppCommissionConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppCommissionConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppCommissionConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppCommissionConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppCommissionConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppCommissionConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppCommissionConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppCommissionConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppCommissionConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppCommissionConfig edge %s", name)
}

// AppConfigMutation represents an operation that mutates the AppConfig nodes in the graph.
type AppConfigMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	ent_id             *uuid.UUID
	app_id             *uuid.UUID
	settle_mode        *string
	settle_amount_type *string
	settle_interval    *string
	commission_type    *string
	settle_benefit     *bool
	max_level          *uint32
	addmax_level       *int32
	start_at           *uint32
	addstart_at        *int32
	end_at             *uint32
	addend_at          *int32
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*AppConfig, error)
	predicates         []predicate.AppConfig
}

var _ ent.Mutation = (*AppConfigMutation)(nil)

// appconfigOption allows management of the mutation configuration using functional options.
type appconfigOption func(*AppConfigMutation)

// newAppConfigMutation creates new mutation for the AppConfig entity.
func newAppConfigMutation(c config, op Op, opts ...appconfigOption) *AppConfigMutation {
	m := &AppConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeAppConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppConfigID sets the ID field of the mutation.
func withAppConfigID(id uint32) appconfigOption {
	return func(m *AppConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *AppConfig
		)
		m.oldValue = func(ctx context.Context) (*AppConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppConfig sets the old AppConfig of the mutation.
func withAppConfig(node *AppConfig) appconfigOption {
	return func(m *AppConfigMutation) {
		m.oldValue = func(context.Context) (*AppConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppConfig entities.
func (m *AppConfigMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppConfigMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppConfigMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppConfigMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppConfigMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppConfigMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppConfigMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppConfigMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppConfigMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppConfigMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppConfigMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppConfigMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppConfigMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppConfigMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppConfigMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppConfigMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppConfigMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppConfigMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppConfigMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppConfigMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppConfigMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppConfigMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appconfig.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppConfigMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppConfigMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appconfig.FieldAppID)
}

// SetSettleMode sets the "settle_mode" field.
func (m *AppConfigMutation) SetSettleMode(s string) {
	m.settle_mode = &s
}

// SettleMode returns the value of the "settle_mode" field in the mutation.
func (m *AppConfigMutation) SettleMode() (r string, exists bool) {
	v := m.settle_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleMode returns the old "settle_mode" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldSettleMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleMode: %w", err)
	}
	return oldValue.SettleMode, nil
}

// ClearSettleMode clears the value of the "settle_mode" field.
func (m *AppConfigMutation) ClearSettleMode() {
	m.settle_mode = nil
	m.clearedFields[appconfig.FieldSettleMode] = struct{}{}
}

// SettleModeCleared returns if the "settle_mode" field was cleared in this mutation.
func (m *AppConfigMutation) SettleModeCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldSettleMode]
	return ok
}

// ResetSettleMode resets all changes to the "settle_mode" field.
func (m *AppConfigMutation) ResetSettleMode() {
	m.settle_mode = nil
	delete(m.clearedFields, appconfig.FieldSettleMode)
}

// SetSettleAmountType sets the "settle_amount_type" field.
func (m *AppConfigMutation) SetSettleAmountType(s string) {
	m.settle_amount_type = &s
}

// SettleAmountType returns the value of the "settle_amount_type" field in the mutation.
func (m *AppConfigMutation) SettleAmountType() (r string, exists bool) {
	v := m.settle_amount_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleAmountType returns the old "settle_amount_type" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldSettleAmountType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleAmountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleAmountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleAmountType: %w", err)
	}
	return oldValue.SettleAmountType, nil
}

// ClearSettleAmountType clears the value of the "settle_amount_type" field.
func (m *AppConfigMutation) ClearSettleAmountType() {
	m.settle_amount_type = nil
	m.clearedFields[appconfig.FieldSettleAmountType] = struct{}{}
}

// SettleAmountTypeCleared returns if the "settle_amount_type" field was cleared in this mutation.
func (m *AppConfigMutation) SettleAmountTypeCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldSettleAmountType]
	return ok
}

// ResetSettleAmountType resets all changes to the "settle_amount_type" field.
func (m *AppConfigMutation) ResetSettleAmountType() {
	m.settle_amount_type = nil
	delete(m.clearedFields, appconfig.FieldSettleAmountType)
}

// SetSettleInterval sets the "settle_interval" field.
func (m *AppConfigMutation) SetSettleInterval(s string) {
	m.settle_interval = &s
}

// SettleInterval returns the value of the "settle_interval" field in the mutation.
func (m *AppConfigMutation) SettleInterval() (r string, exists bool) {
	v := m.settle_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleInterval returns the old "settle_interval" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldSettleInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleInterval: %w", err)
	}
	return oldValue.SettleInterval, nil
}

// ClearSettleInterval clears the value of the "settle_interval" field.
func (m *AppConfigMutation) ClearSettleInterval() {
	m.settle_interval = nil
	m.clearedFields[appconfig.FieldSettleInterval] = struct{}{}
}

// SettleIntervalCleared returns if the "settle_interval" field was cleared in this mutation.
func (m *AppConfigMutation) SettleIntervalCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldSettleInterval]
	return ok
}

// ResetSettleInterval resets all changes to the "settle_interval" field.
func (m *AppConfigMutation) ResetSettleInterval() {
	m.settle_interval = nil
	delete(m.clearedFields, appconfig.FieldSettleInterval)
}

// SetCommissionType sets the "commission_type" field.
func (m *AppConfigMutation) SetCommissionType(s string) {
	m.commission_type = &s
}

// CommissionType returns the value of the "commission_type" field in the mutation.
func (m *AppConfigMutation) CommissionType() (r string, exists bool) {
	v := m.commission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionType returns the old "commission_type" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldCommissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionType: %w", err)
	}
	return oldValue.CommissionType, nil
}

// ClearCommissionType clears the value of the "commission_type" field.
func (m *AppConfigMutation) ClearCommissionType() {
	m.commission_type = nil
	m.clearedFields[appconfig.FieldCommissionType] = struct{}{}
}

// CommissionTypeCleared returns if the "commission_type" field was cleared in this mutation.
func (m *AppConfigMutation) CommissionTypeCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldCommissionType]
	return ok
}

// ResetCommissionType resets all changes to the "commission_type" field.
func (m *AppConfigMutation) ResetCommissionType() {
	m.commission_type = nil
	delete(m.clearedFields, appconfig.FieldCommissionType)
}

// SetSettleBenefit sets the "settle_benefit" field.
func (m *AppConfigMutation) SetSettleBenefit(b bool) {
	m.settle_benefit = &b
}

// SettleBenefit returns the value of the "settle_benefit" field in the mutation.
func (m *AppConfigMutation) SettleBenefit() (r bool, exists bool) {
	v := m.settle_benefit
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleBenefit returns the old "settle_benefit" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldSettleBenefit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleBenefit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleBenefit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleBenefit: %w", err)
	}
	return oldValue.SettleBenefit, nil
}

// ClearSettleBenefit clears the value of the "settle_benefit" field.
func (m *AppConfigMutation) ClearSettleBenefit() {
	m.settle_benefit = nil
	m.clearedFields[appconfig.FieldSettleBenefit] = struct{}{}
}

// SettleBenefitCleared returns if the "settle_benefit" field was cleared in this mutation.
func (m *AppConfigMutation) SettleBenefitCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldSettleBenefit]
	return ok
}

// ResetSettleBenefit resets all changes to the "settle_benefit" field.
func (m *AppConfigMutation) ResetSettleBenefit() {
	m.settle_benefit = nil
	delete(m.clearedFields, appconfig.FieldSettleBenefit)
}

// SetMaxLevel sets the "max_level" field.
func (m *AppConfigMutation) SetMaxLevel(u uint32) {
	m.max_level = &u
	m.addmax_level = nil
}

// MaxLevel returns the value of the "max_level" field in the mutation.
func (m *AppConfigMutation) MaxLevel() (r uint32, exists bool) {
	v := m.max_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLevel returns the old "max_level" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldMaxLevel(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLevel: %w", err)
	}
	return oldValue.MaxLevel, nil
}

// AddMaxLevel adds u to the "max_level" field.
func (m *AppConfigMutation) AddMaxLevel(u int32) {
	if m.addmax_level != nil {
		*m.addmax_level += u
	} else {
		m.addmax_level = &u
	}
}

// AddedMaxLevel returns the value that was added to the "max_level" field in this mutation.
func (m *AppConfigMutation) AddedMaxLevel() (r int32, exists bool) {
	v := m.addmax_level
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxLevel clears the value of the "max_level" field.
func (m *AppConfigMutation) ClearMaxLevel() {
	m.max_level = nil
	m.addmax_level = nil
	m.clearedFields[appconfig.FieldMaxLevel] = struct{}{}
}

// MaxLevelCleared returns if the "max_level" field was cleared in this mutation.
func (m *AppConfigMutation) MaxLevelCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldMaxLevel]
	return ok
}

// ResetMaxLevel resets all changes to the "max_level" field.
func (m *AppConfigMutation) ResetMaxLevel() {
	m.max_level = nil
	m.addmax_level = nil
	delete(m.clearedFields, appconfig.FieldMaxLevel)
}

// SetStartAt sets the "start_at" field.
func (m *AppConfigMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *AppConfigMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *AppConfigMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *AppConfigMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *AppConfigMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[appconfig.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *AppConfigMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *AppConfigMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, appconfig.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *AppConfigMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *AppConfigMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *AppConfigMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *AppConfigMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *AppConfigMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[appconfig.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *AppConfigMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[appconfig.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *AppConfigMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, appconfig.FieldEndAt)
}

// Where appends a list predicates to the AppConfigMutation builder.
func (m *AppConfigMutation) Where(ps ...predicate.AppConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppConfig).
func (m *AppConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppConfigMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, appconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appconfig.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appconfig.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appconfig.FieldAppID)
	}
	if m.settle_mode != nil {
		fields = append(fields, appconfig.FieldSettleMode)
	}
	if m.settle_amount_type != nil {
		fields = append(fields, appconfig.FieldSettleAmountType)
	}
	if m.settle_interval != nil {
		fields = append(fields, appconfig.FieldSettleInterval)
	}
	if m.commission_type != nil {
		fields = append(fields, appconfig.FieldCommissionType)
	}
	if m.settle_benefit != nil {
		fields = append(fields, appconfig.FieldSettleBenefit)
	}
	if m.max_level != nil {
		fields = append(fields, appconfig.FieldMaxLevel)
	}
	if m.start_at != nil {
		fields = append(fields, appconfig.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, appconfig.FieldEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appconfig.FieldCreatedAt:
		return m.CreatedAt()
	case appconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case appconfig.FieldDeletedAt:
		return m.DeletedAt()
	case appconfig.FieldEntID:
		return m.EntID()
	case appconfig.FieldAppID:
		return m.AppID()
	case appconfig.FieldSettleMode:
		return m.SettleMode()
	case appconfig.FieldSettleAmountType:
		return m.SettleAmountType()
	case appconfig.FieldSettleInterval:
		return m.SettleInterval()
	case appconfig.FieldCommissionType:
		return m.CommissionType()
	case appconfig.FieldSettleBenefit:
		return m.SettleBenefit()
	case appconfig.FieldMaxLevel:
		return m.MaxLevel()
	case appconfig.FieldStartAt:
		return m.StartAt()
	case appconfig.FieldEndAt:
		return m.EndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appconfig.FieldEntID:
		return m.OldEntID(ctx)
	case appconfig.FieldAppID:
		return m.OldAppID(ctx)
	case appconfig.FieldSettleMode:
		return m.OldSettleMode(ctx)
	case appconfig.FieldSettleAmountType:
		return m.OldSettleAmountType(ctx)
	case appconfig.FieldSettleInterval:
		return m.OldSettleInterval(ctx)
	case appconfig.FieldCommissionType:
		return m.OldCommissionType(ctx)
	case appconfig.FieldSettleBenefit:
		return m.OldSettleBenefit(ctx)
	case appconfig.FieldMaxLevel:
		return m.OldMaxLevel(ctx)
	case appconfig.FieldStartAt:
		return m.OldStartAt(ctx)
	case appconfig.FieldEndAt:
		return m.OldEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appconfig.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appconfig.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appconfig.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appconfig.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appconfig.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appconfig.FieldSettleMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleMode(v)
		return nil
	case appconfig.FieldSettleAmountType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleAmountType(v)
		return nil
	case appconfig.FieldSettleInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleInterval(v)
		return nil
	case appconfig.FieldCommissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionType(v)
		return nil
	case appconfig.FieldSettleBenefit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleBenefit(v)
		return nil
	case appconfig.FieldMaxLevel:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLevel(v)
		return nil
	case appconfig.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case appconfig.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appconfig.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appconfig.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appconfig.FieldDeletedAt)
	}
	if m.addmax_level != nil {
		fields = append(fields, appconfig.FieldMaxLevel)
	}
	if m.addstart_at != nil {
		fields = append(fields, appconfig.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, appconfig.FieldEndAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appconfig.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appconfig.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appconfig.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appconfig.FieldMaxLevel:
		return m.AddedMaxLevel()
	case appconfig.FieldStartAt:
		return m.AddedStartAt()
	case appconfig.FieldEndAt:
		return m.AddedEndAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appconfig.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appconfig.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appconfig.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appconfig.FieldMaxLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLevel(v)
		return nil
	case appconfig.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case appconfig.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appconfig.FieldAppID) {
		fields = append(fields, appconfig.FieldAppID)
	}
	if m.FieldCleared(appconfig.FieldSettleMode) {
		fields = append(fields, appconfig.FieldSettleMode)
	}
	if m.FieldCleared(appconfig.FieldSettleAmountType) {
		fields = append(fields, appconfig.FieldSettleAmountType)
	}
	if m.FieldCleared(appconfig.FieldSettleInterval) {
		fields = append(fields, appconfig.FieldSettleInterval)
	}
	if m.FieldCleared(appconfig.FieldCommissionType) {
		fields = append(fields, appconfig.FieldCommissionType)
	}
	if m.FieldCleared(appconfig.FieldSettleBenefit) {
		fields = append(fields, appconfig.FieldSettleBenefit)
	}
	if m.FieldCleared(appconfig.FieldMaxLevel) {
		fields = append(fields, appconfig.FieldMaxLevel)
	}
	if m.FieldCleared(appconfig.FieldStartAt) {
		fields = append(fields, appconfig.FieldStartAt)
	}
	if m.FieldCleared(appconfig.FieldEndAt) {
		fields = append(fields, appconfig.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppConfigMutation) ClearField(name string) error {
	switch name {
	case appconfig.FieldAppID:
		m.ClearAppID()
		return nil
	case appconfig.FieldSettleMode:
		m.ClearSettleMode()
		return nil
	case appconfig.FieldSettleAmountType:
		m.ClearSettleAmountType()
		return nil
	case appconfig.FieldSettleInterval:
		m.ClearSettleInterval()
		return nil
	case appconfig.FieldCommissionType:
		m.ClearCommissionType()
		return nil
	case appconfig.FieldSettleBenefit:
		m.ClearSettleBenefit()
		return nil
	case appconfig.FieldMaxLevel:
		m.ClearMaxLevel()
		return nil
	case appconfig.FieldStartAt:
		m.ClearStartAt()
		return nil
	case appconfig.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown AppConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppConfigMutation) ResetField(name string) error {
	switch name {
	case appconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appconfig.FieldEntID:
		m.ResetEntID()
		return nil
	case appconfig.FieldAppID:
		m.ResetAppID()
		return nil
	case appconfig.FieldSettleMode:
		m.ResetSettleMode()
		return nil
	case appconfig.FieldSettleAmountType:
		m.ResetSettleAmountType()
		return nil
	case appconfig.FieldSettleInterval:
		m.ResetSettleInterval()
		return nil
	case appconfig.FieldCommissionType:
		m.ResetCommissionType()
		return nil
	case appconfig.FieldSettleBenefit:
		m.ResetSettleBenefit()
		return nil
	case appconfig.FieldMaxLevel:
		m.ResetMaxLevel()
		return nil
	case appconfig.FieldStartAt:
		m.ResetStartAt()
		return nil
	case appconfig.FieldEndAt:
		m.ResetEndAt()
		return nil
	}
	return fmt.Errorf("unknown AppConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppConfig edge %s", name)
}

// AppGoodCommissionConfigMutation represents an operation that mutates the AppGoodCommissionConfig nodes in the graph.
type AppGoodCommissionConfigMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	ent_id            *uuid.UUID
	app_id            *uuid.UUID
	good_id           *uuid.UUID
	app_good_id       *uuid.UUID
	level             *uint32
	addlevel          *int32
	threshold_amount  *decimal.Decimal
	amount_or_percent *decimal.Decimal
	start_at          *uint32
	addstart_at       *int32
	end_at            *uint32
	addend_at         *int32
	invites           *uint32
	addinvites        *int32
	settle_type       *string
	disabled          *bool
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*AppGoodCommissionConfig, error)
	predicates        []predicate.AppGoodCommissionConfig
}

var _ ent.Mutation = (*AppGoodCommissionConfigMutation)(nil)

// appgoodcommissionconfigOption allows management of the mutation configuration using functional options.
type appgoodcommissionconfigOption func(*AppGoodCommissionConfigMutation)

// newAppGoodCommissionConfigMutation creates new mutation for the AppGoodCommissionConfig entity.
func newAppGoodCommissionConfigMutation(c config, op Op, opts ...appgoodcommissionconfigOption) *AppGoodCommissionConfigMutation {
	m := &AppGoodCommissionConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGoodCommissionConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodCommissionConfigID sets the ID field of the mutation.
func withAppGoodCommissionConfigID(id uint32) appgoodcommissionconfigOption {
	return func(m *AppGoodCommissionConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGoodCommissionConfig
		)
		m.oldValue = func(ctx context.Context) (*AppGoodCommissionConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGoodCommissionConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGoodCommissionConfig sets the old AppGoodCommissionConfig of the mutation.
func withAppGoodCommissionConfig(node *AppGoodCommissionConfig) appgoodcommissionconfigOption {
	return func(m *AppGoodCommissionConfigMutation) {
		m.oldValue = func(context.Context) (*AppGoodCommissionConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodCommissionConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodCommissionConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGoodCommissionConfig entities.
func (m *AppGoodCommissionConfigMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodCommissionConfigMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodCommissionConfigMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGoodCommissionConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodCommissionConfigMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodCommissionConfigMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodCommissionConfigMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodCommissionConfigMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodCommissionConfigMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodCommissionConfigMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodCommissionConfigMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodCommissionConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodCommissionConfigMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodCommissionConfigMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodCommissionConfigMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodCommissionConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodCommissionConfigMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodCommissionConfigMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodCommissionConfigMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppGoodCommissionConfigMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppGoodCommissionConfigMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppGoodCommissionConfigMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appgoodcommissionconfig.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppGoodCommissionConfigMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldAppID)
}

// SetGoodID sets the "good_id" field.
func (m *AppGoodCommissionConfigMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppGoodCommissionConfigMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *AppGoodCommissionConfigMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[appgoodcommissionconfig.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppGoodCommissionConfigMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppGoodCommissionConfigMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppGoodCommissionConfigMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppGoodCommissionConfigMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appgoodcommissionconfig.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppGoodCommissionConfigMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldAppGoodID)
}

// SetLevel sets the "level" field.
func (m *AppGoodCommissionConfigMutation) SetLevel(u uint32) {
	m.level = &u
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *AppGoodCommissionConfigMutation) Level() (r uint32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldLevel(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds u to the "level" field.
func (m *AppGoodCommissionConfigMutation) AddLevel(u int32) {
	if m.addlevel != nil {
		*m.addlevel += u
	} else {
		m.addlevel = &u
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *AppGoodCommissionConfigMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[appgoodcommissionconfig.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) LevelCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *AppGoodCommissionConfigMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldLevel)
}

// SetThresholdAmount sets the "threshold_amount" field.
func (m *AppGoodCommissionConfigMutation) SetThresholdAmount(d decimal.Decimal) {
	m.threshold_amount = &d
}

// ThresholdAmount returns the value of the "threshold_amount" field in the mutation.
func (m *AppGoodCommissionConfigMutation) ThresholdAmount() (r decimal.Decimal, exists bool) {
	v := m.threshold_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldThresholdAmount returns the old "threshold_amount" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldThresholdAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThresholdAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThresholdAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThresholdAmount: %w", err)
	}
	return oldValue.ThresholdAmount, nil
}

// ClearThresholdAmount clears the value of the "threshold_amount" field.
func (m *AppGoodCommissionConfigMutation) ClearThresholdAmount() {
	m.threshold_amount = nil
	m.clearedFields[appgoodcommissionconfig.FieldThresholdAmount] = struct{}{}
}

// ThresholdAmountCleared returns if the "threshold_amount" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) ThresholdAmountCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldThresholdAmount]
	return ok
}

// ResetThresholdAmount resets all changes to the "threshold_amount" field.
func (m *AppGoodCommissionConfigMutation) ResetThresholdAmount() {
	m.threshold_amount = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldThresholdAmount)
}

// SetAmountOrPercent sets the "amount_or_percent" field.
func (m *AppGoodCommissionConfigMutation) SetAmountOrPercent(d decimal.Decimal) {
	m.amount_or_percent = &d
}

// AmountOrPercent returns the value of the "amount_or_percent" field in the mutation.
func (m *AppGoodCommissionConfigMutation) AmountOrPercent() (r decimal.Decimal, exists bool) {
	v := m.amount_or_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountOrPercent returns the old "amount_or_percent" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldAmountOrPercent(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountOrPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountOrPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountOrPercent: %w", err)
	}
	return oldValue.AmountOrPercent, nil
}

// ClearAmountOrPercent clears the value of the "amount_or_percent" field.
func (m *AppGoodCommissionConfigMutation) ClearAmountOrPercent() {
	m.amount_or_percent = nil
	m.clearedFields[appgoodcommissionconfig.FieldAmountOrPercent] = struct{}{}
}

// AmountOrPercentCleared returns if the "amount_or_percent" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) AmountOrPercentCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldAmountOrPercent]
	return ok
}

// ResetAmountOrPercent resets all changes to the "amount_or_percent" field.
func (m *AppGoodCommissionConfigMutation) ResetAmountOrPercent() {
	m.amount_or_percent = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldAmountOrPercent)
}

// SetStartAt sets the "start_at" field.
func (m *AppGoodCommissionConfigMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *AppGoodCommissionConfigMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *AppGoodCommissionConfigMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *AppGoodCommissionConfigMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[appgoodcommissionconfig.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *AppGoodCommissionConfigMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *AppGoodCommissionConfigMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *AppGoodCommissionConfigMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *AppGoodCommissionConfigMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *AppGoodCommissionConfigMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[appgoodcommissionconfig.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *AppGoodCommissionConfigMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldEndAt)
}

// SetInvites sets the "invites" field.
func (m *AppGoodCommissionConfigMutation) SetInvites(u uint32) {
	m.invites = &u
	m.addinvites = nil
}

// Invites returns the value of the "invites" field in the mutation.
func (m *AppGoodCommissionConfigMutation) Invites() (r uint32, exists bool) {
	v := m.invites
	if v == nil {
		return
	}
	return *v, true
}

// OldInvites returns the old "invites" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldInvites(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvites is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvites requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvites: %w", err)
	}
	return oldValue.Invites, nil
}

// AddInvites adds u to the "invites" field.
func (m *AppGoodCommissionConfigMutation) AddInvites(u int32) {
	if m.addinvites != nil {
		*m.addinvites += u
	} else {
		m.addinvites = &u
	}
}

// AddedInvites returns the value that was added to the "invites" field in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedInvites() (r int32, exists bool) {
	v := m.addinvites
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvites clears the value of the "invites" field.
func (m *AppGoodCommissionConfigMutation) ClearInvites() {
	m.invites = nil
	m.addinvites = nil
	m.clearedFields[appgoodcommissionconfig.FieldInvites] = struct{}{}
}

// InvitesCleared returns if the "invites" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) InvitesCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldInvites]
	return ok
}

// ResetInvites resets all changes to the "invites" field.
func (m *AppGoodCommissionConfigMutation) ResetInvites() {
	m.invites = nil
	m.addinvites = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldInvites)
}

// SetSettleType sets the "settle_type" field.
func (m *AppGoodCommissionConfigMutation) SetSettleType(s string) {
	m.settle_type = &s
}

// SettleType returns the value of the "settle_type" field in the mutation.
func (m *AppGoodCommissionConfigMutation) SettleType() (r string, exists bool) {
	v := m.settle_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleType returns the old "settle_type" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldSettleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleType: %w", err)
	}
	return oldValue.SettleType, nil
}

// ClearSettleType clears the value of the "settle_type" field.
func (m *AppGoodCommissionConfigMutation) ClearSettleType() {
	m.settle_type = nil
	m.clearedFields[appgoodcommissionconfig.FieldSettleType] = struct{}{}
}

// SettleTypeCleared returns if the "settle_type" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) SettleTypeCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldSettleType]
	return ok
}

// ResetSettleType resets all changes to the "settle_type" field.
func (m *AppGoodCommissionConfigMutation) ResetSettleType() {
	m.settle_type = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldSettleType)
}

// SetDisabled sets the "disabled" field.
func (m *AppGoodCommissionConfigMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *AppGoodCommissionConfigMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the AppGoodCommissionConfig entity.
// If the AppGoodCommissionConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodCommissionConfigMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *AppGoodCommissionConfigMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[appgoodcommissionconfig.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[appgoodcommissionconfig.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *AppGoodCommissionConfigMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, appgoodcommissionconfig.FieldDisabled)
}

// Where appends a list predicates to the AppGoodCommissionConfigMutation builder.
func (m *AppGoodCommissionConfigMutation) Where(ps ...predicate.AppGoodCommissionConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodCommissionConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodCommissionConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGoodCommissionConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodCommissionConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodCommissionConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGoodCommissionConfig).
func (m *AppGoodCommissionConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodCommissionConfigMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appgoodcommissionconfig.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appgoodcommissionconfig.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appgoodcommissionconfig.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, appgoodcommissionconfig.FieldAppGoodID)
	}
	if m.level != nil {
		fields = append(fields, appgoodcommissionconfig.FieldLevel)
	}
	if m.threshold_amount != nil {
		fields = append(fields, appgoodcommissionconfig.FieldThresholdAmount)
	}
	if m.amount_or_percent != nil {
		fields = append(fields, appgoodcommissionconfig.FieldAmountOrPercent)
	}
	if m.start_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldEndAt)
	}
	if m.invites != nil {
		fields = append(fields, appgoodcommissionconfig.FieldInvites)
	}
	if m.settle_type != nil {
		fields = append(fields, appgoodcommissionconfig.FieldSettleType)
	}
	if m.disabled != nil {
		fields = append(fields, appgoodcommissionconfig.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodCommissionConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgoodcommissionconfig.FieldCreatedAt:
		return m.CreatedAt()
	case appgoodcommissionconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgoodcommissionconfig.FieldDeletedAt:
		return m.DeletedAt()
	case appgoodcommissionconfig.FieldEntID:
		return m.EntID()
	case appgoodcommissionconfig.FieldAppID:
		return m.AppID()
	case appgoodcommissionconfig.FieldGoodID:
		return m.GoodID()
	case appgoodcommissionconfig.FieldAppGoodID:
		return m.AppGoodID()
	case appgoodcommissionconfig.FieldLevel:
		return m.Level()
	case appgoodcommissionconfig.FieldThresholdAmount:
		return m.ThresholdAmount()
	case appgoodcommissionconfig.FieldAmountOrPercent:
		return m.AmountOrPercent()
	case appgoodcommissionconfig.FieldStartAt:
		return m.StartAt()
	case appgoodcommissionconfig.FieldEndAt:
		return m.EndAt()
	case appgoodcommissionconfig.FieldInvites:
		return m.Invites()
	case appgoodcommissionconfig.FieldSettleType:
		return m.SettleType()
	case appgoodcommissionconfig.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodCommissionConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgoodcommissionconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgoodcommissionconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgoodcommissionconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgoodcommissionconfig.FieldEntID:
		return m.OldEntID(ctx)
	case appgoodcommissionconfig.FieldAppID:
		return m.OldAppID(ctx)
	case appgoodcommissionconfig.FieldGoodID:
		return m.OldGoodID(ctx)
	case appgoodcommissionconfig.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appgoodcommissionconfig.FieldLevel:
		return m.OldLevel(ctx)
	case appgoodcommissionconfig.FieldThresholdAmount:
		return m.OldThresholdAmount(ctx)
	case appgoodcommissionconfig.FieldAmountOrPercent:
		return m.OldAmountOrPercent(ctx)
	case appgoodcommissionconfig.FieldStartAt:
		return m.OldStartAt(ctx)
	case appgoodcommissionconfig.FieldEndAt:
		return m.OldEndAt(ctx)
	case appgoodcommissionconfig.FieldInvites:
		return m.OldInvites(ctx)
	case appgoodcommissionconfig.FieldSettleType:
		return m.OldSettleType(ctx)
	case appgoodcommissionconfig.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown AppGoodCommissionConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodCommissionConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgoodcommissionconfig.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgoodcommissionconfig.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgoodcommissionconfig.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgoodcommissionconfig.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgoodcommissionconfig.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appgoodcommissionconfig.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appgoodcommissionconfig.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appgoodcommissionconfig.FieldLevel:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case appgoodcommissionconfig.FieldThresholdAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThresholdAmount(v)
		return nil
	case appgoodcommissionconfig.FieldAmountOrPercent:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountOrPercent(v)
		return nil
	case appgoodcommissionconfig.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case appgoodcommissionconfig.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case appgoodcommissionconfig.FieldInvites:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvites(v)
		return nil
	case appgoodcommissionconfig.FieldSettleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleType(v)
		return nil
	case appgoodcommissionconfig.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodCommissionConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodCommissionConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldDeletedAt)
	}
	if m.addlevel != nil {
		fields = append(fields, appgoodcommissionconfig.FieldLevel)
	}
	if m.addstart_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, appgoodcommissionconfig.FieldEndAt)
	}
	if m.addinvites != nil {
		fields = append(fields, appgoodcommissionconfig.FieldInvites)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodCommissionConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgoodcommissionconfig.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgoodcommissionconfig.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgoodcommissionconfig.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgoodcommissionconfig.FieldLevel:
		return m.AddedLevel()
	case appgoodcommissionconfig.FieldStartAt:
		return m.AddedStartAt()
	case appgoodcommissionconfig.FieldEndAt:
		return m.AddedEndAt()
	case appgoodcommissionconfig.FieldInvites:
		return m.AddedInvites()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodCommissionConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgoodcommissionconfig.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgoodcommissionconfig.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgoodcommissionconfig.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgoodcommissionconfig.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case appgoodcommissionconfig.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case appgoodcommissionconfig.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	case appgoodcommissionconfig.FieldInvites:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvites(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodCommissionConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodCommissionConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgoodcommissionconfig.FieldAppID) {
		fields = append(fields, appgoodcommissionconfig.FieldAppID)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldGoodID) {
		fields = append(fields, appgoodcommissionconfig.FieldGoodID)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldAppGoodID) {
		fields = append(fields, appgoodcommissionconfig.FieldAppGoodID)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldLevel) {
		fields = append(fields, appgoodcommissionconfig.FieldLevel)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldThresholdAmount) {
		fields = append(fields, appgoodcommissionconfig.FieldThresholdAmount)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldAmountOrPercent) {
		fields = append(fields, appgoodcommissionconfig.FieldAmountOrPercent)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldStartAt) {
		fields = append(fields, appgoodcommissionconfig.FieldStartAt)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldEndAt) {
		fields = append(fields, appgoodcommissionconfig.FieldEndAt)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldInvites) {
		fields = append(fields, appgoodcommissionconfig.FieldInvites)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldSettleType) {
		fields = append(fields, appgoodcommissionconfig.FieldSettleType)
	}
	if m.FieldCleared(appgoodcommissionconfig.FieldDisabled) {
		fields = append(fields, appgoodcommissionconfig.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodCommissionConfigMutation) ClearField(name string) error {
	switch name {
	case appgoodcommissionconfig.FieldAppID:
		m.ClearAppID()
		return nil
	case appgoodcommissionconfig.FieldGoodID:
		m.ClearGoodID()
		return nil
	case appgoodcommissionconfig.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appgoodcommissionconfig.FieldLevel:
		m.ClearLevel()
		return nil
	case appgoodcommissionconfig.FieldThresholdAmount:
		m.ClearThresholdAmount()
		return nil
	case appgoodcommissionconfig.FieldAmountOrPercent:
		m.ClearAmountOrPercent()
		return nil
	case appgoodcommissionconfig.FieldStartAt:
		m.ClearStartAt()
		return nil
	case appgoodcommissionconfig.FieldEndAt:
		m.ClearEndAt()
		return nil
	case appgoodcommissionconfig.FieldInvites:
		m.ClearInvites()
		return nil
	case appgoodcommissionconfig.FieldSettleType:
		m.ClearSettleType()
		return nil
	case appgoodcommissionconfig.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown AppGoodCommissionConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodCommissionConfigMutation) ResetField(name string) error {
	switch name {
	case appgoodcommissionconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgoodcommissionconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgoodcommissionconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgoodcommissionconfig.FieldEntID:
		m.ResetEntID()
		return nil
	case appgoodcommissionconfig.FieldAppID:
		m.ResetAppID()
		return nil
	case appgoodcommissionconfig.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appgoodcommissionconfig.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appgoodcommissionconfig.FieldLevel:
		m.ResetLevel()
		return nil
	case appgoodcommissionconfig.FieldThresholdAmount:
		m.ResetThresholdAmount()
		return nil
	case appgoodcommissionconfig.FieldAmountOrPercent:
		m.ResetAmountOrPercent()
		return nil
	case appgoodcommissionconfig.FieldStartAt:
		m.ResetStartAt()
		return nil
	case appgoodcommissionconfig.FieldEndAt:
		m.ResetEndAt()
		return nil
	case appgoodcommissionconfig.FieldInvites:
		m.ResetInvites()
		return nil
	case appgoodcommissionconfig.FieldSettleType:
		m.ResetSettleType()
		return nil
	case appgoodcommissionconfig.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown AppGoodCommissionConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodCommissionConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodCommissionConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodCommissionConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodCommissionConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodCommissionConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGoodCommissionConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodCommissionConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGoodCommissionConfig edge %s", name)
}

// AppGoodScopeMutation represents an operation that mutates the AppGoodScope nodes in the graph.
type AppGoodScopeMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	app_good_id   *uuid.UUID
	coupon_id     *uuid.UUID
	coupon_scope  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppGoodScope, error)
	predicates    []predicate.AppGoodScope
}

var _ ent.Mutation = (*AppGoodScopeMutation)(nil)

// appgoodscopeOption allows management of the mutation configuration using functional options.
type appgoodscopeOption func(*AppGoodScopeMutation)

// newAppGoodScopeMutation creates new mutation for the AppGoodScope entity.
func newAppGoodScopeMutation(c config, op Op, opts ...appgoodscopeOption) *AppGoodScopeMutation {
	m := &AppGoodScopeMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGoodScope,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodScopeID sets the ID field of the mutation.
func withAppGoodScopeID(id uint32) appgoodscopeOption {
	return func(m *AppGoodScopeMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGoodScope
		)
		m.oldValue = func(ctx context.Context) (*AppGoodScope, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGoodScope.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGoodScope sets the old AppGoodScope of the mutation.
func withAppGoodScope(node *AppGoodScope) appgoodscopeOption {
	return func(m *AppGoodScopeMutation) {
		m.oldValue = func(context.Context) (*AppGoodScope, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodScopeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodScopeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGoodScope entities.
func (m *AppGoodScopeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodScopeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodScopeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGoodScope.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodScopeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodScopeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGoodScope entity.
// If the AppGoodScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodScopeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodScopeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodScopeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodScopeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodScopeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodScopeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGoodScope entity.
// If the AppGoodScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodScopeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodScopeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodScopeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodScopeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodScopeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodScopeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGoodScope entity.
// If the AppGoodScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodScopeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodScopeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodScopeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodScopeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodScopeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodScopeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGoodScope entity.
// If the AppGoodScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodScopeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodScopeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppGoodScopeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppGoodScopeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppGoodScope entity.
// If the AppGoodScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodScopeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppGoodScopeMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appgoodscope.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppGoodScopeMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appgoodscope.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppGoodScopeMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appgoodscope.FieldAppID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppGoodScopeMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppGoodScopeMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppGoodScope entity.
// If the AppGoodScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodScopeMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppGoodScopeMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appgoodscope.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppGoodScopeMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appgoodscope.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppGoodScopeMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appgoodscope.FieldAppGoodID)
}

// SetCouponID sets the "coupon_id" field.
func (m *AppGoodScopeMutation) SetCouponID(u uuid.UUID) {
	m.coupon_id = &u
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *AppGoodScopeMutation) CouponID() (r uuid.UUID, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the AppGoodScope entity.
// If the AppGoodScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodScopeMutation) OldCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// ClearCouponID clears the value of the "coupon_id" field.
func (m *AppGoodScopeMutation) ClearCouponID() {
	m.coupon_id = nil
	m.clearedFields[appgoodscope.FieldCouponID] = struct{}{}
}

// CouponIDCleared returns if the "coupon_id" field was cleared in this mutation.
func (m *AppGoodScopeMutation) CouponIDCleared() bool {
	_, ok := m.clearedFields[appgoodscope.FieldCouponID]
	return ok
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *AppGoodScopeMutation) ResetCouponID() {
	m.coupon_id = nil
	delete(m.clearedFields, appgoodscope.FieldCouponID)
}

// SetCouponScope sets the "coupon_scope" field.
func (m *AppGoodScopeMutation) SetCouponScope(s string) {
	m.coupon_scope = &s
}

// CouponScope returns the value of the "coupon_scope" field in the mutation.
func (m *AppGoodScopeMutation) CouponScope() (r string, exists bool) {
	v := m.coupon_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponScope returns the old "coupon_scope" field's value of the AppGoodScope entity.
// If the AppGoodScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodScopeMutation) OldCouponScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponScope: %w", err)
	}
	return oldValue.CouponScope, nil
}

// ClearCouponScope clears the value of the "coupon_scope" field.
func (m *AppGoodScopeMutation) ClearCouponScope() {
	m.coupon_scope = nil
	m.clearedFields[appgoodscope.FieldCouponScope] = struct{}{}
}

// CouponScopeCleared returns if the "coupon_scope" field was cleared in this mutation.
func (m *AppGoodScopeMutation) CouponScopeCleared() bool {
	_, ok := m.clearedFields[appgoodscope.FieldCouponScope]
	return ok
}

// ResetCouponScope resets all changes to the "coupon_scope" field.
func (m *AppGoodScopeMutation) ResetCouponScope() {
	m.coupon_scope = nil
	delete(m.clearedFields, appgoodscope.FieldCouponScope)
}

// Where appends a list predicates to the AppGoodScopeMutation builder.
func (m *AppGoodScopeMutation) Where(ps ...predicate.AppGoodScope) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodScopeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodScopeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGoodScope, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodScopeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodScopeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGoodScope).
func (m *AppGoodScopeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodScopeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, appgoodscope.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgoodscope.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgoodscope.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appgoodscope.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appgoodscope.FieldAppID)
	}
	if m.app_good_id != nil {
		fields = append(fields, appgoodscope.FieldAppGoodID)
	}
	if m.coupon_id != nil {
		fields = append(fields, appgoodscope.FieldCouponID)
	}
	if m.coupon_scope != nil {
		fields = append(fields, appgoodscope.FieldCouponScope)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodScopeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgoodscope.FieldCreatedAt:
		return m.CreatedAt()
	case appgoodscope.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgoodscope.FieldDeletedAt:
		return m.DeletedAt()
	case appgoodscope.FieldEntID:
		return m.EntID()
	case appgoodscope.FieldAppID:
		return m.AppID()
	case appgoodscope.FieldAppGoodID:
		return m.AppGoodID()
	case appgoodscope.FieldCouponID:
		return m.CouponID()
	case appgoodscope.FieldCouponScope:
		return m.CouponScope()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodScopeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgoodscope.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgoodscope.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgoodscope.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgoodscope.FieldEntID:
		return m.OldEntID(ctx)
	case appgoodscope.FieldAppID:
		return m.OldAppID(ctx)
	case appgoodscope.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appgoodscope.FieldCouponID:
		return m.OldCouponID(ctx)
	case appgoodscope.FieldCouponScope:
		return m.OldCouponScope(ctx)
	}
	return nil, fmt.Errorf("unknown AppGoodScope field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodScopeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgoodscope.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgoodscope.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgoodscope.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgoodscope.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgoodscope.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appgoodscope.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appgoodscope.FieldCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case appgoodscope.FieldCouponScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponScope(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodScope field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodScopeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgoodscope.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgoodscope.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgoodscope.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodScopeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgoodscope.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgoodscope.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgoodscope.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodScopeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgoodscope.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgoodscope.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgoodscope.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodScope numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodScopeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgoodscope.FieldAppID) {
		fields = append(fields, appgoodscope.FieldAppID)
	}
	if m.FieldCleared(appgoodscope.FieldAppGoodID) {
		fields = append(fields, appgoodscope.FieldAppGoodID)
	}
	if m.FieldCleared(appgoodscope.FieldCouponID) {
		fields = append(fields, appgoodscope.FieldCouponID)
	}
	if m.FieldCleared(appgoodscope.FieldCouponScope) {
		fields = append(fields, appgoodscope.FieldCouponScope)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodScopeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodScopeMutation) ClearField(name string) error {
	switch name {
	case appgoodscope.FieldAppID:
		m.ClearAppID()
		return nil
	case appgoodscope.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appgoodscope.FieldCouponID:
		m.ClearCouponID()
		return nil
	case appgoodscope.FieldCouponScope:
		m.ClearCouponScope()
		return nil
	}
	return fmt.Errorf("unknown AppGoodScope nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodScopeMutation) ResetField(name string) error {
	switch name {
	case appgoodscope.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgoodscope.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgoodscope.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgoodscope.FieldEntID:
		m.ResetEntID()
		return nil
	case appgoodscope.FieldAppID:
		m.ResetAppID()
		return nil
	case appgoodscope.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appgoodscope.FieldCouponID:
		m.ResetCouponID()
		return nil
	case appgoodscope.FieldCouponScope:
		m.ResetCouponScope()
		return nil
	}
	return fmt.Errorf("unknown AppGoodScope field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodScopeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodScopeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodScopeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodScopeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodScopeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodScopeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodScopeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGoodScope unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodScopeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGoodScope edge %s", name)
}

// CashControlMutation represents an operation that mutates the CashControl nodes in the graph.
type CashControlMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	coupon_id     *uuid.UUID
	control_type  *string
	value         *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CashControl, error)
	predicates    []predicate.CashControl
}

var _ ent.Mutation = (*CashControlMutation)(nil)

// cashcontrolOption allows management of the mutation configuration using functional options.
type cashcontrolOption func(*CashControlMutation)

// newCashControlMutation creates new mutation for the CashControl entity.
func newCashControlMutation(c config, op Op, opts ...cashcontrolOption) *CashControlMutation {
	m := &CashControlMutation{
		config:        c,
		op:            op,
		typ:           TypeCashControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCashControlID sets the ID field of the mutation.
func withCashControlID(id uint32) cashcontrolOption {
	return func(m *CashControlMutation) {
		var (
			err   error
			once  sync.Once
			value *CashControl
		)
		m.oldValue = func(ctx context.Context) (*CashControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CashControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCashControl sets the old CashControl of the mutation.
func withCashControl(node *CashControl) cashcontrolOption {
	return func(m *CashControlMutation) {
		m.oldValue = func(context.Context) (*CashControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CashControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CashControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CashControl entities.
func (m *CashControlMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CashControlMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CashControlMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CashControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CashControlMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CashControlMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CashControl entity.
// If the CashControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashControlMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CashControlMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CashControlMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CashControlMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CashControlMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CashControlMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CashControl entity.
// If the CashControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashControlMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CashControlMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CashControlMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CashControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CashControlMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CashControlMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CashControl entity.
// If the CashControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashControlMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CashControlMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CashControlMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CashControlMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CashControlMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CashControlMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the CashControl entity.
// If the CashControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashControlMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CashControlMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CashControlMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CashControlMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CashControl entity.
// If the CashControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashControlMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CashControlMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[cashcontrol.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CashControlMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[cashcontrol.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CashControlMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, cashcontrol.FieldAppID)
}

// SetCouponID sets the "coupon_id" field.
func (m *CashControlMutation) SetCouponID(u uuid.UUID) {
	m.coupon_id = &u
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *CashControlMutation) CouponID() (r uuid.UUID, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the CashControl entity.
// If the CashControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashControlMutation) OldCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// ClearCouponID clears the value of the "coupon_id" field.
func (m *CashControlMutation) ClearCouponID() {
	m.coupon_id = nil
	m.clearedFields[cashcontrol.FieldCouponID] = struct{}{}
}

// CouponIDCleared returns if the "coupon_id" field was cleared in this mutation.
func (m *CashControlMutation) CouponIDCleared() bool {
	_, ok := m.clearedFields[cashcontrol.FieldCouponID]
	return ok
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *CashControlMutation) ResetCouponID() {
	m.coupon_id = nil
	delete(m.clearedFields, cashcontrol.FieldCouponID)
}

// SetControlType sets the "control_type" field.
func (m *CashControlMutation) SetControlType(s string) {
	m.control_type = &s
}

// ControlType returns the value of the "control_type" field in the mutation.
func (m *CashControlMutation) ControlType() (r string, exists bool) {
	v := m.control_type
	if v == nil {
		return
	}
	return *v, true
}

// OldControlType returns the old "control_type" field's value of the CashControl entity.
// If the CashControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashControlMutation) OldControlType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlType: %w", err)
	}
	return oldValue.ControlType, nil
}

// ClearControlType clears the value of the "control_type" field.
func (m *CashControlMutation) ClearControlType() {
	m.control_type = nil
	m.clearedFields[cashcontrol.FieldControlType] = struct{}{}
}

// ControlTypeCleared returns if the "control_type" field was cleared in this mutation.
func (m *CashControlMutation) ControlTypeCleared() bool {
	_, ok := m.clearedFields[cashcontrol.FieldControlType]
	return ok
}

// ResetControlType resets all changes to the "control_type" field.
func (m *CashControlMutation) ResetControlType() {
	m.control_type = nil
	delete(m.clearedFields, cashcontrol.FieldControlType)
}

// SetValue sets the "value" field.
func (m *CashControlMutation) SetValue(d decimal.Decimal) {
	m.value = &d
}

// Value returns the value of the "value" field in the mutation.
func (m *CashControlMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the CashControl entity.
// If the CashControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CashControlMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *CashControlMutation) ClearValue() {
	m.value = nil
	m.clearedFields[cashcontrol.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *CashControlMutation) ValueCleared() bool {
	_, ok := m.clearedFields[cashcontrol.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *CashControlMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, cashcontrol.FieldValue)
}

// Where appends a list predicates to the CashControlMutation builder.
func (m *CashControlMutation) Where(ps ...predicate.CashControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CashControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CashControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CashControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CashControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CashControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CashControl).
func (m *CashControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CashControlMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, cashcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cashcontrol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cashcontrol.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, cashcontrol.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, cashcontrol.FieldAppID)
	}
	if m.coupon_id != nil {
		fields = append(fields, cashcontrol.FieldCouponID)
	}
	if m.control_type != nil {
		fields = append(fields, cashcontrol.FieldControlType)
	}
	if m.value != nil {
		fields = append(fields, cashcontrol.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CashControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cashcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case cashcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case cashcontrol.FieldDeletedAt:
		return m.DeletedAt()
	case cashcontrol.FieldEntID:
		return m.EntID()
	case cashcontrol.FieldAppID:
		return m.AppID()
	case cashcontrol.FieldCouponID:
		return m.CouponID()
	case cashcontrol.FieldControlType:
		return m.ControlType()
	case cashcontrol.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CashControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cashcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cashcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cashcontrol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cashcontrol.FieldEntID:
		return m.OldEntID(ctx)
	case cashcontrol.FieldAppID:
		return m.OldAppID(ctx)
	case cashcontrol.FieldCouponID:
		return m.OldCouponID(ctx)
	case cashcontrol.FieldControlType:
		return m.OldControlType(ctx)
	case cashcontrol.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown CashControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CashControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cashcontrol.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cashcontrol.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cashcontrol.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cashcontrol.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case cashcontrol.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case cashcontrol.FieldCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case cashcontrol.FieldControlType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlType(v)
		return nil
	case cashcontrol.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown CashControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CashControlMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, cashcontrol.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, cashcontrol.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, cashcontrol.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CashControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cashcontrol.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cashcontrol.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cashcontrol.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CashControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cashcontrol.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cashcontrol.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cashcontrol.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CashControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CashControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cashcontrol.FieldAppID) {
		fields = append(fields, cashcontrol.FieldAppID)
	}
	if m.FieldCleared(cashcontrol.FieldCouponID) {
		fields = append(fields, cashcontrol.FieldCouponID)
	}
	if m.FieldCleared(cashcontrol.FieldControlType) {
		fields = append(fields, cashcontrol.FieldControlType)
	}
	if m.FieldCleared(cashcontrol.FieldValue) {
		fields = append(fields, cashcontrol.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CashControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CashControlMutation) ClearField(name string) error {
	switch name {
	case cashcontrol.FieldAppID:
		m.ClearAppID()
		return nil
	case cashcontrol.FieldCouponID:
		m.ClearCouponID()
		return nil
	case cashcontrol.FieldControlType:
		m.ClearControlType()
		return nil
	case cashcontrol.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown CashControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CashControlMutation) ResetField(name string) error {
	switch name {
	case cashcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cashcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cashcontrol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cashcontrol.FieldEntID:
		m.ResetEntID()
		return nil
	case cashcontrol.FieldAppID:
		m.ResetAppID()
		return nil
	case cashcontrol.FieldCouponID:
		m.ResetCouponID()
		return nil
	case cashcontrol.FieldControlType:
		m.ResetControlType()
		return nil
	case cashcontrol.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown CashControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CashControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CashControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CashControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CashControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CashControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CashControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CashControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CashControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CashControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CashControl edge %s", name)
}

// CoinAllocatedMutation represents an operation that mutates the CoinAllocated nodes in the graph.
type CoinAllocatedMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	ent_id         *uuid.UUID
	app_id         *uuid.UUID
	coin_config_id *uuid.UUID
	coin_type_id   *uuid.UUID
	user_id        *uuid.UUID
	value          *decimal.Decimal
	extra          *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CoinAllocated, error)
	predicates     []predicate.CoinAllocated
}

var _ ent.Mutation = (*CoinAllocatedMutation)(nil)

// coinallocatedOption allows management of the mutation configuration using functional options.
type coinallocatedOption func(*CoinAllocatedMutation)

// newCoinAllocatedMutation creates new mutation for the CoinAllocated entity.
func newCoinAllocatedMutation(c config, op Op, opts ...coinallocatedOption) *CoinAllocatedMutation {
	m := &CoinAllocatedMutation{
		config:        c,
		op:            op,
		typ:           TypeCoinAllocated,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoinAllocatedID sets the ID field of the mutation.
func withCoinAllocatedID(id uint32) coinallocatedOption {
	return func(m *CoinAllocatedMutation) {
		var (
			err   error
			once  sync.Once
			value *CoinAllocated
		)
		m.oldValue = func(ctx context.Context) (*CoinAllocated, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CoinAllocated.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoinAllocated sets the old CoinAllocated of the mutation.
func withCoinAllocated(node *CoinAllocated) coinallocatedOption {
	return func(m *CoinAllocatedMutation) {
		m.oldValue = func(context.Context) (*CoinAllocated, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoinAllocatedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoinAllocatedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CoinAllocated entities.
func (m *CoinAllocatedMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CoinAllocatedMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CoinAllocatedMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CoinAllocated.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CoinAllocatedMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CoinAllocatedMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CoinAllocatedMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CoinAllocatedMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CoinAllocatedMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CoinAllocatedMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CoinAllocatedMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CoinAllocatedMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CoinAllocatedMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CoinAllocatedMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CoinAllocatedMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CoinAllocatedMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CoinAllocatedMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CoinAllocatedMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CoinAllocatedMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CoinAllocatedMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CoinAllocatedMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CoinAllocatedMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CoinAllocatedMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CoinAllocatedMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CoinAllocatedMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[coinallocated.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CoinAllocatedMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[coinallocated.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CoinAllocatedMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, coinallocated.FieldAppID)
}

// SetCoinConfigID sets the "coin_config_id" field.
func (m *CoinAllocatedMutation) SetCoinConfigID(u uuid.UUID) {
	m.coin_config_id = &u
}

// CoinConfigID returns the value of the "coin_config_id" field in the mutation.
func (m *CoinAllocatedMutation) CoinConfigID() (r uuid.UUID, exists bool) {
	v := m.coin_config_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinConfigID returns the old "coin_config_id" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldCoinConfigID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinConfigID: %w", err)
	}
	return oldValue.CoinConfigID, nil
}

// ClearCoinConfigID clears the value of the "coin_config_id" field.
func (m *CoinAllocatedMutation) ClearCoinConfigID() {
	m.coin_config_id = nil
	m.clearedFields[coinallocated.FieldCoinConfigID] = struct{}{}
}

// CoinConfigIDCleared returns if the "coin_config_id" field was cleared in this mutation.
func (m *CoinAllocatedMutation) CoinConfigIDCleared() bool {
	_, ok := m.clearedFields[coinallocated.FieldCoinConfigID]
	return ok
}

// ResetCoinConfigID resets all changes to the "coin_config_id" field.
func (m *CoinAllocatedMutation) ResetCoinConfigID() {
	m.coin_config_id = nil
	delete(m.clearedFields, coinallocated.FieldCoinConfigID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *CoinAllocatedMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *CoinAllocatedMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *CoinAllocatedMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[coinallocated.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *CoinAllocatedMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[coinallocated.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *CoinAllocatedMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, coinallocated.FieldCoinTypeID)
}

// SetUserID sets the "user_id" field.
func (m *CoinAllocatedMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CoinAllocatedMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CoinAllocatedMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[coinallocated.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CoinAllocatedMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[coinallocated.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CoinAllocatedMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, coinallocated.FieldUserID)
}

// SetValue sets the "value" field.
func (m *CoinAllocatedMutation) SetValue(d decimal.Decimal) {
	m.value = &d
}

// Value returns the value of the "value" field in the mutation.
func (m *CoinAllocatedMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *CoinAllocatedMutation) ClearValue() {
	m.value = nil
	m.clearedFields[coinallocated.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *CoinAllocatedMutation) ValueCleared() bool {
	_, ok := m.clearedFields[coinallocated.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *CoinAllocatedMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, coinallocated.FieldValue)
}

// SetExtra sets the "extra" field.
func (m *CoinAllocatedMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *CoinAllocatedMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the CoinAllocated entity.
// If the CoinAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinAllocatedMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *CoinAllocatedMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[coinallocated.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *CoinAllocatedMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[coinallocated.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *CoinAllocatedMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, coinallocated.FieldExtra)
}

// Where appends a list predicates to the CoinAllocatedMutation builder.
func (m *CoinAllocatedMutation) Where(ps ...predicate.CoinAllocated) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CoinAllocatedMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CoinAllocatedMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CoinAllocated, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CoinAllocatedMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CoinAllocatedMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CoinAllocated).
func (m *CoinAllocatedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CoinAllocatedMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, coinallocated.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coinallocated.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coinallocated.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, coinallocated.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, coinallocated.FieldAppID)
	}
	if m.coin_config_id != nil {
		fields = append(fields, coinallocated.FieldCoinConfigID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, coinallocated.FieldCoinTypeID)
	}
	if m.user_id != nil {
		fields = append(fields, coinallocated.FieldUserID)
	}
	if m.value != nil {
		fields = append(fields, coinallocated.FieldValue)
	}
	if m.extra != nil {
		fields = append(fields, coinallocated.FieldExtra)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CoinAllocatedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coinallocated.FieldCreatedAt:
		return m.CreatedAt()
	case coinallocated.FieldUpdatedAt:
		return m.UpdatedAt()
	case coinallocated.FieldDeletedAt:
		return m.DeletedAt()
	case coinallocated.FieldEntID:
		return m.EntID()
	case coinallocated.FieldAppID:
		return m.AppID()
	case coinallocated.FieldCoinConfigID:
		return m.CoinConfigID()
	case coinallocated.FieldCoinTypeID:
		return m.CoinTypeID()
	case coinallocated.FieldUserID:
		return m.UserID()
	case coinallocated.FieldValue:
		return m.Value()
	case coinallocated.FieldExtra:
		return m.Extra()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CoinAllocatedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coinallocated.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coinallocated.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coinallocated.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case coinallocated.FieldEntID:
		return m.OldEntID(ctx)
	case coinallocated.FieldAppID:
		return m.OldAppID(ctx)
	case coinallocated.FieldCoinConfigID:
		return m.OldCoinConfigID(ctx)
	case coinallocated.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case coinallocated.FieldUserID:
		return m.OldUserID(ctx)
	case coinallocated.FieldValue:
		return m.OldValue(ctx)
	case coinallocated.FieldExtra:
		return m.OldExtra(ctx)
	}
	return nil, fmt.Errorf("unknown CoinAllocated field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinAllocatedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coinallocated.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coinallocated.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coinallocated.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case coinallocated.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case coinallocated.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case coinallocated.FieldCoinConfigID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinConfigID(v)
		return nil
	case coinallocated.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case coinallocated.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case coinallocated.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case coinallocated.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	}
	return fmt.Errorf("unknown CoinAllocated field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CoinAllocatedMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, coinallocated.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, coinallocated.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, coinallocated.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CoinAllocatedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coinallocated.FieldCreatedAt:
		return m.AddedCreatedAt()
	case coinallocated.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case coinallocated.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinAllocatedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coinallocated.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case coinallocated.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case coinallocated.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CoinAllocated numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CoinAllocatedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coinallocated.FieldAppID) {
		fields = append(fields, coinallocated.FieldAppID)
	}
	if m.FieldCleared(coinallocated.FieldCoinConfigID) {
		fields = append(fields, coinallocated.FieldCoinConfigID)
	}
	if m.FieldCleared(coinallocated.FieldCoinTypeID) {
		fields = append(fields, coinallocated.FieldCoinTypeID)
	}
	if m.FieldCleared(coinallocated.FieldUserID) {
		fields = append(fields, coinallocated.FieldUserID)
	}
	if m.FieldCleared(coinallocated.FieldValue) {
		fields = append(fields, coinallocated.FieldValue)
	}
	if m.FieldCleared(coinallocated.FieldExtra) {
		fields = append(fields, coinallocated.FieldExtra)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CoinAllocatedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoinAllocatedMutation) ClearField(name string) error {
	switch name {
	case coinallocated.FieldAppID:
		m.ClearAppID()
		return nil
	case coinallocated.FieldCoinConfigID:
		m.ClearCoinConfigID()
		return nil
	case coinallocated.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case coinallocated.FieldUserID:
		m.ClearUserID()
		return nil
	case coinallocated.FieldValue:
		m.ClearValue()
		return nil
	case coinallocated.FieldExtra:
		m.ClearExtra()
		return nil
	}
	return fmt.Errorf("unknown CoinAllocated nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CoinAllocatedMutation) ResetField(name string) error {
	switch name {
	case coinallocated.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coinallocated.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coinallocated.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case coinallocated.FieldEntID:
		m.ResetEntID()
		return nil
	case coinallocated.FieldAppID:
		m.ResetAppID()
		return nil
	case coinallocated.FieldCoinConfigID:
		m.ResetCoinConfigID()
		return nil
	case coinallocated.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case coinallocated.FieldUserID:
		m.ResetUserID()
		return nil
	case coinallocated.FieldValue:
		m.ResetValue()
		return nil
	case coinallocated.FieldExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown CoinAllocated field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CoinAllocatedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CoinAllocatedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CoinAllocatedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CoinAllocatedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CoinAllocatedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CoinAllocatedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CoinAllocatedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CoinAllocated unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CoinAllocatedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CoinAllocated edge %s", name)
}

// CoinConfigMutation represents an operation that mutates the CoinConfig nodes in the graph.
type CoinConfigMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	coin_type_id  *uuid.UUID
	max_value     *decimal.Decimal
	allocated     *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CoinConfig, error)
	predicates    []predicate.CoinConfig
}

var _ ent.Mutation = (*CoinConfigMutation)(nil)

// coinconfigOption allows management of the mutation configuration using functional options.
type coinconfigOption func(*CoinConfigMutation)

// newCoinConfigMutation creates new mutation for the CoinConfig entity.
func newCoinConfigMutation(c config, op Op, opts ...coinconfigOption) *CoinConfigMutation {
	m := &CoinConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeCoinConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoinConfigID sets the ID field of the mutation.
func withCoinConfigID(id uint32) coinconfigOption {
	return func(m *CoinConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *CoinConfig
		)
		m.oldValue = func(ctx context.Context) (*CoinConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CoinConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoinConfig sets the old CoinConfig of the mutation.
func withCoinConfig(node *CoinConfig) coinconfigOption {
	return func(m *CoinConfigMutation) {
		m.oldValue = func(context.Context) (*CoinConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoinConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoinConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CoinConfig entities.
func (m *CoinConfigMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CoinConfigMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CoinConfigMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CoinConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CoinConfigMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CoinConfigMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CoinConfig entity.
// If the CoinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinConfigMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CoinConfigMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CoinConfigMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CoinConfigMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CoinConfigMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CoinConfigMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CoinConfig entity.
// If the CoinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinConfigMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CoinConfigMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CoinConfigMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CoinConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CoinConfigMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CoinConfigMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CoinConfig entity.
// If the CoinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinConfigMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CoinConfigMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CoinConfigMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CoinConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CoinConfigMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CoinConfigMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the CoinConfig entity.
// If the CoinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinConfigMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CoinConfigMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CoinConfigMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CoinConfigMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CoinConfig entity.
// If the CoinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinConfigMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CoinConfigMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[coinconfig.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CoinConfigMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[coinconfig.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CoinConfigMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, coinconfig.FieldAppID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *CoinConfigMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *CoinConfigMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the CoinConfig entity.
// If the CoinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinConfigMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *CoinConfigMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[coinconfig.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *CoinConfigMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[coinconfig.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *CoinConfigMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, coinconfig.FieldCoinTypeID)
}

// SetMaxValue sets the "max_value" field.
func (m *CoinConfigMutation) SetMaxValue(d decimal.Decimal) {
	m.max_value = &d
}

// MaxValue returns the value of the "max_value" field in the mutation.
func (m *CoinConfigMutation) MaxValue() (r decimal.Decimal, exists bool) {
	v := m.max_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxValue returns the old "max_value" field's value of the CoinConfig entity.
// If the CoinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinConfigMutation) OldMaxValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxValue: %w", err)
	}
	return oldValue.MaxValue, nil
}

// ClearMaxValue clears the value of the "max_value" field.
func (m *CoinConfigMutation) ClearMaxValue() {
	m.max_value = nil
	m.clearedFields[coinconfig.FieldMaxValue] = struct{}{}
}

// MaxValueCleared returns if the "max_value" field was cleared in this mutation.
func (m *CoinConfigMutation) MaxValueCleared() bool {
	_, ok := m.clearedFields[coinconfig.FieldMaxValue]
	return ok
}

// ResetMaxValue resets all changes to the "max_value" field.
func (m *CoinConfigMutation) ResetMaxValue() {
	m.max_value = nil
	delete(m.clearedFields, coinconfig.FieldMaxValue)
}

// SetAllocated sets the "allocated" field.
func (m *CoinConfigMutation) SetAllocated(d decimal.Decimal) {
	m.allocated = &d
}

// Allocated returns the value of the "allocated" field in the mutation.
func (m *CoinConfigMutation) Allocated() (r decimal.Decimal, exists bool) {
	v := m.allocated
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocated returns the old "allocated" field's value of the CoinConfig entity.
// If the CoinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinConfigMutation) OldAllocated(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocated: %w", err)
	}
	return oldValue.Allocated, nil
}

// ClearAllocated clears the value of the "allocated" field.
func (m *CoinConfigMutation) ClearAllocated() {
	m.allocated = nil
	m.clearedFields[coinconfig.FieldAllocated] = struct{}{}
}

// AllocatedCleared returns if the "allocated" field was cleared in this mutation.
func (m *CoinConfigMutation) AllocatedCleared() bool {
	_, ok := m.clearedFields[coinconfig.FieldAllocated]
	return ok
}

// ResetAllocated resets all changes to the "allocated" field.
func (m *CoinConfigMutation) ResetAllocated() {
	m.allocated = nil
	delete(m.clearedFields, coinconfig.FieldAllocated)
}

// Where appends a list predicates to the CoinConfigMutation builder.
func (m *CoinConfigMutation) Where(ps ...predicate.CoinConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CoinConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CoinConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CoinConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CoinConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CoinConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CoinConfig).
func (m *CoinConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CoinConfigMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, coinconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coinconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coinconfig.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, coinconfig.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, coinconfig.FieldAppID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, coinconfig.FieldCoinTypeID)
	}
	if m.max_value != nil {
		fields = append(fields, coinconfig.FieldMaxValue)
	}
	if m.allocated != nil {
		fields = append(fields, coinconfig.FieldAllocated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CoinConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coinconfig.FieldCreatedAt:
		return m.CreatedAt()
	case coinconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case coinconfig.FieldDeletedAt:
		return m.DeletedAt()
	case coinconfig.FieldEntID:
		return m.EntID()
	case coinconfig.FieldAppID:
		return m.AppID()
	case coinconfig.FieldCoinTypeID:
		return m.CoinTypeID()
	case coinconfig.FieldMaxValue:
		return m.MaxValue()
	case coinconfig.FieldAllocated:
		return m.Allocated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CoinConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coinconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coinconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coinconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case coinconfig.FieldEntID:
		return m.OldEntID(ctx)
	case coinconfig.FieldAppID:
		return m.OldAppID(ctx)
	case coinconfig.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case coinconfig.FieldMaxValue:
		return m.OldMaxValue(ctx)
	case coinconfig.FieldAllocated:
		return m.OldAllocated(ctx)
	}
	return nil, fmt.Errorf("unknown CoinConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coinconfig.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coinconfig.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coinconfig.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case coinconfig.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case coinconfig.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case coinconfig.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case coinconfig.FieldMaxValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxValue(v)
		return nil
	case coinconfig.FieldAllocated:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocated(v)
		return nil
	}
	return fmt.Errorf("unknown CoinConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CoinConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, coinconfig.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, coinconfig.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, coinconfig.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CoinConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coinconfig.FieldCreatedAt:
		return m.AddedCreatedAt()
	case coinconfig.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case coinconfig.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coinconfig.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case coinconfig.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case coinconfig.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CoinConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CoinConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coinconfig.FieldAppID) {
		fields = append(fields, coinconfig.FieldAppID)
	}
	if m.FieldCleared(coinconfig.FieldCoinTypeID) {
		fields = append(fields, coinconfig.FieldCoinTypeID)
	}
	if m.FieldCleared(coinconfig.FieldMaxValue) {
		fields = append(fields, coinconfig.FieldMaxValue)
	}
	if m.FieldCleared(coinconfig.FieldAllocated) {
		fields = append(fields, coinconfig.FieldAllocated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CoinConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoinConfigMutation) ClearField(name string) error {
	switch name {
	case coinconfig.FieldAppID:
		m.ClearAppID()
		return nil
	case coinconfig.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case coinconfig.FieldMaxValue:
		m.ClearMaxValue()
		return nil
	case coinconfig.FieldAllocated:
		m.ClearAllocated()
		return nil
	}
	return fmt.Errorf("unknown CoinConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CoinConfigMutation) ResetField(name string) error {
	switch name {
	case coinconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coinconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coinconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case coinconfig.FieldEntID:
		m.ResetEntID()
		return nil
	case coinconfig.FieldAppID:
		m.ResetAppID()
		return nil
	case coinconfig.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case coinconfig.FieldMaxValue:
		m.ResetMaxValue()
		return nil
	case coinconfig.FieldAllocated:
		m.ResetAllocated()
		return nil
	}
	return fmt.Errorf("unknown CoinConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CoinConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CoinConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CoinConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CoinConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CoinConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CoinConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CoinConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CoinConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CoinConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CoinConfig edge %s", name)
}

// CommissionMutation represents an operation that mutates the Commission nodes in the graph.
type CommissionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	ent_id             *uuid.UUID
	app_id             *uuid.UUID
	user_id            *uuid.UUID
	good_id            *uuid.UUID
	app_good_id        *uuid.UUID
	amount_or_percent  *decimal.Decimal
	start_at           *uint32
	addstart_at        *int32
	end_at             *uint32
	addend_at          *int32
	settle_type        *string
	settle_mode        *string
	settle_interval    *string
	settle_amount_type *string
	threshold          *decimal.Decimal
	order_limit        *uint32
	addorder_limit     *int32
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Commission, error)
	predicates         []predicate.Commission
}

var _ ent.Mutation = (*CommissionMutation)(nil)

// commissionOption allows management of the mutation configuration using functional options.
type commissionOption func(*CommissionMutation)

// newCommissionMutation creates new mutation for the Commission entity.
func newCommissionMutation(c config, op Op, opts ...commissionOption) *CommissionMutation {
	m := &CommissionMutation{
		config:        c,
		op:            op,
		typ:           TypeCommission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommissionID sets the ID field of the mutation.
func withCommissionID(id uint32) commissionOption {
	return func(m *CommissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Commission
		)
		m.oldValue = func(ctx context.Context) (*Commission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Commission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommission sets the old Commission of the mutation.
func withCommission(node *Commission) commissionOption {
	return func(m *CommissionMutation) {
		m.oldValue = func(context.Context) (*Commission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Commission entities.
func (m *CommissionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommissionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommissionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Commission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommissionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommissionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CommissionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CommissionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommissionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommissionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommissionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CommissionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CommissionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommissionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommissionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CommissionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CommissionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CommissionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CommissionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CommissionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CommissionMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CommissionMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CommissionMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[commission.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CommissionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CommissionMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, commission.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *CommissionMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommissionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CommissionMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[commission.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CommissionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommissionMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, commission.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *CommissionMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *CommissionMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *CommissionMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[commission.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *CommissionMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *CommissionMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, commission.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *CommissionMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *CommissionMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *CommissionMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[commission.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *CommissionMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *CommissionMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, commission.FieldAppGoodID)
}

// SetAmountOrPercent sets the "amount_or_percent" field.
func (m *CommissionMutation) SetAmountOrPercent(d decimal.Decimal) {
	m.amount_or_percent = &d
}

// AmountOrPercent returns the value of the "amount_or_percent" field in the mutation.
func (m *CommissionMutation) AmountOrPercent() (r decimal.Decimal, exists bool) {
	v := m.amount_or_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountOrPercent returns the old "amount_or_percent" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldAmountOrPercent(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountOrPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountOrPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountOrPercent: %w", err)
	}
	return oldValue.AmountOrPercent, nil
}

// ClearAmountOrPercent clears the value of the "amount_or_percent" field.
func (m *CommissionMutation) ClearAmountOrPercent() {
	m.amount_or_percent = nil
	m.clearedFields[commission.FieldAmountOrPercent] = struct{}{}
}

// AmountOrPercentCleared returns if the "amount_or_percent" field was cleared in this mutation.
func (m *CommissionMutation) AmountOrPercentCleared() bool {
	_, ok := m.clearedFields[commission.FieldAmountOrPercent]
	return ok
}

// ResetAmountOrPercent resets all changes to the "amount_or_percent" field.
func (m *CommissionMutation) ResetAmountOrPercent() {
	m.amount_or_percent = nil
	delete(m.clearedFields, commission.FieldAmountOrPercent)
}

// SetStartAt sets the "start_at" field.
func (m *CommissionMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CommissionMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CommissionMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CommissionMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CommissionMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[commission.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CommissionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[commission.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CommissionMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, commission.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *CommissionMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *CommissionMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *CommissionMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *CommissionMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *CommissionMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[commission.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *CommissionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[commission.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *CommissionMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, commission.FieldEndAt)
}

// SetSettleType sets the "settle_type" field.
func (m *CommissionMutation) SetSettleType(s string) {
	m.settle_type = &s
}

// SettleType returns the value of the "settle_type" field in the mutation.
func (m *CommissionMutation) SettleType() (r string, exists bool) {
	v := m.settle_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleType returns the old "settle_type" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSettleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleType: %w", err)
	}
	return oldValue.SettleType, nil
}

// ClearSettleType clears the value of the "settle_type" field.
func (m *CommissionMutation) ClearSettleType() {
	m.settle_type = nil
	m.clearedFields[commission.FieldSettleType] = struct{}{}
}

// SettleTypeCleared returns if the "settle_type" field was cleared in this mutation.
func (m *CommissionMutation) SettleTypeCleared() bool {
	_, ok := m.clearedFields[commission.FieldSettleType]
	return ok
}

// ResetSettleType resets all changes to the "settle_type" field.
func (m *CommissionMutation) ResetSettleType() {
	m.settle_type = nil
	delete(m.clearedFields, commission.FieldSettleType)
}

// SetSettleMode sets the "settle_mode" field.
func (m *CommissionMutation) SetSettleMode(s string) {
	m.settle_mode = &s
}

// SettleMode returns the value of the "settle_mode" field in the mutation.
func (m *CommissionMutation) SettleMode() (r string, exists bool) {
	v := m.settle_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleMode returns the old "settle_mode" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSettleMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleMode: %w", err)
	}
	return oldValue.SettleMode, nil
}

// ClearSettleMode clears the value of the "settle_mode" field.
func (m *CommissionMutation) ClearSettleMode() {
	m.settle_mode = nil
	m.clearedFields[commission.FieldSettleMode] = struct{}{}
}

// SettleModeCleared returns if the "settle_mode" field was cleared in this mutation.
func (m *CommissionMutation) SettleModeCleared() bool {
	_, ok := m.clearedFields[commission.FieldSettleMode]
	return ok
}

// ResetSettleMode resets all changes to the "settle_mode" field.
func (m *CommissionMutation) ResetSettleMode() {
	m.settle_mode = nil
	delete(m.clearedFields, commission.FieldSettleMode)
}

// SetSettleInterval sets the "settle_interval" field.
func (m *CommissionMutation) SetSettleInterval(s string) {
	m.settle_interval = &s
}

// SettleInterval returns the value of the "settle_interval" field in the mutation.
func (m *CommissionMutation) SettleInterval() (r string, exists bool) {
	v := m.settle_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleInterval returns the old "settle_interval" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSettleInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleInterval: %w", err)
	}
	return oldValue.SettleInterval, nil
}

// ClearSettleInterval clears the value of the "settle_interval" field.
func (m *CommissionMutation) ClearSettleInterval() {
	m.settle_interval = nil
	m.clearedFields[commission.FieldSettleInterval] = struct{}{}
}

// SettleIntervalCleared returns if the "settle_interval" field was cleared in this mutation.
func (m *CommissionMutation) SettleIntervalCleared() bool {
	_, ok := m.clearedFields[commission.FieldSettleInterval]
	return ok
}

// ResetSettleInterval resets all changes to the "settle_interval" field.
func (m *CommissionMutation) ResetSettleInterval() {
	m.settle_interval = nil
	delete(m.clearedFields, commission.FieldSettleInterval)
}

// SetSettleAmountType sets the "settle_amount_type" field.
func (m *CommissionMutation) SetSettleAmountType(s string) {
	m.settle_amount_type = &s
}

// SettleAmountType returns the value of the "settle_amount_type" field in the mutation.
func (m *CommissionMutation) SettleAmountType() (r string, exists bool) {
	v := m.settle_amount_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleAmountType returns the old "settle_amount_type" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSettleAmountType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleAmountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleAmountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleAmountType: %w", err)
	}
	return oldValue.SettleAmountType, nil
}

// ClearSettleAmountType clears the value of the "settle_amount_type" field.
func (m *CommissionMutation) ClearSettleAmountType() {
	m.settle_amount_type = nil
	m.clearedFields[commission.FieldSettleAmountType] = struct{}{}
}

// SettleAmountTypeCleared returns if the "settle_amount_type" field was cleared in this mutation.
func (m *CommissionMutation) SettleAmountTypeCleared() bool {
	_, ok := m.clearedFields[commission.FieldSettleAmountType]
	return ok
}

// ResetSettleAmountType resets all changes to the "settle_amount_type" field.
func (m *CommissionMutation) ResetSettleAmountType() {
	m.settle_amount_type = nil
	delete(m.clearedFields, commission.FieldSettleAmountType)
}

// SetThreshold sets the "threshold" field.
func (m *CommissionMutation) SetThreshold(d decimal.Decimal) {
	m.threshold = &d
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *CommissionMutation) Threshold() (r decimal.Decimal, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldThreshold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// ClearThreshold clears the value of the "threshold" field.
func (m *CommissionMutation) ClearThreshold() {
	m.threshold = nil
	m.clearedFields[commission.FieldThreshold] = struct{}{}
}

// ThresholdCleared returns if the "threshold" field was cleared in this mutation.
func (m *CommissionMutation) ThresholdCleared() bool {
	_, ok := m.clearedFields[commission.FieldThreshold]
	return ok
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *CommissionMutation) ResetThreshold() {
	m.threshold = nil
	delete(m.clearedFields, commission.FieldThreshold)
}

// SetOrderLimit sets the "order_limit" field.
func (m *CommissionMutation) SetOrderLimit(u uint32) {
	m.order_limit = &u
	m.addorder_limit = nil
}

// OrderLimit returns the value of the "order_limit" field in the mutation.
func (m *CommissionMutation) OrderLimit() (r uint32, exists bool) {
	v := m.order_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderLimit returns the old "order_limit" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldOrderLimit(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderLimit: %w", err)
	}
	return oldValue.OrderLimit, nil
}

// AddOrderLimit adds u to the "order_limit" field.
func (m *CommissionMutation) AddOrderLimit(u int32) {
	if m.addorder_limit != nil {
		*m.addorder_limit += u
	} else {
		m.addorder_limit = &u
	}
}

// AddedOrderLimit returns the value that was added to the "order_limit" field in this mutation.
func (m *CommissionMutation) AddedOrderLimit() (r int32, exists bool) {
	v := m.addorder_limit
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderLimit clears the value of the "order_limit" field.
func (m *CommissionMutation) ClearOrderLimit() {
	m.order_limit = nil
	m.addorder_limit = nil
	m.clearedFields[commission.FieldOrderLimit] = struct{}{}
}

// OrderLimitCleared returns if the "order_limit" field was cleared in this mutation.
func (m *CommissionMutation) OrderLimitCleared() bool {
	_, ok := m.clearedFields[commission.FieldOrderLimit]
	return ok
}

// ResetOrderLimit resets all changes to the "order_limit" field.
func (m *CommissionMutation) ResetOrderLimit() {
	m.order_limit = nil
	m.addorder_limit = nil
	delete(m.clearedFields, commission.FieldOrderLimit)
}

// Where appends a list predicates to the CommissionMutation builder.
func (m *CommissionMutation) Where(ps ...predicate.Commission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Commission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Commission).
func (m *CommissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommissionMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, commission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, commission.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, commission.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, commission.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, commission.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, commission.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, commission.FieldAppGoodID)
	}
	if m.amount_or_percent != nil {
		fields = append(fields, commission.FieldAmountOrPercent)
	}
	if m.start_at != nil {
		fields = append(fields, commission.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, commission.FieldEndAt)
	}
	if m.settle_type != nil {
		fields = append(fields, commission.FieldSettleType)
	}
	if m.settle_mode != nil {
		fields = append(fields, commission.FieldSettleMode)
	}
	if m.settle_interval != nil {
		fields = append(fields, commission.FieldSettleInterval)
	}
	if m.settle_amount_type != nil {
		fields = append(fields, commission.FieldSettleAmountType)
	}
	if m.threshold != nil {
		fields = append(fields, commission.FieldThreshold)
	}
	if m.order_limit != nil {
		fields = append(fields, commission.FieldOrderLimit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commission.FieldCreatedAt:
		return m.CreatedAt()
	case commission.FieldUpdatedAt:
		return m.UpdatedAt()
	case commission.FieldDeletedAt:
		return m.DeletedAt()
	case commission.FieldEntID:
		return m.EntID()
	case commission.FieldAppID:
		return m.AppID()
	case commission.FieldUserID:
		return m.UserID()
	case commission.FieldGoodID:
		return m.GoodID()
	case commission.FieldAppGoodID:
		return m.AppGoodID()
	case commission.FieldAmountOrPercent:
		return m.AmountOrPercent()
	case commission.FieldStartAt:
		return m.StartAt()
	case commission.FieldEndAt:
		return m.EndAt()
	case commission.FieldSettleType:
		return m.SettleType()
	case commission.FieldSettleMode:
		return m.SettleMode()
	case commission.FieldSettleInterval:
		return m.SettleInterval()
	case commission.FieldSettleAmountType:
		return m.SettleAmountType()
	case commission.FieldThreshold:
		return m.Threshold()
	case commission.FieldOrderLimit:
		return m.OrderLimit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case commission.FieldEntID:
		return m.OldEntID(ctx)
	case commission.FieldAppID:
		return m.OldAppID(ctx)
	case commission.FieldUserID:
		return m.OldUserID(ctx)
	case commission.FieldGoodID:
		return m.OldGoodID(ctx)
	case commission.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case commission.FieldAmountOrPercent:
		return m.OldAmountOrPercent(ctx)
	case commission.FieldStartAt:
		return m.OldStartAt(ctx)
	case commission.FieldEndAt:
		return m.OldEndAt(ctx)
	case commission.FieldSettleType:
		return m.OldSettleType(ctx)
	case commission.FieldSettleMode:
		return m.OldSettleMode(ctx)
	case commission.FieldSettleInterval:
		return m.OldSettleInterval(ctx)
	case commission.FieldSettleAmountType:
		return m.OldSettleAmountType(ctx)
	case commission.FieldThreshold:
		return m.OldThreshold(ctx)
	case commission.FieldOrderLimit:
		return m.OldOrderLimit(ctx)
	}
	return nil, fmt.Errorf("unknown Commission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commission.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commission.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commission.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case commission.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case commission.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case commission.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case commission.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case commission.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case commission.FieldAmountOrPercent:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountOrPercent(v)
		return nil
	case commission.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case commission.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case commission.FieldSettleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleType(v)
		return nil
	case commission.FieldSettleMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleMode(v)
		return nil
	case commission.FieldSettleInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleInterval(v)
		return nil
	case commission.FieldSettleAmountType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleAmountType(v)
		return nil
	case commission.FieldThreshold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case commission.FieldOrderLimit:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Commission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, commission.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, commission.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, commission.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, commission.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, commission.FieldEndAt)
	}
	if m.addorder_limit != nil {
		fields = append(fields, commission.FieldOrderLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commission.FieldCreatedAt:
		return m.AddedCreatedAt()
	case commission.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case commission.FieldDeletedAt:
		return m.AddedDeletedAt()
	case commission.FieldStartAt:
		return m.AddedStartAt()
	case commission.FieldEndAt:
		return m.AddedEndAt()
	case commission.FieldOrderLimit:
		return m.AddedOrderLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commission.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case commission.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case commission.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case commission.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case commission.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	case commission.FieldOrderLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Commission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commission.FieldAppID) {
		fields = append(fields, commission.FieldAppID)
	}
	if m.FieldCleared(commission.FieldUserID) {
		fields = append(fields, commission.FieldUserID)
	}
	if m.FieldCleared(commission.FieldGoodID) {
		fields = append(fields, commission.FieldGoodID)
	}
	if m.FieldCleared(commission.FieldAppGoodID) {
		fields = append(fields, commission.FieldAppGoodID)
	}
	if m.FieldCleared(commission.FieldAmountOrPercent) {
		fields = append(fields, commission.FieldAmountOrPercent)
	}
	if m.FieldCleared(commission.FieldStartAt) {
		fields = append(fields, commission.FieldStartAt)
	}
	if m.FieldCleared(commission.FieldEndAt) {
		fields = append(fields, commission.FieldEndAt)
	}
	if m.FieldCleared(commission.FieldSettleType) {
		fields = append(fields, commission.FieldSettleType)
	}
	if m.FieldCleared(commission.FieldSettleMode) {
		fields = append(fields, commission.FieldSettleMode)
	}
	if m.FieldCleared(commission.FieldSettleInterval) {
		fields = append(fields, commission.FieldSettleInterval)
	}
	if m.FieldCleared(commission.FieldSettleAmountType) {
		fields = append(fields, commission.FieldSettleAmountType)
	}
	if m.FieldCleared(commission.FieldThreshold) {
		fields = append(fields, commission.FieldThreshold)
	}
	if m.FieldCleared(commission.FieldOrderLimit) {
		fields = append(fields, commission.FieldOrderLimit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommissionMutation) ClearField(name string) error {
	switch name {
	case commission.FieldAppID:
		m.ClearAppID()
		return nil
	case commission.FieldUserID:
		m.ClearUserID()
		return nil
	case commission.FieldGoodID:
		m.ClearGoodID()
		return nil
	case commission.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case commission.FieldAmountOrPercent:
		m.ClearAmountOrPercent()
		return nil
	case commission.FieldStartAt:
		m.ClearStartAt()
		return nil
	case commission.FieldEndAt:
		m.ClearEndAt()
		return nil
	case commission.FieldSettleType:
		m.ClearSettleType()
		return nil
	case commission.FieldSettleMode:
		m.ClearSettleMode()
		return nil
	case commission.FieldSettleInterval:
		m.ClearSettleInterval()
		return nil
	case commission.FieldSettleAmountType:
		m.ClearSettleAmountType()
		return nil
	case commission.FieldThreshold:
		m.ClearThreshold()
		return nil
	case commission.FieldOrderLimit:
		m.ClearOrderLimit()
		return nil
	}
	return fmt.Errorf("unknown Commission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommissionMutation) ResetField(name string) error {
	switch name {
	case commission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case commission.FieldEntID:
		m.ResetEntID()
		return nil
	case commission.FieldAppID:
		m.ResetAppID()
		return nil
	case commission.FieldUserID:
		m.ResetUserID()
		return nil
	case commission.FieldGoodID:
		m.ResetGoodID()
		return nil
	case commission.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case commission.FieldAmountOrPercent:
		m.ResetAmountOrPercent()
		return nil
	case commission.FieldStartAt:
		m.ResetStartAt()
		return nil
	case commission.FieldEndAt:
		m.ResetEndAt()
		return nil
	case commission.FieldSettleType:
		m.ResetSettleType()
		return nil
	case commission.FieldSettleMode:
		m.ResetSettleMode()
		return nil
	case commission.FieldSettleInterval:
		m.ResetSettleInterval()
		return nil
	case commission.FieldSettleAmountType:
		m.ResetSettleAmountType()
		return nil
	case commission.FieldThreshold:
		m.ResetThreshold()
		return nil
	case commission.FieldOrderLimit:
		m.ResetOrderLimit()
		return nil
	}
	return fmt.Errorf("unknown Commission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommissionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommissionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommissionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Commission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommissionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Commission edge %s", name)
}

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	ent_id               *uuid.UUID
	app_id               *uuid.UUID
	denomination         *decimal.Decimal
	circulation          *decimal.Decimal
	random               *bool
	issued_by            *uuid.UUID
	start_at             *uint32
	addstart_at          *int32
	end_at               *uint32
	addend_at            *int32
	duration_days        *uint32
	addduration_days     *int32
	message              *string
	name                 *string
	allocated            *decimal.Decimal
	coupon_type          *string
	threshold            *decimal.Decimal
	coupon_constraint    *string
	coupon_scope         *string
	cashable_probability *decimal.Decimal
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Coupon, error)
	predicates           []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id uint32) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Coupon entities.
func (m *CouponMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CouponMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CouponMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CouponMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CouponMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[coupon.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CouponMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, coupon.FieldAppID)
}

// SetDenomination sets the "denomination" field.
func (m *CouponMutation) SetDenomination(d decimal.Decimal) {
	m.denomination = &d
}

// Denomination returns the value of the "denomination" field in the mutation.
func (m *CouponMutation) Denomination() (r decimal.Decimal, exists bool) {
	v := m.denomination
	if v == nil {
		return
	}
	return *v, true
}

// OldDenomination returns the old "denomination" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDenomination(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenomination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenomination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenomination: %w", err)
	}
	return oldValue.Denomination, nil
}

// ClearDenomination clears the value of the "denomination" field.
func (m *CouponMutation) ClearDenomination() {
	m.denomination = nil
	m.clearedFields[coupon.FieldDenomination] = struct{}{}
}

// DenominationCleared returns if the "denomination" field was cleared in this mutation.
func (m *CouponMutation) DenominationCleared() bool {
	_, ok := m.clearedFields[coupon.FieldDenomination]
	return ok
}

// ResetDenomination resets all changes to the "denomination" field.
func (m *CouponMutation) ResetDenomination() {
	m.denomination = nil
	delete(m.clearedFields, coupon.FieldDenomination)
}

// SetCirculation sets the "circulation" field.
func (m *CouponMutation) SetCirculation(d decimal.Decimal) {
	m.circulation = &d
}

// Circulation returns the value of the "circulation" field in the mutation.
func (m *CouponMutation) Circulation() (r decimal.Decimal, exists bool) {
	v := m.circulation
	if v == nil {
		return
	}
	return *v, true
}

// OldCirculation returns the old "circulation" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCirculation(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCirculation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCirculation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCirculation: %w", err)
	}
	return oldValue.Circulation, nil
}

// ClearCirculation clears the value of the "circulation" field.
func (m *CouponMutation) ClearCirculation() {
	m.circulation = nil
	m.clearedFields[coupon.FieldCirculation] = struct{}{}
}

// CirculationCleared returns if the "circulation" field was cleared in this mutation.
func (m *CouponMutation) CirculationCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCirculation]
	return ok
}

// ResetCirculation resets all changes to the "circulation" field.
func (m *CouponMutation) ResetCirculation() {
	m.circulation = nil
	delete(m.clearedFields, coupon.FieldCirculation)
}

// SetRandom sets the "random" field.
func (m *CouponMutation) SetRandom(b bool) {
	m.random = &b
}

// Random returns the value of the "random" field in the mutation.
func (m *CouponMutation) Random() (r bool, exists bool) {
	v := m.random
	if v == nil {
		return
	}
	return *v, true
}

// OldRandom returns the old "random" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRandom(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRandom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRandom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRandom: %w", err)
	}
	return oldValue.Random, nil
}

// ClearRandom clears the value of the "random" field.
func (m *CouponMutation) ClearRandom() {
	m.random = nil
	m.clearedFields[coupon.FieldRandom] = struct{}{}
}

// RandomCleared returns if the "random" field was cleared in this mutation.
func (m *CouponMutation) RandomCleared() bool {
	_, ok := m.clearedFields[coupon.FieldRandom]
	return ok
}

// ResetRandom resets all changes to the "random" field.
func (m *CouponMutation) ResetRandom() {
	m.random = nil
	delete(m.clearedFields, coupon.FieldRandom)
}

// SetIssuedBy sets the "issued_by" field.
func (m *CouponMutation) SetIssuedBy(u uuid.UUID) {
	m.issued_by = &u
}

// IssuedBy returns the value of the "issued_by" field in the mutation.
func (m *CouponMutation) IssuedBy() (r uuid.UUID, exists bool) {
	v := m.issued_by
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedBy returns the old "issued_by" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldIssuedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedBy: %w", err)
	}
	return oldValue.IssuedBy, nil
}

// ClearIssuedBy clears the value of the "issued_by" field.
func (m *CouponMutation) ClearIssuedBy() {
	m.issued_by = nil
	m.clearedFields[coupon.FieldIssuedBy] = struct{}{}
}

// IssuedByCleared returns if the "issued_by" field was cleared in this mutation.
func (m *CouponMutation) IssuedByCleared() bool {
	_, ok := m.clearedFields[coupon.FieldIssuedBy]
	return ok
}

// ResetIssuedBy resets all changes to the "issued_by" field.
func (m *CouponMutation) ResetIssuedBy() {
	m.issued_by = nil
	delete(m.clearedFields, coupon.FieldIssuedBy)
}

// SetStartAt sets the "start_at" field.
func (m *CouponMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CouponMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CouponMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CouponMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CouponMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[coupon.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CouponMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[coupon.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CouponMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, coupon.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *CouponMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *CouponMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *CouponMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *CouponMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *CouponMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[coupon.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *CouponMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[coupon.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *CouponMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, coupon.FieldEndAt)
}

// SetDurationDays sets the "duration_days" field.
func (m *CouponMutation) SetDurationDays(u uint32) {
	m.duration_days = &u
	m.addduration_days = nil
}

// DurationDays returns the value of the "duration_days" field in the mutation.
func (m *CouponMutation) DurationDays() (r uint32, exists bool) {
	v := m.duration_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDays returns the old "duration_days" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDurationDays(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDays: %w", err)
	}
	return oldValue.DurationDays, nil
}

// AddDurationDays adds u to the "duration_days" field.
func (m *CouponMutation) AddDurationDays(u int32) {
	if m.addduration_days != nil {
		*m.addduration_days += u
	} else {
		m.addduration_days = &u
	}
}

// AddedDurationDays returns the value that was added to the "duration_days" field in this mutation.
func (m *CouponMutation) AddedDurationDays() (r int32, exists bool) {
	v := m.addduration_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationDays clears the value of the "duration_days" field.
func (m *CouponMutation) ClearDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	m.clearedFields[coupon.FieldDurationDays] = struct{}{}
}

// DurationDaysCleared returns if the "duration_days" field was cleared in this mutation.
func (m *CouponMutation) DurationDaysCleared() bool {
	_, ok := m.clearedFields[coupon.FieldDurationDays]
	return ok
}

// ResetDurationDays resets all changes to the "duration_days" field.
func (m *CouponMutation) ResetDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	delete(m.clearedFields, coupon.FieldDurationDays)
}

// SetMessage sets the "message" field.
func (m *CouponMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CouponMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *CouponMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[coupon.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *CouponMutation) MessageCleared() bool {
	_, ok := m.clearedFields[coupon.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *CouponMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, coupon.FieldMessage)
}

// SetName sets the "name" field.
func (m *CouponMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CouponMutation) ClearName() {
	m.name = nil
	m.clearedFields[coupon.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CouponMutation) NameCleared() bool {
	_, ok := m.clearedFields[coupon.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CouponMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, coupon.FieldName)
}

// SetAllocated sets the "allocated" field.
func (m *CouponMutation) SetAllocated(d decimal.Decimal) {
	m.allocated = &d
}

// Allocated returns the value of the "allocated" field in the mutation.
func (m *CouponMutation) Allocated() (r decimal.Decimal, exists bool) {
	v := m.allocated
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocated returns the old "allocated" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldAllocated(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocated: %w", err)
	}
	return oldValue.Allocated, nil
}

// ClearAllocated clears the value of the "allocated" field.
func (m *CouponMutation) ClearAllocated() {
	m.allocated = nil
	m.clearedFields[coupon.FieldAllocated] = struct{}{}
}

// AllocatedCleared returns if the "allocated" field was cleared in this mutation.
func (m *CouponMutation) AllocatedCleared() bool {
	_, ok := m.clearedFields[coupon.FieldAllocated]
	return ok
}

// ResetAllocated resets all changes to the "allocated" field.
func (m *CouponMutation) ResetAllocated() {
	m.allocated = nil
	delete(m.clearedFields, coupon.FieldAllocated)
}

// SetCouponType sets the "coupon_type" field.
func (m *CouponMutation) SetCouponType(s string) {
	m.coupon_type = &s
}

// CouponType returns the value of the "coupon_type" field in the mutation.
func (m *CouponMutation) CouponType() (r string, exists bool) {
	v := m.coupon_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponType returns the old "coupon_type" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCouponType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponType: %w", err)
	}
	return oldValue.CouponType, nil
}

// ClearCouponType clears the value of the "coupon_type" field.
func (m *CouponMutation) ClearCouponType() {
	m.coupon_type = nil
	m.clearedFields[coupon.FieldCouponType] = struct{}{}
}

// CouponTypeCleared returns if the "coupon_type" field was cleared in this mutation.
func (m *CouponMutation) CouponTypeCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCouponType]
	return ok
}

// ResetCouponType resets all changes to the "coupon_type" field.
func (m *CouponMutation) ResetCouponType() {
	m.coupon_type = nil
	delete(m.clearedFields, coupon.FieldCouponType)
}

// SetThreshold sets the "threshold" field.
func (m *CouponMutation) SetThreshold(d decimal.Decimal) {
	m.threshold = &d
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *CouponMutation) Threshold() (r decimal.Decimal, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldThreshold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// ClearThreshold clears the value of the "threshold" field.
func (m *CouponMutation) ClearThreshold() {
	m.threshold = nil
	m.clearedFields[coupon.FieldThreshold] = struct{}{}
}

// ThresholdCleared returns if the "threshold" field was cleared in this mutation.
func (m *CouponMutation) ThresholdCleared() bool {
	_, ok := m.clearedFields[coupon.FieldThreshold]
	return ok
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *CouponMutation) ResetThreshold() {
	m.threshold = nil
	delete(m.clearedFields, coupon.FieldThreshold)
}

// SetCouponConstraint sets the "coupon_constraint" field.
func (m *CouponMutation) SetCouponConstraint(s string) {
	m.coupon_constraint = &s
}

// CouponConstraint returns the value of the "coupon_constraint" field in the mutation.
func (m *CouponMutation) CouponConstraint() (r string, exists bool) {
	v := m.coupon_constraint
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponConstraint returns the old "coupon_constraint" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCouponConstraint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponConstraint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponConstraint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponConstraint: %w", err)
	}
	return oldValue.CouponConstraint, nil
}

// ClearCouponConstraint clears the value of the "coupon_constraint" field.
func (m *CouponMutation) ClearCouponConstraint() {
	m.coupon_constraint = nil
	m.clearedFields[coupon.FieldCouponConstraint] = struct{}{}
}

// CouponConstraintCleared returns if the "coupon_constraint" field was cleared in this mutation.
func (m *CouponMutation) CouponConstraintCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCouponConstraint]
	return ok
}

// ResetCouponConstraint resets all changes to the "coupon_constraint" field.
func (m *CouponMutation) ResetCouponConstraint() {
	m.coupon_constraint = nil
	delete(m.clearedFields, coupon.FieldCouponConstraint)
}

// SetCouponScope sets the "coupon_scope" field.
func (m *CouponMutation) SetCouponScope(s string) {
	m.coupon_scope = &s
}

// CouponScope returns the value of the "coupon_scope" field in the mutation.
func (m *CouponMutation) CouponScope() (r string, exists bool) {
	v := m.coupon_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponScope returns the old "coupon_scope" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCouponScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponScope: %w", err)
	}
	return oldValue.CouponScope, nil
}

// ClearCouponScope clears the value of the "coupon_scope" field.
func (m *CouponMutation) ClearCouponScope() {
	m.coupon_scope = nil
	m.clearedFields[coupon.FieldCouponScope] = struct{}{}
}

// CouponScopeCleared returns if the "coupon_scope" field was cleared in this mutation.
func (m *CouponMutation) CouponScopeCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCouponScope]
	return ok
}

// ResetCouponScope resets all changes to the "coupon_scope" field.
func (m *CouponMutation) ResetCouponScope() {
	m.coupon_scope = nil
	delete(m.clearedFields, coupon.FieldCouponScope)
}

// SetCashableProbability sets the "cashable_probability" field.
func (m *CouponMutation) SetCashableProbability(d decimal.Decimal) {
	m.cashable_probability = &d
}

// CashableProbability returns the value of the "cashable_probability" field in the mutation.
func (m *CouponMutation) CashableProbability() (r decimal.Decimal, exists bool) {
	v := m.cashable_probability
	if v == nil {
		return
	}
	return *v, true
}

// OldCashableProbability returns the old "cashable_probability" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCashableProbability(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashableProbability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashableProbability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashableProbability: %w", err)
	}
	return oldValue.CashableProbability, nil
}

// ClearCashableProbability clears the value of the "cashable_probability" field.
func (m *CouponMutation) ClearCashableProbability() {
	m.cashable_probability = nil
	m.clearedFields[coupon.FieldCashableProbability] = struct{}{}
}

// CashableProbabilityCleared returns if the "cashable_probability" field was cleared in this mutation.
func (m *CouponMutation) CashableProbabilityCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCashableProbability]
	return ok
}

// ResetCashableProbability resets all changes to the "cashable_probability" field.
func (m *CouponMutation) ResetCashableProbability() {
	m.cashable_probability = nil
	delete(m.clearedFields, coupon.FieldCashableProbability)
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coupon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, coupon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coupon.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coupon.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, coupon.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, coupon.FieldAppID)
	}
	if m.denomination != nil {
		fields = append(fields, coupon.FieldDenomination)
	}
	if m.circulation != nil {
		fields = append(fields, coupon.FieldCirculation)
	}
	if m.random != nil {
		fields = append(fields, coupon.FieldRandom)
	}
	if m.issued_by != nil {
		fields = append(fields, coupon.FieldIssuedBy)
	}
	if m.start_at != nil {
		fields = append(fields, coupon.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, coupon.FieldEndAt)
	}
	if m.duration_days != nil {
		fields = append(fields, coupon.FieldDurationDays)
	}
	if m.message != nil {
		fields = append(fields, coupon.FieldMessage)
	}
	if m.name != nil {
		fields = append(fields, coupon.FieldName)
	}
	if m.allocated != nil {
		fields = append(fields, coupon.FieldAllocated)
	}
	if m.coupon_type != nil {
		fields = append(fields, coupon.FieldCouponType)
	}
	if m.threshold != nil {
		fields = append(fields, coupon.FieldThreshold)
	}
	if m.coupon_constraint != nil {
		fields = append(fields, coupon.FieldCouponConstraint)
	}
	if m.coupon_scope != nil {
		fields = append(fields, coupon.FieldCouponScope)
	}
	if m.cashable_probability != nil {
		fields = append(fields, coupon.FieldCashableProbability)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.CreatedAt()
	case coupon.FieldUpdatedAt:
		return m.UpdatedAt()
	case coupon.FieldDeletedAt:
		return m.DeletedAt()
	case coupon.FieldEntID:
		return m.EntID()
	case coupon.FieldAppID:
		return m.AppID()
	case coupon.FieldDenomination:
		return m.Denomination()
	case coupon.FieldCirculation:
		return m.Circulation()
	case coupon.FieldRandom:
		return m.Random()
	case coupon.FieldIssuedBy:
		return m.IssuedBy()
	case coupon.FieldStartAt:
		return m.StartAt()
	case coupon.FieldEndAt:
		return m.EndAt()
	case coupon.FieldDurationDays:
		return m.DurationDays()
	case coupon.FieldMessage:
		return m.Message()
	case coupon.FieldName:
		return m.Name()
	case coupon.FieldAllocated:
		return m.Allocated()
	case coupon.FieldCouponType:
		return m.CouponType()
	case coupon.FieldThreshold:
		return m.Threshold()
	case coupon.FieldCouponConstraint:
		return m.CouponConstraint()
	case coupon.FieldCouponScope:
		return m.CouponScope()
	case coupon.FieldCashableProbability:
		return m.CashableProbability()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coupon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coupon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case coupon.FieldEntID:
		return m.OldEntID(ctx)
	case coupon.FieldAppID:
		return m.OldAppID(ctx)
	case coupon.FieldDenomination:
		return m.OldDenomination(ctx)
	case coupon.FieldCirculation:
		return m.OldCirculation(ctx)
	case coupon.FieldRandom:
		return m.OldRandom(ctx)
	case coupon.FieldIssuedBy:
		return m.OldIssuedBy(ctx)
	case coupon.FieldStartAt:
		return m.OldStartAt(ctx)
	case coupon.FieldEndAt:
		return m.OldEndAt(ctx)
	case coupon.FieldDurationDays:
		return m.OldDurationDays(ctx)
	case coupon.FieldMessage:
		return m.OldMessage(ctx)
	case coupon.FieldName:
		return m.OldName(ctx)
	case coupon.FieldAllocated:
		return m.OldAllocated(ctx)
	case coupon.FieldCouponType:
		return m.OldCouponType(ctx)
	case coupon.FieldThreshold:
		return m.OldThreshold(ctx)
	case coupon.FieldCouponConstraint:
		return m.OldCouponConstraint(ctx)
	case coupon.FieldCouponScope:
		return m.OldCouponScope(ctx)
	case coupon.FieldCashableProbability:
		return m.OldCashableProbability(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coupon.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coupon.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case coupon.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case coupon.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case coupon.FieldDenomination:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenomination(v)
		return nil
	case coupon.FieldCirculation:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCirculation(v)
		return nil
	case coupon.FieldRandom:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRandom(v)
		return nil
	case coupon.FieldIssuedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedBy(v)
		return nil
	case coupon.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case coupon.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case coupon.FieldDurationDays:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDays(v)
		return nil
	case coupon.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case coupon.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupon.FieldAllocated:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocated(v)
		return nil
	case coupon.FieldCouponType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponType(v)
		return nil
	case coupon.FieldThreshold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case coupon.FieldCouponConstraint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponConstraint(v)
		return nil
	case coupon.FieldCouponScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponScope(v)
		return nil
	case coupon.FieldCashableProbability:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashableProbability(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, coupon.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, coupon.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, coupon.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, coupon.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, coupon.FieldEndAt)
	}
	if m.addduration_days != nil {
		fields = append(fields, coupon.FieldDurationDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.AddedCreatedAt()
	case coupon.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case coupon.FieldDeletedAt:
		return m.AddedDeletedAt()
	case coupon.FieldStartAt:
		return m.AddedStartAt()
	case coupon.FieldEndAt:
		return m.AddedEndAt()
	case coupon.FieldDurationDays:
		return m.AddedDurationDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case coupon.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case coupon.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case coupon.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case coupon.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	case coupon.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationDays(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupon.FieldAppID) {
		fields = append(fields, coupon.FieldAppID)
	}
	if m.FieldCleared(coupon.FieldDenomination) {
		fields = append(fields, coupon.FieldDenomination)
	}
	if m.FieldCleared(coupon.FieldCirculation) {
		fields = append(fields, coupon.FieldCirculation)
	}
	if m.FieldCleared(coupon.FieldRandom) {
		fields = append(fields, coupon.FieldRandom)
	}
	if m.FieldCleared(coupon.FieldIssuedBy) {
		fields = append(fields, coupon.FieldIssuedBy)
	}
	if m.FieldCleared(coupon.FieldStartAt) {
		fields = append(fields, coupon.FieldStartAt)
	}
	if m.FieldCleared(coupon.FieldEndAt) {
		fields = append(fields, coupon.FieldEndAt)
	}
	if m.FieldCleared(coupon.FieldDurationDays) {
		fields = append(fields, coupon.FieldDurationDays)
	}
	if m.FieldCleared(coupon.FieldMessage) {
		fields = append(fields, coupon.FieldMessage)
	}
	if m.FieldCleared(coupon.FieldName) {
		fields = append(fields, coupon.FieldName)
	}
	if m.FieldCleared(coupon.FieldAllocated) {
		fields = append(fields, coupon.FieldAllocated)
	}
	if m.FieldCleared(coupon.FieldCouponType) {
		fields = append(fields, coupon.FieldCouponType)
	}
	if m.FieldCleared(coupon.FieldThreshold) {
		fields = append(fields, coupon.FieldThreshold)
	}
	if m.FieldCleared(coupon.FieldCouponConstraint) {
		fields = append(fields, coupon.FieldCouponConstraint)
	}
	if m.FieldCleared(coupon.FieldCouponScope) {
		fields = append(fields, coupon.FieldCouponScope)
	}
	if m.FieldCleared(coupon.FieldCashableProbability) {
		fields = append(fields, coupon.FieldCashableProbability)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case coupon.FieldAppID:
		m.ClearAppID()
		return nil
	case coupon.FieldDenomination:
		m.ClearDenomination()
		return nil
	case coupon.FieldCirculation:
		m.ClearCirculation()
		return nil
	case coupon.FieldRandom:
		m.ClearRandom()
		return nil
	case coupon.FieldIssuedBy:
		m.ClearIssuedBy()
		return nil
	case coupon.FieldStartAt:
		m.ClearStartAt()
		return nil
	case coupon.FieldEndAt:
		m.ClearEndAt()
		return nil
	case coupon.FieldDurationDays:
		m.ClearDurationDays()
		return nil
	case coupon.FieldMessage:
		m.ClearMessage()
		return nil
	case coupon.FieldName:
		m.ClearName()
		return nil
	case coupon.FieldAllocated:
		m.ClearAllocated()
		return nil
	case coupon.FieldCouponType:
		m.ClearCouponType()
		return nil
	case coupon.FieldThreshold:
		m.ClearThreshold()
		return nil
	case coupon.FieldCouponConstraint:
		m.ClearCouponConstraint()
		return nil
	case coupon.FieldCouponScope:
		m.ClearCouponScope()
		return nil
	case coupon.FieldCashableProbability:
		m.ClearCashableProbability()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case coupon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coupon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coupon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case coupon.FieldEntID:
		m.ResetEntID()
		return nil
	case coupon.FieldAppID:
		m.ResetAppID()
		return nil
	case coupon.FieldDenomination:
		m.ResetDenomination()
		return nil
	case coupon.FieldCirculation:
		m.ResetCirculation()
		return nil
	case coupon.FieldRandom:
		m.ResetRandom()
		return nil
	case coupon.FieldIssuedBy:
		m.ResetIssuedBy()
		return nil
	case coupon.FieldStartAt:
		m.ResetStartAt()
		return nil
	case coupon.FieldEndAt:
		m.ResetEndAt()
		return nil
	case coupon.FieldDurationDays:
		m.ResetDurationDays()
		return nil
	case coupon.FieldMessage:
		m.ResetMessage()
		return nil
	case coupon.FieldName:
		m.ResetName()
		return nil
	case coupon.FieldAllocated:
		m.ResetAllocated()
		return nil
	case coupon.FieldCouponType:
		m.ResetCouponType()
		return nil
	case coupon.FieldThreshold:
		m.ResetThreshold()
		return nil
	case coupon.FieldCouponConstraint:
		m.ResetCouponConstraint()
		return nil
	case coupon.FieldCouponScope:
		m.ResetCouponScope()
		return nil
	case coupon.FieldCashableProbability:
		m.ResetCashableProbability()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// CouponAllocatedMutation represents an operation that mutates the CouponAllocated nodes in the graph.
type CouponAllocatedMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	ent_id           *uuid.UUID
	app_id           *uuid.UUID
	user_id          *uuid.UUID
	coupon_id        *uuid.UUID
	denomination     *decimal.Decimal
	used             *bool
	used_at          *uint32
	addused_at       *int32
	used_by_order_id *uuid.UUID
	start_at         *uint32
	addstart_at      *int32
	coupon_scope     *string
	cashable         *bool
	extra            *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CouponAllocated, error)
	predicates       []predicate.CouponAllocated
}

var _ ent.Mutation = (*CouponAllocatedMutation)(nil)

// couponallocatedOption allows management of the mutation configuration using functional options.
type couponallocatedOption func(*CouponAllocatedMutation)

// newCouponAllocatedMutation creates new mutation for the CouponAllocated entity.
func newCouponAllocatedMutation(c config, op Op, opts ...couponallocatedOption) *CouponAllocatedMutation {
	m := &CouponAllocatedMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponAllocated,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponAllocatedID sets the ID field of the mutation.
func withCouponAllocatedID(id uint32) couponallocatedOption {
	return func(m *CouponAllocatedMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponAllocated
		)
		m.oldValue = func(ctx context.Context) (*CouponAllocated, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponAllocated.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponAllocated sets the old CouponAllocated of the mutation.
func withCouponAllocated(node *CouponAllocated) couponallocatedOption {
	return func(m *CouponAllocatedMutation) {
		m.oldValue = func(context.Context) (*CouponAllocated, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponAllocatedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponAllocatedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponAllocated entities.
func (m *CouponAllocatedMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponAllocatedMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponAllocatedMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponAllocated.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponAllocatedMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponAllocatedMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponAllocatedMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponAllocatedMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponAllocatedMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponAllocatedMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponAllocatedMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponAllocatedMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponAllocatedMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponAllocatedMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponAllocatedMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponAllocatedMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CouponAllocatedMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CouponAllocatedMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CouponAllocatedMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponAllocatedMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponAllocatedMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CouponAllocatedMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[couponallocated.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CouponAllocatedMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponAllocatedMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, couponallocated.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *CouponAllocatedMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CouponAllocatedMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CouponAllocatedMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[couponallocated.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CouponAllocatedMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, couponallocated.FieldUserID)
}

// SetCouponID sets the "coupon_id" field.
func (m *CouponAllocatedMutation) SetCouponID(u uuid.UUID) {
	m.coupon_id = &u
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *CouponAllocatedMutation) CouponID() (r uuid.UUID, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// ClearCouponID clears the value of the "coupon_id" field.
func (m *CouponAllocatedMutation) ClearCouponID() {
	m.coupon_id = nil
	m.clearedFields[couponallocated.FieldCouponID] = struct{}{}
}

// CouponIDCleared returns if the "coupon_id" field was cleared in this mutation.
func (m *CouponAllocatedMutation) CouponIDCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldCouponID]
	return ok
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *CouponAllocatedMutation) ResetCouponID() {
	m.coupon_id = nil
	delete(m.clearedFields, couponallocated.FieldCouponID)
}

// SetDenomination sets the "denomination" field.
func (m *CouponAllocatedMutation) SetDenomination(d decimal.Decimal) {
	m.denomination = &d
}

// Denomination returns the value of the "denomination" field in the mutation.
func (m *CouponAllocatedMutation) Denomination() (r decimal.Decimal, exists bool) {
	v := m.denomination
	if v == nil {
		return
	}
	return *v, true
}

// OldDenomination returns the old "denomination" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldDenomination(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenomination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenomination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenomination: %w", err)
	}
	return oldValue.Denomination, nil
}

// ClearDenomination clears the value of the "denomination" field.
func (m *CouponAllocatedMutation) ClearDenomination() {
	m.denomination = nil
	m.clearedFields[couponallocated.FieldDenomination] = struct{}{}
}

// DenominationCleared returns if the "denomination" field was cleared in this mutation.
func (m *CouponAllocatedMutation) DenominationCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldDenomination]
	return ok
}

// ResetDenomination resets all changes to the "denomination" field.
func (m *CouponAllocatedMutation) ResetDenomination() {
	m.denomination = nil
	delete(m.clearedFields, couponallocated.FieldDenomination)
}

// SetUsed sets the "used" field.
func (m *CouponAllocatedMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *CouponAllocatedMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ClearUsed clears the value of the "used" field.
func (m *CouponAllocatedMutation) ClearUsed() {
	m.used = nil
	m.clearedFields[couponallocated.FieldUsed] = struct{}{}
}

// UsedCleared returns if the "used" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsed]
	return ok
}

// ResetUsed resets all changes to the "used" field.
func (m *CouponAllocatedMutation) ResetUsed() {
	m.used = nil
	delete(m.clearedFields, couponallocated.FieldUsed)
}

// SetUsedAt sets the "used_at" field.
func (m *CouponAllocatedMutation) SetUsedAt(u uint32) {
	m.used_at = &u
	m.addused_at = nil
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *CouponAllocatedMutation) UsedAt() (r uint32, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// AddUsedAt adds u to the "used_at" field.
func (m *CouponAllocatedMutation) AddUsedAt(u int32) {
	if m.addused_at != nil {
		*m.addused_at += u
	} else {
		m.addused_at = &u
	}
}

// AddedUsedAt returns the value that was added to the "used_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedUsedAt() (r int32, exists bool) {
	v := m.addused_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *CouponAllocatedMutation) ClearUsedAt() {
	m.used_at = nil
	m.addused_at = nil
	m.clearedFields[couponallocated.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *CouponAllocatedMutation) ResetUsedAt() {
	m.used_at = nil
	m.addused_at = nil
	delete(m.clearedFields, couponallocated.FieldUsedAt)
}

// SetUsedByOrderID sets the "used_by_order_id" field.
func (m *CouponAllocatedMutation) SetUsedByOrderID(u uuid.UUID) {
	m.used_by_order_id = &u
}

// UsedByOrderID returns the value of the "used_by_order_id" field in the mutation.
func (m *CouponAllocatedMutation) UsedByOrderID() (r uuid.UUID, exists bool) {
	v := m.used_by_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedByOrderID returns the old "used_by_order_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsedByOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedByOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedByOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedByOrderID: %w", err)
	}
	return oldValue.UsedByOrderID, nil
}

// ClearUsedByOrderID clears the value of the "used_by_order_id" field.
func (m *CouponAllocatedMutation) ClearUsedByOrderID() {
	m.used_by_order_id = nil
	m.clearedFields[couponallocated.FieldUsedByOrderID] = struct{}{}
}

// UsedByOrderIDCleared returns if the "used_by_order_id" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedByOrderIDCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsedByOrderID]
	return ok
}

// ResetUsedByOrderID resets all changes to the "used_by_order_id" field.
func (m *CouponAllocatedMutation) ResetUsedByOrderID() {
	m.used_by_order_id = nil
	delete(m.clearedFields, couponallocated.FieldUsedByOrderID)
}

// SetStartAt sets the "start_at" field.
func (m *CouponAllocatedMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CouponAllocatedMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CouponAllocatedMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CouponAllocatedMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[couponallocated.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CouponAllocatedMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CouponAllocatedMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, couponallocated.FieldStartAt)
}

// SetCouponScope sets the "coupon_scope" field.
func (m *CouponAllocatedMutation) SetCouponScope(s string) {
	m.coupon_scope = &s
}

// CouponScope returns the value of the "coupon_scope" field in the mutation.
func (m *CouponAllocatedMutation) CouponScope() (r string, exists bool) {
	v := m.coupon_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponScope returns the old "coupon_scope" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCouponScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponScope: %w", err)
	}
	return oldValue.CouponScope, nil
}

// ClearCouponScope clears the value of the "coupon_scope" field.
func (m *CouponAllocatedMutation) ClearCouponScope() {
	m.coupon_scope = nil
	m.clearedFields[couponallocated.FieldCouponScope] = struct{}{}
}

// CouponScopeCleared returns if the "coupon_scope" field was cleared in this mutation.
func (m *CouponAllocatedMutation) CouponScopeCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldCouponScope]
	return ok
}

// ResetCouponScope resets all changes to the "coupon_scope" field.
func (m *CouponAllocatedMutation) ResetCouponScope() {
	m.coupon_scope = nil
	delete(m.clearedFields, couponallocated.FieldCouponScope)
}

// SetCashable sets the "cashable" field.
func (m *CouponAllocatedMutation) SetCashable(b bool) {
	m.cashable = &b
}

// Cashable returns the value of the "cashable" field in the mutation.
func (m *CouponAllocatedMutation) Cashable() (r bool, exists bool) {
	v := m.cashable
	if v == nil {
		return
	}
	return *v, true
}

// OldCashable returns the old "cashable" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCashable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashable: %w", err)
	}
	return oldValue.Cashable, nil
}

// ClearCashable clears the value of the "cashable" field.
func (m *CouponAllocatedMutation) ClearCashable() {
	m.cashable = nil
	m.clearedFields[couponallocated.FieldCashable] = struct{}{}
}

// CashableCleared returns if the "cashable" field was cleared in this mutation.
func (m *CouponAllocatedMutation) CashableCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldCashable]
	return ok
}

// ResetCashable resets all changes to the "cashable" field.
func (m *CouponAllocatedMutation) ResetCashable() {
	m.cashable = nil
	delete(m.clearedFields, couponallocated.FieldCashable)
}

// SetExtra sets the "extra" field.
func (m *CouponAllocatedMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *CouponAllocatedMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *CouponAllocatedMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[couponallocated.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *CouponAllocatedMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *CouponAllocatedMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, couponallocated.FieldExtra)
}

// Where appends a list predicates to the CouponAllocatedMutation builder.
func (m *CouponAllocatedMutation) Where(ps ...predicate.CouponAllocated) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponAllocatedMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponAllocatedMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CouponAllocated, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponAllocatedMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponAllocatedMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CouponAllocated).
func (m *CouponAllocatedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponAllocatedMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, couponallocated.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponallocated.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, couponallocated.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, couponallocated.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, couponallocated.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, couponallocated.FieldUserID)
	}
	if m.coupon_id != nil {
		fields = append(fields, couponallocated.FieldCouponID)
	}
	if m.denomination != nil {
		fields = append(fields, couponallocated.FieldDenomination)
	}
	if m.used != nil {
		fields = append(fields, couponallocated.FieldUsed)
	}
	if m.used_at != nil {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	if m.used_by_order_id != nil {
		fields = append(fields, couponallocated.FieldUsedByOrderID)
	}
	if m.start_at != nil {
		fields = append(fields, couponallocated.FieldStartAt)
	}
	if m.coupon_scope != nil {
		fields = append(fields, couponallocated.FieldCouponScope)
	}
	if m.cashable != nil {
		fields = append(fields, couponallocated.FieldCashable)
	}
	if m.extra != nil {
		fields = append(fields, couponallocated.FieldExtra)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponAllocatedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.CreatedAt()
	case couponallocated.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponallocated.FieldDeletedAt:
		return m.DeletedAt()
	case couponallocated.FieldEntID:
		return m.EntID()
	case couponallocated.FieldAppID:
		return m.AppID()
	case couponallocated.FieldUserID:
		return m.UserID()
	case couponallocated.FieldCouponID:
		return m.CouponID()
	case couponallocated.FieldDenomination:
		return m.Denomination()
	case couponallocated.FieldUsed:
		return m.Used()
	case couponallocated.FieldUsedAt:
		return m.UsedAt()
	case couponallocated.FieldUsedByOrderID:
		return m.UsedByOrderID()
	case couponallocated.FieldStartAt:
		return m.StartAt()
	case couponallocated.FieldCouponScope:
		return m.CouponScope()
	case couponallocated.FieldCashable:
		return m.Cashable()
	case couponallocated.FieldExtra:
		return m.Extra()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponAllocatedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponallocated.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponallocated.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case couponallocated.FieldEntID:
		return m.OldEntID(ctx)
	case couponallocated.FieldAppID:
		return m.OldAppID(ctx)
	case couponallocated.FieldUserID:
		return m.OldUserID(ctx)
	case couponallocated.FieldCouponID:
		return m.OldCouponID(ctx)
	case couponallocated.FieldDenomination:
		return m.OldDenomination(ctx)
	case couponallocated.FieldUsed:
		return m.OldUsed(ctx)
	case couponallocated.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case couponallocated.FieldUsedByOrderID:
		return m.OldUsedByOrderID(ctx)
	case couponallocated.FieldStartAt:
		return m.OldStartAt(ctx)
	case couponallocated.FieldCouponScope:
		return m.OldCouponScope(ctx)
	case couponallocated.FieldCashable:
		return m.OldCashable(ctx)
	case couponallocated.FieldExtra:
		return m.OldExtra(ctx)
	}
	return nil, fmt.Errorf("unknown CouponAllocated field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponAllocatedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponallocated.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponallocated.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case couponallocated.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case couponallocated.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case couponallocated.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case couponallocated.FieldCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case couponallocated.FieldDenomination:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenomination(v)
		return nil
	case couponallocated.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case couponallocated.FieldUsedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case couponallocated.FieldUsedByOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedByOrderID(v)
		return nil
	case couponallocated.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case couponallocated.FieldCouponScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponScope(v)
		return nil
	case couponallocated.FieldCashable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashable(v)
		return nil
	case couponallocated.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponAllocatedMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, couponallocated.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, couponallocated.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, couponallocated.FieldDeletedAt)
	}
	if m.addused_at != nil {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, couponallocated.FieldStartAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponAllocatedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.AddedCreatedAt()
	case couponallocated.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case couponallocated.FieldDeletedAt:
		return m.AddedDeletedAt()
	case couponallocated.FieldUsedAt:
		return m.AddedUsedAt()
	case couponallocated.FieldStartAt:
		return m.AddedStartAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponAllocatedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case couponallocated.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case couponallocated.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case couponallocated.FieldUsedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedAt(v)
		return nil
	case couponallocated.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponAllocatedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponallocated.FieldAppID) {
		fields = append(fields, couponallocated.FieldAppID)
	}
	if m.FieldCleared(couponallocated.FieldUserID) {
		fields = append(fields, couponallocated.FieldUserID)
	}
	if m.FieldCleared(couponallocated.FieldCouponID) {
		fields = append(fields, couponallocated.FieldCouponID)
	}
	if m.FieldCleared(couponallocated.FieldDenomination) {
		fields = append(fields, couponallocated.FieldDenomination)
	}
	if m.FieldCleared(couponallocated.FieldUsed) {
		fields = append(fields, couponallocated.FieldUsed)
	}
	if m.FieldCleared(couponallocated.FieldUsedAt) {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	if m.FieldCleared(couponallocated.FieldUsedByOrderID) {
		fields = append(fields, couponallocated.FieldUsedByOrderID)
	}
	if m.FieldCleared(couponallocated.FieldStartAt) {
		fields = append(fields, couponallocated.FieldStartAt)
	}
	if m.FieldCleared(couponallocated.FieldCouponScope) {
		fields = append(fields, couponallocated.FieldCouponScope)
	}
	if m.FieldCleared(couponallocated.FieldCashable) {
		fields = append(fields, couponallocated.FieldCashable)
	}
	if m.FieldCleared(couponallocated.FieldExtra) {
		fields = append(fields, couponallocated.FieldExtra)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponAllocatedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponAllocatedMutation) ClearField(name string) error {
	switch name {
	case couponallocated.FieldAppID:
		m.ClearAppID()
		return nil
	case couponallocated.FieldUserID:
		m.ClearUserID()
		return nil
	case couponallocated.FieldCouponID:
		m.ClearCouponID()
		return nil
	case couponallocated.FieldDenomination:
		m.ClearDenomination()
		return nil
	case couponallocated.FieldUsed:
		m.ClearUsed()
		return nil
	case couponallocated.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case couponallocated.FieldUsedByOrderID:
		m.ClearUsedByOrderID()
		return nil
	case couponallocated.FieldStartAt:
		m.ClearStartAt()
		return nil
	case couponallocated.FieldCouponScope:
		m.ClearCouponScope()
		return nil
	case couponallocated.FieldCashable:
		m.ClearCashable()
		return nil
	case couponallocated.FieldExtra:
		m.ClearExtra()
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponAllocatedMutation) ResetField(name string) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponallocated.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponallocated.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case couponallocated.FieldEntID:
		m.ResetEntID()
		return nil
	case couponallocated.FieldAppID:
		m.ResetAppID()
		return nil
	case couponallocated.FieldUserID:
		m.ResetUserID()
		return nil
	case couponallocated.FieldCouponID:
		m.ResetCouponID()
		return nil
	case couponallocated.FieldDenomination:
		m.ResetDenomination()
		return nil
	case couponallocated.FieldUsed:
		m.ResetUsed()
		return nil
	case couponallocated.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case couponallocated.FieldUsedByOrderID:
		m.ResetUsedByOrderID()
		return nil
	case couponallocated.FieldStartAt:
		m.ResetStartAt()
		return nil
	case couponallocated.FieldCouponScope:
		m.ResetCouponScope()
		return nil
	case couponallocated.FieldCashable:
		m.ResetCashable()
		return nil
	case couponallocated.FieldExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponAllocatedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponAllocatedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponAllocatedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponAllocatedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponAllocatedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponAllocatedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponAllocatedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponAllocated unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponAllocatedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponAllocated edge %s", name)
}

// CouponScopeMutation represents an operation that mutates the CouponScope nodes in the graph.
type CouponScopeMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	coupon_id     *uuid.UUID
	good_id       *uuid.UUID
	coupon_scope  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CouponScope, error)
	predicates    []predicate.CouponScope
}

var _ ent.Mutation = (*CouponScopeMutation)(nil)

// couponscopeOption allows management of the mutation configuration using functional options.
type couponscopeOption func(*CouponScopeMutation)

// newCouponScopeMutation creates new mutation for the CouponScope entity.
func newCouponScopeMutation(c config, op Op, opts ...couponscopeOption) *CouponScopeMutation {
	m := &CouponScopeMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponScope,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponScopeID sets the ID field of the mutation.
func withCouponScopeID(id uint32) couponscopeOption {
	return func(m *CouponScopeMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponScope
		)
		m.oldValue = func(ctx context.Context) (*CouponScope, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponScope.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponScope sets the old CouponScope of the mutation.
func withCouponScope(node *CouponScope) couponscopeOption {
	return func(m *CouponScopeMutation) {
		m.oldValue = func(context.Context) (*CouponScope, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponScopeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponScopeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponScope entities.
func (m *CouponScopeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponScopeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponScopeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponScope.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponScopeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponScopeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponScope entity.
// If the CouponScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponScopeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponScopeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponScopeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponScopeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponScopeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponScopeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponScope entity.
// If the CouponScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponScopeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponScopeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponScopeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponScopeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponScopeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponScopeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CouponScope entity.
// If the CouponScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponScopeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponScopeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponScopeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponScopeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CouponScopeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CouponScopeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the CouponScope entity.
// If the CouponScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponScopeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CouponScopeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCouponID sets the "coupon_id" field.
func (m *CouponScopeMutation) SetCouponID(u uuid.UUID) {
	m.coupon_id = &u
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *CouponScopeMutation) CouponID() (r uuid.UUID, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the CouponScope entity.
// If the CouponScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponScopeMutation) OldCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// ClearCouponID clears the value of the "coupon_id" field.
func (m *CouponScopeMutation) ClearCouponID() {
	m.coupon_id = nil
	m.clearedFields[couponscope.FieldCouponID] = struct{}{}
}

// CouponIDCleared returns if the "coupon_id" field was cleared in this mutation.
func (m *CouponScopeMutation) CouponIDCleared() bool {
	_, ok := m.clearedFields[couponscope.FieldCouponID]
	return ok
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *CouponScopeMutation) ResetCouponID() {
	m.coupon_id = nil
	delete(m.clearedFields, couponscope.FieldCouponID)
}

// SetGoodID sets the "good_id" field.
func (m *CouponScopeMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *CouponScopeMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the CouponScope entity.
// If the CouponScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponScopeMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *CouponScopeMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[couponscope.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *CouponScopeMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[couponscope.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *CouponScopeMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, couponscope.FieldGoodID)
}

// SetCouponScope sets the "coupon_scope" field.
func (m *CouponScopeMutation) SetCouponScope(s string) {
	m.coupon_scope = &s
}

// CouponScope returns the value of the "coupon_scope" field in the mutation.
func (m *CouponScopeMutation) CouponScope() (r string, exists bool) {
	v := m.coupon_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponScope returns the old "coupon_scope" field's value of the CouponScope entity.
// If the CouponScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponScopeMutation) OldCouponScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponScope: %w", err)
	}
	return oldValue.CouponScope, nil
}

// ClearCouponScope clears the value of the "coupon_scope" field.
func (m *CouponScopeMutation) ClearCouponScope() {
	m.coupon_scope = nil
	m.clearedFields[couponscope.FieldCouponScope] = struct{}{}
}

// CouponScopeCleared returns if the "coupon_scope" field was cleared in this mutation.
func (m *CouponScopeMutation) CouponScopeCleared() bool {
	_, ok := m.clearedFields[couponscope.FieldCouponScope]
	return ok
}

// ResetCouponScope resets all changes to the "coupon_scope" field.
func (m *CouponScopeMutation) ResetCouponScope() {
	m.coupon_scope = nil
	delete(m.clearedFields, couponscope.FieldCouponScope)
}

// Where appends a list predicates to the CouponScopeMutation builder.
func (m *CouponScopeMutation) Where(ps ...predicate.CouponScope) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponScopeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponScopeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CouponScope, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponScopeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponScopeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CouponScope).
func (m *CouponScopeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponScopeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, couponscope.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponscope.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, couponscope.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, couponscope.FieldEntID)
	}
	if m.coupon_id != nil {
		fields = append(fields, couponscope.FieldCouponID)
	}
	if m.good_id != nil {
		fields = append(fields, couponscope.FieldGoodID)
	}
	if m.coupon_scope != nil {
		fields = append(fields, couponscope.FieldCouponScope)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponScopeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponscope.FieldCreatedAt:
		return m.CreatedAt()
	case couponscope.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponscope.FieldDeletedAt:
		return m.DeletedAt()
	case couponscope.FieldEntID:
		return m.EntID()
	case couponscope.FieldCouponID:
		return m.CouponID()
	case couponscope.FieldGoodID:
		return m.GoodID()
	case couponscope.FieldCouponScope:
		return m.CouponScope()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponScopeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponscope.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponscope.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponscope.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case couponscope.FieldEntID:
		return m.OldEntID(ctx)
	case couponscope.FieldCouponID:
		return m.OldCouponID(ctx)
	case couponscope.FieldGoodID:
		return m.OldGoodID(ctx)
	case couponscope.FieldCouponScope:
		return m.OldCouponScope(ctx)
	}
	return nil, fmt.Errorf("unknown CouponScope field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponScopeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponscope.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponscope.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponscope.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case couponscope.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case couponscope.FieldCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case couponscope.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case couponscope.FieldCouponScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponScope(v)
		return nil
	}
	return fmt.Errorf("unknown CouponScope field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponScopeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, couponscope.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, couponscope.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, couponscope.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponScopeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponscope.FieldCreatedAt:
		return m.AddedCreatedAt()
	case couponscope.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case couponscope.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponScopeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponscope.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case couponscope.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case couponscope.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CouponScope numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponScopeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponscope.FieldCouponID) {
		fields = append(fields, couponscope.FieldCouponID)
	}
	if m.FieldCleared(couponscope.FieldGoodID) {
		fields = append(fields, couponscope.FieldGoodID)
	}
	if m.FieldCleared(couponscope.FieldCouponScope) {
		fields = append(fields, couponscope.FieldCouponScope)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponScopeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponScopeMutation) ClearField(name string) error {
	switch name {
	case couponscope.FieldCouponID:
		m.ClearCouponID()
		return nil
	case couponscope.FieldGoodID:
		m.ClearGoodID()
		return nil
	case couponscope.FieldCouponScope:
		m.ClearCouponScope()
		return nil
	}
	return fmt.Errorf("unknown CouponScope nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponScopeMutation) ResetField(name string) error {
	switch name {
	case couponscope.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponscope.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponscope.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case couponscope.FieldEntID:
		m.ResetEntID()
		return nil
	case couponscope.FieldCouponID:
		m.ResetCouponID()
		return nil
	case couponscope.FieldGoodID:
		m.ResetGoodID()
		return nil
	case couponscope.FieldCouponScope:
		m.ResetCouponScope()
		return nil
	}
	return fmt.Errorf("unknown CouponScope field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponScopeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponScopeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponScopeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponScopeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponScopeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponScopeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponScopeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponScope unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponScopeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponScope edge %s", name)
}

// CreditAllocatedMutation represents an operation that mutates the CreditAllocated nodes in the graph.
type CreditAllocatedMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	value         *decimal.Decimal
	extra         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CreditAllocated, error)
	predicates    []predicate.CreditAllocated
}

var _ ent.Mutation = (*CreditAllocatedMutation)(nil)

// creditallocatedOption allows management of the mutation configuration using functional options.
type creditallocatedOption func(*CreditAllocatedMutation)

// newCreditAllocatedMutation creates new mutation for the CreditAllocated entity.
func newCreditAllocatedMutation(c config, op Op, opts ...creditallocatedOption) *CreditAllocatedMutation {
	m := &CreditAllocatedMutation{
		config:        c,
		op:            op,
		typ:           TypeCreditAllocated,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreditAllocatedID sets the ID field of the mutation.
func withCreditAllocatedID(id uint32) creditallocatedOption {
	return func(m *CreditAllocatedMutation) {
		var (
			err   error
			once  sync.Once
			value *CreditAllocated
		)
		m.oldValue = func(ctx context.Context) (*CreditAllocated, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CreditAllocated.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCreditAllocated sets the old CreditAllocated of the mutation.
func withCreditAllocated(node *CreditAllocated) creditallocatedOption {
	return func(m *CreditAllocatedMutation) {
		m.oldValue = func(context.Context) (*CreditAllocated, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreditAllocatedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreditAllocatedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CreditAllocated entities.
func (m *CreditAllocatedMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreditAllocatedMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreditAllocatedMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CreditAllocated.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CreditAllocatedMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CreditAllocatedMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CreditAllocated entity.
// If the CreditAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditAllocatedMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CreditAllocatedMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CreditAllocatedMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CreditAllocatedMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CreditAllocatedMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CreditAllocatedMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CreditAllocated entity.
// If the CreditAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditAllocatedMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CreditAllocatedMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CreditAllocatedMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CreditAllocatedMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CreditAllocatedMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CreditAllocatedMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CreditAllocated entity.
// If the CreditAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditAllocatedMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CreditAllocatedMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CreditAllocatedMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CreditAllocatedMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CreditAllocatedMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CreditAllocatedMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the CreditAllocated entity.
// If the CreditAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditAllocatedMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CreditAllocatedMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CreditAllocatedMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CreditAllocatedMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CreditAllocated entity.
// If the CreditAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditAllocatedMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CreditAllocatedMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[creditallocated.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CreditAllocatedMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[creditallocated.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CreditAllocatedMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, creditallocated.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *CreditAllocatedMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CreditAllocatedMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CreditAllocated entity.
// If the CreditAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditAllocatedMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CreditAllocatedMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[creditallocated.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CreditAllocatedMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[creditallocated.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CreditAllocatedMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, creditallocated.FieldUserID)
}

// SetValue sets the "value" field.
func (m *CreditAllocatedMutation) SetValue(d decimal.Decimal) {
	m.value = &d
}

// Value returns the value of the "value" field in the mutation.
func (m *CreditAllocatedMutation) Value() (r decimal.Decimal, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the CreditAllocated entity.
// If the CreditAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditAllocatedMutation) OldValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *CreditAllocatedMutation) ClearValue() {
	m.value = nil
	m.clearedFields[creditallocated.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *CreditAllocatedMutation) ValueCleared() bool {
	_, ok := m.clearedFields[creditallocated.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *CreditAllocatedMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, creditallocated.FieldValue)
}

// SetExtra sets the "extra" field.
func (m *CreditAllocatedMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *CreditAllocatedMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the CreditAllocated entity.
// If the CreditAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditAllocatedMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *CreditAllocatedMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[creditallocated.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *CreditAllocatedMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[creditallocated.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *CreditAllocatedMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, creditallocated.FieldExtra)
}

// Where appends a list predicates to the CreditAllocatedMutation builder.
func (m *CreditAllocatedMutation) Where(ps ...predicate.CreditAllocated) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreditAllocatedMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreditAllocatedMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CreditAllocated, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreditAllocatedMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreditAllocatedMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CreditAllocated).
func (m *CreditAllocatedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreditAllocatedMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, creditallocated.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, creditallocated.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, creditallocated.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, creditallocated.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, creditallocated.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, creditallocated.FieldUserID)
	}
	if m.value != nil {
		fields = append(fields, creditallocated.FieldValue)
	}
	if m.extra != nil {
		fields = append(fields, creditallocated.FieldExtra)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreditAllocatedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case creditallocated.FieldCreatedAt:
		return m.CreatedAt()
	case creditallocated.FieldUpdatedAt:
		return m.UpdatedAt()
	case creditallocated.FieldDeletedAt:
		return m.DeletedAt()
	case creditallocated.FieldEntID:
		return m.EntID()
	case creditallocated.FieldAppID:
		return m.AppID()
	case creditallocated.FieldUserID:
		return m.UserID()
	case creditallocated.FieldValue:
		return m.Value()
	case creditallocated.FieldExtra:
		return m.Extra()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreditAllocatedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case creditallocated.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case creditallocated.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case creditallocated.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case creditallocated.FieldEntID:
		return m.OldEntID(ctx)
	case creditallocated.FieldAppID:
		return m.OldAppID(ctx)
	case creditallocated.FieldUserID:
		return m.OldUserID(ctx)
	case creditallocated.FieldValue:
		return m.OldValue(ctx)
	case creditallocated.FieldExtra:
		return m.OldExtra(ctx)
	}
	return nil, fmt.Errorf("unknown CreditAllocated field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditAllocatedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case creditallocated.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case creditallocated.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case creditallocated.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case creditallocated.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case creditallocated.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case creditallocated.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case creditallocated.FieldValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case creditallocated.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	}
	return fmt.Errorf("unknown CreditAllocated field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreditAllocatedMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, creditallocated.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, creditallocated.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, creditallocated.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreditAllocatedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case creditallocated.FieldCreatedAt:
		return m.AddedCreatedAt()
	case creditallocated.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case creditallocated.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditAllocatedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case creditallocated.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case creditallocated.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case creditallocated.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CreditAllocated numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreditAllocatedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(creditallocated.FieldAppID) {
		fields = append(fields, creditallocated.FieldAppID)
	}
	if m.FieldCleared(creditallocated.FieldUserID) {
		fields = append(fields, creditallocated.FieldUserID)
	}
	if m.FieldCleared(creditallocated.FieldValue) {
		fields = append(fields, creditallocated.FieldValue)
	}
	if m.FieldCleared(creditallocated.FieldExtra) {
		fields = append(fields, creditallocated.FieldExtra)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreditAllocatedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreditAllocatedMutation) ClearField(name string) error {
	switch name {
	case creditallocated.FieldAppID:
		m.ClearAppID()
		return nil
	case creditallocated.FieldUserID:
		m.ClearUserID()
		return nil
	case creditallocated.FieldValue:
		m.ClearValue()
		return nil
	case creditallocated.FieldExtra:
		m.ClearExtra()
		return nil
	}
	return fmt.Errorf("unknown CreditAllocated nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreditAllocatedMutation) ResetField(name string) error {
	switch name {
	case creditallocated.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case creditallocated.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case creditallocated.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case creditallocated.FieldEntID:
		m.ResetEntID()
		return nil
	case creditallocated.FieldAppID:
		m.ResetAppID()
		return nil
	case creditallocated.FieldUserID:
		m.ResetUserID()
		return nil
	case creditallocated.FieldValue:
		m.ResetValue()
		return nil
	case creditallocated.FieldExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown CreditAllocated field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreditAllocatedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreditAllocatedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreditAllocatedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreditAllocatedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreditAllocatedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreditAllocatedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreditAllocatedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CreditAllocated unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreditAllocatedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CreditAllocated edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	ent_id             *uuid.UUID
	app_id             *uuid.UUID
	event_type         *string
	credits            *decimal.Decimal
	credits_per_usd    *decimal.Decimal
	max_consecutive    *uint32
	addmax_consecutive *int32
	good_id            *uuid.UUID
	app_good_id        *uuid.UUID
	inviter_layers     *uint32
	addinviter_layers  *int32
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Event, error)
	predicates         []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id uint32) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *EventMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EventMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *EventMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EventMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *EventMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *EventMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *EventMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *EventMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *EventMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *EventMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *EventMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *EventMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[event.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *EventMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[event.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *EventMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, event.FieldAppID)
}

// SetEventType sets the "event_type" field.
func (m *EventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *EventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ClearEventType clears the value of the "event_type" field.
func (m *EventMutation) ClearEventType() {
	m.event_type = nil
	m.clearedFields[event.FieldEventType] = struct{}{}
}

// EventTypeCleared returns if the "event_type" field was cleared in this mutation.
func (m *EventMutation) EventTypeCleared() bool {
	_, ok := m.clearedFields[event.FieldEventType]
	return ok
}

// ResetEventType resets all changes to the "event_type" field.
func (m *EventMutation) ResetEventType() {
	m.event_type = nil
	delete(m.clearedFields, event.FieldEventType)
}

// SetCredits sets the "credits" field.
func (m *EventMutation) SetCredits(d decimal.Decimal) {
	m.credits = &d
}

// Credits returns the value of the "credits" field in the mutation.
func (m *EventMutation) Credits() (r decimal.Decimal, exists bool) {
	v := m.credits
	if v == nil {
		return
	}
	return *v, true
}

// OldCredits returns the old "credits" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCredits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredits: %w", err)
	}
	return oldValue.Credits, nil
}

// ClearCredits clears the value of the "credits" field.
func (m *EventMutation) ClearCredits() {
	m.credits = nil
	m.clearedFields[event.FieldCredits] = struct{}{}
}

// CreditsCleared returns if the "credits" field was cleared in this mutation.
func (m *EventMutation) CreditsCleared() bool {
	_, ok := m.clearedFields[event.FieldCredits]
	return ok
}

// ResetCredits resets all changes to the "credits" field.
func (m *EventMutation) ResetCredits() {
	m.credits = nil
	delete(m.clearedFields, event.FieldCredits)
}

// SetCreditsPerUsd sets the "credits_per_usd" field.
func (m *EventMutation) SetCreditsPerUsd(d decimal.Decimal) {
	m.credits_per_usd = &d
}

// CreditsPerUsd returns the value of the "credits_per_usd" field in the mutation.
func (m *EventMutation) CreditsPerUsd() (r decimal.Decimal, exists bool) {
	v := m.credits_per_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditsPerUsd returns the old "credits_per_usd" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreditsPerUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditsPerUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditsPerUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditsPerUsd: %w", err)
	}
	return oldValue.CreditsPerUsd, nil
}

// ClearCreditsPerUsd clears the value of the "credits_per_usd" field.
func (m *EventMutation) ClearCreditsPerUsd() {
	m.credits_per_usd = nil
	m.clearedFields[event.FieldCreditsPerUsd] = struct{}{}
}

// CreditsPerUsdCleared returns if the "credits_per_usd" field was cleared in this mutation.
func (m *EventMutation) CreditsPerUsdCleared() bool {
	_, ok := m.clearedFields[event.FieldCreditsPerUsd]
	return ok
}

// ResetCreditsPerUsd resets all changes to the "credits_per_usd" field.
func (m *EventMutation) ResetCreditsPerUsd() {
	m.credits_per_usd = nil
	delete(m.clearedFields, event.FieldCreditsPerUsd)
}

// SetMaxConsecutive sets the "max_consecutive" field.
func (m *EventMutation) SetMaxConsecutive(u uint32) {
	m.max_consecutive = &u
	m.addmax_consecutive = nil
}

// MaxConsecutive returns the value of the "max_consecutive" field in the mutation.
func (m *EventMutation) MaxConsecutive() (r uint32, exists bool) {
	v := m.max_consecutive
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxConsecutive returns the old "max_consecutive" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMaxConsecutive(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxConsecutive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxConsecutive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxConsecutive: %w", err)
	}
	return oldValue.MaxConsecutive, nil
}

// AddMaxConsecutive adds u to the "max_consecutive" field.
func (m *EventMutation) AddMaxConsecutive(u int32) {
	if m.addmax_consecutive != nil {
		*m.addmax_consecutive += u
	} else {
		m.addmax_consecutive = &u
	}
}

// AddedMaxConsecutive returns the value that was added to the "max_consecutive" field in this mutation.
func (m *EventMutation) AddedMaxConsecutive() (r int32, exists bool) {
	v := m.addmax_consecutive
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxConsecutive clears the value of the "max_consecutive" field.
func (m *EventMutation) ClearMaxConsecutive() {
	m.max_consecutive = nil
	m.addmax_consecutive = nil
	m.clearedFields[event.FieldMaxConsecutive] = struct{}{}
}

// MaxConsecutiveCleared returns if the "max_consecutive" field was cleared in this mutation.
func (m *EventMutation) MaxConsecutiveCleared() bool {
	_, ok := m.clearedFields[event.FieldMaxConsecutive]
	return ok
}

// ResetMaxConsecutive resets all changes to the "max_consecutive" field.
func (m *EventMutation) ResetMaxConsecutive() {
	m.max_consecutive = nil
	m.addmax_consecutive = nil
	delete(m.clearedFields, event.FieldMaxConsecutive)
}

// SetGoodID sets the "good_id" field.
func (m *EventMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *EventMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *EventMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[event.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *EventMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[event.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *EventMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, event.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *EventMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *EventMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *EventMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[event.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *EventMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[event.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *EventMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, event.FieldAppGoodID)
}

// SetInviterLayers sets the "inviter_layers" field.
func (m *EventMutation) SetInviterLayers(u uint32) {
	m.inviter_layers = &u
	m.addinviter_layers = nil
}

// InviterLayers returns the value of the "inviter_layers" field in the mutation.
func (m *EventMutation) InviterLayers() (r uint32, exists bool) {
	v := m.inviter_layers
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterLayers returns the old "inviter_layers" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldInviterLayers(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterLayers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterLayers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterLayers: %w", err)
	}
	return oldValue.InviterLayers, nil
}

// AddInviterLayers adds u to the "inviter_layers" field.
func (m *EventMutation) AddInviterLayers(u int32) {
	if m.addinviter_layers != nil {
		*m.addinviter_layers += u
	} else {
		m.addinviter_layers = &u
	}
}

// AddedInviterLayers returns the value that was added to the "inviter_layers" field in this mutation.
func (m *EventMutation) AddedInviterLayers() (r int32, exists bool) {
	v := m.addinviter_layers
	if v == nil {
		return
	}
	return *v, true
}

// ClearInviterLayers clears the value of the "inviter_layers" field.
func (m *EventMutation) ClearInviterLayers() {
	m.inviter_layers = nil
	m.addinviter_layers = nil
	m.clearedFields[event.FieldInviterLayers] = struct{}{}
}

// InviterLayersCleared returns if the "inviter_layers" field was cleared in this mutation.
func (m *EventMutation) InviterLayersCleared() bool {
	_, ok := m.clearedFields[event.FieldInviterLayers]
	return ok
}

// ResetInviterLayers resets all changes to the "inviter_layers" field.
func (m *EventMutation) ResetInviterLayers() {
	m.inviter_layers = nil
	m.addinviter_layers = nil
	delete(m.clearedFields, event.FieldInviterLayers)
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, event.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, event.FieldAppID)
	}
	if m.event_type != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.credits != nil {
		fields = append(fields, event.FieldCredits)
	}
	if m.credits_per_usd != nil {
		fields = append(fields, event.FieldCreditsPerUsd)
	}
	if m.max_consecutive != nil {
		fields = append(fields, event.FieldMaxConsecutive)
	}
	if m.good_id != nil {
		fields = append(fields, event.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, event.FieldAppGoodID)
	}
	if m.inviter_layers != nil {
		fields = append(fields, event.FieldInviterLayers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldDeletedAt:
		return m.DeletedAt()
	case event.FieldEntID:
		return m.EntID()
	case event.FieldAppID:
		return m.AppID()
	case event.FieldEventType:
		return m.EventType()
	case event.FieldCredits:
		return m.Credits()
	case event.FieldCreditsPerUsd:
		return m.CreditsPerUsd()
	case event.FieldMaxConsecutive:
		return m.MaxConsecutive()
	case event.FieldGoodID:
		return m.GoodID()
	case event.FieldAppGoodID:
		return m.AppGoodID()
	case event.FieldInviterLayers:
		return m.InviterLayers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case event.FieldEntID:
		return m.OldEntID(ctx)
	case event.FieldAppID:
		return m.OldAppID(ctx)
	case event.FieldEventType:
		return m.OldEventType(ctx)
	case event.FieldCredits:
		return m.OldCredits(ctx)
	case event.FieldCreditsPerUsd:
		return m.OldCreditsPerUsd(ctx)
	case event.FieldMaxConsecutive:
		return m.OldMaxConsecutive(ctx)
	case event.FieldGoodID:
		return m.OldGoodID(ctx)
	case event.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case event.FieldInviterLayers:
		return m.OldInviterLayers(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case event.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case event.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case event.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case event.FieldCredits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredits(v)
		return nil
	case event.FieldCreditsPerUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditsPerUsd(v)
		return nil
	case event.FieldMaxConsecutive:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxConsecutive(v)
		return nil
	case event.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case event.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case event.FieldInviterLayers:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterLayers(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.addmax_consecutive != nil {
		fields = append(fields, event.FieldMaxConsecutive)
	}
	if m.addinviter_layers != nil {
		fields = append(fields, event.FieldInviterLayers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.AddedCreatedAt()
	case event.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case event.FieldDeletedAt:
		return m.AddedDeletedAt()
	case event.FieldMaxConsecutive:
		return m.AddedMaxConsecutive()
	case event.FieldInviterLayers:
		return m.AddedInviterLayers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case event.FieldMaxConsecutive:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxConsecutive(v)
		return nil
	case event.FieldInviterLayers:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInviterLayers(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldAppID) {
		fields = append(fields, event.FieldAppID)
	}
	if m.FieldCleared(event.FieldEventType) {
		fields = append(fields, event.FieldEventType)
	}
	if m.FieldCleared(event.FieldCredits) {
		fields = append(fields, event.FieldCredits)
	}
	if m.FieldCleared(event.FieldCreditsPerUsd) {
		fields = append(fields, event.FieldCreditsPerUsd)
	}
	if m.FieldCleared(event.FieldMaxConsecutive) {
		fields = append(fields, event.FieldMaxConsecutive)
	}
	if m.FieldCleared(event.FieldGoodID) {
		fields = append(fields, event.FieldGoodID)
	}
	if m.FieldCleared(event.FieldAppGoodID) {
		fields = append(fields, event.FieldAppGoodID)
	}
	if m.FieldCleared(event.FieldInviterLayers) {
		fields = append(fields, event.FieldInviterLayers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldAppID:
		m.ClearAppID()
		return nil
	case event.FieldEventType:
		m.ClearEventType()
		return nil
	case event.FieldCredits:
		m.ClearCredits()
		return nil
	case event.FieldCreditsPerUsd:
		m.ClearCreditsPerUsd()
		return nil
	case event.FieldMaxConsecutive:
		m.ClearMaxConsecutive()
		return nil
	case event.FieldGoodID:
		m.ClearGoodID()
		return nil
	case event.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case event.FieldInviterLayers:
		m.ClearInviterLayers()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case event.FieldEntID:
		m.ResetEntID()
		return nil
	case event.FieldAppID:
		m.ResetAppID()
		return nil
	case event.FieldEventType:
		m.ResetEventType()
		return nil
	case event.FieldCredits:
		m.ResetCredits()
		return nil
	case event.FieldCreditsPerUsd:
		m.ResetCreditsPerUsd()
		return nil
	case event.FieldMaxConsecutive:
		m.ResetMaxConsecutive()
		return nil
	case event.FieldGoodID:
		m.ResetGoodID()
		return nil
	case event.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case event.FieldInviterLayers:
		m.ResetInviterLayers()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventCoinMutation represents an operation that mutates the EventCoin nodes in the graph.
type EventCoinMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	ent_id         *uuid.UUID
	app_id         *uuid.UUID
	event_id       *uuid.UUID
	coin_config_id *uuid.UUID
	coin_value     *decimal.Decimal
	coin_per_usd   *decimal.Decimal
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*EventCoin, error)
	predicates     []predicate.EventCoin
}

var _ ent.Mutation = (*EventCoinMutation)(nil)

// eventcoinOption allows management of the mutation configuration using functional options.
type eventcoinOption func(*EventCoinMutation)

// newEventCoinMutation creates new mutation for the EventCoin entity.
func newEventCoinMutation(c config, op Op, opts ...eventcoinOption) *EventCoinMutation {
	m := &EventCoinMutation{
		config:        c,
		op:            op,
		typ:           TypeEventCoin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventCoinID sets the ID field of the mutation.
func withEventCoinID(id uint32) eventcoinOption {
	return func(m *EventCoinMutation) {
		var (
			err   error
			once  sync.Once
			value *EventCoin
		)
		m.oldValue = func(ctx context.Context) (*EventCoin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventCoin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventCoin sets the old EventCoin of the mutation.
func withEventCoin(node *EventCoin) eventcoinOption {
	return func(m *EventCoinMutation) {
		m.oldValue = func(context.Context) (*EventCoin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventCoinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventCoinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventCoin entities.
func (m *EventCoinMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventCoinMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventCoinMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventCoin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventCoinMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventCoinMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *EventCoinMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EventCoinMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventCoinMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventCoinMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventCoinMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *EventCoinMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EventCoinMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventCoinMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventCoinMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventCoinMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *EventCoinMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *EventCoinMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventCoinMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *EventCoinMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *EventCoinMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *EventCoinMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *EventCoinMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *EventCoinMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *EventCoinMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[eventcoin.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *EventCoinMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[eventcoin.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *EventCoinMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, eventcoin.FieldAppID)
}

// SetEventID sets the "event_id" field.
func (m *EventCoinMutation) SetEventID(u uuid.UUID) {
	m.event_id = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventCoinMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ClearEventID clears the value of the "event_id" field.
func (m *EventCoinMutation) ClearEventID() {
	m.event_id = nil
	m.clearedFields[eventcoin.FieldEventID] = struct{}{}
}

// EventIDCleared returns if the "event_id" field was cleared in this mutation.
func (m *EventCoinMutation) EventIDCleared() bool {
	_, ok := m.clearedFields[eventcoin.FieldEventID]
	return ok
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventCoinMutation) ResetEventID() {
	m.event_id = nil
	delete(m.clearedFields, eventcoin.FieldEventID)
}

// SetCoinConfigID sets the "coin_config_id" field.
func (m *EventCoinMutation) SetCoinConfigID(u uuid.UUID) {
	m.coin_config_id = &u
}

// CoinConfigID returns the value of the "coin_config_id" field in the mutation.
func (m *EventCoinMutation) CoinConfigID() (r uuid.UUID, exists bool) {
	v := m.coin_config_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinConfigID returns the old "coin_config_id" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldCoinConfigID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinConfigID: %w", err)
	}
	return oldValue.CoinConfigID, nil
}

// ClearCoinConfigID clears the value of the "coin_config_id" field.
func (m *EventCoinMutation) ClearCoinConfigID() {
	m.coin_config_id = nil
	m.clearedFields[eventcoin.FieldCoinConfigID] = struct{}{}
}

// CoinConfigIDCleared returns if the "coin_config_id" field was cleared in this mutation.
func (m *EventCoinMutation) CoinConfigIDCleared() bool {
	_, ok := m.clearedFields[eventcoin.FieldCoinConfigID]
	return ok
}

// ResetCoinConfigID resets all changes to the "coin_config_id" field.
func (m *EventCoinMutation) ResetCoinConfigID() {
	m.coin_config_id = nil
	delete(m.clearedFields, eventcoin.FieldCoinConfigID)
}

// SetCoinValue sets the "coin_value" field.
func (m *EventCoinMutation) SetCoinValue(d decimal.Decimal) {
	m.coin_value = &d
}

// CoinValue returns the value of the "coin_value" field in the mutation.
func (m *EventCoinMutation) CoinValue() (r decimal.Decimal, exists bool) {
	v := m.coin_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinValue returns the old "coin_value" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldCoinValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinValue: %w", err)
	}
	return oldValue.CoinValue, nil
}

// ClearCoinValue clears the value of the "coin_value" field.
func (m *EventCoinMutation) ClearCoinValue() {
	m.coin_value = nil
	m.clearedFields[eventcoin.FieldCoinValue] = struct{}{}
}

// CoinValueCleared returns if the "coin_value" field was cleared in this mutation.
func (m *EventCoinMutation) CoinValueCleared() bool {
	_, ok := m.clearedFields[eventcoin.FieldCoinValue]
	return ok
}

// ResetCoinValue resets all changes to the "coin_value" field.
func (m *EventCoinMutation) ResetCoinValue() {
	m.coin_value = nil
	delete(m.clearedFields, eventcoin.FieldCoinValue)
}

// SetCoinPerUsd sets the "coin_per_usd" field.
func (m *EventCoinMutation) SetCoinPerUsd(d decimal.Decimal) {
	m.coin_per_usd = &d
}

// CoinPerUsd returns the value of the "coin_per_usd" field in the mutation.
func (m *EventCoinMutation) CoinPerUsd() (r decimal.Decimal, exists bool) {
	v := m.coin_per_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinPerUsd returns the old "coin_per_usd" field's value of the EventCoin entity.
// If the EventCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCoinMutation) OldCoinPerUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinPerUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinPerUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinPerUsd: %w", err)
	}
	return oldValue.CoinPerUsd, nil
}

// ClearCoinPerUsd clears the value of the "coin_per_usd" field.
func (m *EventCoinMutation) ClearCoinPerUsd() {
	m.coin_per_usd = nil
	m.clearedFields[eventcoin.FieldCoinPerUsd] = struct{}{}
}

// CoinPerUsdCleared returns if the "coin_per_usd" field was cleared in this mutation.
func (m *EventCoinMutation) CoinPerUsdCleared() bool {
	_, ok := m.clearedFields[eventcoin.FieldCoinPerUsd]
	return ok
}

// ResetCoinPerUsd resets all changes to the "coin_per_usd" field.
func (m *EventCoinMutation) ResetCoinPerUsd() {
	m.coin_per_usd = nil
	delete(m.clearedFields, eventcoin.FieldCoinPerUsd)
}

// Where appends a list predicates to the EventCoinMutation builder.
func (m *EventCoinMutation) Where(ps ...predicate.EventCoin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventCoinMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventCoinMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventCoin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventCoinMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventCoinMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventCoin).
func (m *EventCoinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventCoinMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, eventcoin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, eventcoin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, eventcoin.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, eventcoin.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, eventcoin.FieldAppID)
	}
	if m.event_id != nil {
		fields = append(fields, eventcoin.FieldEventID)
	}
	if m.coin_config_id != nil {
		fields = append(fields, eventcoin.FieldCoinConfigID)
	}
	if m.coin_value != nil {
		fields = append(fields, eventcoin.FieldCoinValue)
	}
	if m.coin_per_usd != nil {
		fields = append(fields, eventcoin.FieldCoinPerUsd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventCoinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventcoin.FieldCreatedAt:
		return m.CreatedAt()
	case eventcoin.FieldUpdatedAt:
		return m.UpdatedAt()
	case eventcoin.FieldDeletedAt:
		return m.DeletedAt()
	case eventcoin.FieldEntID:
		return m.EntID()
	case eventcoin.FieldAppID:
		return m.AppID()
	case eventcoin.FieldEventID:
		return m.EventID()
	case eventcoin.FieldCoinConfigID:
		return m.CoinConfigID()
	case eventcoin.FieldCoinValue:
		return m.CoinValue()
	case eventcoin.FieldCoinPerUsd:
		return m.CoinPerUsd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventCoinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventcoin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventcoin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case eventcoin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case eventcoin.FieldEntID:
		return m.OldEntID(ctx)
	case eventcoin.FieldAppID:
		return m.OldAppID(ctx)
	case eventcoin.FieldEventID:
		return m.OldEventID(ctx)
	case eventcoin.FieldCoinConfigID:
		return m.OldCoinConfigID(ctx)
	case eventcoin.FieldCoinValue:
		return m.OldCoinValue(ctx)
	case eventcoin.FieldCoinPerUsd:
		return m.OldCoinPerUsd(ctx)
	}
	return nil, fmt.Errorf("unknown EventCoin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventCoinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventcoin.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventcoin.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case eventcoin.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case eventcoin.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case eventcoin.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case eventcoin.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case eventcoin.FieldCoinConfigID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinConfigID(v)
		return nil
	case eventcoin.FieldCoinValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinValue(v)
		return nil
	case eventcoin.FieldCoinPerUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinPerUsd(v)
		return nil
	}
	return fmt.Errorf("unknown EventCoin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventCoinMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, eventcoin.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, eventcoin.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, eventcoin.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventCoinMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case eventcoin.FieldCreatedAt:
		return m.AddedCreatedAt()
	case eventcoin.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case eventcoin.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventCoinMutation) AddField(name string, value ent.Value) error {
	switch name {
	case eventcoin.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case eventcoin.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case eventcoin.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EventCoin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventCoinMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventcoin.FieldAppID) {
		fields = append(fields, eventcoin.FieldAppID)
	}
	if m.FieldCleared(eventcoin.FieldEventID) {
		fields = append(fields, eventcoin.FieldEventID)
	}
	if m.FieldCleared(eventcoin.FieldCoinConfigID) {
		fields = append(fields, eventcoin.FieldCoinConfigID)
	}
	if m.FieldCleared(eventcoin.FieldCoinValue) {
		fields = append(fields, eventcoin.FieldCoinValue)
	}
	if m.FieldCleared(eventcoin.FieldCoinPerUsd) {
		fields = append(fields, eventcoin.FieldCoinPerUsd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventCoinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventCoinMutation) ClearField(name string) error {
	switch name {
	case eventcoin.FieldAppID:
		m.ClearAppID()
		return nil
	case eventcoin.FieldEventID:
		m.ClearEventID()
		return nil
	case eventcoin.FieldCoinConfigID:
		m.ClearCoinConfigID()
		return nil
	case eventcoin.FieldCoinValue:
		m.ClearCoinValue()
		return nil
	case eventcoin.FieldCoinPerUsd:
		m.ClearCoinPerUsd()
		return nil
	}
	return fmt.Errorf("unknown EventCoin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventCoinMutation) ResetField(name string) error {
	switch name {
	case eventcoin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventcoin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case eventcoin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case eventcoin.FieldEntID:
		m.ResetEntID()
		return nil
	case eventcoin.FieldAppID:
		m.ResetAppID()
		return nil
	case eventcoin.FieldEventID:
		m.ResetEventID()
		return nil
	case eventcoin.FieldCoinConfigID:
		m.ResetCoinConfigID()
		return nil
	case eventcoin.FieldCoinValue:
		m.ResetCoinValue()
		return nil
	case eventcoin.FieldCoinPerUsd:
		m.ResetCoinPerUsd()
		return nil
	}
	return fmt.Errorf("unknown EventCoin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventCoinMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventCoinMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventCoinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventCoinMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventCoinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventCoinMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventCoinMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EventCoin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventCoinMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EventCoin edge %s", name)
}

// EventCouponMutation represents an operation that mutates the EventCoupon nodes in the graph.
type EventCouponMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	event_id      *uuid.UUID
	coupon_id     *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EventCoupon, error)
	predicates    []predicate.EventCoupon
}

var _ ent.Mutation = (*EventCouponMutation)(nil)

// eventcouponOption allows management of the mutation configuration using functional options.
type eventcouponOption func(*EventCouponMutation)

// newEventCouponMutation creates new mutation for the EventCoupon entity.
func newEventCouponMutation(c config, op Op, opts ...eventcouponOption) *EventCouponMutation {
	m := &EventCouponMutation{
		config:        c,
		op:            op,
		typ:           TypeEventCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventCouponID sets the ID field of the mutation.
func withEventCouponID(id uint32) eventcouponOption {
	return func(m *EventCouponMutation) {
		var (
			err   error
			once  sync.Once
			value *EventCoupon
		)
		m.oldValue = func(ctx context.Context) (*EventCoupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventCoupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventCoupon sets the old EventCoupon of the mutation.
func withEventCoupon(node *EventCoupon) eventcouponOption {
	return func(m *EventCouponMutation) {
		m.oldValue = func(context.Context) (*EventCoupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventCouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventCouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventCoupon entities.
func (m *EventCouponMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventCouponMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventCouponMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventCoupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventCouponMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventCouponMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventCoupon entity.
// If the EventCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCouponMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *EventCouponMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EventCouponMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventCouponMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventCouponMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventCouponMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EventCoupon entity.
// If the EventCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCouponMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *EventCouponMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EventCouponMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventCouponMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventCouponMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventCouponMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EventCoupon entity.
// If the EventCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCouponMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *EventCouponMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *EventCouponMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventCouponMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *EventCouponMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *EventCouponMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the EventCoupon entity.
// If the EventCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCouponMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *EventCouponMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *EventCouponMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *EventCouponMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the EventCoupon entity.
// If the EventCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCouponMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *EventCouponMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[eventcoupon.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *EventCouponMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[eventcoupon.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *EventCouponMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, eventcoupon.FieldAppID)
}

// SetEventID sets the "event_id" field.
func (m *EventCouponMutation) SetEventID(u uuid.UUID) {
	m.event_id = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventCouponMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the EventCoupon entity.
// If the EventCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCouponMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ClearEventID clears the value of the "event_id" field.
func (m *EventCouponMutation) ClearEventID() {
	m.event_id = nil
	m.clearedFields[eventcoupon.FieldEventID] = struct{}{}
}

// EventIDCleared returns if the "event_id" field was cleared in this mutation.
func (m *EventCouponMutation) EventIDCleared() bool {
	_, ok := m.clearedFields[eventcoupon.FieldEventID]
	return ok
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventCouponMutation) ResetEventID() {
	m.event_id = nil
	delete(m.clearedFields, eventcoupon.FieldEventID)
}

// SetCouponID sets the "coupon_id" field.
func (m *EventCouponMutation) SetCouponID(u uuid.UUID) {
	m.coupon_id = &u
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *EventCouponMutation) CouponID() (r uuid.UUID, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the EventCoupon entity.
// If the EventCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventCouponMutation) OldCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// ClearCouponID clears the value of the "coupon_id" field.
func (m *EventCouponMutation) ClearCouponID() {
	m.coupon_id = nil
	m.clearedFields[eventcoupon.FieldCouponID] = struct{}{}
}

// CouponIDCleared returns if the "coupon_id" field was cleared in this mutation.
func (m *EventCouponMutation) CouponIDCleared() bool {
	_, ok := m.clearedFields[eventcoupon.FieldCouponID]
	return ok
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *EventCouponMutation) ResetCouponID() {
	m.coupon_id = nil
	delete(m.clearedFields, eventcoupon.FieldCouponID)
}

// Where appends a list predicates to the EventCouponMutation builder.
func (m *EventCouponMutation) Where(ps ...predicate.EventCoupon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventCouponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventCouponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventCoupon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventCouponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventCouponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventCoupon).
func (m *EventCouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventCouponMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, eventcoupon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, eventcoupon.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, eventcoupon.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, eventcoupon.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, eventcoupon.FieldAppID)
	}
	if m.event_id != nil {
		fields = append(fields, eventcoupon.FieldEventID)
	}
	if m.coupon_id != nil {
		fields = append(fields, eventcoupon.FieldCouponID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventCouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventcoupon.FieldCreatedAt:
		return m.CreatedAt()
	case eventcoupon.FieldUpdatedAt:
		return m.UpdatedAt()
	case eventcoupon.FieldDeletedAt:
		return m.DeletedAt()
	case eventcoupon.FieldEntID:
		return m.EntID()
	case eventcoupon.FieldAppID:
		return m.AppID()
	case eventcoupon.FieldEventID:
		return m.EventID()
	case eventcoupon.FieldCouponID:
		return m.CouponID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventCouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventcoupon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventcoupon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case eventcoupon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case eventcoupon.FieldEntID:
		return m.OldEntID(ctx)
	case eventcoupon.FieldAppID:
		return m.OldAppID(ctx)
	case eventcoupon.FieldEventID:
		return m.OldEventID(ctx)
	case eventcoupon.FieldCouponID:
		return m.OldCouponID(ctx)
	}
	return nil, fmt.Errorf("unknown EventCoupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventCouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventcoupon.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventcoupon.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case eventcoupon.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case eventcoupon.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case eventcoupon.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case eventcoupon.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case eventcoupon.FieldCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	}
	return fmt.Errorf("unknown EventCoupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventCouponMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, eventcoupon.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, eventcoupon.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, eventcoupon.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventCouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case eventcoupon.FieldCreatedAt:
		return m.AddedCreatedAt()
	case eventcoupon.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case eventcoupon.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventCouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case eventcoupon.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case eventcoupon.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case eventcoupon.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EventCoupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventCouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventcoupon.FieldAppID) {
		fields = append(fields, eventcoupon.FieldAppID)
	}
	if m.FieldCleared(eventcoupon.FieldEventID) {
		fields = append(fields, eventcoupon.FieldEventID)
	}
	if m.FieldCleared(eventcoupon.FieldCouponID) {
		fields = append(fields, eventcoupon.FieldCouponID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventCouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventCouponMutation) ClearField(name string) error {
	switch name {
	case eventcoupon.FieldAppID:
		m.ClearAppID()
		return nil
	case eventcoupon.FieldEventID:
		m.ClearEventID()
		return nil
	case eventcoupon.FieldCouponID:
		m.ClearCouponID()
		return nil
	}
	return fmt.Errorf("unknown EventCoupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventCouponMutation) ResetField(name string) error {
	switch name {
	case eventcoupon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventcoupon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case eventcoupon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case eventcoupon.FieldEntID:
		m.ResetEntID()
		return nil
	case eventcoupon.FieldAppID:
		m.ResetAppID()
		return nil
	case eventcoupon.FieldEventID:
		m.ResetEventID()
		return nil
	case eventcoupon.FieldCouponID:
		m.ResetCouponID()
		return nil
	}
	return fmt.Errorf("unknown EventCoupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventCouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventCouponMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventCouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventCouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventCouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventCouponMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventCouponMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EventCoupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventCouponMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EventCoupon edge %s", name)
}

// GoodAchievementMutation represents an operation that mutates the GoodAchievement nodes in the graph.
type GoodAchievementMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	ent_id               *uuid.UUID
	app_id               *uuid.UUID
	user_id              *uuid.UUID
	good_id              *uuid.UUID
	app_good_id          *uuid.UUID
	total_units          *decimal.Decimal
	self_units           *decimal.Decimal
	total_amount_usd     *decimal.Decimal
	self_amount_usd      *decimal.Decimal
	total_commission_usd *decimal.Decimal
	self_commission_usd  *decimal.Decimal
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*GoodAchievement, error)
	predicates           []predicate.GoodAchievement
}

var _ ent.Mutation = (*GoodAchievementMutation)(nil)

// goodachievementOption allows management of the mutation configuration using functional options.
type goodachievementOption func(*GoodAchievementMutation)

// newGoodAchievementMutation creates new mutation for the GoodAchievement entity.
func newGoodAchievementMutation(c config, op Op, opts ...goodachievementOption) *GoodAchievementMutation {
	m := &GoodAchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodAchievementID sets the ID field of the mutation.
func withGoodAchievementID(id uint32) goodachievementOption {
	return func(m *GoodAchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodAchievement
		)
		m.oldValue = func(ctx context.Context) (*GoodAchievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodAchievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodAchievement sets the old GoodAchievement of the mutation.
func withGoodAchievement(node *GoodAchievement) goodachievementOption {
	return func(m *GoodAchievementMutation) {
		m.oldValue = func(context.Context) (*GoodAchievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodAchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodAchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodAchievement entities.
func (m *GoodAchievementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodAchievementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodAchievementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodAchievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodAchievementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodAchievementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodAchievementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodAchievementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodAchievementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodAchievementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodAchievementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodAchievementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodAchievementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodAchievementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodAchievementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodAchievementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodAchievementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodAchievementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodAchievementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *GoodAchievementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodAchievementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodAchievementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *GoodAchievementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *GoodAchievementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *GoodAchievementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[goodachievement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *GoodAchievementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *GoodAchievementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, goodachievement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *GoodAchievementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GoodAchievementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *GoodAchievementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[goodachievement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *GoodAchievementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GoodAchievementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, goodachievement.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *GoodAchievementMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodAchievementMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodAchievementMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodachievement.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodAchievementMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodAchievementMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodachievement.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *GoodAchievementMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *GoodAchievementMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *GoodAchievementMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[goodachievement.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *GoodAchievementMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *GoodAchievementMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, goodachievement.FieldAppGoodID)
}

// SetTotalUnits sets the "total_units" field.
func (m *GoodAchievementMutation) SetTotalUnits(d decimal.Decimal) {
	m.total_units = &d
}

// TotalUnits returns the value of the "total_units" field in the mutation.
func (m *GoodAchievementMutation) TotalUnits() (r decimal.Decimal, exists bool) {
	v := m.total_units
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnits returns the old "total_units" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldTotalUnits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnits: %w", err)
	}
	return oldValue.TotalUnits, nil
}

// ClearTotalUnits clears the value of the "total_units" field.
func (m *GoodAchievementMutation) ClearTotalUnits() {
	m.total_units = nil
	m.clearedFields[goodachievement.FieldTotalUnits] = struct{}{}
}

// TotalUnitsCleared returns if the "total_units" field was cleared in this mutation.
func (m *GoodAchievementMutation) TotalUnitsCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldTotalUnits]
	return ok
}

// ResetTotalUnits resets all changes to the "total_units" field.
func (m *GoodAchievementMutation) ResetTotalUnits() {
	m.total_units = nil
	delete(m.clearedFields, goodachievement.FieldTotalUnits)
}

// SetSelfUnits sets the "self_units" field.
func (m *GoodAchievementMutation) SetSelfUnits(d decimal.Decimal) {
	m.self_units = &d
}

// SelfUnits returns the value of the "self_units" field in the mutation.
func (m *GoodAchievementMutation) SelfUnits() (r decimal.Decimal, exists bool) {
	v := m.self_units
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfUnits returns the old "self_units" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldSelfUnits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfUnits: %w", err)
	}
	return oldValue.SelfUnits, nil
}

// ClearSelfUnits clears the value of the "self_units" field.
func (m *GoodAchievementMutation) ClearSelfUnits() {
	m.self_units = nil
	m.clearedFields[goodachievement.FieldSelfUnits] = struct{}{}
}

// SelfUnitsCleared returns if the "self_units" field was cleared in this mutation.
func (m *GoodAchievementMutation) SelfUnitsCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldSelfUnits]
	return ok
}

// ResetSelfUnits resets all changes to the "self_units" field.
func (m *GoodAchievementMutation) ResetSelfUnits() {
	m.self_units = nil
	delete(m.clearedFields, goodachievement.FieldSelfUnits)
}

// SetTotalAmountUsd sets the "total_amount_usd" field.
func (m *GoodAchievementMutation) SetTotalAmountUsd(d decimal.Decimal) {
	m.total_amount_usd = &d
}

// TotalAmountUsd returns the value of the "total_amount_usd" field in the mutation.
func (m *GoodAchievementMutation) TotalAmountUsd() (r decimal.Decimal, exists bool) {
	v := m.total_amount_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmountUsd returns the old "total_amount_usd" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldTotalAmountUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmountUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmountUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmountUsd: %w", err)
	}
	return oldValue.TotalAmountUsd, nil
}

// ClearTotalAmountUsd clears the value of the "total_amount_usd" field.
func (m *GoodAchievementMutation) ClearTotalAmountUsd() {
	m.total_amount_usd = nil
	m.clearedFields[goodachievement.FieldTotalAmountUsd] = struct{}{}
}

// TotalAmountUsdCleared returns if the "total_amount_usd" field was cleared in this mutation.
func (m *GoodAchievementMutation) TotalAmountUsdCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldTotalAmountUsd]
	return ok
}

// ResetTotalAmountUsd resets all changes to the "total_amount_usd" field.
func (m *GoodAchievementMutation) ResetTotalAmountUsd() {
	m.total_amount_usd = nil
	delete(m.clearedFields, goodachievement.FieldTotalAmountUsd)
}

// SetSelfAmountUsd sets the "self_amount_usd" field.
func (m *GoodAchievementMutation) SetSelfAmountUsd(d decimal.Decimal) {
	m.self_amount_usd = &d
}

// SelfAmountUsd returns the value of the "self_amount_usd" field in the mutation.
func (m *GoodAchievementMutation) SelfAmountUsd() (r decimal.Decimal, exists bool) {
	v := m.self_amount_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfAmountUsd returns the old "self_amount_usd" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldSelfAmountUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfAmountUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfAmountUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfAmountUsd: %w", err)
	}
	return oldValue.SelfAmountUsd, nil
}

// ClearSelfAmountUsd clears the value of the "self_amount_usd" field.
func (m *GoodAchievementMutation) ClearSelfAmountUsd() {
	m.self_amount_usd = nil
	m.clearedFields[goodachievement.FieldSelfAmountUsd] = struct{}{}
}

// SelfAmountUsdCleared returns if the "self_amount_usd" field was cleared in this mutation.
func (m *GoodAchievementMutation) SelfAmountUsdCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldSelfAmountUsd]
	return ok
}

// ResetSelfAmountUsd resets all changes to the "self_amount_usd" field.
func (m *GoodAchievementMutation) ResetSelfAmountUsd() {
	m.self_amount_usd = nil
	delete(m.clearedFields, goodachievement.FieldSelfAmountUsd)
}

// SetTotalCommissionUsd sets the "total_commission_usd" field.
func (m *GoodAchievementMutation) SetTotalCommissionUsd(d decimal.Decimal) {
	m.total_commission_usd = &d
}

// TotalCommissionUsd returns the value of the "total_commission_usd" field in the mutation.
func (m *GoodAchievementMutation) TotalCommissionUsd() (r decimal.Decimal, exists bool) {
	v := m.total_commission_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCommissionUsd returns the old "total_commission_usd" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldTotalCommissionUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCommissionUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCommissionUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCommissionUsd: %w", err)
	}
	return oldValue.TotalCommissionUsd, nil
}

// ClearTotalCommissionUsd clears the value of the "total_commission_usd" field.
func (m *GoodAchievementMutation) ClearTotalCommissionUsd() {
	m.total_commission_usd = nil
	m.clearedFields[goodachievement.FieldTotalCommissionUsd] = struct{}{}
}

// TotalCommissionUsdCleared returns if the "total_commission_usd" field was cleared in this mutation.
func (m *GoodAchievementMutation) TotalCommissionUsdCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldTotalCommissionUsd]
	return ok
}

// ResetTotalCommissionUsd resets all changes to the "total_commission_usd" field.
func (m *GoodAchievementMutation) ResetTotalCommissionUsd() {
	m.total_commission_usd = nil
	delete(m.clearedFields, goodachievement.FieldTotalCommissionUsd)
}

// SetSelfCommissionUsd sets the "self_commission_usd" field.
func (m *GoodAchievementMutation) SetSelfCommissionUsd(d decimal.Decimal) {
	m.self_commission_usd = &d
}

// SelfCommissionUsd returns the value of the "self_commission_usd" field in the mutation.
func (m *GoodAchievementMutation) SelfCommissionUsd() (r decimal.Decimal, exists bool) {
	v := m.self_commission_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfCommissionUsd returns the old "self_commission_usd" field's value of the GoodAchievement entity.
// If the GoodAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodAchievementMutation) OldSelfCommissionUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfCommissionUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfCommissionUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfCommissionUsd: %w", err)
	}
	return oldValue.SelfCommissionUsd, nil
}

// ClearSelfCommissionUsd clears the value of the "self_commission_usd" field.
func (m *GoodAchievementMutation) ClearSelfCommissionUsd() {
	m.self_commission_usd = nil
	m.clearedFields[goodachievement.FieldSelfCommissionUsd] = struct{}{}
}

// SelfCommissionUsdCleared returns if the "self_commission_usd" field was cleared in this mutation.
func (m *GoodAchievementMutation) SelfCommissionUsdCleared() bool {
	_, ok := m.clearedFields[goodachievement.FieldSelfCommissionUsd]
	return ok
}

// ResetSelfCommissionUsd resets all changes to the "self_commission_usd" field.
func (m *GoodAchievementMutation) ResetSelfCommissionUsd() {
	m.self_commission_usd = nil
	delete(m.clearedFields, goodachievement.FieldSelfCommissionUsd)
}

// Where appends a list predicates to the GoodAchievementMutation builder.
func (m *GoodAchievementMutation) Where(ps ...predicate.GoodAchievement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodAchievementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodAchievementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoodAchievement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodAchievementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodAchievementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoodAchievement).
func (m *GoodAchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodAchievementMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, goodachievement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodachievement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodachievement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, goodachievement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, goodachievement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, goodachievement.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, goodachievement.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, goodachievement.FieldAppGoodID)
	}
	if m.total_units != nil {
		fields = append(fields, goodachievement.FieldTotalUnits)
	}
	if m.self_units != nil {
		fields = append(fields, goodachievement.FieldSelfUnits)
	}
	if m.total_amount_usd != nil {
		fields = append(fields, goodachievement.FieldTotalAmountUsd)
	}
	if m.self_amount_usd != nil {
		fields = append(fields, goodachievement.FieldSelfAmountUsd)
	}
	if m.total_commission_usd != nil {
		fields = append(fields, goodachievement.FieldTotalCommissionUsd)
	}
	if m.self_commission_usd != nil {
		fields = append(fields, goodachievement.FieldSelfCommissionUsd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodAchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodachievement.FieldCreatedAt:
		return m.CreatedAt()
	case goodachievement.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodachievement.FieldDeletedAt:
		return m.DeletedAt()
	case goodachievement.FieldEntID:
		return m.EntID()
	case goodachievement.FieldAppID:
		return m.AppID()
	case goodachievement.FieldUserID:
		return m.UserID()
	case goodachievement.FieldGoodID:
		return m.GoodID()
	case goodachievement.FieldAppGoodID:
		return m.AppGoodID()
	case goodachievement.FieldTotalUnits:
		return m.TotalUnits()
	case goodachievement.FieldSelfUnits:
		return m.SelfUnits()
	case goodachievement.FieldTotalAmountUsd:
		return m.TotalAmountUsd()
	case goodachievement.FieldSelfAmountUsd:
		return m.SelfAmountUsd()
	case goodachievement.FieldTotalCommissionUsd:
		return m.TotalCommissionUsd()
	case goodachievement.FieldSelfCommissionUsd:
		return m.SelfCommissionUsd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodAchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodachievement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodachievement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodachievement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodachievement.FieldEntID:
		return m.OldEntID(ctx)
	case goodachievement.FieldAppID:
		return m.OldAppID(ctx)
	case goodachievement.FieldUserID:
		return m.OldUserID(ctx)
	case goodachievement.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodachievement.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case goodachievement.FieldTotalUnits:
		return m.OldTotalUnits(ctx)
	case goodachievement.FieldSelfUnits:
		return m.OldSelfUnits(ctx)
	case goodachievement.FieldTotalAmountUsd:
		return m.OldTotalAmountUsd(ctx)
	case goodachievement.FieldSelfAmountUsd:
		return m.OldSelfAmountUsd(ctx)
	case goodachievement.FieldTotalCommissionUsd:
		return m.OldTotalCommissionUsd(ctx)
	case goodachievement.FieldSelfCommissionUsd:
		return m.OldSelfCommissionUsd(ctx)
	}
	return nil, fmt.Errorf("unknown GoodAchievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodAchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodachievement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodachievement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodachievement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodachievement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodachievement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case goodachievement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case goodachievement.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodachievement.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case goodachievement.FieldTotalUnits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnits(v)
		return nil
	case goodachievement.FieldSelfUnits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfUnits(v)
		return nil
	case goodachievement.FieldTotalAmountUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmountUsd(v)
		return nil
	case goodachievement.FieldSelfAmountUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfAmountUsd(v)
		return nil
	case goodachievement.FieldTotalCommissionUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCommissionUsd(v)
		return nil
	case goodachievement.FieldSelfCommissionUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfCommissionUsd(v)
		return nil
	}
	return fmt.Errorf("unknown GoodAchievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodAchievementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodachievement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodachievement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodachievement.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodAchievementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodachievement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodachievement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodachievement.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodAchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodachievement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodachievement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodachievement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodAchievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodAchievementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodachievement.FieldAppID) {
		fields = append(fields, goodachievement.FieldAppID)
	}
	if m.FieldCleared(goodachievement.FieldUserID) {
		fields = append(fields, goodachievement.FieldUserID)
	}
	if m.FieldCleared(goodachievement.FieldGoodID) {
		fields = append(fields, goodachievement.FieldGoodID)
	}
	if m.FieldCleared(goodachievement.FieldAppGoodID) {
		fields = append(fields, goodachievement.FieldAppGoodID)
	}
	if m.FieldCleared(goodachievement.FieldTotalUnits) {
		fields = append(fields, goodachievement.FieldTotalUnits)
	}
	if m.FieldCleared(goodachievement.FieldSelfUnits) {
		fields = append(fields, goodachievement.FieldSelfUnits)
	}
	if m.FieldCleared(goodachievement.FieldTotalAmountUsd) {
		fields = append(fields, goodachievement.FieldTotalAmountUsd)
	}
	if m.FieldCleared(goodachievement.FieldSelfAmountUsd) {
		fields = append(fields, goodachievement.FieldSelfAmountUsd)
	}
	if m.FieldCleared(goodachievement.FieldTotalCommissionUsd) {
		fields = append(fields, goodachievement.FieldTotalCommissionUsd)
	}
	if m.FieldCleared(goodachievement.FieldSelfCommissionUsd) {
		fields = append(fields, goodachievement.FieldSelfCommissionUsd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodAchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodAchievementMutation) ClearField(name string) error {
	switch name {
	case goodachievement.FieldAppID:
		m.ClearAppID()
		return nil
	case goodachievement.FieldUserID:
		m.ClearUserID()
		return nil
	case goodachievement.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodachievement.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case goodachievement.FieldTotalUnits:
		m.ClearTotalUnits()
		return nil
	case goodachievement.FieldSelfUnits:
		m.ClearSelfUnits()
		return nil
	case goodachievement.FieldTotalAmountUsd:
		m.ClearTotalAmountUsd()
		return nil
	case goodachievement.FieldSelfAmountUsd:
		m.ClearSelfAmountUsd()
		return nil
	case goodachievement.FieldTotalCommissionUsd:
		m.ClearTotalCommissionUsd()
		return nil
	case goodachievement.FieldSelfCommissionUsd:
		m.ClearSelfCommissionUsd()
		return nil
	}
	return fmt.Errorf("unknown GoodAchievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodAchievementMutation) ResetField(name string) error {
	switch name {
	case goodachievement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodachievement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodachievement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodachievement.FieldEntID:
		m.ResetEntID()
		return nil
	case goodachievement.FieldAppID:
		m.ResetAppID()
		return nil
	case goodachievement.FieldUserID:
		m.ResetUserID()
		return nil
	case goodachievement.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodachievement.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case goodachievement.FieldTotalUnits:
		m.ResetTotalUnits()
		return nil
	case goodachievement.FieldSelfUnits:
		m.ResetSelfUnits()
		return nil
	case goodachievement.FieldTotalAmountUsd:
		m.ResetTotalAmountUsd()
		return nil
	case goodachievement.FieldSelfAmountUsd:
		m.ResetSelfAmountUsd()
		return nil
	case goodachievement.FieldTotalCommissionUsd:
		m.ResetTotalCommissionUsd()
		return nil
	case goodachievement.FieldSelfCommissionUsd:
		m.ResetSelfCommissionUsd()
		return nil
	}
	return fmt.Errorf("unknown GoodAchievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodAchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodAchievementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodAchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodAchievementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodAchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodAchievementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodAchievementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodAchievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodAchievementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodAchievement edge %s", name)
}

// GoodCoinAchievementMutation represents an operation that mutates the GoodCoinAchievement nodes in the graph.
type GoodCoinAchievementMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	ent_id               *uuid.UUID
	app_id               *uuid.UUID
	user_id              *uuid.UUID
	good_coin_type_id    *uuid.UUID
	total_units          *decimal.Decimal
	self_units           *decimal.Decimal
	total_amount_usd     *decimal.Decimal
	self_amount_usd      *decimal.Decimal
	total_commission_usd *decimal.Decimal
	self_commission_usd  *decimal.Decimal
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*GoodCoinAchievement, error)
	predicates           []predicate.GoodCoinAchievement
}

var _ ent.Mutation = (*GoodCoinAchievementMutation)(nil)

// goodcoinachievementOption allows management of the mutation configuration using functional options.
type goodcoinachievementOption func(*GoodCoinAchievementMutation)

// newGoodCoinAchievementMutation creates new mutation for the GoodCoinAchievement entity.
func newGoodCoinAchievementMutation(c config, op Op, opts ...goodcoinachievementOption) *GoodCoinAchievementMutation {
	m := &GoodCoinAchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodCoinAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodCoinAchievementID sets the ID field of the mutation.
func withGoodCoinAchievementID(id uint32) goodcoinachievementOption {
	return func(m *GoodCoinAchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodCoinAchievement
		)
		m.oldValue = func(ctx context.Context) (*GoodCoinAchievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodCoinAchievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodCoinAchievement sets the old GoodCoinAchievement of the mutation.
func withGoodCoinAchievement(node *GoodCoinAchievement) goodcoinachievementOption {
	return func(m *GoodCoinAchievementMutation) {
		m.oldValue = func(context.Context) (*GoodCoinAchievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodCoinAchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodCoinAchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodCoinAchievement entities.
func (m *GoodCoinAchievementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodCoinAchievementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodCoinAchievementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodCoinAchievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodCoinAchievementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodCoinAchievementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodCoinAchievementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodCoinAchievementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodCoinAchievementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodCoinAchievementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodCoinAchievementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodCoinAchievementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodCoinAchievementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodCoinAchievementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodCoinAchievementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodCoinAchievementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodCoinAchievementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodCoinAchievementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodCoinAchievementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *GoodCoinAchievementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodCoinAchievementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodCoinAchievementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *GoodCoinAchievementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *GoodCoinAchievementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *GoodCoinAchievementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[goodcoinachievement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *GoodCoinAchievementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, goodcoinachievement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *GoodCoinAchievementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GoodCoinAchievementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *GoodCoinAchievementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[goodcoinachievement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GoodCoinAchievementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, goodcoinachievement.FieldUserID)
}

// SetGoodCoinTypeID sets the "good_coin_type_id" field.
func (m *GoodCoinAchievementMutation) SetGoodCoinTypeID(u uuid.UUID) {
	m.good_coin_type_id = &u
}

// GoodCoinTypeID returns the value of the "good_coin_type_id" field in the mutation.
func (m *GoodCoinAchievementMutation) GoodCoinTypeID() (r uuid.UUID, exists bool) {
	v := m.good_coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodCoinTypeID returns the old "good_coin_type_id" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldGoodCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodCoinTypeID: %w", err)
	}
	return oldValue.GoodCoinTypeID, nil
}

// ClearGoodCoinTypeID clears the value of the "good_coin_type_id" field.
func (m *GoodCoinAchievementMutation) ClearGoodCoinTypeID() {
	m.good_coin_type_id = nil
	m.clearedFields[goodcoinachievement.FieldGoodCoinTypeID] = struct{}{}
}

// GoodCoinTypeIDCleared returns if the "good_coin_type_id" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) GoodCoinTypeIDCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldGoodCoinTypeID]
	return ok
}

// ResetGoodCoinTypeID resets all changes to the "good_coin_type_id" field.
func (m *GoodCoinAchievementMutation) ResetGoodCoinTypeID() {
	m.good_coin_type_id = nil
	delete(m.clearedFields, goodcoinachievement.FieldGoodCoinTypeID)
}

// SetTotalUnits sets the "total_units" field.
func (m *GoodCoinAchievementMutation) SetTotalUnits(d decimal.Decimal) {
	m.total_units = &d
}

// TotalUnits returns the value of the "total_units" field in the mutation.
func (m *GoodCoinAchievementMutation) TotalUnits() (r decimal.Decimal, exists bool) {
	v := m.total_units
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnits returns the old "total_units" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldTotalUnits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnits: %w", err)
	}
	return oldValue.TotalUnits, nil
}

// ClearTotalUnits clears the value of the "total_units" field.
func (m *GoodCoinAchievementMutation) ClearTotalUnits() {
	m.total_units = nil
	m.clearedFields[goodcoinachievement.FieldTotalUnits] = struct{}{}
}

// TotalUnitsCleared returns if the "total_units" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) TotalUnitsCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldTotalUnits]
	return ok
}

// ResetTotalUnits resets all changes to the "total_units" field.
func (m *GoodCoinAchievementMutation) ResetTotalUnits() {
	m.total_units = nil
	delete(m.clearedFields, goodcoinachievement.FieldTotalUnits)
}

// SetSelfUnits sets the "self_units" field.
func (m *GoodCoinAchievementMutation) SetSelfUnits(d decimal.Decimal) {
	m.self_units = &d
}

// SelfUnits returns the value of the "self_units" field in the mutation.
func (m *GoodCoinAchievementMutation) SelfUnits() (r decimal.Decimal, exists bool) {
	v := m.self_units
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfUnits returns the old "self_units" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldSelfUnits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfUnits: %w", err)
	}
	return oldValue.SelfUnits, nil
}

// ClearSelfUnits clears the value of the "self_units" field.
func (m *GoodCoinAchievementMutation) ClearSelfUnits() {
	m.self_units = nil
	m.clearedFields[goodcoinachievement.FieldSelfUnits] = struct{}{}
}

// SelfUnitsCleared returns if the "self_units" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) SelfUnitsCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldSelfUnits]
	return ok
}

// ResetSelfUnits resets all changes to the "self_units" field.
func (m *GoodCoinAchievementMutation) ResetSelfUnits() {
	m.self_units = nil
	delete(m.clearedFields, goodcoinachievement.FieldSelfUnits)
}

// SetTotalAmountUsd sets the "total_amount_usd" field.
func (m *GoodCoinAchievementMutation) SetTotalAmountUsd(d decimal.Decimal) {
	m.total_amount_usd = &d
}

// TotalAmountUsd returns the value of the "total_amount_usd" field in the mutation.
func (m *GoodCoinAchievementMutation) TotalAmountUsd() (r decimal.Decimal, exists bool) {
	v := m.total_amount_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmountUsd returns the old "total_amount_usd" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldTotalAmountUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmountUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmountUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmountUsd: %w", err)
	}
	return oldValue.TotalAmountUsd, nil
}

// ClearTotalAmountUsd clears the value of the "total_amount_usd" field.
func (m *GoodCoinAchievementMutation) ClearTotalAmountUsd() {
	m.total_amount_usd = nil
	m.clearedFields[goodcoinachievement.FieldTotalAmountUsd] = struct{}{}
}

// TotalAmountUsdCleared returns if the "total_amount_usd" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) TotalAmountUsdCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldTotalAmountUsd]
	return ok
}

// ResetTotalAmountUsd resets all changes to the "total_amount_usd" field.
func (m *GoodCoinAchievementMutation) ResetTotalAmountUsd() {
	m.total_amount_usd = nil
	delete(m.clearedFields, goodcoinachievement.FieldTotalAmountUsd)
}

// SetSelfAmountUsd sets the "self_amount_usd" field.
func (m *GoodCoinAchievementMutation) SetSelfAmountUsd(d decimal.Decimal) {
	m.self_amount_usd = &d
}

// SelfAmountUsd returns the value of the "self_amount_usd" field in the mutation.
func (m *GoodCoinAchievementMutation) SelfAmountUsd() (r decimal.Decimal, exists bool) {
	v := m.self_amount_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfAmountUsd returns the old "self_amount_usd" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldSelfAmountUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfAmountUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfAmountUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfAmountUsd: %w", err)
	}
	return oldValue.SelfAmountUsd, nil
}

// ClearSelfAmountUsd clears the value of the "self_amount_usd" field.
func (m *GoodCoinAchievementMutation) ClearSelfAmountUsd() {
	m.self_amount_usd = nil
	m.clearedFields[goodcoinachievement.FieldSelfAmountUsd] = struct{}{}
}

// SelfAmountUsdCleared returns if the "self_amount_usd" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) SelfAmountUsdCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldSelfAmountUsd]
	return ok
}

// ResetSelfAmountUsd resets all changes to the "self_amount_usd" field.
func (m *GoodCoinAchievementMutation) ResetSelfAmountUsd() {
	m.self_amount_usd = nil
	delete(m.clearedFields, goodcoinachievement.FieldSelfAmountUsd)
}

// SetTotalCommissionUsd sets the "total_commission_usd" field.
func (m *GoodCoinAchievementMutation) SetTotalCommissionUsd(d decimal.Decimal) {
	m.total_commission_usd = &d
}

// TotalCommissionUsd returns the value of the "total_commission_usd" field in the mutation.
func (m *GoodCoinAchievementMutation) TotalCommissionUsd() (r decimal.Decimal, exists bool) {
	v := m.total_commission_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCommissionUsd returns the old "total_commission_usd" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldTotalCommissionUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCommissionUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCommissionUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCommissionUsd: %w", err)
	}
	return oldValue.TotalCommissionUsd, nil
}

// ClearTotalCommissionUsd clears the value of the "total_commission_usd" field.
func (m *GoodCoinAchievementMutation) ClearTotalCommissionUsd() {
	m.total_commission_usd = nil
	m.clearedFields[goodcoinachievement.FieldTotalCommissionUsd] = struct{}{}
}

// TotalCommissionUsdCleared returns if the "total_commission_usd" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) TotalCommissionUsdCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldTotalCommissionUsd]
	return ok
}

// ResetTotalCommissionUsd resets all changes to the "total_commission_usd" field.
func (m *GoodCoinAchievementMutation) ResetTotalCommissionUsd() {
	m.total_commission_usd = nil
	delete(m.clearedFields, goodcoinachievement.FieldTotalCommissionUsd)
}

// SetSelfCommissionUsd sets the "self_commission_usd" field.
func (m *GoodCoinAchievementMutation) SetSelfCommissionUsd(d decimal.Decimal) {
	m.self_commission_usd = &d
}

// SelfCommissionUsd returns the value of the "self_commission_usd" field in the mutation.
func (m *GoodCoinAchievementMutation) SelfCommissionUsd() (r decimal.Decimal, exists bool) {
	v := m.self_commission_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfCommissionUsd returns the old "self_commission_usd" field's value of the GoodCoinAchievement entity.
// If the GoodCoinAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinAchievementMutation) OldSelfCommissionUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfCommissionUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfCommissionUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfCommissionUsd: %w", err)
	}
	return oldValue.SelfCommissionUsd, nil
}

// ClearSelfCommissionUsd clears the value of the "self_commission_usd" field.
func (m *GoodCoinAchievementMutation) ClearSelfCommissionUsd() {
	m.self_commission_usd = nil
	m.clearedFields[goodcoinachievement.FieldSelfCommissionUsd] = struct{}{}
}

// SelfCommissionUsdCleared returns if the "self_commission_usd" field was cleared in this mutation.
func (m *GoodCoinAchievementMutation) SelfCommissionUsdCleared() bool {
	_, ok := m.clearedFields[goodcoinachievement.FieldSelfCommissionUsd]
	return ok
}

// ResetSelfCommissionUsd resets all changes to the "self_commission_usd" field.
func (m *GoodCoinAchievementMutation) ResetSelfCommissionUsd() {
	m.self_commission_usd = nil
	delete(m.clearedFields, goodcoinachievement.FieldSelfCommissionUsd)
}

// Where appends a list predicates to the GoodCoinAchievementMutation builder.
func (m *GoodCoinAchievementMutation) Where(ps ...predicate.GoodCoinAchievement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodCoinAchievementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodCoinAchievementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoodCoinAchievement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodCoinAchievementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodCoinAchievementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoodCoinAchievement).
func (m *GoodCoinAchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodCoinAchievementMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, goodcoinachievement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodcoinachievement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodcoinachievement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, goodcoinachievement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, goodcoinachievement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, goodcoinachievement.FieldUserID)
	}
	if m.good_coin_type_id != nil {
		fields = append(fields, goodcoinachievement.FieldGoodCoinTypeID)
	}
	if m.total_units != nil {
		fields = append(fields, goodcoinachievement.FieldTotalUnits)
	}
	if m.self_units != nil {
		fields = append(fields, goodcoinachievement.FieldSelfUnits)
	}
	if m.total_amount_usd != nil {
		fields = append(fields, goodcoinachievement.FieldTotalAmountUsd)
	}
	if m.self_amount_usd != nil {
		fields = append(fields, goodcoinachievement.FieldSelfAmountUsd)
	}
	if m.total_commission_usd != nil {
		fields = append(fields, goodcoinachievement.FieldTotalCommissionUsd)
	}
	if m.self_commission_usd != nil {
		fields = append(fields, goodcoinachievement.FieldSelfCommissionUsd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodCoinAchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodcoinachievement.FieldCreatedAt:
		return m.CreatedAt()
	case goodcoinachievement.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodcoinachievement.FieldDeletedAt:
		return m.DeletedAt()
	case goodcoinachievement.FieldEntID:
		return m.EntID()
	case goodcoinachievement.FieldAppID:
		return m.AppID()
	case goodcoinachievement.FieldUserID:
		return m.UserID()
	case goodcoinachievement.FieldGoodCoinTypeID:
		return m.GoodCoinTypeID()
	case goodcoinachievement.FieldTotalUnits:
		return m.TotalUnits()
	case goodcoinachievement.FieldSelfUnits:
		return m.SelfUnits()
	case goodcoinachievement.FieldTotalAmountUsd:
		return m.TotalAmountUsd()
	case goodcoinachievement.FieldSelfAmountUsd:
		return m.SelfAmountUsd()
	case goodcoinachievement.FieldTotalCommissionUsd:
		return m.TotalCommissionUsd()
	case goodcoinachievement.FieldSelfCommissionUsd:
		return m.SelfCommissionUsd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodCoinAchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodcoinachievement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodcoinachievement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodcoinachievement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodcoinachievement.FieldEntID:
		return m.OldEntID(ctx)
	case goodcoinachievement.FieldAppID:
		return m.OldAppID(ctx)
	case goodcoinachievement.FieldUserID:
		return m.OldUserID(ctx)
	case goodcoinachievement.FieldGoodCoinTypeID:
		return m.OldGoodCoinTypeID(ctx)
	case goodcoinachievement.FieldTotalUnits:
		return m.OldTotalUnits(ctx)
	case goodcoinachievement.FieldSelfUnits:
		return m.OldSelfUnits(ctx)
	case goodcoinachievement.FieldTotalAmountUsd:
		return m.OldTotalAmountUsd(ctx)
	case goodcoinachievement.FieldSelfAmountUsd:
		return m.OldSelfAmountUsd(ctx)
	case goodcoinachievement.FieldTotalCommissionUsd:
		return m.OldTotalCommissionUsd(ctx)
	case goodcoinachievement.FieldSelfCommissionUsd:
		return m.OldSelfCommissionUsd(ctx)
	}
	return nil, fmt.Errorf("unknown GoodCoinAchievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodCoinAchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodcoinachievement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodcoinachievement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodcoinachievement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodcoinachievement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodcoinachievement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case goodcoinachievement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case goodcoinachievement.FieldGoodCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodCoinTypeID(v)
		return nil
	case goodcoinachievement.FieldTotalUnits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnits(v)
		return nil
	case goodcoinachievement.FieldSelfUnits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfUnits(v)
		return nil
	case goodcoinachievement.FieldTotalAmountUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmountUsd(v)
		return nil
	case goodcoinachievement.FieldSelfAmountUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfAmountUsd(v)
		return nil
	case goodcoinachievement.FieldTotalCommissionUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCommissionUsd(v)
		return nil
	case goodcoinachievement.FieldSelfCommissionUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfCommissionUsd(v)
		return nil
	}
	return fmt.Errorf("unknown GoodCoinAchievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodCoinAchievementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodcoinachievement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodcoinachievement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodcoinachievement.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodCoinAchievementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodcoinachievement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodcoinachievement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodcoinachievement.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodCoinAchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodcoinachievement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodcoinachievement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodcoinachievement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodCoinAchievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodCoinAchievementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodcoinachievement.FieldAppID) {
		fields = append(fields, goodcoinachievement.FieldAppID)
	}
	if m.FieldCleared(goodcoinachievement.FieldUserID) {
		fields = append(fields, goodcoinachievement.FieldUserID)
	}
	if m.FieldCleared(goodcoinachievement.FieldGoodCoinTypeID) {
		fields = append(fields, goodcoinachievement.FieldGoodCoinTypeID)
	}
	if m.FieldCleared(goodcoinachievement.FieldTotalUnits) {
		fields = append(fields, goodcoinachievement.FieldTotalUnits)
	}
	if m.FieldCleared(goodcoinachievement.FieldSelfUnits) {
		fields = append(fields, goodcoinachievement.FieldSelfUnits)
	}
	if m.FieldCleared(goodcoinachievement.FieldTotalAmountUsd) {
		fields = append(fields, goodcoinachievement.FieldTotalAmountUsd)
	}
	if m.FieldCleared(goodcoinachievement.FieldSelfAmountUsd) {
		fields = append(fields, goodcoinachievement.FieldSelfAmountUsd)
	}
	if m.FieldCleared(goodcoinachievement.FieldTotalCommissionUsd) {
		fields = append(fields, goodcoinachievement.FieldTotalCommissionUsd)
	}
	if m.FieldCleared(goodcoinachievement.FieldSelfCommissionUsd) {
		fields = append(fields, goodcoinachievement.FieldSelfCommissionUsd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodCoinAchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodCoinAchievementMutation) ClearField(name string) error {
	switch name {
	case goodcoinachievement.FieldAppID:
		m.ClearAppID()
		return nil
	case goodcoinachievement.FieldUserID:
		m.ClearUserID()
		return nil
	case goodcoinachievement.FieldGoodCoinTypeID:
		m.ClearGoodCoinTypeID()
		return nil
	case goodcoinachievement.FieldTotalUnits:
		m.ClearTotalUnits()
		return nil
	case goodcoinachievement.FieldSelfUnits:
		m.ClearSelfUnits()
		return nil
	case goodcoinachievement.FieldTotalAmountUsd:
		m.ClearTotalAmountUsd()
		return nil
	case goodcoinachievement.FieldSelfAmountUsd:
		m.ClearSelfAmountUsd()
		return nil
	case goodcoinachievement.FieldTotalCommissionUsd:
		m.ClearTotalCommissionUsd()
		return nil
	case goodcoinachievement.FieldSelfCommissionUsd:
		m.ClearSelfCommissionUsd()
		return nil
	}
	return fmt.Errorf("unknown GoodCoinAchievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodCoinAchievementMutation) ResetField(name string) error {
	switch name {
	case goodcoinachievement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodcoinachievement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodcoinachievement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodcoinachievement.FieldEntID:
		m.ResetEntID()
		return nil
	case goodcoinachievement.FieldAppID:
		m.ResetAppID()
		return nil
	case goodcoinachievement.FieldUserID:
		m.ResetUserID()
		return nil
	case goodcoinachievement.FieldGoodCoinTypeID:
		m.ResetGoodCoinTypeID()
		return nil
	case goodcoinachievement.FieldTotalUnits:
		m.ResetTotalUnits()
		return nil
	case goodcoinachievement.FieldSelfUnits:
		m.ResetSelfUnits()
		return nil
	case goodcoinachievement.FieldTotalAmountUsd:
		m.ResetTotalAmountUsd()
		return nil
	case goodcoinachievement.FieldSelfAmountUsd:
		m.ResetSelfAmountUsd()
		return nil
	case goodcoinachievement.FieldTotalCommissionUsd:
		m.ResetTotalCommissionUsd()
		return nil
	case goodcoinachievement.FieldSelfCommissionUsd:
		m.ResetSelfCommissionUsd()
		return nil
	}
	return fmt.Errorf("unknown GoodCoinAchievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodCoinAchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodCoinAchievementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodCoinAchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodCoinAchievementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodCoinAchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodCoinAchievementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodCoinAchievementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodCoinAchievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodCoinAchievementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodCoinAchievement edge %s", name)
}

// InvitationCodeMutation represents an operation that mutates the InvitationCode nodes in the graph.
type InvitationCodeMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	ent_id          *uuid.UUID
	app_id          *uuid.UUID
	user_id         *uuid.UUID
	invitation_code *string
	disabled        *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*InvitationCode, error)
	predicates      []predicate.InvitationCode
}

var _ ent.Mutation = (*InvitationCodeMutation)(nil)

// invitationcodeOption allows management of the mutation configuration using functional options.
type invitationcodeOption func(*InvitationCodeMutation)

// newInvitationCodeMutation creates new mutation for the InvitationCode entity.
func newInvitationCodeMutation(c config, op Op, opts ...invitationcodeOption) *InvitationCodeMutation {
	m := &InvitationCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationCodeID sets the ID field of the mutation.
func withInvitationCodeID(id uint32) invitationcodeOption {
	return func(m *InvitationCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationCode
		)
		m.oldValue = func(ctx context.Context) (*InvitationCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationCode sets the old InvitationCode of the mutation.
func withInvitationCode(node *InvitationCode) invitationcodeOption {
	return func(m *InvitationCodeMutation) {
		m.oldValue = func(context.Context) (*InvitationCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationCode entities.
func (m *InvitationCodeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationCodeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationCodeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationCodeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationCodeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *InvitationCodeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *InvitationCodeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationCodeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvitationCodeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvitationCodeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *InvitationCodeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *InvitationCodeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvitationCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InvitationCodeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InvitationCodeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *InvitationCodeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *InvitationCodeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InvitationCodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *InvitationCodeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *InvitationCodeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *InvitationCodeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *InvitationCodeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *InvitationCodeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *InvitationCodeMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[invitationcode.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *InvitationCodeMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *InvitationCodeMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, invitationcode.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *InvitationCodeMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationCodeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *InvitationCodeMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[invitationcode.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *InvitationCodeMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationCodeMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, invitationcode.FieldUserID)
}

// SetInvitationCode sets the "invitation_code" field.
func (m *InvitationCodeMutation) SetInvitationCode(s string) {
	m.invitation_code = &s
}

// InvitationCode returns the value of the "invitation_code" field in the mutation.
func (m *InvitationCodeMutation) InvitationCode() (r string, exists bool) {
	v := m.invitation_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationCode returns the old "invitation_code" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldInvitationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationCode: %w", err)
	}
	return oldValue.InvitationCode, nil
}

// ClearInvitationCode clears the value of the "invitation_code" field.
func (m *InvitationCodeMutation) ClearInvitationCode() {
	m.invitation_code = nil
	m.clearedFields[invitationcode.FieldInvitationCode] = struct{}{}
}

// InvitationCodeCleared returns if the "invitation_code" field was cleared in this mutation.
func (m *InvitationCodeMutation) InvitationCodeCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldInvitationCode]
	return ok
}

// ResetInvitationCode resets all changes to the "invitation_code" field.
func (m *InvitationCodeMutation) ResetInvitationCode() {
	m.invitation_code = nil
	delete(m.clearedFields, invitationcode.FieldInvitationCode)
}

// SetDisabled sets the "disabled" field.
func (m *InvitationCodeMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *InvitationCodeMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *InvitationCodeMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[invitationcode.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *InvitationCodeMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *InvitationCodeMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, invitationcode.FieldDisabled)
}

// Where appends a list predicates to the InvitationCodeMutation builder.
func (m *InvitationCodeMutation) Where(ps ...predicate.InvitationCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvitationCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvitationCode).
func (m *InvitationCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationCodeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, invitationcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invitationcode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invitationcode.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, invitationcode.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, invitationcode.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, invitationcode.FieldUserID)
	}
	if m.invitation_code != nil {
		fields = append(fields, invitationcode.FieldInvitationCode)
	}
	if m.disabled != nil {
		fields = append(fields, invitationcode.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.CreatedAt()
	case invitationcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case invitationcode.FieldDeletedAt:
		return m.DeletedAt()
	case invitationcode.FieldEntID:
		return m.EntID()
	case invitationcode.FieldAppID:
		return m.AppID()
	case invitationcode.FieldUserID:
		return m.UserID()
	case invitationcode.FieldInvitationCode:
		return m.InvitationCode()
	case invitationcode.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invitationcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invitationcode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invitationcode.FieldEntID:
		return m.OldEntID(ctx)
	case invitationcode.FieldAppID:
		return m.OldAppID(ctx)
	case invitationcode.FieldUserID:
		return m.OldUserID(ctx)
	case invitationcode.FieldInvitationCode:
		return m.OldInvitationCode(ctx)
	case invitationcode.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invitationcode.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invitationcode.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invitationcode.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case invitationcode.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case invitationcode.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationcode.FieldInvitationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationCode(v)
		return nil
	case invitationcode.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationCodeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, invitationcode.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, invitationcode.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, invitationcode.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.AddedCreatedAt()
	case invitationcode.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case invitationcode.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case invitationcode.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case invitationcode.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invitationcode.FieldAppID) {
		fields = append(fields, invitationcode.FieldAppID)
	}
	if m.FieldCleared(invitationcode.FieldUserID) {
		fields = append(fields, invitationcode.FieldUserID)
	}
	if m.FieldCleared(invitationcode.FieldInvitationCode) {
		fields = append(fields, invitationcode.FieldInvitationCode)
	}
	if m.FieldCleared(invitationcode.FieldDisabled) {
		fields = append(fields, invitationcode.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationCodeMutation) ClearField(name string) error {
	switch name {
	case invitationcode.FieldAppID:
		m.ClearAppID()
		return nil
	case invitationcode.FieldUserID:
		m.ClearUserID()
		return nil
	case invitationcode.FieldInvitationCode:
		m.ClearInvitationCode()
		return nil
	case invitationcode.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown InvitationCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationCodeMutation) ResetField(name string) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invitationcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invitationcode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invitationcode.FieldEntID:
		m.ResetEntID()
		return nil
	case invitationcode.FieldAppID:
		m.ResetAppID()
		return nil
	case invitationcode.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationcode.FieldInvitationCode:
		m.ResetInvitationCode()
		return nil
	case invitationcode.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown InvitationCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InvitationCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InvitationCode edge %s", name)
}

// OrderPaymentStatementMutation represents an operation that mutates the OrderPaymentStatement nodes in the graph.
type OrderPaymentStatementMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	ent_id               *uuid.UUID
	statement_id         *uuid.UUID
	payment_coin_type_id *uuid.UUID
	amount               *decimal.Decimal
	commission_amount    *decimal.Decimal
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*OrderPaymentStatement, error)
	predicates           []predicate.OrderPaymentStatement
}

var _ ent.Mutation = (*OrderPaymentStatementMutation)(nil)

// orderpaymentstatementOption allows management of the mutation configuration using functional options.
type orderpaymentstatementOption func(*OrderPaymentStatementMutation)

// newOrderPaymentStatementMutation creates new mutation for the OrderPaymentStatement entity.
func newOrderPaymentStatementMutation(c config, op Op, opts ...orderpaymentstatementOption) *OrderPaymentStatementMutation {
	m := &OrderPaymentStatementMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderPaymentStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderPaymentStatementID sets the ID field of the mutation.
func withOrderPaymentStatementID(id uint32) orderpaymentstatementOption {
	return func(m *OrderPaymentStatementMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderPaymentStatement
		)
		m.oldValue = func(ctx context.Context) (*OrderPaymentStatement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderPaymentStatement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderPaymentStatement sets the old OrderPaymentStatement of the mutation.
func withOrderPaymentStatement(node *OrderPaymentStatement) orderpaymentstatementOption {
	return func(m *OrderPaymentStatementMutation) {
		m.oldValue = func(context.Context) (*OrderPaymentStatement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderPaymentStatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderPaymentStatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderPaymentStatement entities.
func (m *OrderPaymentStatementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderPaymentStatementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderPaymentStatementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderPaymentStatement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderPaymentStatementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderPaymentStatementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderPaymentStatement entity.
// If the OrderPaymentStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentStatementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *OrderPaymentStatementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *OrderPaymentStatementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderPaymentStatementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderPaymentStatementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderPaymentStatementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderPaymentStatement entity.
// If the OrderPaymentStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentStatementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *OrderPaymentStatementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *OrderPaymentStatementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderPaymentStatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderPaymentStatementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderPaymentStatementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderPaymentStatement entity.
// If the OrderPaymentStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentStatementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *OrderPaymentStatementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderPaymentStatementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderPaymentStatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *OrderPaymentStatementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *OrderPaymentStatementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the OrderPaymentStatement entity.
// If the OrderPaymentStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentStatementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *OrderPaymentStatementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetStatementID sets the "statement_id" field.
func (m *OrderPaymentStatementMutation) SetStatementID(u uuid.UUID) {
	m.statement_id = &u
}

// StatementID returns the value of the "statement_id" field in the mutation.
func (m *OrderPaymentStatementMutation) StatementID() (r uuid.UUID, exists bool) {
	v := m.statement_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementID returns the old "statement_id" field's value of the OrderPaymentStatement entity.
// If the OrderPaymentStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentStatementMutation) OldStatementID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementID: %w", err)
	}
	return oldValue.StatementID, nil
}

// ClearStatementID clears the value of the "statement_id" field.
func (m *OrderPaymentStatementMutation) ClearStatementID() {
	m.statement_id = nil
	m.clearedFields[orderpaymentstatement.FieldStatementID] = struct{}{}
}

// StatementIDCleared returns if the "statement_id" field was cleared in this mutation.
func (m *OrderPaymentStatementMutation) StatementIDCleared() bool {
	_, ok := m.clearedFields[orderpaymentstatement.FieldStatementID]
	return ok
}

// ResetStatementID resets all changes to the "statement_id" field.
func (m *OrderPaymentStatementMutation) ResetStatementID() {
	m.statement_id = nil
	delete(m.clearedFields, orderpaymentstatement.FieldStatementID)
}

// SetPaymentCoinTypeID sets the "payment_coin_type_id" field.
func (m *OrderPaymentStatementMutation) SetPaymentCoinTypeID(u uuid.UUID) {
	m.payment_coin_type_id = &u
}

// PaymentCoinTypeID returns the value of the "payment_coin_type_id" field in the mutation.
func (m *OrderPaymentStatementMutation) PaymentCoinTypeID() (r uuid.UUID, exists bool) {
	v := m.payment_coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCoinTypeID returns the old "payment_coin_type_id" field's value of the OrderPaymentStatement entity.
// If the OrderPaymentStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentStatementMutation) OldPaymentCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCoinTypeID: %w", err)
	}
	return oldValue.PaymentCoinTypeID, nil
}

// ClearPaymentCoinTypeID clears the value of the "payment_coin_type_id" field.
func (m *OrderPaymentStatementMutation) ClearPaymentCoinTypeID() {
	m.payment_coin_type_id = nil
	m.clearedFields[orderpaymentstatement.FieldPaymentCoinTypeID] = struct{}{}
}

// PaymentCoinTypeIDCleared returns if the "payment_coin_type_id" field was cleared in this mutation.
func (m *OrderPaymentStatementMutation) PaymentCoinTypeIDCleared() bool {
	_, ok := m.clearedFields[orderpaymentstatement.FieldPaymentCoinTypeID]
	return ok
}

// ResetPaymentCoinTypeID resets all changes to the "payment_coin_type_id" field.
func (m *OrderPaymentStatementMutation) ResetPaymentCoinTypeID() {
	m.payment_coin_type_id = nil
	delete(m.clearedFields, orderpaymentstatement.FieldPaymentCoinTypeID)
}

// SetAmount sets the "amount" field.
func (m *OrderPaymentStatementMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderPaymentStatementMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderPaymentStatement entity.
// If the OrderPaymentStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentStatementMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *OrderPaymentStatementMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[orderpaymentstatement.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *OrderPaymentStatementMutation) AmountCleared() bool {
	_, ok := m.clearedFields[orderpaymentstatement.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderPaymentStatementMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, orderpaymentstatement.FieldAmount)
}

// SetCommissionAmount sets the "commission_amount" field.
func (m *OrderPaymentStatementMutation) SetCommissionAmount(d decimal.Decimal) {
	m.commission_amount = &d
}

// CommissionAmount returns the value of the "commission_amount" field in the mutation.
func (m *OrderPaymentStatementMutation) CommissionAmount() (r decimal.Decimal, exists bool) {
	v := m.commission_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionAmount returns the old "commission_amount" field's value of the OrderPaymentStatement entity.
// If the OrderPaymentStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentStatementMutation) OldCommissionAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionAmount: %w", err)
	}
	return oldValue.CommissionAmount, nil
}

// ClearCommissionAmount clears the value of the "commission_amount" field.
func (m *OrderPaymentStatementMutation) ClearCommissionAmount() {
	m.commission_amount = nil
	m.clearedFields[orderpaymentstatement.FieldCommissionAmount] = struct{}{}
}

// CommissionAmountCleared returns if the "commission_amount" field was cleared in this mutation.
func (m *OrderPaymentStatementMutation) CommissionAmountCleared() bool {
	_, ok := m.clearedFields[orderpaymentstatement.FieldCommissionAmount]
	return ok
}

// ResetCommissionAmount resets all changes to the "commission_amount" field.
func (m *OrderPaymentStatementMutation) ResetCommissionAmount() {
	m.commission_amount = nil
	delete(m.clearedFields, orderpaymentstatement.FieldCommissionAmount)
}

// Where appends a list predicates to the OrderPaymentStatementMutation builder.
func (m *OrderPaymentStatementMutation) Where(ps ...predicate.OrderPaymentStatement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderPaymentStatementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderPaymentStatementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderPaymentStatement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderPaymentStatementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderPaymentStatementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderPaymentStatement).
func (m *OrderPaymentStatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderPaymentStatementMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, orderpaymentstatement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderpaymentstatement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderpaymentstatement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, orderpaymentstatement.FieldEntID)
	}
	if m.statement_id != nil {
		fields = append(fields, orderpaymentstatement.FieldStatementID)
	}
	if m.payment_coin_type_id != nil {
		fields = append(fields, orderpaymentstatement.FieldPaymentCoinTypeID)
	}
	if m.amount != nil {
		fields = append(fields, orderpaymentstatement.FieldAmount)
	}
	if m.commission_amount != nil {
		fields = append(fields, orderpaymentstatement.FieldCommissionAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderPaymentStatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderpaymentstatement.FieldCreatedAt:
		return m.CreatedAt()
	case orderpaymentstatement.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderpaymentstatement.FieldDeletedAt:
		return m.DeletedAt()
	case orderpaymentstatement.FieldEntID:
		return m.EntID()
	case orderpaymentstatement.FieldStatementID:
		return m.StatementID()
	case orderpaymentstatement.FieldPaymentCoinTypeID:
		return m.PaymentCoinTypeID()
	case orderpaymentstatement.FieldAmount:
		return m.Amount()
	case orderpaymentstatement.FieldCommissionAmount:
		return m.CommissionAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderPaymentStatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderpaymentstatement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderpaymentstatement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderpaymentstatement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderpaymentstatement.FieldEntID:
		return m.OldEntID(ctx)
	case orderpaymentstatement.FieldStatementID:
		return m.OldStatementID(ctx)
	case orderpaymentstatement.FieldPaymentCoinTypeID:
		return m.OldPaymentCoinTypeID(ctx)
	case orderpaymentstatement.FieldAmount:
		return m.OldAmount(ctx)
	case orderpaymentstatement.FieldCommissionAmount:
		return m.OldCommissionAmount(ctx)
	}
	return nil, fmt.Errorf("unknown OrderPaymentStatement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPaymentStatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderpaymentstatement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderpaymentstatement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderpaymentstatement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderpaymentstatement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case orderpaymentstatement.FieldStatementID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementID(v)
		return nil
	case orderpaymentstatement.FieldPaymentCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCoinTypeID(v)
		return nil
	case orderpaymentstatement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case orderpaymentstatement.FieldCommissionAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentStatement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderPaymentStatementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, orderpaymentstatement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, orderpaymentstatement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, orderpaymentstatement.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderPaymentStatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderpaymentstatement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case orderpaymentstatement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case orderpaymentstatement.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPaymentStatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderpaymentstatement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case orderpaymentstatement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case orderpaymentstatement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentStatement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderPaymentStatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderpaymentstatement.FieldStatementID) {
		fields = append(fields, orderpaymentstatement.FieldStatementID)
	}
	if m.FieldCleared(orderpaymentstatement.FieldPaymentCoinTypeID) {
		fields = append(fields, orderpaymentstatement.FieldPaymentCoinTypeID)
	}
	if m.FieldCleared(orderpaymentstatement.FieldAmount) {
		fields = append(fields, orderpaymentstatement.FieldAmount)
	}
	if m.FieldCleared(orderpaymentstatement.FieldCommissionAmount) {
		fields = append(fields, orderpaymentstatement.FieldCommissionAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderPaymentStatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderPaymentStatementMutation) ClearField(name string) error {
	switch name {
	case orderpaymentstatement.FieldStatementID:
		m.ClearStatementID()
		return nil
	case orderpaymentstatement.FieldPaymentCoinTypeID:
		m.ClearPaymentCoinTypeID()
		return nil
	case orderpaymentstatement.FieldAmount:
		m.ClearAmount()
		return nil
	case orderpaymentstatement.FieldCommissionAmount:
		m.ClearCommissionAmount()
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentStatement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderPaymentStatementMutation) ResetField(name string) error {
	switch name {
	case orderpaymentstatement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderpaymentstatement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderpaymentstatement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderpaymentstatement.FieldEntID:
		m.ResetEntID()
		return nil
	case orderpaymentstatement.FieldStatementID:
		m.ResetStatementID()
		return nil
	case orderpaymentstatement.FieldPaymentCoinTypeID:
		m.ResetPaymentCoinTypeID()
		return nil
	case orderpaymentstatement.FieldAmount:
		m.ResetAmount()
		return nil
	case orderpaymentstatement.FieldCommissionAmount:
		m.ResetCommissionAmount()
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentStatement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderPaymentStatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderPaymentStatementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderPaymentStatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderPaymentStatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderPaymentStatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderPaymentStatementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderPaymentStatementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderPaymentStatement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderPaymentStatementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderPaymentStatement edge %s", name)
}

// OrderStatementMutation represents an operation that mutates the OrderStatement nodes in the graph.
type OrderStatementMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint32
	created_at             *uint32
	addcreated_at          *int32
	updated_at             *uint32
	addupdated_at          *int32
	deleted_at             *uint32
	adddeleted_at          *int32
	ent_id                 *uuid.UUID
	app_id                 *uuid.UUID
	user_id                *uuid.UUID
	good_id                *uuid.UUID
	app_good_id            *uuid.UUID
	order_id               *uuid.UUID
	direct_contributor_id  *uuid.UUID
	order_user_id          *uuid.UUID
	good_coin_type_id      *uuid.UUID
	units                  *decimal.Decimal
	good_value_usd         *decimal.Decimal
	payment_amount_usd     *decimal.Decimal
	commission_amount_usd  *decimal.Decimal
	app_config_id          *uuid.UUID
	commission_config_id   *uuid.UUID
	commission_config_type *string
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*OrderStatement, error)
	predicates             []predicate.OrderStatement
}

var _ ent.Mutation = (*OrderStatementMutation)(nil)

// orderstatementOption allows management of the mutation configuration using functional options.
type orderstatementOption func(*OrderStatementMutation)

// newOrderStatementMutation creates new mutation for the OrderStatement entity.
func newOrderStatementMutation(c config, op Op, opts ...orderstatementOption) *OrderStatementMutation {
	m := &OrderStatementMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderStatementID sets the ID field of the mutation.
func withOrderStatementID(id uint32) orderstatementOption {
	return func(m *OrderStatementMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderStatement
		)
		m.oldValue = func(ctx context.Context) (*OrderStatement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderStatement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderStatement sets the old OrderStatement of the mutation.
func withOrderStatement(node *OrderStatement) orderstatementOption {
	return func(m *OrderStatementMutation) {
		m.oldValue = func(context.Context) (*OrderStatement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderStatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderStatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderStatement entities.
func (m *OrderStatementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderStatementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderStatementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderStatement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderStatementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderStatementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *OrderStatementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *OrderStatementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderStatementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderStatementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderStatementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *OrderStatementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *OrderStatementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderStatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderStatementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderStatementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *OrderStatementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderStatementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderStatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *OrderStatementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *OrderStatementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *OrderStatementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *OrderStatementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrderStatementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *OrderStatementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[orderstatement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *OrderStatementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrderStatementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, orderstatement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *OrderStatementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderStatementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *OrderStatementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[orderstatement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OrderStatementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderStatementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, orderstatement.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *OrderStatementMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *OrderStatementMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *OrderStatementMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[orderstatement.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *OrderStatementMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *OrderStatementMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, orderstatement.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *OrderStatementMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *OrderStatementMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *OrderStatementMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[orderstatement.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *OrderStatementMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *OrderStatementMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, orderstatement.FieldAppGoodID)
}

// SetOrderID sets the "order_id" field.
func (m *OrderStatementMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderStatementMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderStatementMutation) ClearOrderID() {
	m.order_id = nil
	m.clearedFields[orderstatement.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderStatementMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderStatementMutation) ResetOrderID() {
	m.order_id = nil
	delete(m.clearedFields, orderstatement.FieldOrderID)
}

// SetDirectContributorID sets the "direct_contributor_id" field.
func (m *OrderStatementMutation) SetDirectContributorID(u uuid.UUID) {
	m.direct_contributor_id = &u
}

// DirectContributorID returns the value of the "direct_contributor_id" field in the mutation.
func (m *OrderStatementMutation) DirectContributorID() (r uuid.UUID, exists bool) {
	v := m.direct_contributor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectContributorID returns the old "direct_contributor_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldDirectContributorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectContributorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectContributorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectContributorID: %w", err)
	}
	return oldValue.DirectContributorID, nil
}

// ClearDirectContributorID clears the value of the "direct_contributor_id" field.
func (m *OrderStatementMutation) ClearDirectContributorID() {
	m.direct_contributor_id = nil
	m.clearedFields[orderstatement.FieldDirectContributorID] = struct{}{}
}

// DirectContributorIDCleared returns if the "direct_contributor_id" field was cleared in this mutation.
func (m *OrderStatementMutation) DirectContributorIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldDirectContributorID]
	return ok
}

// ResetDirectContributorID resets all changes to the "direct_contributor_id" field.
func (m *OrderStatementMutation) ResetDirectContributorID() {
	m.direct_contributor_id = nil
	delete(m.clearedFields, orderstatement.FieldDirectContributorID)
}

// SetOrderUserID sets the "order_user_id" field.
func (m *OrderStatementMutation) SetOrderUserID(u uuid.UUID) {
	m.order_user_id = &u
}

// OrderUserID returns the value of the "order_user_id" field in the mutation.
func (m *OrderStatementMutation) OrderUserID() (r uuid.UUID, exists bool) {
	v := m.order_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderUserID returns the old "order_user_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldOrderUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderUserID: %w", err)
	}
	return oldValue.OrderUserID, nil
}

// ClearOrderUserID clears the value of the "order_user_id" field.
func (m *OrderStatementMutation) ClearOrderUserID() {
	m.order_user_id = nil
	m.clearedFields[orderstatement.FieldOrderUserID] = struct{}{}
}

// OrderUserIDCleared returns if the "order_user_id" field was cleared in this mutation.
func (m *OrderStatementMutation) OrderUserIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldOrderUserID]
	return ok
}

// ResetOrderUserID resets all changes to the "order_user_id" field.
func (m *OrderStatementMutation) ResetOrderUserID() {
	m.order_user_id = nil
	delete(m.clearedFields, orderstatement.FieldOrderUserID)
}

// SetGoodCoinTypeID sets the "good_coin_type_id" field.
func (m *OrderStatementMutation) SetGoodCoinTypeID(u uuid.UUID) {
	m.good_coin_type_id = &u
}

// GoodCoinTypeID returns the value of the "good_coin_type_id" field in the mutation.
func (m *OrderStatementMutation) GoodCoinTypeID() (r uuid.UUID, exists bool) {
	v := m.good_coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodCoinTypeID returns the old "good_coin_type_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldGoodCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodCoinTypeID: %w", err)
	}
	return oldValue.GoodCoinTypeID, nil
}

// ClearGoodCoinTypeID clears the value of the "good_coin_type_id" field.
func (m *OrderStatementMutation) ClearGoodCoinTypeID() {
	m.good_coin_type_id = nil
	m.clearedFields[orderstatement.FieldGoodCoinTypeID] = struct{}{}
}

// GoodCoinTypeIDCleared returns if the "good_coin_type_id" field was cleared in this mutation.
func (m *OrderStatementMutation) GoodCoinTypeIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldGoodCoinTypeID]
	return ok
}

// ResetGoodCoinTypeID resets all changes to the "good_coin_type_id" field.
func (m *OrderStatementMutation) ResetGoodCoinTypeID() {
	m.good_coin_type_id = nil
	delete(m.clearedFields, orderstatement.FieldGoodCoinTypeID)
}

// SetUnits sets the "units" field.
func (m *OrderStatementMutation) SetUnits(d decimal.Decimal) {
	m.units = &d
}

// Units returns the value of the "units" field in the mutation.
func (m *OrderStatementMutation) Units() (r decimal.Decimal, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldUnits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// ClearUnits clears the value of the "units" field.
func (m *OrderStatementMutation) ClearUnits() {
	m.units = nil
	m.clearedFields[orderstatement.FieldUnits] = struct{}{}
}

// UnitsCleared returns if the "units" field was cleared in this mutation.
func (m *OrderStatementMutation) UnitsCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldUnits]
	return ok
}

// ResetUnits resets all changes to the "units" field.
func (m *OrderStatementMutation) ResetUnits() {
	m.units = nil
	delete(m.clearedFields, orderstatement.FieldUnits)
}

// SetGoodValueUsd sets the "good_value_usd" field.
func (m *OrderStatementMutation) SetGoodValueUsd(d decimal.Decimal) {
	m.good_value_usd = &d
}

// GoodValueUsd returns the value of the "good_value_usd" field in the mutation.
func (m *OrderStatementMutation) GoodValueUsd() (r decimal.Decimal, exists bool) {
	v := m.good_value_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodValueUsd returns the old "good_value_usd" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldGoodValueUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodValueUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodValueUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodValueUsd: %w", err)
	}
	return oldValue.GoodValueUsd, nil
}

// ClearGoodValueUsd clears the value of the "good_value_usd" field.
func (m *OrderStatementMutation) ClearGoodValueUsd() {
	m.good_value_usd = nil
	m.clearedFields[orderstatement.FieldGoodValueUsd] = struct{}{}
}

// GoodValueUsdCleared returns if the "good_value_usd" field was cleared in this mutation.
func (m *OrderStatementMutation) GoodValueUsdCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldGoodValueUsd]
	return ok
}

// ResetGoodValueUsd resets all changes to the "good_value_usd" field.
func (m *OrderStatementMutation) ResetGoodValueUsd() {
	m.good_value_usd = nil
	delete(m.clearedFields, orderstatement.FieldGoodValueUsd)
}

// SetPaymentAmountUsd sets the "payment_amount_usd" field.
func (m *OrderStatementMutation) SetPaymentAmountUsd(d decimal.Decimal) {
	m.payment_amount_usd = &d
}

// PaymentAmountUsd returns the value of the "payment_amount_usd" field in the mutation.
func (m *OrderStatementMutation) PaymentAmountUsd() (r decimal.Decimal, exists bool) {
	v := m.payment_amount_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentAmountUsd returns the old "payment_amount_usd" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldPaymentAmountUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentAmountUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentAmountUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentAmountUsd: %w", err)
	}
	return oldValue.PaymentAmountUsd, nil
}

// ClearPaymentAmountUsd clears the value of the "payment_amount_usd" field.
func (m *OrderStatementMutation) ClearPaymentAmountUsd() {
	m.payment_amount_usd = nil
	m.clearedFields[orderstatement.FieldPaymentAmountUsd] = struct{}{}
}

// PaymentAmountUsdCleared returns if the "payment_amount_usd" field was cleared in this mutation.
func (m *OrderStatementMutation) PaymentAmountUsdCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldPaymentAmountUsd]
	return ok
}

// ResetPaymentAmountUsd resets all changes to the "payment_amount_usd" field.
func (m *OrderStatementMutation) ResetPaymentAmountUsd() {
	m.payment_amount_usd = nil
	delete(m.clearedFields, orderstatement.FieldPaymentAmountUsd)
}

// SetCommissionAmountUsd sets the "commission_amount_usd" field.
func (m *OrderStatementMutation) SetCommissionAmountUsd(d decimal.Decimal) {
	m.commission_amount_usd = &d
}

// CommissionAmountUsd returns the value of the "commission_amount_usd" field in the mutation.
func (m *OrderStatementMutation) CommissionAmountUsd() (r decimal.Decimal, exists bool) {
	v := m.commission_amount_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionAmountUsd returns the old "commission_amount_usd" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldCommissionAmountUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionAmountUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionAmountUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionAmountUsd: %w", err)
	}
	return oldValue.CommissionAmountUsd, nil
}

// ClearCommissionAmountUsd clears the value of the "commission_amount_usd" field.
func (m *OrderStatementMutation) ClearCommissionAmountUsd() {
	m.commission_amount_usd = nil
	m.clearedFields[orderstatement.FieldCommissionAmountUsd] = struct{}{}
}

// CommissionAmountUsdCleared returns if the "commission_amount_usd" field was cleared in this mutation.
func (m *OrderStatementMutation) CommissionAmountUsdCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldCommissionAmountUsd]
	return ok
}

// ResetCommissionAmountUsd resets all changes to the "commission_amount_usd" field.
func (m *OrderStatementMutation) ResetCommissionAmountUsd() {
	m.commission_amount_usd = nil
	delete(m.clearedFields, orderstatement.FieldCommissionAmountUsd)
}

// SetAppConfigID sets the "app_config_id" field.
func (m *OrderStatementMutation) SetAppConfigID(u uuid.UUID) {
	m.app_config_id = &u
}

// AppConfigID returns the value of the "app_config_id" field in the mutation.
func (m *OrderStatementMutation) AppConfigID() (r uuid.UUID, exists bool) {
	v := m.app_config_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppConfigID returns the old "app_config_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldAppConfigID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppConfigID: %w", err)
	}
	return oldValue.AppConfigID, nil
}

// ClearAppConfigID clears the value of the "app_config_id" field.
func (m *OrderStatementMutation) ClearAppConfigID() {
	m.app_config_id = nil
	m.clearedFields[orderstatement.FieldAppConfigID] = struct{}{}
}

// AppConfigIDCleared returns if the "app_config_id" field was cleared in this mutation.
func (m *OrderStatementMutation) AppConfigIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldAppConfigID]
	return ok
}

// ResetAppConfigID resets all changes to the "app_config_id" field.
func (m *OrderStatementMutation) ResetAppConfigID() {
	m.app_config_id = nil
	delete(m.clearedFields, orderstatement.FieldAppConfigID)
}

// SetCommissionConfigID sets the "commission_config_id" field.
func (m *OrderStatementMutation) SetCommissionConfigID(u uuid.UUID) {
	m.commission_config_id = &u
}

// CommissionConfigID returns the value of the "commission_config_id" field in the mutation.
func (m *OrderStatementMutation) CommissionConfigID() (r uuid.UUID, exists bool) {
	v := m.commission_config_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionConfigID returns the old "commission_config_id" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldCommissionConfigID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionConfigID: %w", err)
	}
	return oldValue.CommissionConfigID, nil
}

// ClearCommissionConfigID clears the value of the "commission_config_id" field.
func (m *OrderStatementMutation) ClearCommissionConfigID() {
	m.commission_config_id = nil
	m.clearedFields[orderstatement.FieldCommissionConfigID] = struct{}{}
}

// CommissionConfigIDCleared returns if the "commission_config_id" field was cleared in this mutation.
func (m *OrderStatementMutation) CommissionConfigIDCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldCommissionConfigID]
	return ok
}

// ResetCommissionConfigID resets all changes to the "commission_config_id" field.
func (m *OrderStatementMutation) ResetCommissionConfigID() {
	m.commission_config_id = nil
	delete(m.clearedFields, orderstatement.FieldCommissionConfigID)
}

// SetCommissionConfigType sets the "commission_config_type" field.
func (m *OrderStatementMutation) SetCommissionConfigType(s string) {
	m.commission_config_type = &s
}

// CommissionConfigType returns the value of the "commission_config_type" field in the mutation.
func (m *OrderStatementMutation) CommissionConfigType() (r string, exists bool) {
	v := m.commission_config_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionConfigType returns the old "commission_config_type" field's value of the OrderStatement entity.
// If the OrderStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatementMutation) OldCommissionConfigType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionConfigType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionConfigType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionConfigType: %w", err)
	}
	return oldValue.CommissionConfigType, nil
}

// ClearCommissionConfigType clears the value of the "commission_config_type" field.
func (m *OrderStatementMutation) ClearCommissionConfigType() {
	m.commission_config_type = nil
	m.clearedFields[orderstatement.FieldCommissionConfigType] = struct{}{}
}

// CommissionConfigTypeCleared returns if the "commission_config_type" field was cleared in this mutation.
func (m *OrderStatementMutation) CommissionConfigTypeCleared() bool {
	_, ok := m.clearedFields[orderstatement.FieldCommissionConfigType]
	return ok
}

// ResetCommissionConfigType resets all changes to the "commission_config_type" field.
func (m *OrderStatementMutation) ResetCommissionConfigType() {
	m.commission_config_type = nil
	delete(m.clearedFields, orderstatement.FieldCommissionConfigType)
}

// Where appends a list predicates to the OrderStatementMutation builder.
func (m *OrderStatementMutation) Where(ps ...predicate.OrderStatement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderStatementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderStatementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderStatement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderStatementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderStatementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderStatement).
func (m *OrderStatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderStatementMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, orderstatement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderstatement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderstatement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, orderstatement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, orderstatement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, orderstatement.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, orderstatement.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, orderstatement.FieldAppGoodID)
	}
	if m.order_id != nil {
		fields = append(fields, orderstatement.FieldOrderID)
	}
	if m.direct_contributor_id != nil {
		fields = append(fields, orderstatement.FieldDirectContributorID)
	}
	if m.order_user_id != nil {
		fields = append(fields, orderstatement.FieldOrderUserID)
	}
	if m.good_coin_type_id != nil {
		fields = append(fields, orderstatement.FieldGoodCoinTypeID)
	}
	if m.units != nil {
		fields = append(fields, orderstatement.FieldUnits)
	}
	if m.good_value_usd != nil {
		fields = append(fields, orderstatement.FieldGoodValueUsd)
	}
	if m.payment_amount_usd != nil {
		fields = append(fields, orderstatement.FieldPaymentAmountUsd)
	}
	if m.commission_amount_usd != nil {
		fields = append(fields, orderstatement.FieldCommissionAmountUsd)
	}
	if m.app_config_id != nil {
		fields = append(fields, orderstatement.FieldAppConfigID)
	}
	if m.commission_config_id != nil {
		fields = append(fields, orderstatement.FieldCommissionConfigID)
	}
	if m.commission_config_type != nil {
		fields = append(fields, orderstatement.FieldCommissionConfigType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderStatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderstatement.FieldCreatedAt:
		return m.CreatedAt()
	case orderstatement.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderstatement.FieldDeletedAt:
		return m.DeletedAt()
	case orderstatement.FieldEntID:
		return m.EntID()
	case orderstatement.FieldAppID:
		return m.AppID()
	case orderstatement.FieldUserID:
		return m.UserID()
	case orderstatement.FieldGoodID:
		return m.GoodID()
	case orderstatement.FieldAppGoodID:
		return m.AppGoodID()
	case orderstatement.FieldOrderID:
		return m.OrderID()
	case orderstatement.FieldDirectContributorID:
		return m.DirectContributorID()
	case orderstatement.FieldOrderUserID:
		return m.OrderUserID()
	case orderstatement.FieldGoodCoinTypeID:
		return m.GoodCoinTypeID()
	case orderstatement.FieldUnits:
		return m.Units()
	case orderstatement.FieldGoodValueUsd:
		return m.GoodValueUsd()
	case orderstatement.FieldPaymentAmountUsd:
		return m.PaymentAmountUsd()
	case orderstatement.FieldCommissionAmountUsd:
		return m.CommissionAmountUsd()
	case orderstatement.FieldAppConfigID:
		return m.AppConfigID()
	case orderstatement.FieldCommissionConfigID:
		return m.CommissionConfigID()
	case orderstatement.FieldCommissionConfigType:
		return m.CommissionConfigType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderStatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderstatement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderstatement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderstatement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderstatement.FieldEntID:
		return m.OldEntID(ctx)
	case orderstatement.FieldAppID:
		return m.OldAppID(ctx)
	case orderstatement.FieldUserID:
		return m.OldUserID(ctx)
	case orderstatement.FieldGoodID:
		return m.OldGoodID(ctx)
	case orderstatement.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case orderstatement.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderstatement.FieldDirectContributorID:
		return m.OldDirectContributorID(ctx)
	case orderstatement.FieldOrderUserID:
		return m.OldOrderUserID(ctx)
	case orderstatement.FieldGoodCoinTypeID:
		return m.OldGoodCoinTypeID(ctx)
	case orderstatement.FieldUnits:
		return m.OldUnits(ctx)
	case orderstatement.FieldGoodValueUsd:
		return m.OldGoodValueUsd(ctx)
	case orderstatement.FieldPaymentAmountUsd:
		return m.OldPaymentAmountUsd(ctx)
	case orderstatement.FieldCommissionAmountUsd:
		return m.OldCommissionAmountUsd(ctx)
	case orderstatement.FieldAppConfigID:
		return m.OldAppConfigID(ctx)
	case orderstatement.FieldCommissionConfigID:
		return m.OldCommissionConfigID(ctx)
	case orderstatement.FieldCommissionConfigType:
		return m.OldCommissionConfigType(ctx)
	}
	return nil, fmt.Errorf("unknown OrderStatement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderstatement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderstatement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderstatement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderstatement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case orderstatement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case orderstatement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orderstatement.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case orderstatement.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case orderstatement.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderstatement.FieldDirectContributorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectContributorID(v)
		return nil
	case orderstatement.FieldOrderUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderUserID(v)
		return nil
	case orderstatement.FieldGoodCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodCoinTypeID(v)
		return nil
	case orderstatement.FieldUnits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case orderstatement.FieldGoodValueUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodValueUsd(v)
		return nil
	case orderstatement.FieldPaymentAmountUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentAmountUsd(v)
		return nil
	case orderstatement.FieldCommissionAmountUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionAmountUsd(v)
		return nil
	case orderstatement.FieldAppConfigID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppConfigID(v)
		return nil
	case orderstatement.FieldCommissionConfigID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionConfigID(v)
		return nil
	case orderstatement.FieldCommissionConfigType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionConfigType(v)
		return nil
	}
	return fmt.Errorf("unknown OrderStatement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderStatementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, orderstatement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, orderstatement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, orderstatement.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderStatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderstatement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case orderstatement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case orderstatement.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderstatement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case orderstatement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case orderstatement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderStatement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderStatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderstatement.FieldAppID) {
		fields = append(fields, orderstatement.FieldAppID)
	}
	if m.FieldCleared(orderstatement.FieldUserID) {
		fields = append(fields, orderstatement.FieldUserID)
	}
	if m.FieldCleared(orderstatement.FieldGoodID) {
		fields = append(fields, orderstatement.FieldGoodID)
	}
	if m.FieldCleared(orderstatement.FieldAppGoodID) {
		fields = append(fields, orderstatement.FieldAppGoodID)
	}
	if m.FieldCleared(orderstatement.FieldOrderID) {
		fields = append(fields, orderstatement.FieldOrderID)
	}
	if m.FieldCleared(orderstatement.FieldDirectContributorID) {
		fields = append(fields, orderstatement.FieldDirectContributorID)
	}
	if m.FieldCleared(orderstatement.FieldOrderUserID) {
		fields = append(fields, orderstatement.FieldOrderUserID)
	}
	if m.FieldCleared(orderstatement.FieldGoodCoinTypeID) {
		fields = append(fields, orderstatement.FieldGoodCoinTypeID)
	}
	if m.FieldCleared(orderstatement.FieldUnits) {
		fields = append(fields, orderstatement.FieldUnits)
	}
	if m.FieldCleared(orderstatement.FieldGoodValueUsd) {
		fields = append(fields, orderstatement.FieldGoodValueUsd)
	}
	if m.FieldCleared(orderstatement.FieldPaymentAmountUsd) {
		fields = append(fields, orderstatement.FieldPaymentAmountUsd)
	}
	if m.FieldCleared(orderstatement.FieldCommissionAmountUsd) {
		fields = append(fields, orderstatement.FieldCommissionAmountUsd)
	}
	if m.FieldCleared(orderstatement.FieldAppConfigID) {
		fields = append(fields, orderstatement.FieldAppConfigID)
	}
	if m.FieldCleared(orderstatement.FieldCommissionConfigID) {
		fields = append(fields, orderstatement.FieldCommissionConfigID)
	}
	if m.FieldCleared(orderstatement.FieldCommissionConfigType) {
		fields = append(fields, orderstatement.FieldCommissionConfigType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderStatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderStatementMutation) ClearField(name string) error {
	switch name {
	case orderstatement.FieldAppID:
		m.ClearAppID()
		return nil
	case orderstatement.FieldUserID:
		m.ClearUserID()
		return nil
	case orderstatement.FieldGoodID:
		m.ClearGoodID()
		return nil
	case orderstatement.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case orderstatement.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderstatement.FieldDirectContributorID:
		m.ClearDirectContributorID()
		return nil
	case orderstatement.FieldOrderUserID:
		m.ClearOrderUserID()
		return nil
	case orderstatement.FieldGoodCoinTypeID:
		m.ClearGoodCoinTypeID()
		return nil
	case orderstatement.FieldUnits:
		m.ClearUnits()
		return nil
	case orderstatement.FieldGoodValueUsd:
		m.ClearGoodValueUsd()
		return nil
	case orderstatement.FieldPaymentAmountUsd:
		m.ClearPaymentAmountUsd()
		return nil
	case orderstatement.FieldCommissionAmountUsd:
		m.ClearCommissionAmountUsd()
		return nil
	case orderstatement.FieldAppConfigID:
		m.ClearAppConfigID()
		return nil
	case orderstatement.FieldCommissionConfigID:
		m.ClearCommissionConfigID()
		return nil
	case orderstatement.FieldCommissionConfigType:
		m.ClearCommissionConfigType()
		return nil
	}
	return fmt.Errorf("unknown OrderStatement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderStatementMutation) ResetField(name string) error {
	switch name {
	case orderstatement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderstatement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderstatement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderstatement.FieldEntID:
		m.ResetEntID()
		return nil
	case orderstatement.FieldAppID:
		m.ResetAppID()
		return nil
	case orderstatement.FieldUserID:
		m.ResetUserID()
		return nil
	case orderstatement.FieldGoodID:
		m.ResetGoodID()
		return nil
	case orderstatement.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case orderstatement.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderstatement.FieldDirectContributorID:
		m.ResetDirectContributorID()
		return nil
	case orderstatement.FieldOrderUserID:
		m.ResetOrderUserID()
		return nil
	case orderstatement.FieldGoodCoinTypeID:
		m.ResetGoodCoinTypeID()
		return nil
	case orderstatement.FieldUnits:
		m.ResetUnits()
		return nil
	case orderstatement.FieldGoodValueUsd:
		m.ResetGoodValueUsd()
		return nil
	case orderstatement.FieldPaymentAmountUsd:
		m.ResetPaymentAmountUsd()
		return nil
	case orderstatement.FieldCommissionAmountUsd:
		m.ResetCommissionAmountUsd()
		return nil
	case orderstatement.FieldAppConfigID:
		m.ResetAppConfigID()
		return nil
	case orderstatement.FieldCommissionConfigID:
		m.ResetCommissionConfigID()
		return nil
	case orderstatement.FieldCommissionConfigType:
		m.ResetCommissionConfigType()
		return nil
	}
	return fmt.Errorf("unknown OrderStatement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderStatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderStatementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderStatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderStatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderStatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderStatementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderStatementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderStatement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderStatementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderStatement edge %s", name)
}

// RegistrationMutation represents an operation that mutates the Registration nodes in the graph.
type RegistrationMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	inviter_id    *uuid.UUID
	invitee_id    *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Registration, error)
	predicates    []predicate.Registration
}

var _ ent.Mutation = (*RegistrationMutation)(nil)

// registrationOption allows management of the mutation configuration using functional options.
type registrationOption func(*RegistrationMutation)

// newRegistrationMutation creates new mutation for the Registration entity.
func newRegistrationMutation(c config, op Op, opts ...registrationOption) *RegistrationMutation {
	m := &RegistrationMutation{
		config:        c,
		op:            op,
		typ:           TypeRegistration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegistrationID sets the ID field of the mutation.
func withRegistrationID(id uint32) registrationOption {
	return func(m *RegistrationMutation) {
		var (
			err   error
			once  sync.Once
			value *Registration
		)
		m.oldValue = func(ctx context.Context) (*Registration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Registration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegistration sets the old Registration of the mutation.
func withRegistration(node *Registration) registrationOption {
	return func(m *RegistrationMutation) {
		m.oldValue = func(context.Context) (*Registration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegistrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegistrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Registration entities.
func (m *RegistrationMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegistrationMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegistrationMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Registration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RegistrationMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RegistrationMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RegistrationMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RegistrationMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RegistrationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RegistrationMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RegistrationMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RegistrationMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RegistrationMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RegistrationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RegistrationMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RegistrationMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RegistrationMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RegistrationMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RegistrationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *RegistrationMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *RegistrationMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *RegistrationMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *RegistrationMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *RegistrationMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *RegistrationMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[registration.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *RegistrationMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[registration.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *RegistrationMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, registration.FieldAppID)
}

// SetInviterID sets the "inviter_id" field.
func (m *RegistrationMutation) SetInviterID(u uuid.UUID) {
	m.inviter_id = &u
}

// InviterID returns the value of the "inviter_id" field in the mutation.
func (m *RegistrationMutation) InviterID() (r uuid.UUID, exists bool) {
	v := m.inviter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterID returns the old "inviter_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldInviterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterID: %w", err)
	}
	return oldValue.InviterID, nil
}

// ClearInviterID clears the value of the "inviter_id" field.
func (m *RegistrationMutation) ClearInviterID() {
	m.inviter_id = nil
	m.clearedFields[registration.FieldInviterID] = struct{}{}
}

// InviterIDCleared returns if the "inviter_id" field was cleared in this mutation.
func (m *RegistrationMutation) InviterIDCleared() bool {
	_, ok := m.clearedFields[registration.FieldInviterID]
	return ok
}

// ResetInviterID resets all changes to the "inviter_id" field.
func (m *RegistrationMutation) ResetInviterID() {
	m.inviter_id = nil
	delete(m.clearedFields, registration.FieldInviterID)
}

// SetInviteeID sets the "invitee_id" field.
func (m *RegistrationMutation) SetInviteeID(u uuid.UUID) {
	m.invitee_id = &u
}

// InviteeID returns the value of the "invitee_id" field in the mutation.
func (m *RegistrationMutation) InviteeID() (r uuid.UUID, exists bool) {
	v := m.invitee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeID returns the old "invitee_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldInviteeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeID: %w", err)
	}
	return oldValue.InviteeID, nil
}

// ClearInviteeID clears the value of the "invitee_id" field.
func (m *RegistrationMutation) ClearInviteeID() {
	m.invitee_id = nil
	m.clearedFields[registration.FieldInviteeID] = struct{}{}
}

// InviteeIDCleared returns if the "invitee_id" field was cleared in this mutation.
func (m *RegistrationMutation) InviteeIDCleared() bool {
	_, ok := m.clearedFields[registration.FieldInviteeID]
	return ok
}

// ResetInviteeID resets all changes to the "invitee_id" field.
func (m *RegistrationMutation) ResetInviteeID() {
	m.invitee_id = nil
	delete(m.clearedFields, registration.FieldInviteeID)
}

// Where appends a list predicates to the RegistrationMutation builder.
func (m *RegistrationMutation) Where(ps ...predicate.Registration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegistrationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegistrationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Registration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegistrationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegistrationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Registration).
func (m *RegistrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegistrationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, registration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, registration.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, registration.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, registration.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, registration.FieldAppID)
	}
	if m.inviter_id != nil {
		fields = append(fields, registration.FieldInviterID)
	}
	if m.invitee_id != nil {
		fields = append(fields, registration.FieldInviteeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegistrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case registration.FieldCreatedAt:
		return m.CreatedAt()
	case registration.FieldUpdatedAt:
		return m.UpdatedAt()
	case registration.FieldDeletedAt:
		return m.DeletedAt()
	case registration.FieldEntID:
		return m.EntID()
	case registration.FieldAppID:
		return m.AppID()
	case registration.FieldInviterID:
		return m.InviterID()
	case registration.FieldInviteeID:
		return m.InviteeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegistrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case registration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case registration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case registration.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case registration.FieldEntID:
		return m.OldEntID(ctx)
	case registration.FieldAppID:
		return m.OldAppID(ctx)
	case registration.FieldInviterID:
		return m.OldInviterID(ctx)
	case registration.FieldInviteeID:
		return m.OldInviteeID(ctx)
	}
	return nil, fmt.Errorf("unknown Registration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case registration.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case registration.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case registration.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case registration.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case registration.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case registration.FieldInviterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterID(v)
		return nil
	case registration.FieldInviteeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeID(v)
		return nil
	}
	return fmt.Errorf("unknown Registration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegistrationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, registration.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, registration.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, registration.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegistrationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case registration.FieldCreatedAt:
		return m.AddedCreatedAt()
	case registration.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case registration.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case registration.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case registration.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case registration.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Registration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegistrationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(registration.FieldAppID) {
		fields = append(fields, registration.FieldAppID)
	}
	if m.FieldCleared(registration.FieldInviterID) {
		fields = append(fields, registration.FieldInviterID)
	}
	if m.FieldCleared(registration.FieldInviteeID) {
		fields = append(fields, registration.FieldInviteeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegistrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegistrationMutation) ClearField(name string) error {
	switch name {
	case registration.FieldAppID:
		m.ClearAppID()
		return nil
	case registration.FieldInviterID:
		m.ClearInviterID()
		return nil
	case registration.FieldInviteeID:
		m.ClearInviteeID()
		return nil
	}
	return fmt.Errorf("unknown Registration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegistrationMutation) ResetField(name string) error {
	switch name {
	case registration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case registration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case registration.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case registration.FieldEntID:
		m.ResetEntID()
		return nil
	case registration.FieldAppID:
		m.ResetAppID()
		return nil
	case registration.FieldInviterID:
		m.ResetInviterID()
		return nil
	case registration.FieldInviteeID:
		m.ResetInviteeID()
		return nil
	}
	return fmt.Errorf("unknown Registration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegistrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegistrationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegistrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegistrationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegistrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegistrationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegistrationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Registration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegistrationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Registration edge %s", name)
}

// StatementMutation represents an operation that mutates the Statement nodes in the graph.
type StatementMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	created_at                *uint32
	addcreated_at             *int32
	updated_at                *uint32
	addupdated_at             *int32
	deleted_at                *uint32
	adddeleted_at             *int32
	ent_id                    *uuid.UUID
	app_id                    *uuid.UUID
	user_id                   *uuid.UUID
	direct_contributor_id     *uuid.UUID
	good_id                   *uuid.UUID
	app_good_id               *uuid.UUID
	order_id                  *uuid.UUID
	self_order                *bool
	payment_id                *uuid.UUID
	coin_type_id              *uuid.UUID
	payment_coin_type_id      *uuid.UUID
	payment_coin_usd_currency *decimal.Decimal
	units                     *uint32
	addunits                  *int32
	units_v1                  *decimal.Decimal
	amount                    *decimal.Decimal
	usd_amount                *decimal.Decimal
	commission                *decimal.Decimal
	app_config_id             *uuid.UUID
	commission_config_id      *uuid.UUID
	commission_config_type    *string
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Statement, error)
	predicates                []predicate.Statement
}

var _ ent.Mutation = (*StatementMutation)(nil)

// statementOption allows management of the mutation configuration using functional options.
type statementOption func(*StatementMutation)

// newStatementMutation creates new mutation for the Statement entity.
func newStatementMutation(c config, op Op, opts ...statementOption) *StatementMutation {
	m := &StatementMutation{
		config:        c,
		op:            op,
		typ:           TypeStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatementID sets the ID field of the mutation.
func withStatementID(id uint32) statementOption {
	return func(m *StatementMutation) {
		var (
			err   error
			once  sync.Once
			value *Statement
		)
		m.oldValue = func(ctx context.Context) (*Statement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatement sets the old Statement of the mutation.
func withStatement(node *Statement) statementOption {
	return func(m *StatementMutation) {
		m.oldValue = func(context.Context) (*Statement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Statement entities.
func (m *StatementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Statement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StatementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StatementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *StatementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StatementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StatementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StatementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StatementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *StatementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StatementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StatementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StatementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *StatementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StatementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *StatementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *StatementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *StatementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *StatementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *StatementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *StatementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[statement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *StatementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *StatementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, statement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *StatementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StatementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *StatementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[statement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *StatementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StatementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, statement.FieldUserID)
}

// SetDirectContributorID sets the "direct_contributor_id" field.
func (m *StatementMutation) SetDirectContributorID(u uuid.UUID) {
	m.direct_contributor_id = &u
}

// DirectContributorID returns the value of the "direct_contributor_id" field in the mutation.
func (m *StatementMutation) DirectContributorID() (r uuid.UUID, exists bool) {
	v := m.direct_contributor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectContributorID returns the old "direct_contributor_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldDirectContributorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectContributorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectContributorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectContributorID: %w", err)
	}
	return oldValue.DirectContributorID, nil
}

// ClearDirectContributorID clears the value of the "direct_contributor_id" field.
func (m *StatementMutation) ClearDirectContributorID() {
	m.direct_contributor_id = nil
	m.clearedFields[statement.FieldDirectContributorID] = struct{}{}
}

// DirectContributorIDCleared returns if the "direct_contributor_id" field was cleared in this mutation.
func (m *StatementMutation) DirectContributorIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldDirectContributorID]
	return ok
}

// ResetDirectContributorID resets all changes to the "direct_contributor_id" field.
func (m *StatementMutation) ResetDirectContributorID() {
	m.direct_contributor_id = nil
	delete(m.clearedFields, statement.FieldDirectContributorID)
}

// SetGoodID sets the "good_id" field.
func (m *StatementMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *StatementMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *StatementMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[statement.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *StatementMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *StatementMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, statement.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *StatementMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *StatementMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *StatementMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[statement.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *StatementMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *StatementMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, statement.FieldAppGoodID)
}

// SetOrderID sets the "order_id" field.
func (m *StatementMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *StatementMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *StatementMutation) ClearOrderID() {
	m.order_id = nil
	m.clearedFields[statement.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *StatementMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *StatementMutation) ResetOrderID() {
	m.order_id = nil
	delete(m.clearedFields, statement.FieldOrderID)
}

// SetSelfOrder sets the "self_order" field.
func (m *StatementMutation) SetSelfOrder(b bool) {
	m.self_order = &b
}

// SelfOrder returns the value of the "self_order" field in the mutation.
func (m *StatementMutation) SelfOrder() (r bool, exists bool) {
	v := m.self_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfOrder returns the old "self_order" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldSelfOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfOrder: %w", err)
	}
	return oldValue.SelfOrder, nil
}

// ClearSelfOrder clears the value of the "self_order" field.
func (m *StatementMutation) ClearSelfOrder() {
	m.self_order = nil
	m.clearedFields[statement.FieldSelfOrder] = struct{}{}
}

// SelfOrderCleared returns if the "self_order" field was cleared in this mutation.
func (m *StatementMutation) SelfOrderCleared() bool {
	_, ok := m.clearedFields[statement.FieldSelfOrder]
	return ok
}

// ResetSelfOrder resets all changes to the "self_order" field.
func (m *StatementMutation) ResetSelfOrder() {
	m.self_order = nil
	delete(m.clearedFields, statement.FieldSelfOrder)
}

// SetPaymentID sets the "payment_id" field.
func (m *StatementMutation) SetPaymentID(u uuid.UUID) {
	m.payment_id = &u
}

// PaymentID returns the value of the "payment_id" field in the mutation.
func (m *StatementMutation) PaymentID() (r uuid.UUID, exists bool) {
	v := m.payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentID returns the old "payment_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldPaymentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentID: %w", err)
	}
	return oldValue.PaymentID, nil
}

// ClearPaymentID clears the value of the "payment_id" field.
func (m *StatementMutation) ClearPaymentID() {
	m.payment_id = nil
	m.clearedFields[statement.FieldPaymentID] = struct{}{}
}

// PaymentIDCleared returns if the "payment_id" field was cleared in this mutation.
func (m *StatementMutation) PaymentIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldPaymentID]
	return ok
}

// ResetPaymentID resets all changes to the "payment_id" field.
func (m *StatementMutation) ResetPaymentID() {
	m.payment_id = nil
	delete(m.clearedFields, statement.FieldPaymentID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *StatementMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *StatementMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *StatementMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[statement.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *StatementMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *StatementMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, statement.FieldCoinTypeID)
}

// SetPaymentCoinTypeID sets the "payment_coin_type_id" field.
func (m *StatementMutation) SetPaymentCoinTypeID(u uuid.UUID) {
	m.payment_coin_type_id = &u
}

// PaymentCoinTypeID returns the value of the "payment_coin_type_id" field in the mutation.
func (m *StatementMutation) PaymentCoinTypeID() (r uuid.UUID, exists bool) {
	v := m.payment_coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCoinTypeID returns the old "payment_coin_type_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldPaymentCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCoinTypeID: %w", err)
	}
	return oldValue.PaymentCoinTypeID, nil
}

// ClearPaymentCoinTypeID clears the value of the "payment_coin_type_id" field.
func (m *StatementMutation) ClearPaymentCoinTypeID() {
	m.payment_coin_type_id = nil
	m.clearedFields[statement.FieldPaymentCoinTypeID] = struct{}{}
}

// PaymentCoinTypeIDCleared returns if the "payment_coin_type_id" field was cleared in this mutation.
func (m *StatementMutation) PaymentCoinTypeIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldPaymentCoinTypeID]
	return ok
}

// ResetPaymentCoinTypeID resets all changes to the "payment_coin_type_id" field.
func (m *StatementMutation) ResetPaymentCoinTypeID() {
	m.payment_coin_type_id = nil
	delete(m.clearedFields, statement.FieldPaymentCoinTypeID)
}

// SetPaymentCoinUsdCurrency sets the "payment_coin_usd_currency" field.
func (m *StatementMutation) SetPaymentCoinUsdCurrency(d decimal.Decimal) {
	m.payment_coin_usd_currency = &d
}

// PaymentCoinUsdCurrency returns the value of the "payment_coin_usd_currency" field in the mutation.
func (m *StatementMutation) PaymentCoinUsdCurrency() (r decimal.Decimal, exists bool) {
	v := m.payment_coin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCoinUsdCurrency returns the old "payment_coin_usd_currency" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldPaymentCoinUsdCurrency(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCoinUsdCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCoinUsdCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCoinUsdCurrency: %w", err)
	}
	return oldValue.PaymentCoinUsdCurrency, nil
}

// ClearPaymentCoinUsdCurrency clears the value of the "payment_coin_usd_currency" field.
func (m *StatementMutation) ClearPaymentCoinUsdCurrency() {
	m.payment_coin_usd_currency = nil
	m.clearedFields[statement.FieldPaymentCoinUsdCurrency] = struct{}{}
}

// PaymentCoinUsdCurrencyCleared returns if the "payment_coin_usd_currency" field was cleared in this mutation.
func (m *StatementMutation) PaymentCoinUsdCurrencyCleared() bool {
	_, ok := m.clearedFields[statement.FieldPaymentCoinUsdCurrency]
	return ok
}

// ResetPaymentCoinUsdCurrency resets all changes to the "payment_coin_usd_currency" field.
func (m *StatementMutation) ResetPaymentCoinUsdCurrency() {
	m.payment_coin_usd_currency = nil
	delete(m.clearedFields, statement.FieldPaymentCoinUsdCurrency)
}

// SetUnits sets the "units" field.
func (m *StatementMutation) SetUnits(u uint32) {
	m.units = &u
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *StatementMutation) Units() (r uint32, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUnits(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds u to the "units" field.
func (m *StatementMutation) AddUnits(u int32) {
	if m.addunits != nil {
		*m.addunits += u
	} else {
		m.addunits = &u
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *StatementMutation) AddedUnits() (r int32, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnits clears the value of the "units" field.
func (m *StatementMutation) ClearUnits() {
	m.units = nil
	m.addunits = nil
	m.clearedFields[statement.FieldUnits] = struct{}{}
}

// UnitsCleared returns if the "units" field was cleared in this mutation.
func (m *StatementMutation) UnitsCleared() bool {
	_, ok := m.clearedFields[statement.FieldUnits]
	return ok
}

// ResetUnits resets all changes to the "units" field.
func (m *StatementMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
	delete(m.clearedFields, statement.FieldUnits)
}

// SetUnitsV1 sets the "units_v1" field.
func (m *StatementMutation) SetUnitsV1(d decimal.Decimal) {
	m.units_v1 = &d
}

// UnitsV1 returns the value of the "units_v1" field in the mutation.
func (m *StatementMutation) UnitsV1() (r decimal.Decimal, exists bool) {
	v := m.units_v1
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitsV1 returns the old "units_v1" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUnitsV1(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitsV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitsV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitsV1: %w", err)
	}
	return oldValue.UnitsV1, nil
}

// ClearUnitsV1 clears the value of the "units_v1" field.
func (m *StatementMutation) ClearUnitsV1() {
	m.units_v1 = nil
	m.clearedFields[statement.FieldUnitsV1] = struct{}{}
}

// UnitsV1Cleared returns if the "units_v1" field was cleared in this mutation.
func (m *StatementMutation) UnitsV1Cleared() bool {
	_, ok := m.clearedFields[statement.FieldUnitsV1]
	return ok
}

// ResetUnitsV1 resets all changes to the "units_v1" field.
func (m *StatementMutation) ResetUnitsV1() {
	m.units_v1 = nil
	delete(m.clearedFields, statement.FieldUnitsV1)
}

// SetAmount sets the "amount" field.
func (m *StatementMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *StatementMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *StatementMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[statement.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *StatementMutation) AmountCleared() bool {
	_, ok := m.clearedFields[statement.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *StatementMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, statement.FieldAmount)
}

// SetUsdAmount sets the "usd_amount" field.
func (m *StatementMutation) SetUsdAmount(d decimal.Decimal) {
	m.usd_amount = &d
}

// UsdAmount returns the value of the "usd_amount" field in the mutation.
func (m *StatementMutation) UsdAmount() (r decimal.Decimal, exists bool) {
	v := m.usd_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdAmount returns the old "usd_amount" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUsdAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdAmount: %w", err)
	}
	return oldValue.UsdAmount, nil
}

// ClearUsdAmount clears the value of the "usd_amount" field.
func (m *StatementMutation) ClearUsdAmount() {
	m.usd_amount = nil
	m.clearedFields[statement.FieldUsdAmount] = struct{}{}
}

// UsdAmountCleared returns if the "usd_amount" field was cleared in this mutation.
func (m *StatementMutation) UsdAmountCleared() bool {
	_, ok := m.clearedFields[statement.FieldUsdAmount]
	return ok
}

// ResetUsdAmount resets all changes to the "usd_amount" field.
func (m *StatementMutation) ResetUsdAmount() {
	m.usd_amount = nil
	delete(m.clearedFields, statement.FieldUsdAmount)
}

// SetCommission sets the "commission" field.
func (m *StatementMutation) SetCommission(d decimal.Decimal) {
	m.commission = &d
}

// Commission returns the value of the "commission" field in the mutation.
func (m *StatementMutation) Commission() (r decimal.Decimal, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// ClearCommission clears the value of the "commission" field.
func (m *StatementMutation) ClearCommission() {
	m.commission = nil
	m.clearedFields[statement.FieldCommission] = struct{}{}
}

// CommissionCleared returns if the "commission" field was cleared in this mutation.
func (m *StatementMutation) CommissionCleared() bool {
	_, ok := m.clearedFields[statement.FieldCommission]
	return ok
}

// ResetCommission resets all changes to the "commission" field.
func (m *StatementMutation) ResetCommission() {
	m.commission = nil
	delete(m.clearedFields, statement.FieldCommission)
}

// SetAppConfigID sets the "app_config_id" field.
func (m *StatementMutation) SetAppConfigID(u uuid.UUID) {
	m.app_config_id = &u
}

// AppConfigID returns the value of the "app_config_id" field in the mutation.
func (m *StatementMutation) AppConfigID() (r uuid.UUID, exists bool) {
	v := m.app_config_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppConfigID returns the old "app_config_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAppConfigID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppConfigID: %w", err)
	}
	return oldValue.AppConfigID, nil
}

// ClearAppConfigID clears the value of the "app_config_id" field.
func (m *StatementMutation) ClearAppConfigID() {
	m.app_config_id = nil
	m.clearedFields[statement.FieldAppConfigID] = struct{}{}
}

// AppConfigIDCleared returns if the "app_config_id" field was cleared in this mutation.
func (m *StatementMutation) AppConfigIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldAppConfigID]
	return ok
}

// ResetAppConfigID resets all changes to the "app_config_id" field.
func (m *StatementMutation) ResetAppConfigID() {
	m.app_config_id = nil
	delete(m.clearedFields, statement.FieldAppConfigID)
}

// SetCommissionConfigID sets the "commission_config_id" field.
func (m *StatementMutation) SetCommissionConfigID(u uuid.UUID) {
	m.commission_config_id = &u
}

// CommissionConfigID returns the value of the "commission_config_id" field in the mutation.
func (m *StatementMutation) CommissionConfigID() (r uuid.UUID, exists bool) {
	v := m.commission_config_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionConfigID returns the old "commission_config_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCommissionConfigID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionConfigID: %w", err)
	}
	return oldValue.CommissionConfigID, nil
}

// ClearCommissionConfigID clears the value of the "commission_config_id" field.
func (m *StatementMutation) ClearCommissionConfigID() {
	m.commission_config_id = nil
	m.clearedFields[statement.FieldCommissionConfigID] = struct{}{}
}

// CommissionConfigIDCleared returns if the "commission_config_id" field was cleared in this mutation.
func (m *StatementMutation) CommissionConfigIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldCommissionConfigID]
	return ok
}

// ResetCommissionConfigID resets all changes to the "commission_config_id" field.
func (m *StatementMutation) ResetCommissionConfigID() {
	m.commission_config_id = nil
	delete(m.clearedFields, statement.FieldCommissionConfigID)
}

// SetCommissionConfigType sets the "commission_config_type" field.
func (m *StatementMutation) SetCommissionConfigType(s string) {
	m.commission_config_type = &s
}

// CommissionConfigType returns the value of the "commission_config_type" field in the mutation.
func (m *StatementMutation) CommissionConfigType() (r string, exists bool) {
	v := m.commission_config_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionConfigType returns the old "commission_config_type" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCommissionConfigType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionConfigType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionConfigType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionConfigType: %w", err)
	}
	return oldValue.CommissionConfigType, nil
}

// ClearCommissionConfigType clears the value of the "commission_config_type" field.
func (m *StatementMutation) ClearCommissionConfigType() {
	m.commission_config_type = nil
	m.clearedFields[statement.FieldCommissionConfigType] = struct{}{}
}

// CommissionConfigTypeCleared returns if the "commission_config_type" field was cleared in this mutation.
func (m *StatementMutation) CommissionConfigTypeCleared() bool {
	_, ok := m.clearedFields[statement.FieldCommissionConfigType]
	return ok
}

// ResetCommissionConfigType resets all changes to the "commission_config_type" field.
func (m *StatementMutation) ResetCommissionConfigType() {
	m.commission_config_type = nil
	delete(m.clearedFields, statement.FieldCommissionConfigType)
}

// Where appends a list predicates to the StatementMutation builder.
func (m *StatementMutation) Where(ps ...predicate.Statement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Statement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Statement).
func (m *StatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatementMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, statement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, statement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, statement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, statement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, statement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, statement.FieldUserID)
	}
	if m.direct_contributor_id != nil {
		fields = append(fields, statement.FieldDirectContributorID)
	}
	if m.good_id != nil {
		fields = append(fields, statement.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, statement.FieldAppGoodID)
	}
	if m.order_id != nil {
		fields = append(fields, statement.FieldOrderID)
	}
	if m.self_order != nil {
		fields = append(fields, statement.FieldSelfOrder)
	}
	if m.payment_id != nil {
		fields = append(fields, statement.FieldPaymentID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, statement.FieldCoinTypeID)
	}
	if m.payment_coin_type_id != nil {
		fields = append(fields, statement.FieldPaymentCoinTypeID)
	}
	if m.payment_coin_usd_currency != nil {
		fields = append(fields, statement.FieldPaymentCoinUsdCurrency)
	}
	if m.units != nil {
		fields = append(fields, statement.FieldUnits)
	}
	if m.units_v1 != nil {
		fields = append(fields, statement.FieldUnitsV1)
	}
	if m.amount != nil {
		fields = append(fields, statement.FieldAmount)
	}
	if m.usd_amount != nil {
		fields = append(fields, statement.FieldUsdAmount)
	}
	if m.commission != nil {
		fields = append(fields, statement.FieldCommission)
	}
	if m.app_config_id != nil {
		fields = append(fields, statement.FieldAppConfigID)
	}
	if m.commission_config_id != nil {
		fields = append(fields, statement.FieldCommissionConfigID)
	}
	if m.commission_config_type != nil {
		fields = append(fields, statement.FieldCommissionConfigType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statement.FieldCreatedAt:
		return m.CreatedAt()
	case statement.FieldUpdatedAt:
		return m.UpdatedAt()
	case statement.FieldDeletedAt:
		return m.DeletedAt()
	case statement.FieldEntID:
		return m.EntID()
	case statement.FieldAppID:
		return m.AppID()
	case statement.FieldUserID:
		return m.UserID()
	case statement.FieldDirectContributorID:
		return m.DirectContributorID()
	case statement.FieldGoodID:
		return m.GoodID()
	case statement.FieldAppGoodID:
		return m.AppGoodID()
	case statement.FieldOrderID:
		return m.OrderID()
	case statement.FieldSelfOrder:
		return m.SelfOrder()
	case statement.FieldPaymentID:
		return m.PaymentID()
	case statement.FieldCoinTypeID:
		return m.CoinTypeID()
	case statement.FieldPaymentCoinTypeID:
		return m.PaymentCoinTypeID()
	case statement.FieldPaymentCoinUsdCurrency:
		return m.PaymentCoinUsdCurrency()
	case statement.FieldUnits:
		return m.Units()
	case statement.FieldUnitsV1:
		return m.UnitsV1()
	case statement.FieldAmount:
		return m.Amount()
	case statement.FieldUsdAmount:
		return m.UsdAmount()
	case statement.FieldCommission:
		return m.Commission()
	case statement.FieldAppConfigID:
		return m.AppConfigID()
	case statement.FieldCommissionConfigID:
		return m.CommissionConfigID()
	case statement.FieldCommissionConfigType:
		return m.CommissionConfigType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case statement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case statement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case statement.FieldEntID:
		return m.OldEntID(ctx)
	case statement.FieldAppID:
		return m.OldAppID(ctx)
	case statement.FieldUserID:
		return m.OldUserID(ctx)
	case statement.FieldDirectContributorID:
		return m.OldDirectContributorID(ctx)
	case statement.FieldGoodID:
		return m.OldGoodID(ctx)
	case statement.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case statement.FieldOrderID:
		return m.OldOrderID(ctx)
	case statement.FieldSelfOrder:
		return m.OldSelfOrder(ctx)
	case statement.FieldPaymentID:
		return m.OldPaymentID(ctx)
	case statement.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case statement.FieldPaymentCoinTypeID:
		return m.OldPaymentCoinTypeID(ctx)
	case statement.FieldPaymentCoinUsdCurrency:
		return m.OldPaymentCoinUsdCurrency(ctx)
	case statement.FieldUnits:
		return m.OldUnits(ctx)
	case statement.FieldUnitsV1:
		return m.OldUnitsV1(ctx)
	case statement.FieldAmount:
		return m.OldAmount(ctx)
	case statement.FieldUsdAmount:
		return m.OldUsdAmount(ctx)
	case statement.FieldCommission:
		return m.OldCommission(ctx)
	case statement.FieldAppConfigID:
		return m.OldAppConfigID(ctx)
	case statement.FieldCommissionConfigID:
		return m.OldCommissionConfigID(ctx)
	case statement.FieldCommissionConfigType:
		return m.OldCommissionConfigType(ctx)
	}
	return nil, fmt.Errorf("unknown Statement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case statement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case statement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case statement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case statement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case statement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case statement.FieldDirectContributorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectContributorID(v)
		return nil
	case statement.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case statement.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case statement.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case statement.FieldSelfOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfOrder(v)
		return nil
	case statement.FieldPaymentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentID(v)
		return nil
	case statement.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case statement.FieldPaymentCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCoinTypeID(v)
		return nil
	case statement.FieldPaymentCoinUsdCurrency:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCoinUsdCurrency(v)
		return nil
	case statement.FieldUnits:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case statement.FieldUnitsV1:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitsV1(v)
		return nil
	case statement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case statement.FieldUsdAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdAmount(v)
		return nil
	case statement.FieldCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	case statement.FieldAppConfigID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppConfigID(v)
		return nil
	case statement.FieldCommissionConfigID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionConfigID(v)
		return nil
	case statement.FieldCommissionConfigType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionConfigType(v)
		return nil
	}
	return fmt.Errorf("unknown Statement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, statement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, statement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, statement.FieldDeletedAt)
	}
	if m.addunits != nil {
		fields = append(fields, statement.FieldUnits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case statement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case statement.FieldDeletedAt:
		return m.AddedDeletedAt()
	case statement.FieldUnits:
		return m.AddedUnits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case statement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case statement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case statement.FieldUnits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	}
	return fmt.Errorf("unknown Statement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statement.FieldAppID) {
		fields = append(fields, statement.FieldAppID)
	}
	if m.FieldCleared(statement.FieldUserID) {
		fields = append(fields, statement.FieldUserID)
	}
	if m.FieldCleared(statement.FieldDirectContributorID) {
		fields = append(fields, statement.FieldDirectContributorID)
	}
	if m.FieldCleared(statement.FieldGoodID) {
		fields = append(fields, statement.FieldGoodID)
	}
	if m.FieldCleared(statement.FieldAppGoodID) {
		fields = append(fields, statement.FieldAppGoodID)
	}
	if m.FieldCleared(statement.FieldOrderID) {
		fields = append(fields, statement.FieldOrderID)
	}
	if m.FieldCleared(statement.FieldSelfOrder) {
		fields = append(fields, statement.FieldSelfOrder)
	}
	if m.FieldCleared(statement.FieldPaymentID) {
		fields = append(fields, statement.FieldPaymentID)
	}
	if m.FieldCleared(statement.FieldCoinTypeID) {
		fields = append(fields, statement.FieldCoinTypeID)
	}
	if m.FieldCleared(statement.FieldPaymentCoinTypeID) {
		fields = append(fields, statement.FieldPaymentCoinTypeID)
	}
	if m.FieldCleared(statement.FieldPaymentCoinUsdCurrency) {
		fields = append(fields, statement.FieldPaymentCoinUsdCurrency)
	}
	if m.FieldCleared(statement.FieldUnits) {
		fields = append(fields, statement.FieldUnits)
	}
	if m.FieldCleared(statement.FieldUnitsV1) {
		fields = append(fields, statement.FieldUnitsV1)
	}
	if m.FieldCleared(statement.FieldAmount) {
		fields = append(fields, statement.FieldAmount)
	}
	if m.FieldCleared(statement.FieldUsdAmount) {
		fields = append(fields, statement.FieldUsdAmount)
	}
	if m.FieldCleared(statement.FieldCommission) {
		fields = append(fields, statement.FieldCommission)
	}
	if m.FieldCleared(statement.FieldAppConfigID) {
		fields = append(fields, statement.FieldAppConfigID)
	}
	if m.FieldCleared(statement.FieldCommissionConfigID) {
		fields = append(fields, statement.FieldCommissionConfigID)
	}
	if m.FieldCleared(statement.FieldCommissionConfigType) {
		fields = append(fields, statement.FieldCommissionConfigType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatementMutation) ClearField(name string) error {
	switch name {
	case statement.FieldAppID:
		m.ClearAppID()
		return nil
	case statement.FieldUserID:
		m.ClearUserID()
		return nil
	case statement.FieldDirectContributorID:
		m.ClearDirectContributorID()
		return nil
	case statement.FieldGoodID:
		m.ClearGoodID()
		return nil
	case statement.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case statement.FieldOrderID:
		m.ClearOrderID()
		return nil
	case statement.FieldSelfOrder:
		m.ClearSelfOrder()
		return nil
	case statement.FieldPaymentID:
		m.ClearPaymentID()
		return nil
	case statement.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case statement.FieldPaymentCoinTypeID:
		m.ClearPaymentCoinTypeID()
		return nil
	case statement.FieldPaymentCoinUsdCurrency:
		m.ClearPaymentCoinUsdCurrency()
		return nil
	case statement.FieldUnits:
		m.ClearUnits()
		return nil
	case statement.FieldUnitsV1:
		m.ClearUnitsV1()
		return nil
	case statement.FieldAmount:
		m.ClearAmount()
		return nil
	case statement.FieldUsdAmount:
		m.ClearUsdAmount()
		return nil
	case statement.FieldCommission:
		m.ClearCommission()
		return nil
	case statement.FieldAppConfigID:
		m.ClearAppConfigID()
		return nil
	case statement.FieldCommissionConfigID:
		m.ClearCommissionConfigID()
		return nil
	case statement.FieldCommissionConfigType:
		m.ClearCommissionConfigType()
		return nil
	}
	return fmt.Errorf("unknown Statement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatementMutation) ResetField(name string) error {
	switch name {
	case statement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case statement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case statement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case statement.FieldEntID:
		m.ResetEntID()
		return nil
	case statement.FieldAppID:
		m.ResetAppID()
		return nil
	case statement.FieldUserID:
		m.ResetUserID()
		return nil
	case statement.FieldDirectContributorID:
		m.ResetDirectContributorID()
		return nil
	case statement.FieldGoodID:
		m.ResetGoodID()
		return nil
	case statement.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case statement.FieldOrderID:
		m.ResetOrderID()
		return nil
	case statement.FieldSelfOrder:
		m.ResetSelfOrder()
		return nil
	case statement.FieldPaymentID:
		m.ResetPaymentID()
		return nil
	case statement.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case statement.FieldPaymentCoinTypeID:
		m.ResetPaymentCoinTypeID()
		return nil
	case statement.FieldPaymentCoinUsdCurrency:
		m.ResetPaymentCoinUsdCurrency()
		return nil
	case statement.FieldUnits:
		m.ResetUnits()
		return nil
	case statement.FieldUnitsV1:
		m.ResetUnitsV1()
		return nil
	case statement.FieldAmount:
		m.ResetAmount()
		return nil
	case statement.FieldUsdAmount:
		m.ResetUsdAmount()
		return nil
	case statement.FieldCommission:
		m.ResetCommission()
		return nil
	case statement.FieldAppConfigID:
		m.ResetAppConfigID()
		return nil
	case statement.FieldCommissionConfigID:
		m.ResetCommissionConfigID()
		return nil
	case statement.FieldCommissionConfigType:
		m.ResetCommissionConfigType()
		return nil
	}
	return fmt.Errorf("unknown Statement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Statement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Statement edge %s", name)
}

// TaskConfigMutation represents an operation that mutates the TaskConfig nodes in the graph.
type TaskConfigMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint32
	created_at                   *uint32
	addcreated_at                *int32
	updated_at                   *uint32
	addupdated_at                *int32
	deleted_at                   *uint32
	adddeleted_at                *int32
	ent_id                       *uuid.UUID
	app_id                       *uuid.UUID
	event_id                     *uuid.UUID
	task_type                    *string
	name                         *string
	task_desc                    *string
	step_guide                   *string
	recommend_message            *string
	index                        *uint32
	addindex                     *int32
	last_task_id                 *uuid.UUID
	max_reward_count             *uint32
	addmax_reward_count          *int32
	cooldown_second              *uint32
	addcooldown_second           *int32
	interval_reset               *bool
	interval_reset_second        *uint32
	addinterval_reset_second     *int32
	max_interval_reward_count    *uint32
	addmax_interval_reward_count *int32
	clearedFields                map[string]struct{}
	done                         bool
	oldValue                     func(context.Context) (*TaskConfig, error)
	predicates                   []predicate.TaskConfig
}

var _ ent.Mutation = (*TaskConfigMutation)(nil)

// taskconfigOption allows management of the mutation configuration using functional options.
type taskconfigOption func(*TaskConfigMutation)

// newTaskConfigMutation creates new mutation for the TaskConfig entity.
func newTaskConfigMutation(c config, op Op, opts ...taskconfigOption) *TaskConfigMutation {
	m := &TaskConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskConfigID sets the ID field of the mutation.
func withTaskConfigID(id uint32) taskconfigOption {
	return func(m *TaskConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskConfig
		)
		m.oldValue = func(ctx context.Context) (*TaskConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskConfig sets the old TaskConfig of the mutation.
func withTaskConfig(node *TaskConfig) taskconfigOption {
	return func(m *TaskConfigMutation) {
		m.oldValue = func(context.Context) (*TaskConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskConfig entities.
func (m *TaskConfigMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskConfigMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskConfigMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskConfigMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskConfigMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TaskConfigMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TaskConfigMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskConfigMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskConfigMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskConfigMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TaskConfigMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TaskConfigMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskConfigMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskConfigMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TaskConfigMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TaskConfigMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *TaskConfigMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *TaskConfigMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *TaskConfigMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *TaskConfigMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *TaskConfigMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *TaskConfigMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[taskconfig.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *TaskConfigMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *TaskConfigMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, taskconfig.FieldAppID)
}

// SetEventID sets the "event_id" field.
func (m *TaskConfigMutation) SetEventID(u uuid.UUID) {
	m.event_id = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *TaskConfigMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ClearEventID clears the value of the "event_id" field.
func (m *TaskConfigMutation) ClearEventID() {
	m.event_id = nil
	m.clearedFields[taskconfig.FieldEventID] = struct{}{}
}

// EventIDCleared returns if the "event_id" field was cleared in this mutation.
func (m *TaskConfigMutation) EventIDCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldEventID]
	return ok
}

// ResetEventID resets all changes to the "event_id" field.
func (m *TaskConfigMutation) ResetEventID() {
	m.event_id = nil
	delete(m.clearedFields, taskconfig.FieldEventID)
}

// SetTaskType sets the "task_type" field.
func (m *TaskConfigMutation) SetTaskType(s string) {
	m.task_type = &s
}

// TaskType returns the value of the "task_type" field in the mutation.
func (m *TaskConfigMutation) TaskType() (r string, exists bool) {
	v := m.task_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskType returns the old "task_type" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldTaskType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskType: %w", err)
	}
	return oldValue.TaskType, nil
}

// ClearTaskType clears the value of the "task_type" field.
func (m *TaskConfigMutation) ClearTaskType() {
	m.task_type = nil
	m.clearedFields[taskconfig.FieldTaskType] = struct{}{}
}

// TaskTypeCleared returns if the "task_type" field was cleared in this mutation.
func (m *TaskConfigMutation) TaskTypeCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldTaskType]
	return ok
}

// ResetTaskType resets all changes to the "task_type" field.
func (m *TaskConfigMutation) ResetTaskType() {
	m.task_type = nil
	delete(m.clearedFields, taskconfig.FieldTaskType)
}

// SetName sets the "name" field.
func (m *TaskConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TaskConfigMutation) ClearName() {
	m.name = nil
	m.clearedFields[taskconfig.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TaskConfigMutation) NameCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TaskConfigMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, taskconfig.FieldName)
}

// SetTaskDesc sets the "task_desc" field.
func (m *TaskConfigMutation) SetTaskDesc(s string) {
	m.task_desc = &s
}

// TaskDesc returns the value of the "task_desc" field in the mutation.
func (m *TaskConfigMutation) TaskDesc() (r string, exists bool) {
	v := m.task_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskDesc returns the old "task_desc" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldTaskDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskDesc: %w", err)
	}
	return oldValue.TaskDesc, nil
}

// ClearTaskDesc clears the value of the "task_desc" field.
func (m *TaskConfigMutation) ClearTaskDesc() {
	m.task_desc = nil
	m.clearedFields[taskconfig.FieldTaskDesc] = struct{}{}
}

// TaskDescCleared returns if the "task_desc" field was cleared in this mutation.
func (m *TaskConfigMutation) TaskDescCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldTaskDesc]
	return ok
}

// ResetTaskDesc resets all changes to the "task_desc" field.
func (m *TaskConfigMutation) ResetTaskDesc() {
	m.task_desc = nil
	delete(m.clearedFields, taskconfig.FieldTaskDesc)
}

// SetStepGuide sets the "step_guide" field.
func (m *TaskConfigMutation) SetStepGuide(s string) {
	m.step_guide = &s
}

// StepGuide returns the value of the "step_guide" field in the mutation.
func (m *TaskConfigMutation) StepGuide() (r string, exists bool) {
	v := m.step_guide
	if v == nil {
		return
	}
	return *v, true
}

// OldStepGuide returns the old "step_guide" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldStepGuide(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepGuide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepGuide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepGuide: %w", err)
	}
	return oldValue.StepGuide, nil
}

// ClearStepGuide clears the value of the "step_guide" field.
func (m *TaskConfigMutation) ClearStepGuide() {
	m.step_guide = nil
	m.clearedFields[taskconfig.FieldStepGuide] = struct{}{}
}

// StepGuideCleared returns if the "step_guide" field was cleared in this mutation.
func (m *TaskConfigMutation) StepGuideCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldStepGuide]
	return ok
}

// ResetStepGuide resets all changes to the "step_guide" field.
func (m *TaskConfigMutation) ResetStepGuide() {
	m.step_guide = nil
	delete(m.clearedFields, taskconfig.FieldStepGuide)
}

// SetRecommendMessage sets the "recommend_message" field.
func (m *TaskConfigMutation) SetRecommendMessage(s string) {
	m.recommend_message = &s
}

// RecommendMessage returns the value of the "recommend_message" field in the mutation.
func (m *TaskConfigMutation) RecommendMessage() (r string, exists bool) {
	v := m.recommend_message
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendMessage returns the old "recommend_message" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldRecommendMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendMessage: %w", err)
	}
	return oldValue.RecommendMessage, nil
}

// ClearRecommendMessage clears the value of the "recommend_message" field.
func (m *TaskConfigMutation) ClearRecommendMessage() {
	m.recommend_message = nil
	m.clearedFields[taskconfig.FieldRecommendMessage] = struct{}{}
}

// RecommendMessageCleared returns if the "recommend_message" field was cleared in this mutation.
func (m *TaskConfigMutation) RecommendMessageCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldRecommendMessage]
	return ok
}

// ResetRecommendMessage resets all changes to the "recommend_message" field.
func (m *TaskConfigMutation) ResetRecommendMessage() {
	m.recommend_message = nil
	delete(m.clearedFields, taskconfig.FieldRecommendMessage)
}

// SetIndex sets the "index" field.
func (m *TaskConfigMutation) SetIndex(u uint32) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *TaskConfigMutation) Index() (r uint32, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldIndex(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *TaskConfigMutation) AddIndex(u int32) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *TaskConfigMutation) AddedIndex() (r int32, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *TaskConfigMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[taskconfig.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *TaskConfigMutation) IndexCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *TaskConfigMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, taskconfig.FieldIndex)
}

// SetLastTaskID sets the "last_task_id" field.
func (m *TaskConfigMutation) SetLastTaskID(u uuid.UUID) {
	m.last_task_id = &u
}

// LastTaskID returns the value of the "last_task_id" field in the mutation.
func (m *TaskConfigMutation) LastTaskID() (r uuid.UUID, exists bool) {
	v := m.last_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTaskID returns the old "last_task_id" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldLastTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTaskID: %w", err)
	}
	return oldValue.LastTaskID, nil
}

// ClearLastTaskID clears the value of the "last_task_id" field.
func (m *TaskConfigMutation) ClearLastTaskID() {
	m.last_task_id = nil
	m.clearedFields[taskconfig.FieldLastTaskID] = struct{}{}
}

// LastTaskIDCleared returns if the "last_task_id" field was cleared in this mutation.
func (m *TaskConfigMutation) LastTaskIDCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldLastTaskID]
	return ok
}

// ResetLastTaskID resets all changes to the "last_task_id" field.
func (m *TaskConfigMutation) ResetLastTaskID() {
	m.last_task_id = nil
	delete(m.clearedFields, taskconfig.FieldLastTaskID)
}

// SetMaxRewardCount sets the "max_reward_count" field.
func (m *TaskConfigMutation) SetMaxRewardCount(u uint32) {
	m.max_reward_count = &u
	m.addmax_reward_count = nil
}

// MaxRewardCount returns the value of the "max_reward_count" field in the mutation.
func (m *TaskConfigMutation) MaxRewardCount() (r uint32, exists bool) {
	v := m.max_reward_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRewardCount returns the old "max_reward_count" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldMaxRewardCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRewardCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRewardCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRewardCount: %w", err)
	}
	return oldValue.MaxRewardCount, nil
}

// AddMaxRewardCount adds u to the "max_reward_count" field.
func (m *TaskConfigMutation) AddMaxRewardCount(u int32) {
	if m.addmax_reward_count != nil {
		*m.addmax_reward_count += u
	} else {
		m.addmax_reward_count = &u
	}
}

// AddedMaxRewardCount returns the value that was added to the "max_reward_count" field in this mutation.
func (m *TaskConfigMutation) AddedMaxRewardCount() (r int32, exists bool) {
	v := m.addmax_reward_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxRewardCount clears the value of the "max_reward_count" field.
func (m *TaskConfigMutation) ClearMaxRewardCount() {
	m.max_reward_count = nil
	m.addmax_reward_count = nil
	m.clearedFields[taskconfig.FieldMaxRewardCount] = struct{}{}
}

// MaxRewardCountCleared returns if the "max_reward_count" field was cleared in this mutation.
func (m *TaskConfigMutation) MaxRewardCountCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldMaxRewardCount]
	return ok
}

// ResetMaxRewardCount resets all changes to the "max_reward_count" field.
func (m *TaskConfigMutation) ResetMaxRewardCount() {
	m.max_reward_count = nil
	m.addmax_reward_count = nil
	delete(m.clearedFields, taskconfig.FieldMaxRewardCount)
}

// SetCooldownSecond sets the "cooldown_second" field.
func (m *TaskConfigMutation) SetCooldownSecond(u uint32) {
	m.cooldown_second = &u
	m.addcooldown_second = nil
}

// CooldownSecond returns the value of the "cooldown_second" field in the mutation.
func (m *TaskConfigMutation) CooldownSecond() (r uint32, exists bool) {
	v := m.cooldown_second
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldownSecond returns the old "cooldown_second" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldCooldownSecond(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooldownSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooldownSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldownSecond: %w", err)
	}
	return oldValue.CooldownSecond, nil
}

// AddCooldownSecond adds u to the "cooldown_second" field.
func (m *TaskConfigMutation) AddCooldownSecond(u int32) {
	if m.addcooldown_second != nil {
		*m.addcooldown_second += u
	} else {
		m.addcooldown_second = &u
	}
}

// AddedCooldownSecond returns the value that was added to the "cooldown_second" field in this mutation.
func (m *TaskConfigMutation) AddedCooldownSecond() (r int32, exists bool) {
	v := m.addcooldown_second
	if v == nil {
		return
	}
	return *v, true
}

// ClearCooldownSecond clears the value of the "cooldown_second" field.
func (m *TaskConfigMutation) ClearCooldownSecond() {
	m.cooldown_second = nil
	m.addcooldown_second = nil
	m.clearedFields[taskconfig.FieldCooldownSecond] = struct{}{}
}

// CooldownSecondCleared returns if the "cooldown_second" field was cleared in this mutation.
func (m *TaskConfigMutation) CooldownSecondCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldCooldownSecond]
	return ok
}

// ResetCooldownSecond resets all changes to the "cooldown_second" field.
func (m *TaskConfigMutation) ResetCooldownSecond() {
	m.cooldown_second = nil
	m.addcooldown_second = nil
	delete(m.clearedFields, taskconfig.FieldCooldownSecond)
}

// SetIntervalReset sets the "interval_reset" field.
func (m *TaskConfigMutation) SetIntervalReset(b bool) {
	m.interval_reset = &b
}

// IntervalReset returns the value of the "interval_reset" field in the mutation.
func (m *TaskConfigMutation) IntervalReset() (r bool, exists bool) {
	v := m.interval_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldIntervalReset returns the old "interval_reset" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldIntervalReset(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntervalReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntervalReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntervalReset: %w", err)
	}
	return oldValue.IntervalReset, nil
}

// ClearIntervalReset clears the value of the "interval_reset" field.
func (m *TaskConfigMutation) ClearIntervalReset() {
	m.interval_reset = nil
	m.clearedFields[taskconfig.FieldIntervalReset] = struct{}{}
}

// IntervalResetCleared returns if the "interval_reset" field was cleared in this mutation.
func (m *TaskConfigMutation) IntervalResetCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldIntervalReset]
	return ok
}

// ResetIntervalReset resets all changes to the "interval_reset" field.
func (m *TaskConfigMutation) ResetIntervalReset() {
	m.interval_reset = nil
	delete(m.clearedFields, taskconfig.FieldIntervalReset)
}

// SetIntervalResetSecond sets the "interval_reset_second" field.
func (m *TaskConfigMutation) SetIntervalResetSecond(u uint32) {
	m.interval_reset_second = &u
	m.addinterval_reset_second = nil
}

// IntervalResetSecond returns the value of the "interval_reset_second" field in the mutation.
func (m *TaskConfigMutation) IntervalResetSecond() (r uint32, exists bool) {
	v := m.interval_reset_second
	if v == nil {
		return
	}
	return *v, true
}

// OldIntervalResetSecond returns the old "interval_reset_second" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldIntervalResetSecond(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntervalResetSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntervalResetSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntervalResetSecond: %w", err)
	}
	return oldValue.IntervalResetSecond, nil
}

// AddIntervalResetSecond adds u to the "interval_reset_second" field.
func (m *TaskConfigMutation) AddIntervalResetSecond(u int32) {
	if m.addinterval_reset_second != nil {
		*m.addinterval_reset_second += u
	} else {
		m.addinterval_reset_second = &u
	}
}

// AddedIntervalResetSecond returns the value that was added to the "interval_reset_second" field in this mutation.
func (m *TaskConfigMutation) AddedIntervalResetSecond() (r int32, exists bool) {
	v := m.addinterval_reset_second
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntervalResetSecond clears the value of the "interval_reset_second" field.
func (m *TaskConfigMutation) ClearIntervalResetSecond() {
	m.interval_reset_second = nil
	m.addinterval_reset_second = nil
	m.clearedFields[taskconfig.FieldIntervalResetSecond] = struct{}{}
}

// IntervalResetSecondCleared returns if the "interval_reset_second" field was cleared in this mutation.
func (m *TaskConfigMutation) IntervalResetSecondCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldIntervalResetSecond]
	return ok
}

// ResetIntervalResetSecond resets all changes to the "interval_reset_second" field.
func (m *TaskConfigMutation) ResetIntervalResetSecond() {
	m.interval_reset_second = nil
	m.addinterval_reset_second = nil
	delete(m.clearedFields, taskconfig.FieldIntervalResetSecond)
}

// SetMaxIntervalRewardCount sets the "max_interval_reward_count" field.
func (m *TaskConfigMutation) SetMaxIntervalRewardCount(u uint32) {
	m.max_interval_reward_count = &u
	m.addmax_interval_reward_count = nil
}

// MaxIntervalRewardCount returns the value of the "max_interval_reward_count" field in the mutation.
func (m *TaskConfigMutation) MaxIntervalRewardCount() (r uint32, exists bool) {
	v := m.max_interval_reward_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxIntervalRewardCount returns the old "max_interval_reward_count" field's value of the TaskConfig entity.
// If the TaskConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskConfigMutation) OldMaxIntervalRewardCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxIntervalRewardCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxIntervalRewardCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxIntervalRewardCount: %w", err)
	}
	return oldValue.MaxIntervalRewardCount, nil
}

// AddMaxIntervalRewardCount adds u to the "max_interval_reward_count" field.
func (m *TaskConfigMutation) AddMaxIntervalRewardCount(u int32) {
	if m.addmax_interval_reward_count != nil {
		*m.addmax_interval_reward_count += u
	} else {
		m.addmax_interval_reward_count = &u
	}
}

// AddedMaxIntervalRewardCount returns the value that was added to the "max_interval_reward_count" field in this mutation.
func (m *TaskConfigMutation) AddedMaxIntervalRewardCount() (r int32, exists bool) {
	v := m.addmax_interval_reward_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxIntervalRewardCount clears the value of the "max_interval_reward_count" field.
func (m *TaskConfigMutation) ClearMaxIntervalRewardCount() {
	m.max_interval_reward_count = nil
	m.addmax_interval_reward_count = nil
	m.clearedFields[taskconfig.FieldMaxIntervalRewardCount] = struct{}{}
}

// MaxIntervalRewardCountCleared returns if the "max_interval_reward_count" field was cleared in this mutation.
func (m *TaskConfigMutation) MaxIntervalRewardCountCleared() bool {
	_, ok := m.clearedFields[taskconfig.FieldMaxIntervalRewardCount]
	return ok
}

// ResetMaxIntervalRewardCount resets all changes to the "max_interval_reward_count" field.
func (m *TaskConfigMutation) ResetMaxIntervalRewardCount() {
	m.max_interval_reward_count = nil
	m.addmax_interval_reward_count = nil
	delete(m.clearedFields, taskconfig.FieldMaxIntervalRewardCount)
}

// Where appends a list predicates to the TaskConfigMutation builder.
func (m *TaskConfigMutation) Where(ps ...predicate.TaskConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskConfig).
func (m *TaskConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskConfigMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, taskconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, taskconfig.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, taskconfig.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, taskconfig.FieldAppID)
	}
	if m.event_id != nil {
		fields = append(fields, taskconfig.FieldEventID)
	}
	if m.task_type != nil {
		fields = append(fields, taskconfig.FieldTaskType)
	}
	if m.name != nil {
		fields = append(fields, taskconfig.FieldName)
	}
	if m.task_desc != nil {
		fields = append(fields, taskconfig.FieldTaskDesc)
	}
	if m.step_guide != nil {
		fields = append(fields, taskconfig.FieldStepGuide)
	}
	if m.recommend_message != nil {
		fields = append(fields, taskconfig.FieldRecommendMessage)
	}
	if m.index != nil {
		fields = append(fields, taskconfig.FieldIndex)
	}
	if m.last_task_id != nil {
		fields = append(fields, taskconfig.FieldLastTaskID)
	}
	if m.max_reward_count != nil {
		fields = append(fields, taskconfig.FieldMaxRewardCount)
	}
	if m.cooldown_second != nil {
		fields = append(fields, taskconfig.FieldCooldownSecond)
	}
	if m.interval_reset != nil {
		fields = append(fields, taskconfig.FieldIntervalReset)
	}
	if m.interval_reset_second != nil {
		fields = append(fields, taskconfig.FieldIntervalResetSecond)
	}
	if m.max_interval_reward_count != nil {
		fields = append(fields, taskconfig.FieldMaxIntervalRewardCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskconfig.FieldCreatedAt:
		return m.CreatedAt()
	case taskconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskconfig.FieldDeletedAt:
		return m.DeletedAt()
	case taskconfig.FieldEntID:
		return m.EntID()
	case taskconfig.FieldAppID:
		return m.AppID()
	case taskconfig.FieldEventID:
		return m.EventID()
	case taskconfig.FieldTaskType:
		return m.TaskType()
	case taskconfig.FieldName:
		return m.Name()
	case taskconfig.FieldTaskDesc:
		return m.TaskDesc()
	case taskconfig.FieldStepGuide:
		return m.StepGuide()
	case taskconfig.FieldRecommendMessage:
		return m.RecommendMessage()
	case taskconfig.FieldIndex:
		return m.Index()
	case taskconfig.FieldLastTaskID:
		return m.LastTaskID()
	case taskconfig.FieldMaxRewardCount:
		return m.MaxRewardCount()
	case taskconfig.FieldCooldownSecond:
		return m.CooldownSecond()
	case taskconfig.FieldIntervalReset:
		return m.IntervalReset()
	case taskconfig.FieldIntervalResetSecond:
		return m.IntervalResetSecond()
	case taskconfig.FieldMaxIntervalRewardCount:
		return m.MaxIntervalRewardCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case taskconfig.FieldEntID:
		return m.OldEntID(ctx)
	case taskconfig.FieldAppID:
		return m.OldAppID(ctx)
	case taskconfig.FieldEventID:
		return m.OldEventID(ctx)
	case taskconfig.FieldTaskType:
		return m.OldTaskType(ctx)
	case taskconfig.FieldName:
		return m.OldName(ctx)
	case taskconfig.FieldTaskDesc:
		return m.OldTaskDesc(ctx)
	case taskconfig.FieldStepGuide:
		return m.OldStepGuide(ctx)
	case taskconfig.FieldRecommendMessage:
		return m.OldRecommendMessage(ctx)
	case taskconfig.FieldIndex:
		return m.OldIndex(ctx)
	case taskconfig.FieldLastTaskID:
		return m.OldLastTaskID(ctx)
	case taskconfig.FieldMaxRewardCount:
		return m.OldMaxRewardCount(ctx)
	case taskconfig.FieldCooldownSecond:
		return m.OldCooldownSecond(ctx)
	case taskconfig.FieldIntervalReset:
		return m.OldIntervalReset(ctx)
	case taskconfig.FieldIntervalResetSecond:
		return m.OldIntervalResetSecond(ctx)
	case taskconfig.FieldMaxIntervalRewardCount:
		return m.OldMaxIntervalRewardCount(ctx)
	}
	return nil, fmt.Errorf("unknown TaskConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskconfig.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskconfig.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskconfig.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case taskconfig.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case taskconfig.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case taskconfig.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case taskconfig.FieldTaskType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskType(v)
		return nil
	case taskconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case taskconfig.FieldTaskDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskDesc(v)
		return nil
	case taskconfig.FieldStepGuide:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepGuide(v)
		return nil
	case taskconfig.FieldRecommendMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendMessage(v)
		return nil
	case taskconfig.FieldIndex:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case taskconfig.FieldLastTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTaskID(v)
		return nil
	case taskconfig.FieldMaxRewardCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRewardCount(v)
		return nil
	case taskconfig.FieldCooldownSecond:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldownSecond(v)
		return nil
	case taskconfig.FieldIntervalReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntervalReset(v)
		return nil
	case taskconfig.FieldIntervalResetSecond:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntervalResetSecond(v)
		return nil
	case taskconfig.FieldMaxIntervalRewardCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxIntervalRewardCount(v)
		return nil
	}
	return fmt.Errorf("unknown TaskConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, taskconfig.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, taskconfig.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, taskconfig.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, taskconfig.FieldIndex)
	}
	if m.addmax_reward_count != nil {
		fields = append(fields, taskconfig.FieldMaxRewardCount)
	}
	if m.addcooldown_second != nil {
		fields = append(fields, taskconfig.FieldCooldownSecond)
	}
	if m.addinterval_reset_second != nil {
		fields = append(fields, taskconfig.FieldIntervalResetSecond)
	}
	if m.addmax_interval_reward_count != nil {
		fields = append(fields, taskconfig.FieldMaxIntervalRewardCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case taskconfig.FieldCreatedAt:
		return m.AddedCreatedAt()
	case taskconfig.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case taskconfig.FieldDeletedAt:
		return m.AddedDeletedAt()
	case taskconfig.FieldIndex:
		return m.AddedIndex()
	case taskconfig.FieldMaxRewardCount:
		return m.AddedMaxRewardCount()
	case taskconfig.FieldCooldownSecond:
		return m.AddedCooldownSecond()
	case taskconfig.FieldIntervalResetSecond:
		return m.AddedIntervalResetSecond()
	case taskconfig.FieldMaxIntervalRewardCount:
		return m.AddedMaxIntervalRewardCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case taskconfig.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case taskconfig.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case taskconfig.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case taskconfig.FieldIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case taskconfig.FieldMaxRewardCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRewardCount(v)
		return nil
	case taskconfig.FieldCooldownSecond:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldownSecond(v)
		return nil
	case taskconfig.FieldIntervalResetSecond:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntervalResetSecond(v)
		return nil
	case taskconfig.FieldMaxIntervalRewardCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxIntervalRewardCount(v)
		return nil
	}
	return fmt.Errorf("unknown TaskConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskconfig.FieldAppID) {
		fields = append(fields, taskconfig.FieldAppID)
	}
	if m.FieldCleared(taskconfig.FieldEventID) {
		fields = append(fields, taskconfig.FieldEventID)
	}
	if m.FieldCleared(taskconfig.FieldTaskType) {
		fields = append(fields, taskconfig.FieldTaskType)
	}
	if m.FieldCleared(taskconfig.FieldName) {
		fields = append(fields, taskconfig.FieldName)
	}
	if m.FieldCleared(taskconfig.FieldTaskDesc) {
		fields = append(fields, taskconfig.FieldTaskDesc)
	}
	if m.FieldCleared(taskconfig.FieldStepGuide) {
		fields = append(fields, taskconfig.FieldStepGuide)
	}
	if m.FieldCleared(taskconfig.FieldRecommendMessage) {
		fields = append(fields, taskconfig.FieldRecommendMessage)
	}
	if m.FieldCleared(taskconfig.FieldIndex) {
		fields = append(fields, taskconfig.FieldIndex)
	}
	if m.FieldCleared(taskconfig.FieldLastTaskID) {
		fields = append(fields, taskconfig.FieldLastTaskID)
	}
	if m.FieldCleared(taskconfig.FieldMaxRewardCount) {
		fields = append(fields, taskconfig.FieldMaxRewardCount)
	}
	if m.FieldCleared(taskconfig.FieldCooldownSecond) {
		fields = append(fields, taskconfig.FieldCooldownSecond)
	}
	if m.FieldCleared(taskconfig.FieldIntervalReset) {
		fields = append(fields, taskconfig.FieldIntervalReset)
	}
	if m.FieldCleared(taskconfig.FieldIntervalResetSecond) {
		fields = append(fields, taskconfig.FieldIntervalResetSecond)
	}
	if m.FieldCleared(taskconfig.FieldMaxIntervalRewardCount) {
		fields = append(fields, taskconfig.FieldMaxIntervalRewardCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskConfigMutation) ClearField(name string) error {
	switch name {
	case taskconfig.FieldAppID:
		m.ClearAppID()
		return nil
	case taskconfig.FieldEventID:
		m.ClearEventID()
		return nil
	case taskconfig.FieldTaskType:
		m.ClearTaskType()
		return nil
	case taskconfig.FieldName:
		m.ClearName()
		return nil
	case taskconfig.FieldTaskDesc:
		m.ClearTaskDesc()
		return nil
	case taskconfig.FieldStepGuide:
		m.ClearStepGuide()
		return nil
	case taskconfig.FieldRecommendMessage:
		m.ClearRecommendMessage()
		return nil
	case taskconfig.FieldIndex:
		m.ClearIndex()
		return nil
	case taskconfig.FieldLastTaskID:
		m.ClearLastTaskID()
		return nil
	case taskconfig.FieldMaxRewardCount:
		m.ClearMaxRewardCount()
		return nil
	case taskconfig.FieldCooldownSecond:
		m.ClearCooldownSecond()
		return nil
	case taskconfig.FieldIntervalReset:
		m.ClearIntervalReset()
		return nil
	case taskconfig.FieldIntervalResetSecond:
		m.ClearIntervalResetSecond()
		return nil
	case taskconfig.FieldMaxIntervalRewardCount:
		m.ClearMaxIntervalRewardCount()
		return nil
	}
	return fmt.Errorf("unknown TaskConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskConfigMutation) ResetField(name string) error {
	switch name {
	case taskconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case taskconfig.FieldEntID:
		m.ResetEntID()
		return nil
	case taskconfig.FieldAppID:
		m.ResetAppID()
		return nil
	case taskconfig.FieldEventID:
		m.ResetEventID()
		return nil
	case taskconfig.FieldTaskType:
		m.ResetTaskType()
		return nil
	case taskconfig.FieldName:
		m.ResetName()
		return nil
	case taskconfig.FieldTaskDesc:
		m.ResetTaskDesc()
		return nil
	case taskconfig.FieldStepGuide:
		m.ResetStepGuide()
		return nil
	case taskconfig.FieldRecommendMessage:
		m.ResetRecommendMessage()
		return nil
	case taskconfig.FieldIndex:
		m.ResetIndex()
		return nil
	case taskconfig.FieldLastTaskID:
		m.ResetLastTaskID()
		return nil
	case taskconfig.FieldMaxRewardCount:
		m.ResetMaxRewardCount()
		return nil
	case taskconfig.FieldCooldownSecond:
		m.ResetCooldownSecond()
		return nil
	case taskconfig.FieldIntervalReset:
		m.ResetIntervalReset()
		return nil
	case taskconfig.FieldIntervalResetSecond:
		m.ResetIntervalResetSecond()
		return nil
	case taskconfig.FieldMaxIntervalRewardCount:
		m.ResetMaxIntervalRewardCount()
		return nil
	}
	return fmt.Errorf("unknown TaskConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TaskConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TaskConfig edge %s", name)
}

// TaskUserMutation represents an operation that mutates the TaskUser nodes in the graph.
type TaskUserMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	task_id       *uuid.UUID
	event_id      *uuid.UUID
	task_state    *string
	reward_state  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TaskUser, error)
	predicates    []predicate.TaskUser
}

var _ ent.Mutation = (*TaskUserMutation)(nil)

// taskuserOption allows management of the mutation configuration using functional options.
type taskuserOption func(*TaskUserMutation)

// newTaskUserMutation creates new mutation for the TaskUser entity.
func newTaskUserMutation(c config, op Op, opts ...taskuserOption) *TaskUserMutation {
	m := &TaskUserMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskUserID sets the ID field of the mutation.
func withTaskUserID(id uint32) taskuserOption {
	return func(m *TaskUserMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskUser
		)
		m.oldValue = func(ctx context.Context) (*TaskUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskUser sets the old TaskUser of the mutation.
func withTaskUser(node *TaskUser) taskuserOption {
	return func(m *TaskUserMutation) {
		m.oldValue = func(context.Context) (*TaskUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskUser entities.
func (m *TaskUserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskUserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskUserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TaskUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TaskUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TaskUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TaskUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TaskUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TaskUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *TaskUserMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *TaskUserMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *TaskUserMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *TaskUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *TaskUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *TaskUserMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[taskuser.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *TaskUserMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[taskuser.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *TaskUserMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, taskuser.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *TaskUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TaskUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TaskUserMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[taskuser.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TaskUserMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[taskuser.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TaskUserMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, taskuser.FieldUserID)
}

// SetTaskID sets the "task_id" field.
func (m *TaskUserMutation) SetTaskID(u uuid.UUID) {
	m.task_id = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskUserMutation) TaskID() (r uuid.UUID, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ClearTaskID clears the value of the "task_id" field.
func (m *TaskUserMutation) ClearTaskID() {
	m.task_id = nil
	m.clearedFields[taskuser.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *TaskUserMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[taskuser.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskUserMutation) ResetTaskID() {
	m.task_id = nil
	delete(m.clearedFields, taskuser.FieldTaskID)
}

// SetEventID sets the "event_id" field.
func (m *TaskUserMutation) SetEventID(u uuid.UUID) {
	m.event_id = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *TaskUserMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ClearEventID clears the value of the "event_id" field.
func (m *TaskUserMutation) ClearEventID() {
	m.event_id = nil
	m.clearedFields[taskuser.FieldEventID] = struct{}{}
}

// EventIDCleared returns if the "event_id" field was cleared in this mutation.
func (m *TaskUserMutation) EventIDCleared() bool {
	_, ok := m.clearedFields[taskuser.FieldEventID]
	return ok
}

// ResetEventID resets all changes to the "event_id" field.
func (m *TaskUserMutation) ResetEventID() {
	m.event_id = nil
	delete(m.clearedFields, taskuser.FieldEventID)
}

// SetTaskState sets the "task_state" field.
func (m *TaskUserMutation) SetTaskState(s string) {
	m.task_state = &s
}

// TaskState returns the value of the "task_state" field in the mutation.
func (m *TaskUserMutation) TaskState() (r string, exists bool) {
	v := m.task_state
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskState returns the old "task_state" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldTaskState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskState: %w", err)
	}
	return oldValue.TaskState, nil
}

// ClearTaskState clears the value of the "task_state" field.
func (m *TaskUserMutation) ClearTaskState() {
	m.task_state = nil
	m.clearedFields[taskuser.FieldTaskState] = struct{}{}
}

// TaskStateCleared returns if the "task_state" field was cleared in this mutation.
func (m *TaskUserMutation) TaskStateCleared() bool {
	_, ok := m.clearedFields[taskuser.FieldTaskState]
	return ok
}

// ResetTaskState resets all changes to the "task_state" field.
func (m *TaskUserMutation) ResetTaskState() {
	m.task_state = nil
	delete(m.clearedFields, taskuser.FieldTaskState)
}

// SetRewardState sets the "reward_state" field.
func (m *TaskUserMutation) SetRewardState(s string) {
	m.reward_state = &s
}

// RewardState returns the value of the "reward_state" field in the mutation.
func (m *TaskUserMutation) RewardState() (r string, exists bool) {
	v := m.reward_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardState returns the old "reward_state" field's value of the TaskUser entity.
// If the TaskUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskUserMutation) OldRewardState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardState: %w", err)
	}
	return oldValue.RewardState, nil
}

// ClearRewardState clears the value of the "reward_state" field.
func (m *TaskUserMutation) ClearRewardState() {
	m.reward_state = nil
	m.clearedFields[taskuser.FieldRewardState] = struct{}{}
}

// RewardStateCleared returns if the "reward_state" field was cleared in this mutation.
func (m *TaskUserMutation) RewardStateCleared() bool {
	_, ok := m.clearedFields[taskuser.FieldRewardState]
	return ok
}

// ResetRewardState resets all changes to the "reward_state" field.
func (m *TaskUserMutation) ResetRewardState() {
	m.reward_state = nil
	delete(m.clearedFields, taskuser.FieldRewardState)
}

// Where appends a list predicates to the TaskUserMutation builder.
func (m *TaskUserMutation) Where(ps ...predicate.TaskUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskUser).
func (m *TaskUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskUserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, taskuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, taskuser.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, taskuser.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, taskuser.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, taskuser.FieldUserID)
	}
	if m.task_id != nil {
		fields = append(fields, taskuser.FieldTaskID)
	}
	if m.event_id != nil {
		fields = append(fields, taskuser.FieldEventID)
	}
	if m.task_state != nil {
		fields = append(fields, taskuser.FieldTaskState)
	}
	if m.reward_state != nil {
		fields = append(fields, taskuser.FieldRewardState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskuser.FieldCreatedAt:
		return m.CreatedAt()
	case taskuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskuser.FieldDeletedAt:
		return m.DeletedAt()
	case taskuser.FieldEntID:
		return m.EntID()
	case taskuser.FieldAppID:
		return m.AppID()
	case taskuser.FieldUserID:
		return m.UserID()
	case taskuser.FieldTaskID:
		return m.TaskID()
	case taskuser.FieldEventID:
		return m.EventID()
	case taskuser.FieldTaskState:
		return m.TaskState()
	case taskuser.FieldRewardState:
		return m.RewardState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case taskuser.FieldEntID:
		return m.OldEntID(ctx)
	case taskuser.FieldAppID:
		return m.OldAppID(ctx)
	case taskuser.FieldUserID:
		return m.OldUserID(ctx)
	case taskuser.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskuser.FieldEventID:
		return m.OldEventID(ctx)
	case taskuser.FieldTaskState:
		return m.OldTaskState(ctx)
	case taskuser.FieldRewardState:
		return m.OldRewardState(ctx)
	}
	return nil, fmt.Errorf("unknown TaskUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case taskuser.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case taskuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case taskuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case taskuser.FieldTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskuser.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case taskuser.FieldTaskState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskState(v)
		return nil
	case taskuser.FieldRewardState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardState(v)
		return nil
	}
	return fmt.Errorf("unknown TaskUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, taskuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, taskuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, taskuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case taskuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case taskuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case taskuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case taskuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case taskuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case taskuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskuser.FieldAppID) {
		fields = append(fields, taskuser.FieldAppID)
	}
	if m.FieldCleared(taskuser.FieldUserID) {
		fields = append(fields, taskuser.FieldUserID)
	}
	if m.FieldCleared(taskuser.FieldTaskID) {
		fields = append(fields, taskuser.FieldTaskID)
	}
	if m.FieldCleared(taskuser.FieldEventID) {
		fields = append(fields, taskuser.FieldEventID)
	}
	if m.FieldCleared(taskuser.FieldTaskState) {
		fields = append(fields, taskuser.FieldTaskState)
	}
	if m.FieldCleared(taskuser.FieldRewardState) {
		fields = append(fields, taskuser.FieldRewardState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskUserMutation) ClearField(name string) error {
	switch name {
	case taskuser.FieldAppID:
		m.ClearAppID()
		return nil
	case taskuser.FieldUserID:
		m.ClearUserID()
		return nil
	case taskuser.FieldTaskID:
		m.ClearTaskID()
		return nil
	case taskuser.FieldEventID:
		m.ClearEventID()
		return nil
	case taskuser.FieldTaskState:
		m.ClearTaskState()
		return nil
	case taskuser.FieldRewardState:
		m.ClearRewardState()
		return nil
	}
	return fmt.Errorf("unknown TaskUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskUserMutation) ResetField(name string) error {
	switch name {
	case taskuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case taskuser.FieldEntID:
		m.ResetEntID()
		return nil
	case taskuser.FieldAppID:
		m.ResetAppID()
		return nil
	case taskuser.FieldUserID:
		m.ResetUserID()
		return nil
	case taskuser.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskuser.FieldEventID:
		m.ResetEventID()
		return nil
	case taskuser.FieldTaskState:
		m.ResetTaskState()
		return nil
	case taskuser.FieldRewardState:
		m.ResetRewardState()
		return nil
	}
	return fmt.Errorf("unknown TaskUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TaskUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TaskUser edge %s", name)
}

// UserCoinRewardMutation represents an operation that mutates the UserCoinReward nodes in the graph.
type UserCoinRewardMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	coin_rewards  *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserCoinReward, error)
	predicates    []predicate.UserCoinReward
}

var _ ent.Mutation = (*UserCoinRewardMutation)(nil)

// usercoinrewardOption allows management of the mutation configuration using functional options.
type usercoinrewardOption func(*UserCoinRewardMutation)

// newUserCoinRewardMutation creates new mutation for the UserCoinReward entity.
func newUserCoinRewardMutation(c config, op Op, opts ...usercoinrewardOption) *UserCoinRewardMutation {
	m := &UserCoinRewardMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCoinReward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCoinRewardID sets the ID field of the mutation.
func withUserCoinRewardID(id uint32) usercoinrewardOption {
	return func(m *UserCoinRewardMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCoinReward
		)
		m.oldValue = func(ctx context.Context) (*UserCoinReward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCoinReward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCoinReward sets the old UserCoinReward of the mutation.
func withUserCoinReward(node *UserCoinReward) usercoinrewardOption {
	return func(m *UserCoinRewardMutation) {
		m.oldValue = func(context.Context) (*UserCoinReward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCoinRewardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCoinRewardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserCoinReward entities.
func (m *UserCoinRewardMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCoinRewardMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCoinRewardMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCoinReward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserCoinRewardMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserCoinRewardMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserCoinReward entity.
// If the UserCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCoinRewardMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *UserCoinRewardMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserCoinRewardMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserCoinRewardMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserCoinRewardMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserCoinRewardMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserCoinReward entity.
// If the UserCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCoinRewardMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *UserCoinRewardMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserCoinRewardMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserCoinRewardMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserCoinRewardMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserCoinRewardMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserCoinReward entity.
// If the UserCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCoinRewardMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *UserCoinRewardMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserCoinRewardMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserCoinRewardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *UserCoinRewardMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *UserCoinRewardMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the UserCoinReward entity.
// If the UserCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCoinRewardMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *UserCoinRewardMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *UserCoinRewardMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *UserCoinRewardMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the UserCoinReward entity.
// If the UserCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCoinRewardMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *UserCoinRewardMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[usercoinreward.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *UserCoinRewardMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[usercoinreward.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *UserCoinRewardMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, usercoinreward.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *UserCoinRewardMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserCoinRewardMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserCoinReward entity.
// If the UserCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCoinRewardMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserCoinRewardMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[usercoinreward.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserCoinRewardMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usercoinreward.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserCoinRewardMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, usercoinreward.FieldUserID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *UserCoinRewardMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *UserCoinRewardMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the UserCoinReward entity.
// If the UserCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCoinRewardMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *UserCoinRewardMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[usercoinreward.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *UserCoinRewardMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[usercoinreward.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *UserCoinRewardMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, usercoinreward.FieldCoinTypeID)
}

// SetCoinRewards sets the "coin_rewards" field.
func (m *UserCoinRewardMutation) SetCoinRewards(d decimal.Decimal) {
	m.coin_rewards = &d
}

// CoinRewards returns the value of the "coin_rewards" field in the mutation.
func (m *UserCoinRewardMutation) CoinRewards() (r decimal.Decimal, exists bool) {
	v := m.coin_rewards
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinRewards returns the old "coin_rewards" field's value of the UserCoinReward entity.
// If the UserCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCoinRewardMutation) OldCoinRewards(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinRewards is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinRewards requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinRewards: %w", err)
	}
	return oldValue.CoinRewards, nil
}

// ClearCoinRewards clears the value of the "coin_rewards" field.
func (m *UserCoinRewardMutation) ClearCoinRewards() {
	m.coin_rewards = nil
	m.clearedFields[usercoinreward.FieldCoinRewards] = struct{}{}
}

// CoinRewardsCleared returns if the "coin_rewards" field was cleared in this mutation.
func (m *UserCoinRewardMutation) CoinRewardsCleared() bool {
	_, ok := m.clearedFields[usercoinreward.FieldCoinRewards]
	return ok
}

// ResetCoinRewards resets all changes to the "coin_rewards" field.
func (m *UserCoinRewardMutation) ResetCoinRewards() {
	m.coin_rewards = nil
	delete(m.clearedFields, usercoinreward.FieldCoinRewards)
}

// Where appends a list predicates to the UserCoinRewardMutation builder.
func (m *UserCoinRewardMutation) Where(ps ...predicate.UserCoinReward) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCoinRewardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCoinRewardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCoinReward, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCoinRewardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCoinRewardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCoinReward).
func (m *UserCoinRewardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCoinRewardMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, usercoinreward.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usercoinreward.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usercoinreward.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, usercoinreward.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, usercoinreward.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, usercoinreward.FieldUserID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, usercoinreward.FieldCoinTypeID)
	}
	if m.coin_rewards != nil {
		fields = append(fields, usercoinreward.FieldCoinRewards)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCoinRewardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercoinreward.FieldCreatedAt:
		return m.CreatedAt()
	case usercoinreward.FieldUpdatedAt:
		return m.UpdatedAt()
	case usercoinreward.FieldDeletedAt:
		return m.DeletedAt()
	case usercoinreward.FieldEntID:
		return m.EntID()
	case usercoinreward.FieldAppID:
		return m.AppID()
	case usercoinreward.FieldUserID:
		return m.UserID()
	case usercoinreward.FieldCoinTypeID:
		return m.CoinTypeID()
	case usercoinreward.FieldCoinRewards:
		return m.CoinRewards()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCoinRewardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercoinreward.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usercoinreward.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usercoinreward.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usercoinreward.FieldEntID:
		return m.OldEntID(ctx)
	case usercoinreward.FieldAppID:
		return m.OldAppID(ctx)
	case usercoinreward.FieldUserID:
		return m.OldUserID(ctx)
	case usercoinreward.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case usercoinreward.FieldCoinRewards:
		return m.OldCoinRewards(ctx)
	}
	return nil, fmt.Errorf("unknown UserCoinReward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCoinRewardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercoinreward.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usercoinreward.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usercoinreward.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usercoinreward.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case usercoinreward.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case usercoinreward.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usercoinreward.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case usercoinreward.FieldCoinRewards:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinRewards(v)
		return nil
	}
	return fmt.Errorf("unknown UserCoinReward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCoinRewardMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, usercoinreward.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, usercoinreward.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, usercoinreward.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCoinRewardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usercoinreward.FieldCreatedAt:
		return m.AddedCreatedAt()
	case usercoinreward.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case usercoinreward.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCoinRewardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usercoinreward.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case usercoinreward.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case usercoinreward.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserCoinReward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCoinRewardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usercoinreward.FieldAppID) {
		fields = append(fields, usercoinreward.FieldAppID)
	}
	if m.FieldCleared(usercoinreward.FieldUserID) {
		fields = append(fields, usercoinreward.FieldUserID)
	}
	if m.FieldCleared(usercoinreward.FieldCoinTypeID) {
		fields = append(fields, usercoinreward.FieldCoinTypeID)
	}
	if m.FieldCleared(usercoinreward.FieldCoinRewards) {
		fields = append(fields, usercoinreward.FieldCoinRewards)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCoinRewardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCoinRewardMutation) ClearField(name string) error {
	switch name {
	case usercoinreward.FieldAppID:
		m.ClearAppID()
		return nil
	case usercoinreward.FieldUserID:
		m.ClearUserID()
		return nil
	case usercoinreward.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case usercoinreward.FieldCoinRewards:
		m.ClearCoinRewards()
		return nil
	}
	return fmt.Errorf("unknown UserCoinReward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCoinRewardMutation) ResetField(name string) error {
	switch name {
	case usercoinreward.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usercoinreward.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usercoinreward.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usercoinreward.FieldEntID:
		m.ResetEntID()
		return nil
	case usercoinreward.FieldAppID:
		m.ResetAppID()
		return nil
	case usercoinreward.FieldUserID:
		m.ResetUserID()
		return nil
	case usercoinreward.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case usercoinreward.FieldCoinRewards:
		m.ResetCoinRewards()
		return nil
	}
	return fmt.Errorf("unknown UserCoinReward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCoinRewardMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCoinRewardMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCoinRewardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCoinRewardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCoinRewardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCoinRewardMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCoinRewardMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserCoinReward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCoinRewardMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserCoinReward edge %s", name)
}

// UserRewardMutation represents an operation that mutates the UserReward nodes in the graph.
type UserRewardMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint32
	created_at             *uint32
	addcreated_at          *int32
	updated_at             *uint32
	addupdated_at          *int32
	deleted_at             *uint32
	adddeleted_at          *int32
	ent_id                 *uuid.UUID
	app_id                 *uuid.UUID
	user_id                *uuid.UUID
	action_credits         *decimal.Decimal
	coupon_amount          *decimal.Decimal
	coupon_cashable_amount *decimal.Decimal
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*UserReward, error)
	predicates             []predicate.UserReward
}

var _ ent.Mutation = (*UserRewardMutation)(nil)

// userrewardOption allows management of the mutation configuration using functional options.
type userrewardOption func(*UserRewardMutation)

// newUserRewardMutation creates new mutation for the UserReward entity.
func newUserRewardMutation(c config, op Op, opts ...userrewardOption) *UserRewardMutation {
	m := &UserRewardMutation{
		config:        c,
		op:            op,
		typ:           TypeUserReward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRewardID sets the ID field of the mutation.
func withUserRewardID(id uint32) userrewardOption {
	return func(m *UserRewardMutation) {
		var (
			err   error
			once  sync.Once
			value *UserReward
		)
		m.oldValue = func(ctx context.Context) (*UserReward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserReward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserReward sets the old UserReward of the mutation.
func withUserReward(node *UserReward) userrewardOption {
	return func(m *UserRewardMutation) {
		m.oldValue = func(context.Context) (*UserReward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRewardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRewardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserReward entities.
func (m *UserRewardMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRewardMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRewardMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserReward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRewardMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRewardMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *UserRewardMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserRewardMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRewardMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRewardMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRewardMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *UserRewardMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserRewardMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRewardMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserRewardMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserRewardMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *UserRewardMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserRewardMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserRewardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *UserRewardMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *UserRewardMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *UserRewardMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *UserRewardMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *UserRewardMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *UserRewardMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[userreward.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *UserRewardMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[userreward.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *UserRewardMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, userreward.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *UserRewardMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRewardMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserRewardMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[userreward.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserRewardMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userreward.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRewardMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, userreward.FieldUserID)
}

// SetActionCredits sets the "action_credits" field.
func (m *UserRewardMutation) SetActionCredits(d decimal.Decimal) {
	m.action_credits = &d
}

// ActionCredits returns the value of the "action_credits" field in the mutation.
func (m *UserRewardMutation) ActionCredits() (r decimal.Decimal, exists bool) {
	v := m.action_credits
	if v == nil {
		return
	}
	return *v, true
}

// OldActionCredits returns the old "action_credits" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldActionCredits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionCredits: %w", err)
	}
	return oldValue.ActionCredits, nil
}

// ClearActionCredits clears the value of the "action_credits" field.
func (m *UserRewardMutation) ClearActionCredits() {
	m.action_credits = nil
	m.clearedFields[userreward.FieldActionCredits] = struct{}{}
}

// ActionCreditsCleared returns if the "action_credits" field was cleared in this mutation.
func (m *UserRewardMutation) ActionCreditsCleared() bool {
	_, ok := m.clearedFields[userreward.FieldActionCredits]
	return ok
}

// ResetActionCredits resets all changes to the "action_credits" field.
func (m *UserRewardMutation) ResetActionCredits() {
	m.action_credits = nil
	delete(m.clearedFields, userreward.FieldActionCredits)
}

// SetCouponAmount sets the "coupon_amount" field.
func (m *UserRewardMutation) SetCouponAmount(d decimal.Decimal) {
	m.coupon_amount = &d
}

// CouponAmount returns the value of the "coupon_amount" field in the mutation.
func (m *UserRewardMutation) CouponAmount() (r decimal.Decimal, exists bool) {
	v := m.coupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponAmount returns the old "coupon_amount" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldCouponAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponAmount: %w", err)
	}
	return oldValue.CouponAmount, nil
}

// ClearCouponAmount clears the value of the "coupon_amount" field.
func (m *UserRewardMutation) ClearCouponAmount() {
	m.coupon_amount = nil
	m.clearedFields[userreward.FieldCouponAmount] = struct{}{}
}

// CouponAmountCleared returns if the "coupon_amount" field was cleared in this mutation.
func (m *UserRewardMutation) CouponAmountCleared() bool {
	_, ok := m.clearedFields[userreward.FieldCouponAmount]
	return ok
}

// ResetCouponAmount resets all changes to the "coupon_amount" field.
func (m *UserRewardMutation) ResetCouponAmount() {
	m.coupon_amount = nil
	delete(m.clearedFields, userreward.FieldCouponAmount)
}

// SetCouponCashableAmount sets the "coupon_cashable_amount" field.
func (m *UserRewardMutation) SetCouponCashableAmount(d decimal.Decimal) {
	m.coupon_cashable_amount = &d
}

// CouponCashableAmount returns the value of the "coupon_cashable_amount" field in the mutation.
func (m *UserRewardMutation) CouponCashableAmount() (r decimal.Decimal, exists bool) {
	v := m.coupon_cashable_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponCashableAmount returns the old "coupon_cashable_amount" field's value of the UserReward entity.
// If the UserReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRewardMutation) OldCouponCashableAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponCashableAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponCashableAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponCashableAmount: %w", err)
	}
	return oldValue.CouponCashableAmount, nil
}

// ClearCouponCashableAmount clears the value of the "coupon_cashable_amount" field.
func (m *UserRewardMutation) ClearCouponCashableAmount() {
	m.coupon_cashable_amount = nil
	m.clearedFields[userreward.FieldCouponCashableAmount] = struct{}{}
}

// CouponCashableAmountCleared returns if the "coupon_cashable_amount" field was cleared in this mutation.
func (m *UserRewardMutation) CouponCashableAmountCleared() bool {
	_, ok := m.clearedFields[userreward.FieldCouponCashableAmount]
	return ok
}

// ResetCouponCashableAmount resets all changes to the "coupon_cashable_amount" field.
func (m *UserRewardMutation) ResetCouponCashableAmount() {
	m.coupon_cashable_amount = nil
	delete(m.clearedFields, userreward.FieldCouponCashableAmount)
}

// Where appends a list predicates to the UserRewardMutation builder.
func (m *UserRewardMutation) Where(ps ...predicate.UserReward) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRewardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRewardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserReward, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRewardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRewardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserReward).
func (m *UserRewardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRewardMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, userreward.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userreward.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userreward.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, userreward.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, userreward.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, userreward.FieldUserID)
	}
	if m.action_credits != nil {
		fields = append(fields, userreward.FieldActionCredits)
	}
	if m.coupon_amount != nil {
		fields = append(fields, userreward.FieldCouponAmount)
	}
	if m.coupon_cashable_amount != nil {
		fields = append(fields, userreward.FieldCouponCashableAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRewardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userreward.FieldCreatedAt:
		return m.CreatedAt()
	case userreward.FieldUpdatedAt:
		return m.UpdatedAt()
	case userreward.FieldDeletedAt:
		return m.DeletedAt()
	case userreward.FieldEntID:
		return m.EntID()
	case userreward.FieldAppID:
		return m.AppID()
	case userreward.FieldUserID:
		return m.UserID()
	case userreward.FieldActionCredits:
		return m.ActionCredits()
	case userreward.FieldCouponAmount:
		return m.CouponAmount()
	case userreward.FieldCouponCashableAmount:
		return m.CouponCashableAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRewardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userreward.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userreward.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userreward.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userreward.FieldEntID:
		return m.OldEntID(ctx)
	case userreward.FieldAppID:
		return m.OldAppID(ctx)
	case userreward.FieldUserID:
		return m.OldUserID(ctx)
	case userreward.FieldActionCredits:
		return m.OldActionCredits(ctx)
	case userreward.FieldCouponAmount:
		return m.OldCouponAmount(ctx)
	case userreward.FieldCouponCashableAmount:
		return m.OldCouponCashableAmount(ctx)
	}
	return nil, fmt.Errorf("unknown UserReward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRewardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userreward.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userreward.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userreward.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userreward.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case userreward.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case userreward.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userreward.FieldActionCredits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionCredits(v)
		return nil
	case userreward.FieldCouponAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponAmount(v)
		return nil
	case userreward.FieldCouponCashableAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponCashableAmount(v)
		return nil
	}
	return fmt.Errorf("unknown UserReward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRewardMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, userreward.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, userreward.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, userreward.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRewardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userreward.FieldCreatedAt:
		return m.AddedCreatedAt()
	case userreward.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case userreward.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRewardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userreward.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case userreward.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case userreward.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserReward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRewardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userreward.FieldAppID) {
		fields = append(fields, userreward.FieldAppID)
	}
	if m.FieldCleared(userreward.FieldUserID) {
		fields = append(fields, userreward.FieldUserID)
	}
	if m.FieldCleared(userreward.FieldActionCredits) {
		fields = append(fields, userreward.FieldActionCredits)
	}
	if m.FieldCleared(userreward.FieldCouponAmount) {
		fields = append(fields, userreward.FieldCouponAmount)
	}
	if m.FieldCleared(userreward.FieldCouponCashableAmount) {
		fields = append(fields, userreward.FieldCouponCashableAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRewardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRewardMutation) ClearField(name string) error {
	switch name {
	case userreward.FieldAppID:
		m.ClearAppID()
		return nil
	case userreward.FieldUserID:
		m.ClearUserID()
		return nil
	case userreward.FieldActionCredits:
		m.ClearActionCredits()
		return nil
	case userreward.FieldCouponAmount:
		m.ClearCouponAmount()
		return nil
	case userreward.FieldCouponCashableAmount:
		m.ClearCouponCashableAmount()
		return nil
	}
	return fmt.Errorf("unknown UserReward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRewardMutation) ResetField(name string) error {
	switch name {
	case userreward.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userreward.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userreward.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userreward.FieldEntID:
		m.ResetEntID()
		return nil
	case userreward.FieldAppID:
		m.ResetAppID()
		return nil
	case userreward.FieldUserID:
		m.ResetUserID()
		return nil
	case userreward.FieldActionCredits:
		m.ResetActionCredits()
		return nil
	case userreward.FieldCouponAmount:
		m.ResetCouponAmount()
		return nil
	case userreward.FieldCouponCashableAmount:
		m.ResetCouponCashableAmount()
		return nil
	}
	return fmt.Errorf("unknown UserReward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRewardMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRewardMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRewardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRewardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRewardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRewardMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRewardMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserReward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRewardMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserReward edge %s", name)
}
