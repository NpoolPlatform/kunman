// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appdefaultgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appdelegatedstaking"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appfee"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgoodbase"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgooddescription"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgooddisplaycolor"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgooddisplayname"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgoodlabel"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgoodposter"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/applegacypowerrental"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appmininggoodstock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/apppowerrental"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appsimulatepowerrental"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appstock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appstocklock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appsubscription"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appsubscriptiononeshot"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/comment"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/delegatedstaking"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/deviceinfo"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/devicemanufacturer"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/deviceposter"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/extrainfo"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/fbmcrowdfunding"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/fee"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/good"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodbase"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodcoin"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodcoinreward"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodmalfunction"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodreward"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodrewardhistory"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/like"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/mininggoodstock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/powerrental"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/predicate"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/recommend"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/requiredappgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/requiredgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/score"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/stock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/subscription"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/subscriptiononeshot"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmost"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostconstraint"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostgoodconstraint"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostgoodposter"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostposter"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/vendorbrand"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/vendorlocation"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppDefaultGood         = "AppDefaultGood"
	TypeAppDelegatedStaking    = "AppDelegatedStaking"
	TypeAppFee                 = "AppFee"
	TypeAppGood                = "AppGood"
	TypeAppGoodBase            = "AppGoodBase"
	TypeAppGoodDescription     = "AppGoodDescription"
	TypeAppGoodDisplayColor    = "AppGoodDisplayColor"
	TypeAppGoodDisplayName     = "AppGoodDisplayName"
	TypeAppGoodLabel           = "AppGoodLabel"
	TypeAppGoodPoster          = "AppGoodPoster"
	TypeAppLegacyPowerRental   = "AppLegacyPowerRental"
	TypeAppMiningGoodStock     = "AppMiningGoodStock"
	TypeAppPowerRental         = "AppPowerRental"
	TypeAppSimulatePowerRental = "AppSimulatePowerRental"
	TypeAppStock               = "AppStock"
	TypeAppStockLock           = "AppStockLock"
	TypeAppSubscription        = "AppSubscription"
	TypeAppSubscriptionOneShot = "AppSubscriptionOneShot"
	TypeComment                = "Comment"
	TypeDelegatedStaking       = "DelegatedStaking"
	TypeDeviceInfo             = "DeviceInfo"
	TypeDeviceManufacturer     = "DeviceManufacturer"
	TypeDevicePoster           = "DevicePoster"
	TypeExtraInfo              = "ExtraInfo"
	TypeFbmCrowdFunding        = "FbmCrowdFunding"
	TypeFee                    = "Fee"
	TypeGood                   = "Good"
	TypeGoodBase               = "GoodBase"
	TypeGoodCoin               = "GoodCoin"
	TypeGoodCoinReward         = "GoodCoinReward"
	TypeGoodMalfunction        = "GoodMalfunction"
	TypeGoodReward             = "GoodReward"
	TypeGoodRewardHistory      = "GoodRewardHistory"
	TypeLike                   = "Like"
	TypeMiningGoodStock        = "MiningGoodStock"
	TypePowerRental            = "PowerRental"
	TypeRecommend              = "Recommend"
	TypeRequiredAppGood        = "RequiredAppGood"
	TypeRequiredGood           = "RequiredGood"
	TypeScore                  = "Score"
	TypeStock                  = "Stock"
	TypeSubscription           = "Subscription"
	TypeSubscriptionOneShot    = "SubscriptionOneShot"
	TypeTopMost                = "TopMost"
	TypeTopMostConstraint      = "TopMostConstraint"
	TypeTopMostGood            = "TopMostGood"
	TypeTopMostGoodConstraint  = "TopMostGoodConstraint"
	TypeTopMostGoodPoster      = "TopMostGoodPoster"
	TypeTopMostPoster          = "TopMostPoster"
	TypeVendorBrand            = "VendorBrand"
	TypeVendorLocation         = "VendorLocation"
)

// AppDefaultGoodMutation represents an operation that mutates the AppDefaultGood nodes in the graph.
type AppDefaultGoodMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_good_id   *uuid.UUID
	coin_type_id  *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppDefaultGood, error)
	predicates    []predicate.AppDefaultGood
}

var _ ent.Mutation = (*AppDefaultGoodMutation)(nil)

// appdefaultgoodOption allows management of the mutation configuration using functional options.
type appdefaultgoodOption func(*AppDefaultGoodMutation)

// newAppDefaultGoodMutation creates new mutation for the AppDefaultGood entity.
func newAppDefaultGoodMutation(c config, op Op, opts ...appdefaultgoodOption) *AppDefaultGoodMutation {
	m := &AppDefaultGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeAppDefaultGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppDefaultGoodID sets the ID field of the mutation.
func withAppDefaultGoodID(id uint32) appdefaultgoodOption {
	return func(m *AppDefaultGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *AppDefaultGood
		)
		m.oldValue = func(ctx context.Context) (*AppDefaultGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppDefaultGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppDefaultGood sets the old AppDefaultGood of the mutation.
func withAppDefaultGood(node *AppDefaultGood) appdefaultgoodOption {
	return func(m *AppDefaultGoodMutation) {
		m.oldValue = func(context.Context) (*AppDefaultGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppDefaultGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppDefaultGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppDefaultGood entities.
func (m *AppDefaultGoodMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppDefaultGoodMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppDefaultGoodMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppDefaultGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppDefaultGoodMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppDefaultGoodMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppDefaultGoodMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppDefaultGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppDefaultGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppDefaultGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppDefaultGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppDefaultGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppDefaultGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppDefaultGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppDefaultGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppDefaultGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppDefaultGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppDefaultGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppDefaultGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppDefaultGoodMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppDefaultGoodMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppDefaultGoodMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appdefaultgood.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppDefaultGoodMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appdefaultgood.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppDefaultGoodMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appdefaultgood.FieldAppGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *AppDefaultGoodMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *AppDefaultGoodMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *AppDefaultGoodMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[appdefaultgood.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *AppDefaultGoodMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[appdefaultgood.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *AppDefaultGoodMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, appdefaultgood.FieldCoinTypeID)
}

// Where appends a list predicates to the AppDefaultGoodMutation builder.
func (m *AppDefaultGoodMutation) Where(ps ...predicate.AppDefaultGood) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppDefaultGoodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppDefaultGoodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppDefaultGood, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppDefaultGoodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppDefaultGoodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppDefaultGood).
func (m *AppDefaultGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppDefaultGoodMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.ent_id != nil {
		fields = append(fields, appdefaultgood.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appdefaultgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appdefaultgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appdefaultgood.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appdefaultgood.FieldAppGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, appdefaultgood.FieldCoinTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppDefaultGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appdefaultgood.FieldEntID:
		return m.EntID()
	case appdefaultgood.FieldCreatedAt:
		return m.CreatedAt()
	case appdefaultgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case appdefaultgood.FieldDeletedAt:
		return m.DeletedAt()
	case appdefaultgood.FieldAppGoodID:
		return m.AppGoodID()
	case appdefaultgood.FieldCoinTypeID:
		return m.CoinTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppDefaultGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appdefaultgood.FieldEntID:
		return m.OldEntID(ctx)
	case appdefaultgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appdefaultgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appdefaultgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appdefaultgood.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appdefaultgood.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppDefaultGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appdefaultgood.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appdefaultgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appdefaultgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appdefaultgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appdefaultgood.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appdefaultgood.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppDefaultGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appdefaultgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appdefaultgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appdefaultgood.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppDefaultGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appdefaultgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appdefaultgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppDefaultGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appdefaultgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appdefaultgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppDefaultGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appdefaultgood.FieldAppGoodID) {
		fields = append(fields, appdefaultgood.FieldAppGoodID)
	}
	if m.FieldCleared(appdefaultgood.FieldCoinTypeID) {
		fields = append(fields, appdefaultgood.FieldCoinTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppDefaultGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppDefaultGoodMutation) ClearField(name string) error {
	switch name {
	case appdefaultgood.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appdefaultgood.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppDefaultGoodMutation) ResetField(name string) error {
	switch name {
	case appdefaultgood.FieldEntID:
		m.ResetEntID()
		return nil
	case appdefaultgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appdefaultgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appdefaultgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appdefaultgood.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appdefaultgood.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppDefaultGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppDefaultGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppDefaultGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppDefaultGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppDefaultGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppDefaultGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppDefaultGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppDefaultGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppDefaultGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppDefaultGood edge %s", name)
}

// AppDelegatedStakingMutation represents an operation that mutates the AppDelegatedStaking nodes in the graph.
type AppDelegatedStakingMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	ent_id                *uuid.UUID
	created_at            *uint32
	addcreated_at         *int32
	updated_at            *uint32
	addupdated_at         *int32
	deleted_at            *uint32
	adddeleted_at         *int32
	app_good_id           *uuid.UUID
	service_start_at      *uint32
	addservice_start_at   *int32
	start_mode            *string
	enable_set_commission *bool
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*AppDelegatedStaking, error)
	predicates            []predicate.AppDelegatedStaking
}

var _ ent.Mutation = (*AppDelegatedStakingMutation)(nil)

// appdelegatedstakingOption allows management of the mutation configuration using functional options.
type appdelegatedstakingOption func(*AppDelegatedStakingMutation)

// newAppDelegatedStakingMutation creates new mutation for the AppDelegatedStaking entity.
func newAppDelegatedStakingMutation(c config, op Op, opts ...appdelegatedstakingOption) *AppDelegatedStakingMutation {
	m := &AppDelegatedStakingMutation{
		config:        c,
		op:            op,
		typ:           TypeAppDelegatedStaking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppDelegatedStakingID sets the ID field of the mutation.
func withAppDelegatedStakingID(id uint32) appdelegatedstakingOption {
	return func(m *AppDelegatedStakingMutation) {
		var (
			err   error
			once  sync.Once
			value *AppDelegatedStaking
		)
		m.oldValue = func(ctx context.Context) (*AppDelegatedStaking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppDelegatedStaking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppDelegatedStaking sets the old AppDelegatedStaking of the mutation.
func withAppDelegatedStaking(node *AppDelegatedStaking) appdelegatedstakingOption {
	return func(m *AppDelegatedStakingMutation) {
		m.oldValue = func(context.Context) (*AppDelegatedStaking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppDelegatedStakingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppDelegatedStakingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppDelegatedStaking entities.
func (m *AppDelegatedStakingMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppDelegatedStakingMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppDelegatedStakingMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppDelegatedStaking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppDelegatedStakingMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppDelegatedStakingMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppDelegatedStaking entity.
// If the AppDelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDelegatedStakingMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppDelegatedStakingMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppDelegatedStakingMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppDelegatedStakingMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppDelegatedStaking entity.
// If the AppDelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDelegatedStakingMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppDelegatedStakingMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppDelegatedStakingMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppDelegatedStakingMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppDelegatedStakingMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppDelegatedStakingMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppDelegatedStaking entity.
// If the AppDelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDelegatedStakingMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppDelegatedStakingMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppDelegatedStakingMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppDelegatedStakingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppDelegatedStakingMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppDelegatedStakingMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppDelegatedStaking entity.
// If the AppDelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDelegatedStakingMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppDelegatedStakingMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppDelegatedStakingMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppDelegatedStakingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppDelegatedStakingMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppDelegatedStakingMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppDelegatedStaking entity.
// If the AppDelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDelegatedStakingMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppDelegatedStakingMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appdelegatedstaking.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppDelegatedStakingMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appdelegatedstaking.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppDelegatedStakingMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appdelegatedstaking.FieldAppGoodID)
}

// SetServiceStartAt sets the "service_start_at" field.
func (m *AppDelegatedStakingMutation) SetServiceStartAt(u uint32) {
	m.service_start_at = &u
	m.addservice_start_at = nil
}

// ServiceStartAt returns the value of the "service_start_at" field in the mutation.
func (m *AppDelegatedStakingMutation) ServiceStartAt() (r uint32, exists bool) {
	v := m.service_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceStartAt returns the old "service_start_at" field's value of the AppDelegatedStaking entity.
// If the AppDelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDelegatedStakingMutation) OldServiceStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceStartAt: %w", err)
	}
	return oldValue.ServiceStartAt, nil
}

// AddServiceStartAt adds u to the "service_start_at" field.
func (m *AppDelegatedStakingMutation) AddServiceStartAt(u int32) {
	if m.addservice_start_at != nil {
		*m.addservice_start_at += u
	} else {
		m.addservice_start_at = &u
	}
}

// AddedServiceStartAt returns the value that was added to the "service_start_at" field in this mutation.
func (m *AppDelegatedStakingMutation) AddedServiceStartAt() (r int32, exists bool) {
	v := m.addservice_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearServiceStartAt clears the value of the "service_start_at" field.
func (m *AppDelegatedStakingMutation) ClearServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	m.clearedFields[appdelegatedstaking.FieldServiceStartAt] = struct{}{}
}

// ServiceStartAtCleared returns if the "service_start_at" field was cleared in this mutation.
func (m *AppDelegatedStakingMutation) ServiceStartAtCleared() bool {
	_, ok := m.clearedFields[appdelegatedstaking.FieldServiceStartAt]
	return ok
}

// ResetServiceStartAt resets all changes to the "service_start_at" field.
func (m *AppDelegatedStakingMutation) ResetServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	delete(m.clearedFields, appdelegatedstaking.FieldServiceStartAt)
}

// SetStartMode sets the "start_mode" field.
func (m *AppDelegatedStakingMutation) SetStartMode(s string) {
	m.start_mode = &s
}

// StartMode returns the value of the "start_mode" field in the mutation.
func (m *AppDelegatedStakingMutation) StartMode() (r string, exists bool) {
	v := m.start_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStartMode returns the old "start_mode" field's value of the AppDelegatedStaking entity.
// If the AppDelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDelegatedStakingMutation) OldStartMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartMode: %w", err)
	}
	return oldValue.StartMode, nil
}

// ClearStartMode clears the value of the "start_mode" field.
func (m *AppDelegatedStakingMutation) ClearStartMode() {
	m.start_mode = nil
	m.clearedFields[appdelegatedstaking.FieldStartMode] = struct{}{}
}

// StartModeCleared returns if the "start_mode" field was cleared in this mutation.
func (m *AppDelegatedStakingMutation) StartModeCleared() bool {
	_, ok := m.clearedFields[appdelegatedstaking.FieldStartMode]
	return ok
}

// ResetStartMode resets all changes to the "start_mode" field.
func (m *AppDelegatedStakingMutation) ResetStartMode() {
	m.start_mode = nil
	delete(m.clearedFields, appdelegatedstaking.FieldStartMode)
}

// SetEnableSetCommission sets the "enable_set_commission" field.
func (m *AppDelegatedStakingMutation) SetEnableSetCommission(b bool) {
	m.enable_set_commission = &b
}

// EnableSetCommission returns the value of the "enable_set_commission" field in the mutation.
func (m *AppDelegatedStakingMutation) EnableSetCommission() (r bool, exists bool) {
	v := m.enable_set_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableSetCommission returns the old "enable_set_commission" field's value of the AppDelegatedStaking entity.
// If the AppDelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDelegatedStakingMutation) OldEnableSetCommission(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableSetCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableSetCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableSetCommission: %w", err)
	}
	return oldValue.EnableSetCommission, nil
}

// ClearEnableSetCommission clears the value of the "enable_set_commission" field.
func (m *AppDelegatedStakingMutation) ClearEnableSetCommission() {
	m.enable_set_commission = nil
	m.clearedFields[appdelegatedstaking.FieldEnableSetCommission] = struct{}{}
}

// EnableSetCommissionCleared returns if the "enable_set_commission" field was cleared in this mutation.
func (m *AppDelegatedStakingMutation) EnableSetCommissionCleared() bool {
	_, ok := m.clearedFields[appdelegatedstaking.FieldEnableSetCommission]
	return ok
}

// ResetEnableSetCommission resets all changes to the "enable_set_commission" field.
func (m *AppDelegatedStakingMutation) ResetEnableSetCommission() {
	m.enable_set_commission = nil
	delete(m.clearedFields, appdelegatedstaking.FieldEnableSetCommission)
}

// Where appends a list predicates to the AppDelegatedStakingMutation builder.
func (m *AppDelegatedStakingMutation) Where(ps ...predicate.AppDelegatedStaking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppDelegatedStakingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppDelegatedStakingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppDelegatedStaking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppDelegatedStakingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppDelegatedStakingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppDelegatedStaking).
func (m *AppDelegatedStakingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppDelegatedStakingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, appdelegatedstaking.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appdelegatedstaking.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appdelegatedstaking.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appdelegatedstaking.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appdelegatedstaking.FieldAppGoodID)
	}
	if m.service_start_at != nil {
		fields = append(fields, appdelegatedstaking.FieldServiceStartAt)
	}
	if m.start_mode != nil {
		fields = append(fields, appdelegatedstaking.FieldStartMode)
	}
	if m.enable_set_commission != nil {
		fields = append(fields, appdelegatedstaking.FieldEnableSetCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppDelegatedStakingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appdelegatedstaking.FieldEntID:
		return m.EntID()
	case appdelegatedstaking.FieldCreatedAt:
		return m.CreatedAt()
	case appdelegatedstaking.FieldUpdatedAt:
		return m.UpdatedAt()
	case appdelegatedstaking.FieldDeletedAt:
		return m.DeletedAt()
	case appdelegatedstaking.FieldAppGoodID:
		return m.AppGoodID()
	case appdelegatedstaking.FieldServiceStartAt:
		return m.ServiceStartAt()
	case appdelegatedstaking.FieldStartMode:
		return m.StartMode()
	case appdelegatedstaking.FieldEnableSetCommission:
		return m.EnableSetCommission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppDelegatedStakingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appdelegatedstaking.FieldEntID:
		return m.OldEntID(ctx)
	case appdelegatedstaking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appdelegatedstaking.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appdelegatedstaking.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appdelegatedstaking.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appdelegatedstaking.FieldServiceStartAt:
		return m.OldServiceStartAt(ctx)
	case appdelegatedstaking.FieldStartMode:
		return m.OldStartMode(ctx)
	case appdelegatedstaking.FieldEnableSetCommission:
		return m.OldEnableSetCommission(ctx)
	}
	return nil, fmt.Errorf("unknown AppDelegatedStaking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppDelegatedStakingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appdelegatedstaking.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appdelegatedstaking.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appdelegatedstaking.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appdelegatedstaking.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appdelegatedstaking.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appdelegatedstaking.FieldServiceStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceStartAt(v)
		return nil
	case appdelegatedstaking.FieldStartMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartMode(v)
		return nil
	case appdelegatedstaking.FieldEnableSetCommission:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableSetCommission(v)
		return nil
	}
	return fmt.Errorf("unknown AppDelegatedStaking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppDelegatedStakingMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appdelegatedstaking.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appdelegatedstaking.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appdelegatedstaking.FieldDeletedAt)
	}
	if m.addservice_start_at != nil {
		fields = append(fields, appdelegatedstaking.FieldServiceStartAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppDelegatedStakingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appdelegatedstaking.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appdelegatedstaking.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appdelegatedstaking.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appdelegatedstaking.FieldServiceStartAt:
		return m.AddedServiceStartAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppDelegatedStakingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appdelegatedstaking.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appdelegatedstaking.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appdelegatedstaking.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appdelegatedstaking.FieldServiceStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceStartAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppDelegatedStaking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppDelegatedStakingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appdelegatedstaking.FieldAppGoodID) {
		fields = append(fields, appdelegatedstaking.FieldAppGoodID)
	}
	if m.FieldCleared(appdelegatedstaking.FieldServiceStartAt) {
		fields = append(fields, appdelegatedstaking.FieldServiceStartAt)
	}
	if m.FieldCleared(appdelegatedstaking.FieldStartMode) {
		fields = append(fields, appdelegatedstaking.FieldStartMode)
	}
	if m.FieldCleared(appdelegatedstaking.FieldEnableSetCommission) {
		fields = append(fields, appdelegatedstaking.FieldEnableSetCommission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppDelegatedStakingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppDelegatedStakingMutation) ClearField(name string) error {
	switch name {
	case appdelegatedstaking.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appdelegatedstaking.FieldServiceStartAt:
		m.ClearServiceStartAt()
		return nil
	case appdelegatedstaking.FieldStartMode:
		m.ClearStartMode()
		return nil
	case appdelegatedstaking.FieldEnableSetCommission:
		m.ClearEnableSetCommission()
		return nil
	}
	return fmt.Errorf("unknown AppDelegatedStaking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppDelegatedStakingMutation) ResetField(name string) error {
	switch name {
	case appdelegatedstaking.FieldEntID:
		m.ResetEntID()
		return nil
	case appdelegatedstaking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appdelegatedstaking.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appdelegatedstaking.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appdelegatedstaking.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appdelegatedstaking.FieldServiceStartAt:
		m.ResetServiceStartAt()
		return nil
	case appdelegatedstaking.FieldStartMode:
		m.ResetStartMode()
		return nil
	case appdelegatedstaking.FieldEnableSetCommission:
		m.ResetEnableSetCommission()
		return nil
	}
	return fmt.Errorf("unknown AppDelegatedStaking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppDelegatedStakingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppDelegatedStakingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppDelegatedStakingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppDelegatedStakingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppDelegatedStakingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppDelegatedStakingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppDelegatedStakingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppDelegatedStaking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppDelegatedStakingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppDelegatedStaking edge %s", name)
}

// AppFeeMutation represents an operation that mutates the AppFee nodes in the graph.
type AppFeeMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uint32
	ent_id                        *uuid.UUID
	created_at                    *uint32
	addcreated_at                 *int32
	updated_at                    *uint32
	addupdated_at                 *int32
	deleted_at                    *uint32
	adddeleted_at                 *int32
	app_good_id                   *uuid.UUID
	unit_value                    *decimal.Decimal
	cancel_mode                   *string
	min_order_duration_seconds    *uint32
	addmin_order_duration_seconds *int32
	clearedFields                 map[string]struct{}
	done                          bool
	oldValue                      func(context.Context) (*AppFee, error)
	predicates                    []predicate.AppFee
}

var _ ent.Mutation = (*AppFeeMutation)(nil)

// appfeeOption allows management of the mutation configuration using functional options.
type appfeeOption func(*AppFeeMutation)

// newAppFeeMutation creates new mutation for the AppFee entity.
func newAppFeeMutation(c config, op Op, opts ...appfeeOption) *AppFeeMutation {
	m := &AppFeeMutation{
		config:        c,
		op:            op,
		typ:           TypeAppFee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppFeeID sets the ID field of the mutation.
func withAppFeeID(id uint32) appfeeOption {
	return func(m *AppFeeMutation) {
		var (
			err   error
			once  sync.Once
			value *AppFee
		)
		m.oldValue = func(ctx context.Context) (*AppFee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppFee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppFee sets the old AppFee of the mutation.
func withAppFee(node *AppFee) appfeeOption {
	return func(m *AppFeeMutation) {
		m.oldValue = func(context.Context) (*AppFee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppFeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppFeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppFee entities.
func (m *AppFeeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppFeeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppFeeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppFee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppFeeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppFeeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppFee entity.
// If the AppFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppFeeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppFeeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppFeeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppFeeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppFee entity.
// If the AppFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppFeeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppFeeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppFeeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppFeeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppFeeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppFeeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppFee entity.
// If the AppFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppFeeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppFeeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppFeeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppFeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppFeeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppFeeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppFee entity.
// If the AppFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppFeeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppFeeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppFeeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppFeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppFeeMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppFeeMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppFee entity.
// If the AppFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppFeeMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppFeeMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appfee.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppFeeMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appfee.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppFeeMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appfee.FieldAppGoodID)
}

// SetUnitValue sets the "unit_value" field.
func (m *AppFeeMutation) SetUnitValue(d decimal.Decimal) {
	m.unit_value = &d
}

// UnitValue returns the value of the "unit_value" field in the mutation.
func (m *AppFeeMutation) UnitValue() (r decimal.Decimal, exists bool) {
	v := m.unit_value
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitValue returns the old "unit_value" field's value of the AppFee entity.
// If the AppFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppFeeMutation) OldUnitValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitValue: %w", err)
	}
	return oldValue.UnitValue, nil
}

// ClearUnitValue clears the value of the "unit_value" field.
func (m *AppFeeMutation) ClearUnitValue() {
	m.unit_value = nil
	m.clearedFields[appfee.FieldUnitValue] = struct{}{}
}

// UnitValueCleared returns if the "unit_value" field was cleared in this mutation.
func (m *AppFeeMutation) UnitValueCleared() bool {
	_, ok := m.clearedFields[appfee.FieldUnitValue]
	return ok
}

// ResetUnitValue resets all changes to the "unit_value" field.
func (m *AppFeeMutation) ResetUnitValue() {
	m.unit_value = nil
	delete(m.clearedFields, appfee.FieldUnitValue)
}

// SetCancelMode sets the "cancel_mode" field.
func (m *AppFeeMutation) SetCancelMode(s string) {
	m.cancel_mode = &s
}

// CancelMode returns the value of the "cancel_mode" field in the mutation.
func (m *AppFeeMutation) CancelMode() (r string, exists bool) {
	v := m.cancel_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelMode returns the old "cancel_mode" field's value of the AppFee entity.
// If the AppFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppFeeMutation) OldCancelMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelMode: %w", err)
	}
	return oldValue.CancelMode, nil
}

// ClearCancelMode clears the value of the "cancel_mode" field.
func (m *AppFeeMutation) ClearCancelMode() {
	m.cancel_mode = nil
	m.clearedFields[appfee.FieldCancelMode] = struct{}{}
}

// CancelModeCleared returns if the "cancel_mode" field was cleared in this mutation.
func (m *AppFeeMutation) CancelModeCleared() bool {
	_, ok := m.clearedFields[appfee.FieldCancelMode]
	return ok
}

// ResetCancelMode resets all changes to the "cancel_mode" field.
func (m *AppFeeMutation) ResetCancelMode() {
	m.cancel_mode = nil
	delete(m.clearedFields, appfee.FieldCancelMode)
}

// SetMinOrderDurationSeconds sets the "min_order_duration_seconds" field.
func (m *AppFeeMutation) SetMinOrderDurationSeconds(u uint32) {
	m.min_order_duration_seconds = &u
	m.addmin_order_duration_seconds = nil
}

// MinOrderDurationSeconds returns the value of the "min_order_duration_seconds" field in the mutation.
func (m *AppFeeMutation) MinOrderDurationSeconds() (r uint32, exists bool) {
	v := m.min_order_duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldMinOrderDurationSeconds returns the old "min_order_duration_seconds" field's value of the AppFee entity.
// If the AppFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppFeeMutation) OldMinOrderDurationSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinOrderDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinOrderDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinOrderDurationSeconds: %w", err)
	}
	return oldValue.MinOrderDurationSeconds, nil
}

// AddMinOrderDurationSeconds adds u to the "min_order_duration_seconds" field.
func (m *AppFeeMutation) AddMinOrderDurationSeconds(u int32) {
	if m.addmin_order_duration_seconds != nil {
		*m.addmin_order_duration_seconds += u
	} else {
		m.addmin_order_duration_seconds = &u
	}
}

// AddedMinOrderDurationSeconds returns the value that was added to the "min_order_duration_seconds" field in this mutation.
func (m *AppFeeMutation) AddedMinOrderDurationSeconds() (r int32, exists bool) {
	v := m.addmin_order_duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinOrderDurationSeconds clears the value of the "min_order_duration_seconds" field.
func (m *AppFeeMutation) ClearMinOrderDurationSeconds() {
	m.min_order_duration_seconds = nil
	m.addmin_order_duration_seconds = nil
	m.clearedFields[appfee.FieldMinOrderDurationSeconds] = struct{}{}
}

// MinOrderDurationSecondsCleared returns if the "min_order_duration_seconds" field was cleared in this mutation.
func (m *AppFeeMutation) MinOrderDurationSecondsCleared() bool {
	_, ok := m.clearedFields[appfee.FieldMinOrderDurationSeconds]
	return ok
}

// ResetMinOrderDurationSeconds resets all changes to the "min_order_duration_seconds" field.
func (m *AppFeeMutation) ResetMinOrderDurationSeconds() {
	m.min_order_duration_seconds = nil
	m.addmin_order_duration_seconds = nil
	delete(m.clearedFields, appfee.FieldMinOrderDurationSeconds)
}

// Where appends a list predicates to the AppFeeMutation builder.
func (m *AppFeeMutation) Where(ps ...predicate.AppFee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppFeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppFeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppFee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppFeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppFeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppFee).
func (m *AppFeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppFeeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, appfee.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appfee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appfee.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appfee.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appfee.FieldAppGoodID)
	}
	if m.unit_value != nil {
		fields = append(fields, appfee.FieldUnitValue)
	}
	if m.cancel_mode != nil {
		fields = append(fields, appfee.FieldCancelMode)
	}
	if m.min_order_duration_seconds != nil {
		fields = append(fields, appfee.FieldMinOrderDurationSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppFeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appfee.FieldEntID:
		return m.EntID()
	case appfee.FieldCreatedAt:
		return m.CreatedAt()
	case appfee.FieldUpdatedAt:
		return m.UpdatedAt()
	case appfee.FieldDeletedAt:
		return m.DeletedAt()
	case appfee.FieldAppGoodID:
		return m.AppGoodID()
	case appfee.FieldUnitValue:
		return m.UnitValue()
	case appfee.FieldCancelMode:
		return m.CancelMode()
	case appfee.FieldMinOrderDurationSeconds:
		return m.MinOrderDurationSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppFeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appfee.FieldEntID:
		return m.OldEntID(ctx)
	case appfee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appfee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appfee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appfee.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appfee.FieldUnitValue:
		return m.OldUnitValue(ctx)
	case appfee.FieldCancelMode:
		return m.OldCancelMode(ctx)
	case appfee.FieldMinOrderDurationSeconds:
		return m.OldMinOrderDurationSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown AppFee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppFeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appfee.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appfee.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appfee.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appfee.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appfee.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appfee.FieldUnitValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitValue(v)
		return nil
	case appfee.FieldCancelMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelMode(v)
		return nil
	case appfee.FieldMinOrderDurationSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinOrderDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown AppFee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppFeeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appfee.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appfee.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appfee.FieldDeletedAt)
	}
	if m.addmin_order_duration_seconds != nil {
		fields = append(fields, appfee.FieldMinOrderDurationSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppFeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appfee.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appfee.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appfee.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appfee.FieldMinOrderDurationSeconds:
		return m.AddedMinOrderDurationSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppFeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appfee.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appfee.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appfee.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appfee.FieldMinOrderDurationSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinOrderDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown AppFee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppFeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appfee.FieldAppGoodID) {
		fields = append(fields, appfee.FieldAppGoodID)
	}
	if m.FieldCleared(appfee.FieldUnitValue) {
		fields = append(fields, appfee.FieldUnitValue)
	}
	if m.FieldCleared(appfee.FieldCancelMode) {
		fields = append(fields, appfee.FieldCancelMode)
	}
	if m.FieldCleared(appfee.FieldMinOrderDurationSeconds) {
		fields = append(fields, appfee.FieldMinOrderDurationSeconds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppFeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppFeeMutation) ClearField(name string) error {
	switch name {
	case appfee.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appfee.FieldUnitValue:
		m.ClearUnitValue()
		return nil
	case appfee.FieldCancelMode:
		m.ClearCancelMode()
		return nil
	case appfee.FieldMinOrderDurationSeconds:
		m.ClearMinOrderDurationSeconds()
		return nil
	}
	return fmt.Errorf("unknown AppFee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppFeeMutation) ResetField(name string) error {
	switch name {
	case appfee.FieldEntID:
		m.ResetEntID()
		return nil
	case appfee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appfee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appfee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appfee.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appfee.FieldUnitValue:
		m.ResetUnitValue()
		return nil
	case appfee.FieldCancelMode:
		m.ResetCancelMode()
		return nil
	case appfee.FieldMinOrderDurationSeconds:
		m.ResetMinOrderDurationSeconds()
		return nil
	}
	return fmt.Errorf("unknown AppFee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppFeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppFeeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppFeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppFeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppFeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppFeeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppFeeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppFee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppFeeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppFee edge %s", name)
}

// AppGoodMutation represents an operation that mutates the AppGood nodes in the graph.
type AppGoodMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uint32
	ent_id                      *uuid.UUID
	created_at                  *uint32
	addcreated_at               *int32
	updated_at                  *uint32
	addupdated_at               *int32
	deleted_at                  *uint32
	adddeleted_at               *int32
	app_id                      *uuid.UUID
	good_id                     *uuid.UUID
	online                      *bool
	visible                     *bool
	good_name                   *string
	unit_price                  *decimal.Decimal
	package_price               *decimal.Decimal
	display_index               *int32
	adddisplay_index            *int32
	sale_start_at               *uint32
	addsale_start_at            *int32
	sale_end_at                 *uint32
	addsale_end_at              *int32
	service_start_at            *uint32
	addservice_start_at         *int32
	technical_fee_ratio         *decimal.Decimal
	electricity_fee_ratio       *decimal.Decimal
	descriptions                *[]string
	appenddescriptions          []string
	good_banner                 *string
	display_names               *[]string
	appenddisplay_names         []string
	enable_purchase             *bool
	enable_product_page         *bool
	cancel_mode                 *string
	display_colors              *[]string
	appenddisplay_colors        []string
	cancellable_before_start    *uint32
	addcancellable_before_start *int32
	product_page                *string
	enable_set_commission       *bool
	posters                     *[]string
	appendposters               []string
	min_order_amount            *decimal.Decimal
	max_order_amount            *decimal.Decimal
	max_user_amount             *decimal.Decimal
	min_order_duration          *uint32
	addmin_order_duration       *int32
	max_order_duration          *uint32
	addmax_order_duration       *int32
	package_with_requireds      *bool
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*AppGood, error)
	predicates                  []predicate.AppGood
}

var _ ent.Mutation = (*AppGoodMutation)(nil)

// appgoodOption allows management of the mutation configuration using functional options.
type appgoodOption func(*AppGoodMutation)

// newAppGoodMutation creates new mutation for the AppGood entity.
func newAppGoodMutation(c config, op Op, opts ...appgoodOption) *AppGoodMutation {
	m := &AppGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodID sets the ID field of the mutation.
func withAppGoodID(id uint32) appgoodOption {
	return func(m *AppGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGood
		)
		m.oldValue = func(ctx context.Context) (*AppGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGood sets the old AppGood of the mutation.
func withAppGood(node *AppGood) appgoodOption {
	return func(m *AppGoodMutation) {
		m.oldValue = func(context.Context) (*AppGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGood entities.
func (m *AppGoodMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppGoodMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppGoodMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppGoodMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *AppGoodMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppGoodMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppGoodMutation) ResetGoodID() {
	m.good_id = nil
}

// SetOnline sets the "online" field.
func (m *AppGoodMutation) SetOnline(b bool) {
	m.online = &b
}

// Online returns the value of the "online" field in the mutation.
func (m *AppGoodMutation) Online() (r bool, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// ClearOnline clears the value of the "online" field.
func (m *AppGoodMutation) ClearOnline() {
	m.online = nil
	m.clearedFields[appgood.FieldOnline] = struct{}{}
}

// OnlineCleared returns if the "online" field was cleared in this mutation.
func (m *AppGoodMutation) OnlineCleared() bool {
	_, ok := m.clearedFields[appgood.FieldOnline]
	return ok
}

// ResetOnline resets all changes to the "online" field.
func (m *AppGoodMutation) ResetOnline() {
	m.online = nil
	delete(m.clearedFields, appgood.FieldOnline)
}

// SetVisible sets the "visible" field.
func (m *AppGoodMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *AppGoodMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ClearVisible clears the value of the "visible" field.
func (m *AppGoodMutation) ClearVisible() {
	m.visible = nil
	m.clearedFields[appgood.FieldVisible] = struct{}{}
}

// VisibleCleared returns if the "visible" field was cleared in this mutation.
func (m *AppGoodMutation) VisibleCleared() bool {
	_, ok := m.clearedFields[appgood.FieldVisible]
	return ok
}

// ResetVisible resets all changes to the "visible" field.
func (m *AppGoodMutation) ResetVisible() {
	m.visible = nil
	delete(m.clearedFields, appgood.FieldVisible)
}

// SetGoodName sets the "good_name" field.
func (m *AppGoodMutation) SetGoodName(s string) {
	m.good_name = &s
}

// GoodName returns the value of the "good_name" field in the mutation.
func (m *AppGoodMutation) GoodName() (r string, exists bool) {
	v := m.good_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodName returns the old "good_name" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodName: %w", err)
	}
	return oldValue.GoodName, nil
}

// ClearGoodName clears the value of the "good_name" field.
func (m *AppGoodMutation) ClearGoodName() {
	m.good_name = nil
	m.clearedFields[appgood.FieldGoodName] = struct{}{}
}

// GoodNameCleared returns if the "good_name" field was cleared in this mutation.
func (m *AppGoodMutation) GoodNameCleared() bool {
	_, ok := m.clearedFields[appgood.FieldGoodName]
	return ok
}

// ResetGoodName resets all changes to the "good_name" field.
func (m *AppGoodMutation) ResetGoodName() {
	m.good_name = nil
	delete(m.clearedFields, appgood.FieldGoodName)
}

// SetUnitPrice sets the "unit_price" field.
func (m *AppGoodMutation) SetUnitPrice(d decimal.Decimal) {
	m.unit_price = &d
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *AppGoodMutation) UnitPrice() (r decimal.Decimal, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldUnitPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// ClearUnitPrice clears the value of the "unit_price" field.
func (m *AppGoodMutation) ClearUnitPrice() {
	m.unit_price = nil
	m.clearedFields[appgood.FieldUnitPrice] = struct{}{}
}

// UnitPriceCleared returns if the "unit_price" field was cleared in this mutation.
func (m *AppGoodMutation) UnitPriceCleared() bool {
	_, ok := m.clearedFields[appgood.FieldUnitPrice]
	return ok
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *AppGoodMutation) ResetUnitPrice() {
	m.unit_price = nil
	delete(m.clearedFields, appgood.FieldUnitPrice)
}

// SetPackagePrice sets the "package_price" field.
func (m *AppGoodMutation) SetPackagePrice(d decimal.Decimal) {
	m.package_price = &d
}

// PackagePrice returns the value of the "package_price" field in the mutation.
func (m *AppGoodMutation) PackagePrice() (r decimal.Decimal, exists bool) {
	v := m.package_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPackagePrice returns the old "package_price" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPackagePrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackagePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackagePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackagePrice: %w", err)
	}
	return oldValue.PackagePrice, nil
}

// ClearPackagePrice clears the value of the "package_price" field.
func (m *AppGoodMutation) ClearPackagePrice() {
	m.package_price = nil
	m.clearedFields[appgood.FieldPackagePrice] = struct{}{}
}

// PackagePriceCleared returns if the "package_price" field was cleared in this mutation.
func (m *AppGoodMutation) PackagePriceCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPackagePrice]
	return ok
}

// ResetPackagePrice resets all changes to the "package_price" field.
func (m *AppGoodMutation) ResetPackagePrice() {
	m.package_price = nil
	delete(m.clearedFields, appgood.FieldPackagePrice)
}

// SetDisplayIndex sets the "display_index" field.
func (m *AppGoodMutation) SetDisplayIndex(i int32) {
	m.display_index = &i
	m.adddisplay_index = nil
}

// DisplayIndex returns the value of the "display_index" field in the mutation.
func (m *AppGoodMutation) DisplayIndex() (r int32, exists bool) {
	v := m.display_index
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayIndex returns the old "display_index" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayIndex: %w", err)
	}
	return oldValue.DisplayIndex, nil
}

// AddDisplayIndex adds i to the "display_index" field.
func (m *AppGoodMutation) AddDisplayIndex(i int32) {
	if m.adddisplay_index != nil {
		*m.adddisplay_index += i
	} else {
		m.adddisplay_index = &i
	}
}

// AddedDisplayIndex returns the value that was added to the "display_index" field in this mutation.
func (m *AppGoodMutation) AddedDisplayIndex() (r int32, exists bool) {
	v := m.adddisplay_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayIndex clears the value of the "display_index" field.
func (m *AppGoodMutation) ClearDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	m.clearedFields[appgood.FieldDisplayIndex] = struct{}{}
}

// DisplayIndexCleared returns if the "display_index" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayIndexCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayIndex]
	return ok
}

// ResetDisplayIndex resets all changes to the "display_index" field.
func (m *AppGoodMutation) ResetDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	delete(m.clearedFields, appgood.FieldDisplayIndex)
}

// SetSaleStartAt sets the "sale_start_at" field.
func (m *AppGoodMutation) SetSaleStartAt(u uint32) {
	m.sale_start_at = &u
	m.addsale_start_at = nil
}

// SaleStartAt returns the value of the "sale_start_at" field in the mutation.
func (m *AppGoodMutation) SaleStartAt() (r uint32, exists bool) {
	v := m.sale_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStartAt returns the old "sale_start_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldSaleStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStartAt: %w", err)
	}
	return oldValue.SaleStartAt, nil
}

// AddSaleStartAt adds u to the "sale_start_at" field.
func (m *AppGoodMutation) AddSaleStartAt(u int32) {
	if m.addsale_start_at != nil {
		*m.addsale_start_at += u
	} else {
		m.addsale_start_at = &u
	}
}

// AddedSaleStartAt returns the value that was added to the "sale_start_at" field in this mutation.
func (m *AppGoodMutation) AddedSaleStartAt() (r int32, exists bool) {
	v := m.addsale_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleStartAt clears the value of the "sale_start_at" field.
func (m *AppGoodMutation) ClearSaleStartAt() {
	m.sale_start_at = nil
	m.addsale_start_at = nil
	m.clearedFields[appgood.FieldSaleStartAt] = struct{}{}
}

// SaleStartAtCleared returns if the "sale_start_at" field was cleared in this mutation.
func (m *AppGoodMutation) SaleStartAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldSaleStartAt]
	return ok
}

// ResetSaleStartAt resets all changes to the "sale_start_at" field.
func (m *AppGoodMutation) ResetSaleStartAt() {
	m.sale_start_at = nil
	m.addsale_start_at = nil
	delete(m.clearedFields, appgood.FieldSaleStartAt)
}

// SetSaleEndAt sets the "sale_end_at" field.
func (m *AppGoodMutation) SetSaleEndAt(u uint32) {
	m.sale_end_at = &u
	m.addsale_end_at = nil
}

// SaleEndAt returns the value of the "sale_end_at" field in the mutation.
func (m *AppGoodMutation) SaleEndAt() (r uint32, exists bool) {
	v := m.sale_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleEndAt returns the old "sale_end_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldSaleEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleEndAt: %w", err)
	}
	return oldValue.SaleEndAt, nil
}

// AddSaleEndAt adds u to the "sale_end_at" field.
func (m *AppGoodMutation) AddSaleEndAt(u int32) {
	if m.addsale_end_at != nil {
		*m.addsale_end_at += u
	} else {
		m.addsale_end_at = &u
	}
}

// AddedSaleEndAt returns the value that was added to the "sale_end_at" field in this mutation.
func (m *AppGoodMutation) AddedSaleEndAt() (r int32, exists bool) {
	v := m.addsale_end_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleEndAt clears the value of the "sale_end_at" field.
func (m *AppGoodMutation) ClearSaleEndAt() {
	m.sale_end_at = nil
	m.addsale_end_at = nil
	m.clearedFields[appgood.FieldSaleEndAt] = struct{}{}
}

// SaleEndAtCleared returns if the "sale_end_at" field was cleared in this mutation.
func (m *AppGoodMutation) SaleEndAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldSaleEndAt]
	return ok
}

// ResetSaleEndAt resets all changes to the "sale_end_at" field.
func (m *AppGoodMutation) ResetSaleEndAt() {
	m.sale_end_at = nil
	m.addsale_end_at = nil
	delete(m.clearedFields, appgood.FieldSaleEndAt)
}

// SetServiceStartAt sets the "service_start_at" field.
func (m *AppGoodMutation) SetServiceStartAt(u uint32) {
	m.service_start_at = &u
	m.addservice_start_at = nil
}

// ServiceStartAt returns the value of the "service_start_at" field in the mutation.
func (m *AppGoodMutation) ServiceStartAt() (r uint32, exists bool) {
	v := m.service_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceStartAt returns the old "service_start_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldServiceStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceStartAt: %w", err)
	}
	return oldValue.ServiceStartAt, nil
}

// AddServiceStartAt adds u to the "service_start_at" field.
func (m *AppGoodMutation) AddServiceStartAt(u int32) {
	if m.addservice_start_at != nil {
		*m.addservice_start_at += u
	} else {
		m.addservice_start_at = &u
	}
}

// AddedServiceStartAt returns the value that was added to the "service_start_at" field in this mutation.
func (m *AppGoodMutation) AddedServiceStartAt() (r int32, exists bool) {
	v := m.addservice_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearServiceStartAt clears the value of the "service_start_at" field.
func (m *AppGoodMutation) ClearServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	m.clearedFields[appgood.FieldServiceStartAt] = struct{}{}
}

// ServiceStartAtCleared returns if the "service_start_at" field was cleared in this mutation.
func (m *AppGoodMutation) ServiceStartAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldServiceStartAt]
	return ok
}

// ResetServiceStartAt resets all changes to the "service_start_at" field.
func (m *AppGoodMutation) ResetServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	delete(m.clearedFields, appgood.FieldServiceStartAt)
}

// SetTechnicalFeeRatio sets the "technical_fee_ratio" field.
func (m *AppGoodMutation) SetTechnicalFeeRatio(d decimal.Decimal) {
	m.technical_fee_ratio = &d
}

// TechnicalFeeRatio returns the value of the "technical_fee_ratio" field in the mutation.
func (m *AppGoodMutation) TechnicalFeeRatio() (r decimal.Decimal, exists bool) {
	v := m.technical_fee_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldTechnicalFeeRatio returns the old "technical_fee_ratio" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldTechnicalFeeRatio(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechnicalFeeRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechnicalFeeRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechnicalFeeRatio: %w", err)
	}
	return oldValue.TechnicalFeeRatio, nil
}

// ClearTechnicalFeeRatio clears the value of the "technical_fee_ratio" field.
func (m *AppGoodMutation) ClearTechnicalFeeRatio() {
	m.technical_fee_ratio = nil
	m.clearedFields[appgood.FieldTechnicalFeeRatio] = struct{}{}
}

// TechnicalFeeRatioCleared returns if the "technical_fee_ratio" field was cleared in this mutation.
func (m *AppGoodMutation) TechnicalFeeRatioCleared() bool {
	_, ok := m.clearedFields[appgood.FieldTechnicalFeeRatio]
	return ok
}

// ResetTechnicalFeeRatio resets all changes to the "technical_fee_ratio" field.
func (m *AppGoodMutation) ResetTechnicalFeeRatio() {
	m.technical_fee_ratio = nil
	delete(m.clearedFields, appgood.FieldTechnicalFeeRatio)
}

// SetElectricityFeeRatio sets the "electricity_fee_ratio" field.
func (m *AppGoodMutation) SetElectricityFeeRatio(d decimal.Decimal) {
	m.electricity_fee_ratio = &d
}

// ElectricityFeeRatio returns the value of the "electricity_fee_ratio" field in the mutation.
func (m *AppGoodMutation) ElectricityFeeRatio() (r decimal.Decimal, exists bool) {
	v := m.electricity_fee_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldElectricityFeeRatio returns the old "electricity_fee_ratio" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldElectricityFeeRatio(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectricityFeeRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectricityFeeRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectricityFeeRatio: %w", err)
	}
	return oldValue.ElectricityFeeRatio, nil
}

// ClearElectricityFeeRatio clears the value of the "electricity_fee_ratio" field.
func (m *AppGoodMutation) ClearElectricityFeeRatio() {
	m.electricity_fee_ratio = nil
	m.clearedFields[appgood.FieldElectricityFeeRatio] = struct{}{}
}

// ElectricityFeeRatioCleared returns if the "electricity_fee_ratio" field was cleared in this mutation.
func (m *AppGoodMutation) ElectricityFeeRatioCleared() bool {
	_, ok := m.clearedFields[appgood.FieldElectricityFeeRatio]
	return ok
}

// ResetElectricityFeeRatio resets all changes to the "electricity_fee_ratio" field.
func (m *AppGoodMutation) ResetElectricityFeeRatio() {
	m.electricity_fee_ratio = nil
	delete(m.clearedFields, appgood.FieldElectricityFeeRatio)
}

// SetDescriptions sets the "descriptions" field.
func (m *AppGoodMutation) SetDescriptions(s []string) {
	m.descriptions = &s
	m.appenddescriptions = nil
}

// Descriptions returns the value of the "descriptions" field in the mutation.
func (m *AppGoodMutation) Descriptions() (r []string, exists bool) {
	v := m.descriptions
	if v == nil {
		return
	}
	return *v, true
}

// OldDescriptions returns the old "descriptions" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDescriptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescriptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescriptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescriptions: %w", err)
	}
	return oldValue.Descriptions, nil
}

// AppendDescriptions adds s to the "descriptions" field.
func (m *AppGoodMutation) AppendDescriptions(s []string) {
	m.appenddescriptions = append(m.appenddescriptions, s...)
}

// AppendedDescriptions returns the list of values that were appended to the "descriptions" field in this mutation.
func (m *AppGoodMutation) AppendedDescriptions() ([]string, bool) {
	if len(m.appenddescriptions) == 0 {
		return nil, false
	}
	return m.appenddescriptions, true
}

// ClearDescriptions clears the value of the "descriptions" field.
func (m *AppGoodMutation) ClearDescriptions() {
	m.descriptions = nil
	m.appenddescriptions = nil
	m.clearedFields[appgood.FieldDescriptions] = struct{}{}
}

// DescriptionsCleared returns if the "descriptions" field was cleared in this mutation.
func (m *AppGoodMutation) DescriptionsCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDescriptions]
	return ok
}

// ResetDescriptions resets all changes to the "descriptions" field.
func (m *AppGoodMutation) ResetDescriptions() {
	m.descriptions = nil
	m.appenddescriptions = nil
	delete(m.clearedFields, appgood.FieldDescriptions)
}

// SetGoodBanner sets the "good_banner" field.
func (m *AppGoodMutation) SetGoodBanner(s string) {
	m.good_banner = &s
}

// GoodBanner returns the value of the "good_banner" field in the mutation.
func (m *AppGoodMutation) GoodBanner() (r string, exists bool) {
	v := m.good_banner
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodBanner returns the old "good_banner" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodBanner: %w", err)
	}
	return oldValue.GoodBanner, nil
}

// ClearGoodBanner clears the value of the "good_banner" field.
func (m *AppGoodMutation) ClearGoodBanner() {
	m.good_banner = nil
	m.clearedFields[appgood.FieldGoodBanner] = struct{}{}
}

// GoodBannerCleared returns if the "good_banner" field was cleared in this mutation.
func (m *AppGoodMutation) GoodBannerCleared() bool {
	_, ok := m.clearedFields[appgood.FieldGoodBanner]
	return ok
}

// ResetGoodBanner resets all changes to the "good_banner" field.
func (m *AppGoodMutation) ResetGoodBanner() {
	m.good_banner = nil
	delete(m.clearedFields, appgood.FieldGoodBanner)
}

// SetDisplayNames sets the "display_names" field.
func (m *AppGoodMutation) SetDisplayNames(s []string) {
	m.display_names = &s
	m.appenddisplay_names = nil
}

// DisplayNames returns the value of the "display_names" field in the mutation.
func (m *AppGoodMutation) DisplayNames() (r []string, exists bool) {
	v := m.display_names
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNames returns the old "display_names" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNames: %w", err)
	}
	return oldValue.DisplayNames, nil
}

// AppendDisplayNames adds s to the "display_names" field.
func (m *AppGoodMutation) AppendDisplayNames(s []string) {
	m.appenddisplay_names = append(m.appenddisplay_names, s...)
}

// AppendedDisplayNames returns the list of values that were appended to the "display_names" field in this mutation.
func (m *AppGoodMutation) AppendedDisplayNames() ([]string, bool) {
	if len(m.appenddisplay_names) == 0 {
		return nil, false
	}
	return m.appenddisplay_names, true
}

// ClearDisplayNames clears the value of the "display_names" field.
func (m *AppGoodMutation) ClearDisplayNames() {
	m.display_names = nil
	m.appenddisplay_names = nil
	m.clearedFields[appgood.FieldDisplayNames] = struct{}{}
}

// DisplayNamesCleared returns if the "display_names" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayNamesCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayNames]
	return ok
}

// ResetDisplayNames resets all changes to the "display_names" field.
func (m *AppGoodMutation) ResetDisplayNames() {
	m.display_names = nil
	m.appenddisplay_names = nil
	delete(m.clearedFields, appgood.FieldDisplayNames)
}

// SetEnablePurchase sets the "enable_purchase" field.
func (m *AppGoodMutation) SetEnablePurchase(b bool) {
	m.enable_purchase = &b
}

// EnablePurchase returns the value of the "enable_purchase" field in the mutation.
func (m *AppGoodMutation) EnablePurchase() (r bool, exists bool) {
	v := m.enable_purchase
	if v == nil {
		return
	}
	return *v, true
}

// OldEnablePurchase returns the old "enable_purchase" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnablePurchase(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnablePurchase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnablePurchase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnablePurchase: %w", err)
	}
	return oldValue.EnablePurchase, nil
}

// ClearEnablePurchase clears the value of the "enable_purchase" field.
func (m *AppGoodMutation) ClearEnablePurchase() {
	m.enable_purchase = nil
	m.clearedFields[appgood.FieldEnablePurchase] = struct{}{}
}

// EnablePurchaseCleared returns if the "enable_purchase" field was cleared in this mutation.
func (m *AppGoodMutation) EnablePurchaseCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnablePurchase]
	return ok
}

// ResetEnablePurchase resets all changes to the "enable_purchase" field.
func (m *AppGoodMutation) ResetEnablePurchase() {
	m.enable_purchase = nil
	delete(m.clearedFields, appgood.FieldEnablePurchase)
}

// SetEnableProductPage sets the "enable_product_page" field.
func (m *AppGoodMutation) SetEnableProductPage(b bool) {
	m.enable_product_page = &b
}

// EnableProductPage returns the value of the "enable_product_page" field in the mutation.
func (m *AppGoodMutation) EnableProductPage() (r bool, exists bool) {
	v := m.enable_product_page
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableProductPage returns the old "enable_product_page" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnableProductPage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableProductPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableProductPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableProductPage: %w", err)
	}
	return oldValue.EnableProductPage, nil
}

// ClearEnableProductPage clears the value of the "enable_product_page" field.
func (m *AppGoodMutation) ClearEnableProductPage() {
	m.enable_product_page = nil
	m.clearedFields[appgood.FieldEnableProductPage] = struct{}{}
}

// EnableProductPageCleared returns if the "enable_product_page" field was cleared in this mutation.
func (m *AppGoodMutation) EnableProductPageCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnableProductPage]
	return ok
}

// ResetEnableProductPage resets all changes to the "enable_product_page" field.
func (m *AppGoodMutation) ResetEnableProductPage() {
	m.enable_product_page = nil
	delete(m.clearedFields, appgood.FieldEnableProductPage)
}

// SetCancelMode sets the "cancel_mode" field.
func (m *AppGoodMutation) SetCancelMode(s string) {
	m.cancel_mode = &s
}

// CancelMode returns the value of the "cancel_mode" field in the mutation.
func (m *AppGoodMutation) CancelMode() (r string, exists bool) {
	v := m.cancel_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelMode returns the old "cancel_mode" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCancelMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelMode: %w", err)
	}
	return oldValue.CancelMode, nil
}

// ClearCancelMode clears the value of the "cancel_mode" field.
func (m *AppGoodMutation) ClearCancelMode() {
	m.cancel_mode = nil
	m.clearedFields[appgood.FieldCancelMode] = struct{}{}
}

// CancelModeCleared returns if the "cancel_mode" field was cleared in this mutation.
func (m *AppGoodMutation) CancelModeCleared() bool {
	_, ok := m.clearedFields[appgood.FieldCancelMode]
	return ok
}

// ResetCancelMode resets all changes to the "cancel_mode" field.
func (m *AppGoodMutation) ResetCancelMode() {
	m.cancel_mode = nil
	delete(m.clearedFields, appgood.FieldCancelMode)
}

// SetDisplayColors sets the "display_colors" field.
func (m *AppGoodMutation) SetDisplayColors(s []string) {
	m.display_colors = &s
	m.appenddisplay_colors = nil
}

// DisplayColors returns the value of the "display_colors" field in the mutation.
func (m *AppGoodMutation) DisplayColors() (r []string, exists bool) {
	v := m.display_colors
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayColors returns the old "display_colors" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayColors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayColors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayColors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayColors: %w", err)
	}
	return oldValue.DisplayColors, nil
}

// AppendDisplayColors adds s to the "display_colors" field.
func (m *AppGoodMutation) AppendDisplayColors(s []string) {
	m.appenddisplay_colors = append(m.appenddisplay_colors, s...)
}

// AppendedDisplayColors returns the list of values that were appended to the "display_colors" field in this mutation.
func (m *AppGoodMutation) AppendedDisplayColors() ([]string, bool) {
	if len(m.appenddisplay_colors) == 0 {
		return nil, false
	}
	return m.appenddisplay_colors, true
}

// ClearDisplayColors clears the value of the "display_colors" field.
func (m *AppGoodMutation) ClearDisplayColors() {
	m.display_colors = nil
	m.appenddisplay_colors = nil
	m.clearedFields[appgood.FieldDisplayColors] = struct{}{}
}

// DisplayColorsCleared returns if the "display_colors" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayColorsCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayColors]
	return ok
}

// ResetDisplayColors resets all changes to the "display_colors" field.
func (m *AppGoodMutation) ResetDisplayColors() {
	m.display_colors = nil
	m.appenddisplay_colors = nil
	delete(m.clearedFields, appgood.FieldDisplayColors)
}

// SetCancellableBeforeStart sets the "cancellable_before_start" field.
func (m *AppGoodMutation) SetCancellableBeforeStart(u uint32) {
	m.cancellable_before_start = &u
	m.addcancellable_before_start = nil
}

// CancellableBeforeStart returns the value of the "cancellable_before_start" field in the mutation.
func (m *AppGoodMutation) CancellableBeforeStart() (r uint32, exists bool) {
	v := m.cancellable_before_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellableBeforeStart returns the old "cancellable_before_start" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCancellableBeforeStart(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellableBeforeStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellableBeforeStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellableBeforeStart: %w", err)
	}
	return oldValue.CancellableBeforeStart, nil
}

// AddCancellableBeforeStart adds u to the "cancellable_before_start" field.
func (m *AppGoodMutation) AddCancellableBeforeStart(u int32) {
	if m.addcancellable_before_start != nil {
		*m.addcancellable_before_start += u
	} else {
		m.addcancellable_before_start = &u
	}
}

// AddedCancellableBeforeStart returns the value that was added to the "cancellable_before_start" field in this mutation.
func (m *AppGoodMutation) AddedCancellableBeforeStart() (r int32, exists bool) {
	v := m.addcancellable_before_start
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancellableBeforeStart clears the value of the "cancellable_before_start" field.
func (m *AppGoodMutation) ClearCancellableBeforeStart() {
	m.cancellable_before_start = nil
	m.addcancellable_before_start = nil
	m.clearedFields[appgood.FieldCancellableBeforeStart] = struct{}{}
}

// CancellableBeforeStartCleared returns if the "cancellable_before_start" field was cleared in this mutation.
func (m *AppGoodMutation) CancellableBeforeStartCleared() bool {
	_, ok := m.clearedFields[appgood.FieldCancellableBeforeStart]
	return ok
}

// ResetCancellableBeforeStart resets all changes to the "cancellable_before_start" field.
func (m *AppGoodMutation) ResetCancellableBeforeStart() {
	m.cancellable_before_start = nil
	m.addcancellable_before_start = nil
	delete(m.clearedFields, appgood.FieldCancellableBeforeStart)
}

// SetProductPage sets the "product_page" field.
func (m *AppGoodMutation) SetProductPage(s string) {
	m.product_page = &s
}

// ProductPage returns the value of the "product_page" field in the mutation.
func (m *AppGoodMutation) ProductPage() (r string, exists bool) {
	v := m.product_page
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPage returns the old "product_page" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldProductPage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPage: %w", err)
	}
	return oldValue.ProductPage, nil
}

// ClearProductPage clears the value of the "product_page" field.
func (m *AppGoodMutation) ClearProductPage() {
	m.product_page = nil
	m.clearedFields[appgood.FieldProductPage] = struct{}{}
}

// ProductPageCleared returns if the "product_page" field was cleared in this mutation.
func (m *AppGoodMutation) ProductPageCleared() bool {
	_, ok := m.clearedFields[appgood.FieldProductPage]
	return ok
}

// ResetProductPage resets all changes to the "product_page" field.
func (m *AppGoodMutation) ResetProductPage() {
	m.product_page = nil
	delete(m.clearedFields, appgood.FieldProductPage)
}

// SetEnableSetCommission sets the "enable_set_commission" field.
func (m *AppGoodMutation) SetEnableSetCommission(b bool) {
	m.enable_set_commission = &b
}

// EnableSetCommission returns the value of the "enable_set_commission" field in the mutation.
func (m *AppGoodMutation) EnableSetCommission() (r bool, exists bool) {
	v := m.enable_set_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableSetCommission returns the old "enable_set_commission" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnableSetCommission(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableSetCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableSetCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableSetCommission: %w", err)
	}
	return oldValue.EnableSetCommission, nil
}

// ClearEnableSetCommission clears the value of the "enable_set_commission" field.
func (m *AppGoodMutation) ClearEnableSetCommission() {
	m.enable_set_commission = nil
	m.clearedFields[appgood.FieldEnableSetCommission] = struct{}{}
}

// EnableSetCommissionCleared returns if the "enable_set_commission" field was cleared in this mutation.
func (m *AppGoodMutation) EnableSetCommissionCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnableSetCommission]
	return ok
}

// ResetEnableSetCommission resets all changes to the "enable_set_commission" field.
func (m *AppGoodMutation) ResetEnableSetCommission() {
	m.enable_set_commission = nil
	delete(m.clearedFields, appgood.FieldEnableSetCommission)
}

// SetPosters sets the "posters" field.
func (m *AppGoodMutation) SetPosters(s []string) {
	m.posters = &s
	m.appendposters = nil
}

// Posters returns the value of the "posters" field in the mutation.
func (m *AppGoodMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// AppendPosters adds s to the "posters" field.
func (m *AppGoodMutation) AppendPosters(s []string) {
	m.appendposters = append(m.appendposters, s...)
}

// AppendedPosters returns the list of values that were appended to the "posters" field in this mutation.
func (m *AppGoodMutation) AppendedPosters() ([]string, bool) {
	if len(m.appendposters) == 0 {
		return nil, false
	}
	return m.appendposters, true
}

// ClearPosters clears the value of the "posters" field.
func (m *AppGoodMutation) ClearPosters() {
	m.posters = nil
	m.appendposters = nil
	m.clearedFields[appgood.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *AppGoodMutation) PostersCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *AppGoodMutation) ResetPosters() {
	m.posters = nil
	m.appendposters = nil
	delete(m.clearedFields, appgood.FieldPosters)
}

// SetMinOrderAmount sets the "min_order_amount" field.
func (m *AppGoodMutation) SetMinOrderAmount(d decimal.Decimal) {
	m.min_order_amount = &d
}

// MinOrderAmount returns the value of the "min_order_amount" field in the mutation.
func (m *AppGoodMutation) MinOrderAmount() (r decimal.Decimal, exists bool) {
	v := m.min_order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMinOrderAmount returns the old "min_order_amount" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldMinOrderAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinOrderAmount: %w", err)
	}
	return oldValue.MinOrderAmount, nil
}

// ClearMinOrderAmount clears the value of the "min_order_amount" field.
func (m *AppGoodMutation) ClearMinOrderAmount() {
	m.min_order_amount = nil
	m.clearedFields[appgood.FieldMinOrderAmount] = struct{}{}
}

// MinOrderAmountCleared returns if the "min_order_amount" field was cleared in this mutation.
func (m *AppGoodMutation) MinOrderAmountCleared() bool {
	_, ok := m.clearedFields[appgood.FieldMinOrderAmount]
	return ok
}

// ResetMinOrderAmount resets all changes to the "min_order_amount" field.
func (m *AppGoodMutation) ResetMinOrderAmount() {
	m.min_order_amount = nil
	delete(m.clearedFields, appgood.FieldMinOrderAmount)
}

// SetMaxOrderAmount sets the "max_order_amount" field.
func (m *AppGoodMutation) SetMaxOrderAmount(d decimal.Decimal) {
	m.max_order_amount = &d
}

// MaxOrderAmount returns the value of the "max_order_amount" field in the mutation.
func (m *AppGoodMutation) MaxOrderAmount() (r decimal.Decimal, exists bool) {
	v := m.max_order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxOrderAmount returns the old "max_order_amount" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldMaxOrderAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxOrderAmount: %w", err)
	}
	return oldValue.MaxOrderAmount, nil
}

// ClearMaxOrderAmount clears the value of the "max_order_amount" field.
func (m *AppGoodMutation) ClearMaxOrderAmount() {
	m.max_order_amount = nil
	m.clearedFields[appgood.FieldMaxOrderAmount] = struct{}{}
}

// MaxOrderAmountCleared returns if the "max_order_amount" field was cleared in this mutation.
func (m *AppGoodMutation) MaxOrderAmountCleared() bool {
	_, ok := m.clearedFields[appgood.FieldMaxOrderAmount]
	return ok
}

// ResetMaxOrderAmount resets all changes to the "max_order_amount" field.
func (m *AppGoodMutation) ResetMaxOrderAmount() {
	m.max_order_amount = nil
	delete(m.clearedFields, appgood.FieldMaxOrderAmount)
}

// SetMaxUserAmount sets the "max_user_amount" field.
func (m *AppGoodMutation) SetMaxUserAmount(d decimal.Decimal) {
	m.max_user_amount = &d
}

// MaxUserAmount returns the value of the "max_user_amount" field in the mutation.
func (m *AppGoodMutation) MaxUserAmount() (r decimal.Decimal, exists bool) {
	v := m.max_user_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUserAmount returns the old "max_user_amount" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldMaxUserAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUserAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUserAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUserAmount: %w", err)
	}
	return oldValue.MaxUserAmount, nil
}

// ClearMaxUserAmount clears the value of the "max_user_amount" field.
func (m *AppGoodMutation) ClearMaxUserAmount() {
	m.max_user_amount = nil
	m.clearedFields[appgood.FieldMaxUserAmount] = struct{}{}
}

// MaxUserAmountCleared returns if the "max_user_amount" field was cleared in this mutation.
func (m *AppGoodMutation) MaxUserAmountCleared() bool {
	_, ok := m.clearedFields[appgood.FieldMaxUserAmount]
	return ok
}

// ResetMaxUserAmount resets all changes to the "max_user_amount" field.
func (m *AppGoodMutation) ResetMaxUserAmount() {
	m.max_user_amount = nil
	delete(m.clearedFields, appgood.FieldMaxUserAmount)
}

// SetMinOrderDuration sets the "min_order_duration" field.
func (m *AppGoodMutation) SetMinOrderDuration(u uint32) {
	m.min_order_duration = &u
	m.addmin_order_duration = nil
}

// MinOrderDuration returns the value of the "min_order_duration" field in the mutation.
func (m *AppGoodMutation) MinOrderDuration() (r uint32, exists bool) {
	v := m.min_order_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMinOrderDuration returns the old "min_order_duration" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldMinOrderDuration(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinOrderDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinOrderDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinOrderDuration: %w", err)
	}
	return oldValue.MinOrderDuration, nil
}

// AddMinOrderDuration adds u to the "min_order_duration" field.
func (m *AppGoodMutation) AddMinOrderDuration(u int32) {
	if m.addmin_order_duration != nil {
		*m.addmin_order_duration += u
	} else {
		m.addmin_order_duration = &u
	}
}

// AddedMinOrderDuration returns the value that was added to the "min_order_duration" field in this mutation.
func (m *AppGoodMutation) AddedMinOrderDuration() (r int32, exists bool) {
	v := m.addmin_order_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinOrderDuration clears the value of the "min_order_duration" field.
func (m *AppGoodMutation) ClearMinOrderDuration() {
	m.min_order_duration = nil
	m.addmin_order_duration = nil
	m.clearedFields[appgood.FieldMinOrderDuration] = struct{}{}
}

// MinOrderDurationCleared returns if the "min_order_duration" field was cleared in this mutation.
func (m *AppGoodMutation) MinOrderDurationCleared() bool {
	_, ok := m.clearedFields[appgood.FieldMinOrderDuration]
	return ok
}

// ResetMinOrderDuration resets all changes to the "min_order_duration" field.
func (m *AppGoodMutation) ResetMinOrderDuration() {
	m.min_order_duration = nil
	m.addmin_order_duration = nil
	delete(m.clearedFields, appgood.FieldMinOrderDuration)
}

// SetMaxOrderDuration sets the "max_order_duration" field.
func (m *AppGoodMutation) SetMaxOrderDuration(u uint32) {
	m.max_order_duration = &u
	m.addmax_order_duration = nil
}

// MaxOrderDuration returns the value of the "max_order_duration" field in the mutation.
func (m *AppGoodMutation) MaxOrderDuration() (r uint32, exists bool) {
	v := m.max_order_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxOrderDuration returns the old "max_order_duration" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldMaxOrderDuration(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxOrderDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxOrderDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxOrderDuration: %w", err)
	}
	return oldValue.MaxOrderDuration, nil
}

// AddMaxOrderDuration adds u to the "max_order_duration" field.
func (m *AppGoodMutation) AddMaxOrderDuration(u int32) {
	if m.addmax_order_duration != nil {
		*m.addmax_order_duration += u
	} else {
		m.addmax_order_duration = &u
	}
}

// AddedMaxOrderDuration returns the value that was added to the "max_order_duration" field in this mutation.
func (m *AppGoodMutation) AddedMaxOrderDuration() (r int32, exists bool) {
	v := m.addmax_order_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxOrderDuration clears the value of the "max_order_duration" field.
func (m *AppGoodMutation) ClearMaxOrderDuration() {
	m.max_order_duration = nil
	m.addmax_order_duration = nil
	m.clearedFields[appgood.FieldMaxOrderDuration] = struct{}{}
}

// MaxOrderDurationCleared returns if the "max_order_duration" field was cleared in this mutation.
func (m *AppGoodMutation) MaxOrderDurationCleared() bool {
	_, ok := m.clearedFields[appgood.FieldMaxOrderDuration]
	return ok
}

// ResetMaxOrderDuration resets all changes to the "max_order_duration" field.
func (m *AppGoodMutation) ResetMaxOrderDuration() {
	m.max_order_duration = nil
	m.addmax_order_duration = nil
	delete(m.clearedFields, appgood.FieldMaxOrderDuration)
}

// SetPackageWithRequireds sets the "package_with_requireds" field.
func (m *AppGoodMutation) SetPackageWithRequireds(b bool) {
	m.package_with_requireds = &b
}

// PackageWithRequireds returns the value of the "package_with_requireds" field in the mutation.
func (m *AppGoodMutation) PackageWithRequireds() (r bool, exists bool) {
	v := m.package_with_requireds
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageWithRequireds returns the old "package_with_requireds" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPackageWithRequireds(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageWithRequireds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageWithRequireds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageWithRequireds: %w", err)
	}
	return oldValue.PackageWithRequireds, nil
}

// ClearPackageWithRequireds clears the value of the "package_with_requireds" field.
func (m *AppGoodMutation) ClearPackageWithRequireds() {
	m.package_with_requireds = nil
	m.clearedFields[appgood.FieldPackageWithRequireds] = struct{}{}
}

// PackageWithRequiredsCleared returns if the "package_with_requireds" field was cleared in this mutation.
func (m *AppGoodMutation) PackageWithRequiredsCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPackageWithRequireds]
	return ok
}

// ResetPackageWithRequireds resets all changes to the "package_with_requireds" field.
func (m *AppGoodMutation) ResetPackageWithRequireds() {
	m.package_with_requireds = nil
	delete(m.clearedFields, appgood.FieldPackageWithRequireds)
}

// Where appends a list predicates to the AppGoodMutation builder.
func (m *AppGoodMutation) Where(ps ...predicate.AppGood) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGood, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGood).
func (m *AppGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.ent_id != nil {
		fields = append(fields, appgood.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgood.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appgood.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appgood.FieldGoodID)
	}
	if m.online != nil {
		fields = append(fields, appgood.FieldOnline)
	}
	if m.visible != nil {
		fields = append(fields, appgood.FieldVisible)
	}
	if m.good_name != nil {
		fields = append(fields, appgood.FieldGoodName)
	}
	if m.unit_price != nil {
		fields = append(fields, appgood.FieldUnitPrice)
	}
	if m.package_price != nil {
		fields = append(fields, appgood.FieldPackagePrice)
	}
	if m.display_index != nil {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.sale_start_at != nil {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.sale_end_at != nil {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.service_start_at != nil {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.technical_fee_ratio != nil {
		fields = append(fields, appgood.FieldTechnicalFeeRatio)
	}
	if m.electricity_fee_ratio != nil {
		fields = append(fields, appgood.FieldElectricityFeeRatio)
	}
	if m.descriptions != nil {
		fields = append(fields, appgood.FieldDescriptions)
	}
	if m.good_banner != nil {
		fields = append(fields, appgood.FieldGoodBanner)
	}
	if m.display_names != nil {
		fields = append(fields, appgood.FieldDisplayNames)
	}
	if m.enable_purchase != nil {
		fields = append(fields, appgood.FieldEnablePurchase)
	}
	if m.enable_product_page != nil {
		fields = append(fields, appgood.FieldEnableProductPage)
	}
	if m.cancel_mode != nil {
		fields = append(fields, appgood.FieldCancelMode)
	}
	if m.display_colors != nil {
		fields = append(fields, appgood.FieldDisplayColors)
	}
	if m.cancellable_before_start != nil {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	if m.product_page != nil {
		fields = append(fields, appgood.FieldProductPage)
	}
	if m.enable_set_commission != nil {
		fields = append(fields, appgood.FieldEnableSetCommission)
	}
	if m.posters != nil {
		fields = append(fields, appgood.FieldPosters)
	}
	if m.min_order_amount != nil {
		fields = append(fields, appgood.FieldMinOrderAmount)
	}
	if m.max_order_amount != nil {
		fields = append(fields, appgood.FieldMaxOrderAmount)
	}
	if m.max_user_amount != nil {
		fields = append(fields, appgood.FieldMaxUserAmount)
	}
	if m.min_order_duration != nil {
		fields = append(fields, appgood.FieldMinOrderDuration)
	}
	if m.max_order_duration != nil {
		fields = append(fields, appgood.FieldMaxOrderDuration)
	}
	if m.package_with_requireds != nil {
		fields = append(fields, appgood.FieldPackageWithRequireds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgood.FieldEntID:
		return m.EntID()
	case appgood.FieldCreatedAt:
		return m.CreatedAt()
	case appgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgood.FieldDeletedAt:
		return m.DeletedAt()
	case appgood.FieldAppID:
		return m.AppID()
	case appgood.FieldGoodID:
		return m.GoodID()
	case appgood.FieldOnline:
		return m.Online()
	case appgood.FieldVisible:
		return m.Visible()
	case appgood.FieldGoodName:
		return m.GoodName()
	case appgood.FieldUnitPrice:
		return m.UnitPrice()
	case appgood.FieldPackagePrice:
		return m.PackagePrice()
	case appgood.FieldDisplayIndex:
		return m.DisplayIndex()
	case appgood.FieldSaleStartAt:
		return m.SaleStartAt()
	case appgood.FieldSaleEndAt:
		return m.SaleEndAt()
	case appgood.FieldServiceStartAt:
		return m.ServiceStartAt()
	case appgood.FieldTechnicalFeeRatio:
		return m.TechnicalFeeRatio()
	case appgood.FieldElectricityFeeRatio:
		return m.ElectricityFeeRatio()
	case appgood.FieldDescriptions:
		return m.Descriptions()
	case appgood.FieldGoodBanner:
		return m.GoodBanner()
	case appgood.FieldDisplayNames:
		return m.DisplayNames()
	case appgood.FieldEnablePurchase:
		return m.EnablePurchase()
	case appgood.FieldEnableProductPage:
		return m.EnableProductPage()
	case appgood.FieldCancelMode:
		return m.CancelMode()
	case appgood.FieldDisplayColors:
		return m.DisplayColors()
	case appgood.FieldCancellableBeforeStart:
		return m.CancellableBeforeStart()
	case appgood.FieldProductPage:
		return m.ProductPage()
	case appgood.FieldEnableSetCommission:
		return m.EnableSetCommission()
	case appgood.FieldPosters:
		return m.Posters()
	case appgood.FieldMinOrderAmount:
		return m.MinOrderAmount()
	case appgood.FieldMaxOrderAmount:
		return m.MaxOrderAmount()
	case appgood.FieldMaxUserAmount:
		return m.MaxUserAmount()
	case appgood.FieldMinOrderDuration:
		return m.MinOrderDuration()
	case appgood.FieldMaxOrderDuration:
		return m.MaxOrderDuration()
	case appgood.FieldPackageWithRequireds:
		return m.PackageWithRequireds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgood.FieldEntID:
		return m.OldEntID(ctx)
	case appgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgood.FieldAppID:
		return m.OldAppID(ctx)
	case appgood.FieldGoodID:
		return m.OldGoodID(ctx)
	case appgood.FieldOnline:
		return m.OldOnline(ctx)
	case appgood.FieldVisible:
		return m.OldVisible(ctx)
	case appgood.FieldGoodName:
		return m.OldGoodName(ctx)
	case appgood.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case appgood.FieldPackagePrice:
		return m.OldPackagePrice(ctx)
	case appgood.FieldDisplayIndex:
		return m.OldDisplayIndex(ctx)
	case appgood.FieldSaleStartAt:
		return m.OldSaleStartAt(ctx)
	case appgood.FieldSaleEndAt:
		return m.OldSaleEndAt(ctx)
	case appgood.FieldServiceStartAt:
		return m.OldServiceStartAt(ctx)
	case appgood.FieldTechnicalFeeRatio:
		return m.OldTechnicalFeeRatio(ctx)
	case appgood.FieldElectricityFeeRatio:
		return m.OldElectricityFeeRatio(ctx)
	case appgood.FieldDescriptions:
		return m.OldDescriptions(ctx)
	case appgood.FieldGoodBanner:
		return m.OldGoodBanner(ctx)
	case appgood.FieldDisplayNames:
		return m.OldDisplayNames(ctx)
	case appgood.FieldEnablePurchase:
		return m.OldEnablePurchase(ctx)
	case appgood.FieldEnableProductPage:
		return m.OldEnableProductPage(ctx)
	case appgood.FieldCancelMode:
		return m.OldCancelMode(ctx)
	case appgood.FieldDisplayColors:
		return m.OldDisplayColors(ctx)
	case appgood.FieldCancellableBeforeStart:
		return m.OldCancellableBeforeStart(ctx)
	case appgood.FieldProductPage:
		return m.OldProductPage(ctx)
	case appgood.FieldEnableSetCommission:
		return m.OldEnableSetCommission(ctx)
	case appgood.FieldPosters:
		return m.OldPosters(ctx)
	case appgood.FieldMinOrderAmount:
		return m.OldMinOrderAmount(ctx)
	case appgood.FieldMaxOrderAmount:
		return m.OldMaxOrderAmount(ctx)
	case appgood.FieldMaxUserAmount:
		return m.OldMaxUserAmount(ctx)
	case appgood.FieldMinOrderDuration:
		return m.OldMinOrderDuration(ctx)
	case appgood.FieldMaxOrderDuration:
		return m.OldMaxOrderDuration(ctx)
	case appgood.FieldPackageWithRequireds:
		return m.OldPackageWithRequireds(ctx)
	}
	return nil, fmt.Errorf("unknown AppGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgood.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgood.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appgood.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appgood.FieldOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case appgood.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	case appgood.FieldGoodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodName(v)
		return nil
	case appgood.FieldUnitPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case appgood.FieldPackagePrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackagePrice(v)
		return nil
	case appgood.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayIndex(v)
		return nil
	case appgood.FieldSaleStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStartAt(v)
		return nil
	case appgood.FieldSaleEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleEndAt(v)
		return nil
	case appgood.FieldServiceStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceStartAt(v)
		return nil
	case appgood.FieldTechnicalFeeRatio:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechnicalFeeRatio(v)
		return nil
	case appgood.FieldElectricityFeeRatio:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectricityFeeRatio(v)
		return nil
	case appgood.FieldDescriptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescriptions(v)
		return nil
	case appgood.FieldGoodBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodBanner(v)
		return nil
	case appgood.FieldDisplayNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNames(v)
		return nil
	case appgood.FieldEnablePurchase:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnablePurchase(v)
		return nil
	case appgood.FieldEnableProductPage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableProductPage(v)
		return nil
	case appgood.FieldCancelMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelMode(v)
		return nil
	case appgood.FieldDisplayColors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayColors(v)
		return nil
	case appgood.FieldCancellableBeforeStart:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellableBeforeStart(v)
		return nil
	case appgood.FieldProductPage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPage(v)
		return nil
	case appgood.FieldEnableSetCommission:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableSetCommission(v)
		return nil
	case appgood.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	case appgood.FieldMinOrderAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinOrderAmount(v)
		return nil
	case appgood.FieldMaxOrderAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxOrderAmount(v)
		return nil
	case appgood.FieldMaxUserAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUserAmount(v)
		return nil
	case appgood.FieldMinOrderDuration:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinOrderDuration(v)
		return nil
	case appgood.FieldMaxOrderDuration:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxOrderDuration(v)
		return nil
	case appgood.FieldPackageWithRequireds:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageWithRequireds(v)
		return nil
	}
	return fmt.Errorf("unknown AppGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgood.FieldDeletedAt)
	}
	if m.adddisplay_index != nil {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.addsale_start_at != nil {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.addsale_end_at != nil {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.addservice_start_at != nil {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.addcancellable_before_start != nil {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	if m.addmin_order_duration != nil {
		fields = append(fields, appgood.FieldMinOrderDuration)
	}
	if m.addmax_order_duration != nil {
		fields = append(fields, appgood.FieldMaxOrderDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgood.FieldDisplayIndex:
		return m.AddedDisplayIndex()
	case appgood.FieldSaleStartAt:
		return m.AddedSaleStartAt()
	case appgood.FieldSaleEndAt:
		return m.AddedSaleEndAt()
	case appgood.FieldServiceStartAt:
		return m.AddedServiceStartAt()
	case appgood.FieldCancellableBeforeStart:
		return m.AddedCancellableBeforeStart()
	case appgood.FieldMinOrderDuration:
		return m.AddedMinOrderDuration()
	case appgood.FieldMaxOrderDuration:
		return m.AddedMaxOrderDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgood.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayIndex(v)
		return nil
	case appgood.FieldSaleStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleStartAt(v)
		return nil
	case appgood.FieldSaleEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleEndAt(v)
		return nil
	case appgood.FieldServiceStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceStartAt(v)
		return nil
	case appgood.FieldCancellableBeforeStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancellableBeforeStart(v)
		return nil
	case appgood.FieldMinOrderDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinOrderDuration(v)
		return nil
	case appgood.FieldMaxOrderDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxOrderDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AppGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgood.FieldOnline) {
		fields = append(fields, appgood.FieldOnline)
	}
	if m.FieldCleared(appgood.FieldVisible) {
		fields = append(fields, appgood.FieldVisible)
	}
	if m.FieldCleared(appgood.FieldGoodName) {
		fields = append(fields, appgood.FieldGoodName)
	}
	if m.FieldCleared(appgood.FieldUnitPrice) {
		fields = append(fields, appgood.FieldUnitPrice)
	}
	if m.FieldCleared(appgood.FieldPackagePrice) {
		fields = append(fields, appgood.FieldPackagePrice)
	}
	if m.FieldCleared(appgood.FieldDisplayIndex) {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.FieldCleared(appgood.FieldSaleStartAt) {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.FieldCleared(appgood.FieldSaleEndAt) {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.FieldCleared(appgood.FieldServiceStartAt) {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.FieldCleared(appgood.FieldTechnicalFeeRatio) {
		fields = append(fields, appgood.FieldTechnicalFeeRatio)
	}
	if m.FieldCleared(appgood.FieldElectricityFeeRatio) {
		fields = append(fields, appgood.FieldElectricityFeeRatio)
	}
	if m.FieldCleared(appgood.FieldDescriptions) {
		fields = append(fields, appgood.FieldDescriptions)
	}
	if m.FieldCleared(appgood.FieldGoodBanner) {
		fields = append(fields, appgood.FieldGoodBanner)
	}
	if m.FieldCleared(appgood.FieldDisplayNames) {
		fields = append(fields, appgood.FieldDisplayNames)
	}
	if m.FieldCleared(appgood.FieldEnablePurchase) {
		fields = append(fields, appgood.FieldEnablePurchase)
	}
	if m.FieldCleared(appgood.FieldEnableProductPage) {
		fields = append(fields, appgood.FieldEnableProductPage)
	}
	if m.FieldCleared(appgood.FieldCancelMode) {
		fields = append(fields, appgood.FieldCancelMode)
	}
	if m.FieldCleared(appgood.FieldDisplayColors) {
		fields = append(fields, appgood.FieldDisplayColors)
	}
	if m.FieldCleared(appgood.FieldCancellableBeforeStart) {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	if m.FieldCleared(appgood.FieldProductPage) {
		fields = append(fields, appgood.FieldProductPage)
	}
	if m.FieldCleared(appgood.FieldEnableSetCommission) {
		fields = append(fields, appgood.FieldEnableSetCommission)
	}
	if m.FieldCleared(appgood.FieldPosters) {
		fields = append(fields, appgood.FieldPosters)
	}
	if m.FieldCleared(appgood.FieldMinOrderAmount) {
		fields = append(fields, appgood.FieldMinOrderAmount)
	}
	if m.FieldCleared(appgood.FieldMaxOrderAmount) {
		fields = append(fields, appgood.FieldMaxOrderAmount)
	}
	if m.FieldCleared(appgood.FieldMaxUserAmount) {
		fields = append(fields, appgood.FieldMaxUserAmount)
	}
	if m.FieldCleared(appgood.FieldMinOrderDuration) {
		fields = append(fields, appgood.FieldMinOrderDuration)
	}
	if m.FieldCleared(appgood.FieldMaxOrderDuration) {
		fields = append(fields, appgood.FieldMaxOrderDuration)
	}
	if m.FieldCleared(appgood.FieldPackageWithRequireds) {
		fields = append(fields, appgood.FieldPackageWithRequireds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodMutation) ClearField(name string) error {
	switch name {
	case appgood.FieldOnline:
		m.ClearOnline()
		return nil
	case appgood.FieldVisible:
		m.ClearVisible()
		return nil
	case appgood.FieldGoodName:
		m.ClearGoodName()
		return nil
	case appgood.FieldUnitPrice:
		m.ClearUnitPrice()
		return nil
	case appgood.FieldPackagePrice:
		m.ClearPackagePrice()
		return nil
	case appgood.FieldDisplayIndex:
		m.ClearDisplayIndex()
		return nil
	case appgood.FieldSaleStartAt:
		m.ClearSaleStartAt()
		return nil
	case appgood.FieldSaleEndAt:
		m.ClearSaleEndAt()
		return nil
	case appgood.FieldServiceStartAt:
		m.ClearServiceStartAt()
		return nil
	case appgood.FieldTechnicalFeeRatio:
		m.ClearTechnicalFeeRatio()
		return nil
	case appgood.FieldElectricityFeeRatio:
		m.ClearElectricityFeeRatio()
		return nil
	case appgood.FieldDescriptions:
		m.ClearDescriptions()
		return nil
	case appgood.FieldGoodBanner:
		m.ClearGoodBanner()
		return nil
	case appgood.FieldDisplayNames:
		m.ClearDisplayNames()
		return nil
	case appgood.FieldEnablePurchase:
		m.ClearEnablePurchase()
		return nil
	case appgood.FieldEnableProductPage:
		m.ClearEnableProductPage()
		return nil
	case appgood.FieldCancelMode:
		m.ClearCancelMode()
		return nil
	case appgood.FieldDisplayColors:
		m.ClearDisplayColors()
		return nil
	case appgood.FieldCancellableBeforeStart:
		m.ClearCancellableBeforeStart()
		return nil
	case appgood.FieldProductPage:
		m.ClearProductPage()
		return nil
	case appgood.FieldEnableSetCommission:
		m.ClearEnableSetCommission()
		return nil
	case appgood.FieldPosters:
		m.ClearPosters()
		return nil
	case appgood.FieldMinOrderAmount:
		m.ClearMinOrderAmount()
		return nil
	case appgood.FieldMaxOrderAmount:
		m.ClearMaxOrderAmount()
		return nil
	case appgood.FieldMaxUserAmount:
		m.ClearMaxUserAmount()
		return nil
	case appgood.FieldMinOrderDuration:
		m.ClearMinOrderDuration()
		return nil
	case appgood.FieldMaxOrderDuration:
		m.ClearMaxOrderDuration()
		return nil
	case appgood.FieldPackageWithRequireds:
		m.ClearPackageWithRequireds()
		return nil
	}
	return fmt.Errorf("unknown AppGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodMutation) ResetField(name string) error {
	switch name {
	case appgood.FieldEntID:
		m.ResetEntID()
		return nil
	case appgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgood.FieldAppID:
		m.ResetAppID()
		return nil
	case appgood.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appgood.FieldOnline:
		m.ResetOnline()
		return nil
	case appgood.FieldVisible:
		m.ResetVisible()
		return nil
	case appgood.FieldGoodName:
		m.ResetGoodName()
		return nil
	case appgood.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case appgood.FieldPackagePrice:
		m.ResetPackagePrice()
		return nil
	case appgood.FieldDisplayIndex:
		m.ResetDisplayIndex()
		return nil
	case appgood.FieldSaleStartAt:
		m.ResetSaleStartAt()
		return nil
	case appgood.FieldSaleEndAt:
		m.ResetSaleEndAt()
		return nil
	case appgood.FieldServiceStartAt:
		m.ResetServiceStartAt()
		return nil
	case appgood.FieldTechnicalFeeRatio:
		m.ResetTechnicalFeeRatio()
		return nil
	case appgood.FieldElectricityFeeRatio:
		m.ResetElectricityFeeRatio()
		return nil
	case appgood.FieldDescriptions:
		m.ResetDescriptions()
		return nil
	case appgood.FieldGoodBanner:
		m.ResetGoodBanner()
		return nil
	case appgood.FieldDisplayNames:
		m.ResetDisplayNames()
		return nil
	case appgood.FieldEnablePurchase:
		m.ResetEnablePurchase()
		return nil
	case appgood.FieldEnableProductPage:
		m.ResetEnableProductPage()
		return nil
	case appgood.FieldCancelMode:
		m.ResetCancelMode()
		return nil
	case appgood.FieldDisplayColors:
		m.ResetDisplayColors()
		return nil
	case appgood.FieldCancellableBeforeStart:
		m.ResetCancellableBeforeStart()
		return nil
	case appgood.FieldProductPage:
		m.ResetProductPage()
		return nil
	case appgood.FieldEnableSetCommission:
		m.ResetEnableSetCommission()
		return nil
	case appgood.FieldPosters:
		m.ResetPosters()
		return nil
	case appgood.FieldMinOrderAmount:
		m.ResetMinOrderAmount()
		return nil
	case appgood.FieldMaxOrderAmount:
		m.ResetMaxOrderAmount()
		return nil
	case appgood.FieldMaxUserAmount:
		m.ResetMaxUserAmount()
		return nil
	case appgood.FieldMinOrderDuration:
		m.ResetMinOrderDuration()
		return nil
	case appgood.FieldMaxOrderDuration:
		m.ResetMaxOrderDuration()
		return nil
	case appgood.FieldPackageWithRequireds:
		m.ResetPackageWithRequireds()
		return nil
	}
	return fmt.Errorf("unknown AppGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGood edge %s", name)
}

// AppGoodBaseMutation represents an operation that mutates the AppGoodBase nodes in the graph.
type AppGoodBaseMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint32
	ent_id              *uuid.UUID
	created_at          *uint32
	addcreated_at       *int32
	updated_at          *uint32
	addupdated_at       *int32
	deleted_at          *uint32
	adddeleted_at       *int32
	app_id              *uuid.UUID
	good_id             *uuid.UUID
	purchasable         *bool
	enable_product_page *bool
	product_page        *string
	online              *bool
	visible             *bool
	name                *string
	display_index       *int32
	adddisplay_index    *int32
	banner              *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*AppGoodBase, error)
	predicates          []predicate.AppGoodBase
}

var _ ent.Mutation = (*AppGoodBaseMutation)(nil)

// appgoodbaseOption allows management of the mutation configuration using functional options.
type appgoodbaseOption func(*AppGoodBaseMutation)

// newAppGoodBaseMutation creates new mutation for the AppGoodBase entity.
func newAppGoodBaseMutation(c config, op Op, opts ...appgoodbaseOption) *AppGoodBaseMutation {
	m := &AppGoodBaseMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGoodBase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodBaseID sets the ID field of the mutation.
func withAppGoodBaseID(id uint32) appgoodbaseOption {
	return func(m *AppGoodBaseMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGoodBase
		)
		m.oldValue = func(ctx context.Context) (*AppGoodBase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGoodBase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGoodBase sets the old AppGoodBase of the mutation.
func withAppGoodBase(node *AppGoodBase) appgoodbaseOption {
	return func(m *AppGoodBaseMutation) {
		m.oldValue = func(context.Context) (*AppGoodBase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodBaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodBaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGoodBase entities.
func (m *AppGoodBaseMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodBaseMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodBaseMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGoodBase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodBaseMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodBaseMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodBaseMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodBaseMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodBaseMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodBaseMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodBaseMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodBaseMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodBaseMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodBaseMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodBaseMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodBaseMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodBaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodBaseMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodBaseMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodBaseMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodBaseMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodBaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppGoodBaseMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppGoodBaseMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppGoodBaseMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appgoodbase.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppGoodBaseMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppGoodBaseMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appgoodbase.FieldAppID)
}

// SetGoodID sets the "good_id" field.
func (m *AppGoodBaseMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppGoodBaseMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *AppGoodBaseMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[appgoodbase.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *AppGoodBaseMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppGoodBaseMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, appgoodbase.FieldGoodID)
}

// SetPurchasable sets the "purchasable" field.
func (m *AppGoodBaseMutation) SetPurchasable(b bool) {
	m.purchasable = &b
}

// Purchasable returns the value of the "purchasable" field in the mutation.
func (m *AppGoodBaseMutation) Purchasable() (r bool, exists bool) {
	v := m.purchasable
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchasable returns the old "purchasable" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldPurchasable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchasable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchasable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchasable: %w", err)
	}
	return oldValue.Purchasable, nil
}

// ClearPurchasable clears the value of the "purchasable" field.
func (m *AppGoodBaseMutation) ClearPurchasable() {
	m.purchasable = nil
	m.clearedFields[appgoodbase.FieldPurchasable] = struct{}{}
}

// PurchasableCleared returns if the "purchasable" field was cleared in this mutation.
func (m *AppGoodBaseMutation) PurchasableCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldPurchasable]
	return ok
}

// ResetPurchasable resets all changes to the "purchasable" field.
func (m *AppGoodBaseMutation) ResetPurchasable() {
	m.purchasable = nil
	delete(m.clearedFields, appgoodbase.FieldPurchasable)
}

// SetEnableProductPage sets the "enable_product_page" field.
func (m *AppGoodBaseMutation) SetEnableProductPage(b bool) {
	m.enable_product_page = &b
}

// EnableProductPage returns the value of the "enable_product_page" field in the mutation.
func (m *AppGoodBaseMutation) EnableProductPage() (r bool, exists bool) {
	v := m.enable_product_page
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableProductPage returns the old "enable_product_page" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldEnableProductPage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableProductPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableProductPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableProductPage: %w", err)
	}
	return oldValue.EnableProductPage, nil
}

// ClearEnableProductPage clears the value of the "enable_product_page" field.
func (m *AppGoodBaseMutation) ClearEnableProductPage() {
	m.enable_product_page = nil
	m.clearedFields[appgoodbase.FieldEnableProductPage] = struct{}{}
}

// EnableProductPageCleared returns if the "enable_product_page" field was cleared in this mutation.
func (m *AppGoodBaseMutation) EnableProductPageCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldEnableProductPage]
	return ok
}

// ResetEnableProductPage resets all changes to the "enable_product_page" field.
func (m *AppGoodBaseMutation) ResetEnableProductPage() {
	m.enable_product_page = nil
	delete(m.clearedFields, appgoodbase.FieldEnableProductPage)
}

// SetProductPage sets the "product_page" field.
func (m *AppGoodBaseMutation) SetProductPage(s string) {
	m.product_page = &s
}

// ProductPage returns the value of the "product_page" field in the mutation.
func (m *AppGoodBaseMutation) ProductPage() (r string, exists bool) {
	v := m.product_page
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPage returns the old "product_page" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldProductPage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPage: %w", err)
	}
	return oldValue.ProductPage, nil
}

// ClearProductPage clears the value of the "product_page" field.
func (m *AppGoodBaseMutation) ClearProductPage() {
	m.product_page = nil
	m.clearedFields[appgoodbase.FieldProductPage] = struct{}{}
}

// ProductPageCleared returns if the "product_page" field was cleared in this mutation.
func (m *AppGoodBaseMutation) ProductPageCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldProductPage]
	return ok
}

// ResetProductPage resets all changes to the "product_page" field.
func (m *AppGoodBaseMutation) ResetProductPage() {
	m.product_page = nil
	delete(m.clearedFields, appgoodbase.FieldProductPage)
}

// SetOnline sets the "online" field.
func (m *AppGoodBaseMutation) SetOnline(b bool) {
	m.online = &b
}

// Online returns the value of the "online" field in the mutation.
func (m *AppGoodBaseMutation) Online() (r bool, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// ClearOnline clears the value of the "online" field.
func (m *AppGoodBaseMutation) ClearOnline() {
	m.online = nil
	m.clearedFields[appgoodbase.FieldOnline] = struct{}{}
}

// OnlineCleared returns if the "online" field was cleared in this mutation.
func (m *AppGoodBaseMutation) OnlineCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldOnline]
	return ok
}

// ResetOnline resets all changes to the "online" field.
func (m *AppGoodBaseMutation) ResetOnline() {
	m.online = nil
	delete(m.clearedFields, appgoodbase.FieldOnline)
}

// SetVisible sets the "visible" field.
func (m *AppGoodBaseMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *AppGoodBaseMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ClearVisible clears the value of the "visible" field.
func (m *AppGoodBaseMutation) ClearVisible() {
	m.visible = nil
	m.clearedFields[appgoodbase.FieldVisible] = struct{}{}
}

// VisibleCleared returns if the "visible" field was cleared in this mutation.
func (m *AppGoodBaseMutation) VisibleCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldVisible]
	return ok
}

// ResetVisible resets all changes to the "visible" field.
func (m *AppGoodBaseMutation) ResetVisible() {
	m.visible = nil
	delete(m.clearedFields, appgoodbase.FieldVisible)
}

// SetName sets the "name" field.
func (m *AppGoodBaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppGoodBaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppGoodBaseMutation) ClearName() {
	m.name = nil
	m.clearedFields[appgoodbase.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppGoodBaseMutation) NameCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppGoodBaseMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, appgoodbase.FieldName)
}

// SetDisplayIndex sets the "display_index" field.
func (m *AppGoodBaseMutation) SetDisplayIndex(i int32) {
	m.display_index = &i
	m.adddisplay_index = nil
}

// DisplayIndex returns the value of the "display_index" field in the mutation.
func (m *AppGoodBaseMutation) DisplayIndex() (r int32, exists bool) {
	v := m.display_index
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayIndex returns the old "display_index" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldDisplayIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayIndex: %w", err)
	}
	return oldValue.DisplayIndex, nil
}

// AddDisplayIndex adds i to the "display_index" field.
func (m *AppGoodBaseMutation) AddDisplayIndex(i int32) {
	if m.adddisplay_index != nil {
		*m.adddisplay_index += i
	} else {
		m.adddisplay_index = &i
	}
}

// AddedDisplayIndex returns the value that was added to the "display_index" field in this mutation.
func (m *AppGoodBaseMutation) AddedDisplayIndex() (r int32, exists bool) {
	v := m.adddisplay_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayIndex clears the value of the "display_index" field.
func (m *AppGoodBaseMutation) ClearDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	m.clearedFields[appgoodbase.FieldDisplayIndex] = struct{}{}
}

// DisplayIndexCleared returns if the "display_index" field was cleared in this mutation.
func (m *AppGoodBaseMutation) DisplayIndexCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldDisplayIndex]
	return ok
}

// ResetDisplayIndex resets all changes to the "display_index" field.
func (m *AppGoodBaseMutation) ResetDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	delete(m.clearedFields, appgoodbase.FieldDisplayIndex)
}

// SetBanner sets the "banner" field.
func (m *AppGoodBaseMutation) SetBanner(s string) {
	m.banner = &s
}

// Banner returns the value of the "banner" field in the mutation.
func (m *AppGoodBaseMutation) Banner() (r string, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBanner returns the old "banner" field's value of the AppGoodBase entity.
// If the AppGoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodBaseMutation) OldBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanner: %w", err)
	}
	return oldValue.Banner, nil
}

// ClearBanner clears the value of the "banner" field.
func (m *AppGoodBaseMutation) ClearBanner() {
	m.banner = nil
	m.clearedFields[appgoodbase.FieldBanner] = struct{}{}
}

// BannerCleared returns if the "banner" field was cleared in this mutation.
func (m *AppGoodBaseMutation) BannerCleared() bool {
	_, ok := m.clearedFields[appgoodbase.FieldBanner]
	return ok
}

// ResetBanner resets all changes to the "banner" field.
func (m *AppGoodBaseMutation) ResetBanner() {
	m.banner = nil
	delete(m.clearedFields, appgoodbase.FieldBanner)
}

// Where appends a list predicates to the AppGoodBaseMutation builder.
func (m *AppGoodBaseMutation) Where(ps ...predicate.AppGoodBase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodBaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodBaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGoodBase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodBaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodBaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGoodBase).
func (m *AppGoodBaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodBaseMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.ent_id != nil {
		fields = append(fields, appgoodbase.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appgoodbase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgoodbase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgoodbase.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appgoodbase.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appgoodbase.FieldGoodID)
	}
	if m.purchasable != nil {
		fields = append(fields, appgoodbase.FieldPurchasable)
	}
	if m.enable_product_page != nil {
		fields = append(fields, appgoodbase.FieldEnableProductPage)
	}
	if m.product_page != nil {
		fields = append(fields, appgoodbase.FieldProductPage)
	}
	if m.online != nil {
		fields = append(fields, appgoodbase.FieldOnline)
	}
	if m.visible != nil {
		fields = append(fields, appgoodbase.FieldVisible)
	}
	if m.name != nil {
		fields = append(fields, appgoodbase.FieldName)
	}
	if m.display_index != nil {
		fields = append(fields, appgoodbase.FieldDisplayIndex)
	}
	if m.banner != nil {
		fields = append(fields, appgoodbase.FieldBanner)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodBaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgoodbase.FieldEntID:
		return m.EntID()
	case appgoodbase.FieldCreatedAt:
		return m.CreatedAt()
	case appgoodbase.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgoodbase.FieldDeletedAt:
		return m.DeletedAt()
	case appgoodbase.FieldAppID:
		return m.AppID()
	case appgoodbase.FieldGoodID:
		return m.GoodID()
	case appgoodbase.FieldPurchasable:
		return m.Purchasable()
	case appgoodbase.FieldEnableProductPage:
		return m.EnableProductPage()
	case appgoodbase.FieldProductPage:
		return m.ProductPage()
	case appgoodbase.FieldOnline:
		return m.Online()
	case appgoodbase.FieldVisible:
		return m.Visible()
	case appgoodbase.FieldName:
		return m.Name()
	case appgoodbase.FieldDisplayIndex:
		return m.DisplayIndex()
	case appgoodbase.FieldBanner:
		return m.Banner()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodBaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgoodbase.FieldEntID:
		return m.OldEntID(ctx)
	case appgoodbase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgoodbase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgoodbase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgoodbase.FieldAppID:
		return m.OldAppID(ctx)
	case appgoodbase.FieldGoodID:
		return m.OldGoodID(ctx)
	case appgoodbase.FieldPurchasable:
		return m.OldPurchasable(ctx)
	case appgoodbase.FieldEnableProductPage:
		return m.OldEnableProductPage(ctx)
	case appgoodbase.FieldProductPage:
		return m.OldProductPage(ctx)
	case appgoodbase.FieldOnline:
		return m.OldOnline(ctx)
	case appgoodbase.FieldVisible:
		return m.OldVisible(ctx)
	case appgoodbase.FieldName:
		return m.OldName(ctx)
	case appgoodbase.FieldDisplayIndex:
		return m.OldDisplayIndex(ctx)
	case appgoodbase.FieldBanner:
		return m.OldBanner(ctx)
	}
	return nil, fmt.Errorf("unknown AppGoodBase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodBaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgoodbase.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgoodbase.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgoodbase.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgoodbase.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgoodbase.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appgoodbase.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appgoodbase.FieldPurchasable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchasable(v)
		return nil
	case appgoodbase.FieldEnableProductPage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableProductPage(v)
		return nil
	case appgoodbase.FieldProductPage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPage(v)
		return nil
	case appgoodbase.FieldOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case appgoodbase.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	case appgoodbase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appgoodbase.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayIndex(v)
		return nil
	case appgoodbase.FieldBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanner(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodBase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodBaseMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgoodbase.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgoodbase.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgoodbase.FieldDeletedAt)
	}
	if m.adddisplay_index != nil {
		fields = append(fields, appgoodbase.FieldDisplayIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodBaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgoodbase.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgoodbase.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgoodbase.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgoodbase.FieldDisplayIndex:
		return m.AddedDisplayIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodBaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgoodbase.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgoodbase.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgoodbase.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgoodbase.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodBase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodBaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgoodbase.FieldAppID) {
		fields = append(fields, appgoodbase.FieldAppID)
	}
	if m.FieldCleared(appgoodbase.FieldGoodID) {
		fields = append(fields, appgoodbase.FieldGoodID)
	}
	if m.FieldCleared(appgoodbase.FieldPurchasable) {
		fields = append(fields, appgoodbase.FieldPurchasable)
	}
	if m.FieldCleared(appgoodbase.FieldEnableProductPage) {
		fields = append(fields, appgoodbase.FieldEnableProductPage)
	}
	if m.FieldCleared(appgoodbase.FieldProductPage) {
		fields = append(fields, appgoodbase.FieldProductPage)
	}
	if m.FieldCleared(appgoodbase.FieldOnline) {
		fields = append(fields, appgoodbase.FieldOnline)
	}
	if m.FieldCleared(appgoodbase.FieldVisible) {
		fields = append(fields, appgoodbase.FieldVisible)
	}
	if m.FieldCleared(appgoodbase.FieldName) {
		fields = append(fields, appgoodbase.FieldName)
	}
	if m.FieldCleared(appgoodbase.FieldDisplayIndex) {
		fields = append(fields, appgoodbase.FieldDisplayIndex)
	}
	if m.FieldCleared(appgoodbase.FieldBanner) {
		fields = append(fields, appgoodbase.FieldBanner)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodBaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodBaseMutation) ClearField(name string) error {
	switch name {
	case appgoodbase.FieldAppID:
		m.ClearAppID()
		return nil
	case appgoodbase.FieldGoodID:
		m.ClearGoodID()
		return nil
	case appgoodbase.FieldPurchasable:
		m.ClearPurchasable()
		return nil
	case appgoodbase.FieldEnableProductPage:
		m.ClearEnableProductPage()
		return nil
	case appgoodbase.FieldProductPage:
		m.ClearProductPage()
		return nil
	case appgoodbase.FieldOnline:
		m.ClearOnline()
		return nil
	case appgoodbase.FieldVisible:
		m.ClearVisible()
		return nil
	case appgoodbase.FieldName:
		m.ClearName()
		return nil
	case appgoodbase.FieldDisplayIndex:
		m.ClearDisplayIndex()
		return nil
	case appgoodbase.FieldBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown AppGoodBase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodBaseMutation) ResetField(name string) error {
	switch name {
	case appgoodbase.FieldEntID:
		m.ResetEntID()
		return nil
	case appgoodbase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgoodbase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgoodbase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgoodbase.FieldAppID:
		m.ResetAppID()
		return nil
	case appgoodbase.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appgoodbase.FieldPurchasable:
		m.ResetPurchasable()
		return nil
	case appgoodbase.FieldEnableProductPage:
		m.ResetEnableProductPage()
		return nil
	case appgoodbase.FieldProductPage:
		m.ResetProductPage()
		return nil
	case appgoodbase.FieldOnline:
		m.ResetOnline()
		return nil
	case appgoodbase.FieldVisible:
		m.ResetVisible()
		return nil
	case appgoodbase.FieldName:
		m.ResetName()
		return nil
	case appgoodbase.FieldDisplayIndex:
		m.ResetDisplayIndex()
		return nil
	case appgoodbase.FieldBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown AppGoodBase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodBaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodBaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodBaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodBaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodBaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodBaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodBaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGoodBase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodBaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGoodBase edge %s", name)
}

// AppGoodDescriptionMutation represents an operation that mutates the AppGoodDescription nodes in the graph.
type AppGoodDescriptionMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_good_id   *uuid.UUID
	description   *string
	index         *uint8
	addindex      *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppGoodDescription, error)
	predicates    []predicate.AppGoodDescription
}

var _ ent.Mutation = (*AppGoodDescriptionMutation)(nil)

// appgooddescriptionOption allows management of the mutation configuration using functional options.
type appgooddescriptionOption func(*AppGoodDescriptionMutation)

// newAppGoodDescriptionMutation creates new mutation for the AppGoodDescription entity.
func newAppGoodDescriptionMutation(c config, op Op, opts ...appgooddescriptionOption) *AppGoodDescriptionMutation {
	m := &AppGoodDescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGoodDescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodDescriptionID sets the ID field of the mutation.
func withAppGoodDescriptionID(id uint32) appgooddescriptionOption {
	return func(m *AppGoodDescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGoodDescription
		)
		m.oldValue = func(ctx context.Context) (*AppGoodDescription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGoodDescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGoodDescription sets the old AppGoodDescription of the mutation.
func withAppGoodDescription(node *AppGoodDescription) appgooddescriptionOption {
	return func(m *AppGoodDescriptionMutation) {
		m.oldValue = func(context.Context) (*AppGoodDescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodDescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodDescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGoodDescription entities.
func (m *AppGoodDescriptionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodDescriptionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodDescriptionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGoodDescription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodDescriptionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodDescriptionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGoodDescription entity.
// If the AppGoodDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDescriptionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodDescriptionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodDescriptionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodDescriptionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGoodDescription entity.
// If the AppGoodDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDescriptionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodDescriptionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodDescriptionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodDescriptionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodDescriptionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodDescriptionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGoodDescription entity.
// If the AppGoodDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDescriptionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodDescriptionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodDescriptionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodDescriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodDescriptionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodDescriptionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGoodDescription entity.
// If the AppGoodDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDescriptionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodDescriptionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodDescriptionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodDescriptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppGoodDescriptionMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppGoodDescriptionMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppGoodDescription entity.
// If the AppGoodDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDescriptionMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppGoodDescriptionMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appgooddescription.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppGoodDescriptionMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appgooddescription.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppGoodDescriptionMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appgooddescription.FieldAppGoodID)
}

// SetDescription sets the "description" field.
func (m *AppGoodDescriptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppGoodDescriptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppGoodDescription entity.
// If the AppGoodDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDescriptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppGoodDescriptionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[appgooddescription.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppGoodDescriptionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[appgooddescription.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppGoodDescriptionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, appgooddescription.FieldDescription)
}

// SetIndex sets the "index" field.
func (m *AppGoodDescriptionMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *AppGoodDescriptionMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the AppGoodDescription entity.
// If the AppGoodDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDescriptionMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *AppGoodDescriptionMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *AppGoodDescriptionMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *AppGoodDescriptionMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[appgooddescription.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *AppGoodDescriptionMutation) IndexCleared() bool {
	_, ok := m.clearedFields[appgooddescription.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *AppGoodDescriptionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, appgooddescription.FieldIndex)
}

// Where appends a list predicates to the AppGoodDescriptionMutation builder.
func (m *AppGoodDescriptionMutation) Where(ps ...predicate.AppGoodDescription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodDescriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodDescriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGoodDescription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodDescriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodDescriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGoodDescription).
func (m *AppGoodDescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodDescriptionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, appgooddescription.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appgooddescription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgooddescription.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgooddescription.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appgooddescription.FieldAppGoodID)
	}
	if m.description != nil {
		fields = append(fields, appgooddescription.FieldDescription)
	}
	if m.index != nil {
		fields = append(fields, appgooddescription.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodDescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgooddescription.FieldEntID:
		return m.EntID()
	case appgooddescription.FieldCreatedAt:
		return m.CreatedAt()
	case appgooddescription.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgooddescription.FieldDeletedAt:
		return m.DeletedAt()
	case appgooddescription.FieldAppGoodID:
		return m.AppGoodID()
	case appgooddescription.FieldDescription:
		return m.Description()
	case appgooddescription.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodDescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgooddescription.FieldEntID:
		return m.OldEntID(ctx)
	case appgooddescription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgooddescription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgooddescription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgooddescription.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appgooddescription.FieldDescription:
		return m.OldDescription(ctx)
	case appgooddescription.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown AppGoodDescription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodDescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgooddescription.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgooddescription.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgooddescription.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgooddescription.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgooddescription.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appgooddescription.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case appgooddescription.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodDescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodDescriptionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgooddescription.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgooddescription.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgooddescription.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, appgooddescription.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodDescriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgooddescription.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgooddescription.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgooddescription.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgooddescription.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodDescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgooddescription.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgooddescription.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgooddescription.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgooddescription.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodDescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodDescriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgooddescription.FieldAppGoodID) {
		fields = append(fields, appgooddescription.FieldAppGoodID)
	}
	if m.FieldCleared(appgooddescription.FieldDescription) {
		fields = append(fields, appgooddescription.FieldDescription)
	}
	if m.FieldCleared(appgooddescription.FieldIndex) {
		fields = append(fields, appgooddescription.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodDescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodDescriptionMutation) ClearField(name string) error {
	switch name {
	case appgooddescription.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appgooddescription.FieldDescription:
		m.ClearDescription()
		return nil
	case appgooddescription.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodDescription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodDescriptionMutation) ResetField(name string) error {
	switch name {
	case appgooddescription.FieldEntID:
		m.ResetEntID()
		return nil
	case appgooddescription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgooddescription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgooddescription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgooddescription.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appgooddescription.FieldDescription:
		m.ResetDescription()
		return nil
	case appgooddescription.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodDescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodDescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodDescriptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodDescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodDescriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodDescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodDescriptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodDescriptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGoodDescription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodDescriptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGoodDescription edge %s", name)
}

// AppGoodDisplayColorMutation represents an operation that mutates the AppGoodDisplayColor nodes in the graph.
type AppGoodDisplayColorMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_good_id   *uuid.UUID
	color         *string
	index         *uint8
	addindex      *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppGoodDisplayColor, error)
	predicates    []predicate.AppGoodDisplayColor
}

var _ ent.Mutation = (*AppGoodDisplayColorMutation)(nil)

// appgooddisplaycolorOption allows management of the mutation configuration using functional options.
type appgooddisplaycolorOption func(*AppGoodDisplayColorMutation)

// newAppGoodDisplayColorMutation creates new mutation for the AppGoodDisplayColor entity.
func newAppGoodDisplayColorMutation(c config, op Op, opts ...appgooddisplaycolorOption) *AppGoodDisplayColorMutation {
	m := &AppGoodDisplayColorMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGoodDisplayColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodDisplayColorID sets the ID field of the mutation.
func withAppGoodDisplayColorID(id uint32) appgooddisplaycolorOption {
	return func(m *AppGoodDisplayColorMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGoodDisplayColor
		)
		m.oldValue = func(ctx context.Context) (*AppGoodDisplayColor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGoodDisplayColor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGoodDisplayColor sets the old AppGoodDisplayColor of the mutation.
func withAppGoodDisplayColor(node *AppGoodDisplayColor) appgooddisplaycolorOption {
	return func(m *AppGoodDisplayColorMutation) {
		m.oldValue = func(context.Context) (*AppGoodDisplayColor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodDisplayColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodDisplayColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGoodDisplayColor entities.
func (m *AppGoodDisplayColorMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodDisplayColorMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodDisplayColorMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGoodDisplayColor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodDisplayColorMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodDisplayColorMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGoodDisplayColor entity.
// If the AppGoodDisplayColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayColorMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodDisplayColorMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodDisplayColorMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodDisplayColorMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGoodDisplayColor entity.
// If the AppGoodDisplayColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayColorMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodDisplayColorMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodDisplayColorMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodDisplayColorMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodDisplayColorMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodDisplayColorMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGoodDisplayColor entity.
// If the AppGoodDisplayColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayColorMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodDisplayColorMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodDisplayColorMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodDisplayColorMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodDisplayColorMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodDisplayColorMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGoodDisplayColor entity.
// If the AppGoodDisplayColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayColorMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodDisplayColorMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodDisplayColorMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodDisplayColorMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppGoodDisplayColorMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppGoodDisplayColorMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppGoodDisplayColor entity.
// If the AppGoodDisplayColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayColorMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppGoodDisplayColorMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appgooddisplaycolor.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppGoodDisplayColorMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appgooddisplaycolor.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppGoodDisplayColorMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appgooddisplaycolor.FieldAppGoodID)
}

// SetColor sets the "color" field.
func (m *AppGoodDisplayColorMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *AppGoodDisplayColorMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the AppGoodDisplayColor entity.
// If the AppGoodDisplayColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayColorMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *AppGoodDisplayColorMutation) ClearColor() {
	m.color = nil
	m.clearedFields[appgooddisplaycolor.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *AppGoodDisplayColorMutation) ColorCleared() bool {
	_, ok := m.clearedFields[appgooddisplaycolor.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *AppGoodDisplayColorMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, appgooddisplaycolor.FieldColor)
}

// SetIndex sets the "index" field.
func (m *AppGoodDisplayColorMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *AppGoodDisplayColorMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the AppGoodDisplayColor entity.
// If the AppGoodDisplayColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayColorMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *AppGoodDisplayColorMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *AppGoodDisplayColorMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *AppGoodDisplayColorMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[appgooddisplaycolor.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *AppGoodDisplayColorMutation) IndexCleared() bool {
	_, ok := m.clearedFields[appgooddisplaycolor.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *AppGoodDisplayColorMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, appgooddisplaycolor.FieldIndex)
}

// Where appends a list predicates to the AppGoodDisplayColorMutation builder.
func (m *AppGoodDisplayColorMutation) Where(ps ...predicate.AppGoodDisplayColor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodDisplayColorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodDisplayColorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGoodDisplayColor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodDisplayColorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodDisplayColorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGoodDisplayColor).
func (m *AppGoodDisplayColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodDisplayColorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, appgooddisplaycolor.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appgooddisplaycolor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgooddisplaycolor.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgooddisplaycolor.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appgooddisplaycolor.FieldAppGoodID)
	}
	if m.color != nil {
		fields = append(fields, appgooddisplaycolor.FieldColor)
	}
	if m.index != nil {
		fields = append(fields, appgooddisplaycolor.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodDisplayColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgooddisplaycolor.FieldEntID:
		return m.EntID()
	case appgooddisplaycolor.FieldCreatedAt:
		return m.CreatedAt()
	case appgooddisplaycolor.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgooddisplaycolor.FieldDeletedAt:
		return m.DeletedAt()
	case appgooddisplaycolor.FieldAppGoodID:
		return m.AppGoodID()
	case appgooddisplaycolor.FieldColor:
		return m.Color()
	case appgooddisplaycolor.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodDisplayColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgooddisplaycolor.FieldEntID:
		return m.OldEntID(ctx)
	case appgooddisplaycolor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgooddisplaycolor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgooddisplaycolor.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgooddisplaycolor.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appgooddisplaycolor.FieldColor:
		return m.OldColor(ctx)
	case appgooddisplaycolor.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown AppGoodDisplayColor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodDisplayColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgooddisplaycolor.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgooddisplaycolor.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgooddisplaycolor.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgooddisplaycolor.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgooddisplaycolor.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appgooddisplaycolor.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case appgooddisplaycolor.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodDisplayColor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodDisplayColorMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgooddisplaycolor.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgooddisplaycolor.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgooddisplaycolor.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, appgooddisplaycolor.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodDisplayColorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgooddisplaycolor.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgooddisplaycolor.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgooddisplaycolor.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgooddisplaycolor.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodDisplayColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgooddisplaycolor.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgooddisplaycolor.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgooddisplaycolor.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgooddisplaycolor.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodDisplayColor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodDisplayColorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgooddisplaycolor.FieldAppGoodID) {
		fields = append(fields, appgooddisplaycolor.FieldAppGoodID)
	}
	if m.FieldCleared(appgooddisplaycolor.FieldColor) {
		fields = append(fields, appgooddisplaycolor.FieldColor)
	}
	if m.FieldCleared(appgooddisplaycolor.FieldIndex) {
		fields = append(fields, appgooddisplaycolor.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodDisplayColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodDisplayColorMutation) ClearField(name string) error {
	switch name {
	case appgooddisplaycolor.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appgooddisplaycolor.FieldColor:
		m.ClearColor()
		return nil
	case appgooddisplaycolor.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodDisplayColor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodDisplayColorMutation) ResetField(name string) error {
	switch name {
	case appgooddisplaycolor.FieldEntID:
		m.ResetEntID()
		return nil
	case appgooddisplaycolor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgooddisplaycolor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgooddisplaycolor.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgooddisplaycolor.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appgooddisplaycolor.FieldColor:
		m.ResetColor()
		return nil
	case appgooddisplaycolor.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodDisplayColor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodDisplayColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodDisplayColorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodDisplayColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodDisplayColorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodDisplayColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodDisplayColorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodDisplayColorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGoodDisplayColor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodDisplayColorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGoodDisplayColor edge %s", name)
}

// AppGoodDisplayNameMutation represents an operation that mutates the AppGoodDisplayName nodes in the graph.
type AppGoodDisplayNameMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_good_id   *uuid.UUID
	name          *string
	index         *uint8
	addindex      *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppGoodDisplayName, error)
	predicates    []predicate.AppGoodDisplayName
}

var _ ent.Mutation = (*AppGoodDisplayNameMutation)(nil)

// appgooddisplaynameOption allows management of the mutation configuration using functional options.
type appgooddisplaynameOption func(*AppGoodDisplayNameMutation)

// newAppGoodDisplayNameMutation creates new mutation for the AppGoodDisplayName entity.
func newAppGoodDisplayNameMutation(c config, op Op, opts ...appgooddisplaynameOption) *AppGoodDisplayNameMutation {
	m := &AppGoodDisplayNameMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGoodDisplayName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodDisplayNameID sets the ID field of the mutation.
func withAppGoodDisplayNameID(id uint32) appgooddisplaynameOption {
	return func(m *AppGoodDisplayNameMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGoodDisplayName
		)
		m.oldValue = func(ctx context.Context) (*AppGoodDisplayName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGoodDisplayName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGoodDisplayName sets the old AppGoodDisplayName of the mutation.
func withAppGoodDisplayName(node *AppGoodDisplayName) appgooddisplaynameOption {
	return func(m *AppGoodDisplayNameMutation) {
		m.oldValue = func(context.Context) (*AppGoodDisplayName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodDisplayNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodDisplayNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGoodDisplayName entities.
func (m *AppGoodDisplayNameMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodDisplayNameMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodDisplayNameMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGoodDisplayName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodDisplayNameMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodDisplayNameMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGoodDisplayName entity.
// If the AppGoodDisplayName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayNameMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodDisplayNameMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodDisplayNameMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodDisplayNameMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGoodDisplayName entity.
// If the AppGoodDisplayName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayNameMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodDisplayNameMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodDisplayNameMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodDisplayNameMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodDisplayNameMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodDisplayNameMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGoodDisplayName entity.
// If the AppGoodDisplayName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayNameMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodDisplayNameMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodDisplayNameMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodDisplayNameMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodDisplayNameMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodDisplayNameMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGoodDisplayName entity.
// If the AppGoodDisplayName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayNameMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodDisplayNameMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodDisplayNameMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodDisplayNameMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppGoodDisplayNameMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppGoodDisplayNameMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppGoodDisplayName entity.
// If the AppGoodDisplayName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayNameMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppGoodDisplayNameMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appgooddisplayname.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppGoodDisplayNameMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appgooddisplayname.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppGoodDisplayNameMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appgooddisplayname.FieldAppGoodID)
}

// SetName sets the "name" field.
func (m *AppGoodDisplayNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppGoodDisplayNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppGoodDisplayName entity.
// If the AppGoodDisplayName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppGoodDisplayNameMutation) ClearName() {
	m.name = nil
	m.clearedFields[appgooddisplayname.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppGoodDisplayNameMutation) NameCleared() bool {
	_, ok := m.clearedFields[appgooddisplayname.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppGoodDisplayNameMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, appgooddisplayname.FieldName)
}

// SetIndex sets the "index" field.
func (m *AppGoodDisplayNameMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *AppGoodDisplayNameMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the AppGoodDisplayName entity.
// If the AppGoodDisplayName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodDisplayNameMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *AppGoodDisplayNameMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *AppGoodDisplayNameMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *AppGoodDisplayNameMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[appgooddisplayname.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *AppGoodDisplayNameMutation) IndexCleared() bool {
	_, ok := m.clearedFields[appgooddisplayname.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *AppGoodDisplayNameMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, appgooddisplayname.FieldIndex)
}

// Where appends a list predicates to the AppGoodDisplayNameMutation builder.
func (m *AppGoodDisplayNameMutation) Where(ps ...predicate.AppGoodDisplayName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodDisplayNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodDisplayNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGoodDisplayName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodDisplayNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodDisplayNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGoodDisplayName).
func (m *AppGoodDisplayNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodDisplayNameMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, appgooddisplayname.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appgooddisplayname.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgooddisplayname.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgooddisplayname.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appgooddisplayname.FieldAppGoodID)
	}
	if m.name != nil {
		fields = append(fields, appgooddisplayname.FieldName)
	}
	if m.index != nil {
		fields = append(fields, appgooddisplayname.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodDisplayNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgooddisplayname.FieldEntID:
		return m.EntID()
	case appgooddisplayname.FieldCreatedAt:
		return m.CreatedAt()
	case appgooddisplayname.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgooddisplayname.FieldDeletedAt:
		return m.DeletedAt()
	case appgooddisplayname.FieldAppGoodID:
		return m.AppGoodID()
	case appgooddisplayname.FieldName:
		return m.Name()
	case appgooddisplayname.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodDisplayNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgooddisplayname.FieldEntID:
		return m.OldEntID(ctx)
	case appgooddisplayname.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgooddisplayname.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgooddisplayname.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgooddisplayname.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appgooddisplayname.FieldName:
		return m.OldName(ctx)
	case appgooddisplayname.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown AppGoodDisplayName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodDisplayNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgooddisplayname.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgooddisplayname.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgooddisplayname.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgooddisplayname.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgooddisplayname.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appgooddisplayname.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appgooddisplayname.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodDisplayName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodDisplayNameMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgooddisplayname.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgooddisplayname.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgooddisplayname.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, appgooddisplayname.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodDisplayNameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgooddisplayname.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgooddisplayname.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgooddisplayname.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgooddisplayname.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodDisplayNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgooddisplayname.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgooddisplayname.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgooddisplayname.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgooddisplayname.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodDisplayName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodDisplayNameMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgooddisplayname.FieldAppGoodID) {
		fields = append(fields, appgooddisplayname.FieldAppGoodID)
	}
	if m.FieldCleared(appgooddisplayname.FieldName) {
		fields = append(fields, appgooddisplayname.FieldName)
	}
	if m.FieldCleared(appgooddisplayname.FieldIndex) {
		fields = append(fields, appgooddisplayname.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodDisplayNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodDisplayNameMutation) ClearField(name string) error {
	switch name {
	case appgooddisplayname.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appgooddisplayname.FieldName:
		m.ClearName()
		return nil
	case appgooddisplayname.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodDisplayName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodDisplayNameMutation) ResetField(name string) error {
	switch name {
	case appgooddisplayname.FieldEntID:
		m.ResetEntID()
		return nil
	case appgooddisplayname.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgooddisplayname.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgooddisplayname.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgooddisplayname.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appgooddisplayname.FieldName:
		m.ResetName()
		return nil
	case appgooddisplayname.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodDisplayName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodDisplayNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodDisplayNameMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodDisplayNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodDisplayNameMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodDisplayNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodDisplayNameMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodDisplayNameMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGoodDisplayName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodDisplayNameMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGoodDisplayName edge %s", name)
}

// AppGoodLabelMutation represents an operation that mutates the AppGoodLabel nodes in the graph.
type AppGoodLabelMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	ent_id         *uuid.UUID
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	app_good_id    *uuid.UUID
	icon           *string
	icon_bg_color  *string
	label          *string
	label_bg_color *string
	index          *uint8
	addindex       *int8
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AppGoodLabel, error)
	predicates     []predicate.AppGoodLabel
}

var _ ent.Mutation = (*AppGoodLabelMutation)(nil)

// appgoodlabelOption allows management of the mutation configuration using functional options.
type appgoodlabelOption func(*AppGoodLabelMutation)

// newAppGoodLabelMutation creates new mutation for the AppGoodLabel entity.
func newAppGoodLabelMutation(c config, op Op, opts ...appgoodlabelOption) *AppGoodLabelMutation {
	m := &AppGoodLabelMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGoodLabel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodLabelID sets the ID field of the mutation.
func withAppGoodLabelID(id uint32) appgoodlabelOption {
	return func(m *AppGoodLabelMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGoodLabel
		)
		m.oldValue = func(ctx context.Context) (*AppGoodLabel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGoodLabel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGoodLabel sets the old AppGoodLabel of the mutation.
func withAppGoodLabel(node *AppGoodLabel) appgoodlabelOption {
	return func(m *AppGoodLabelMutation) {
		m.oldValue = func(context.Context) (*AppGoodLabel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodLabelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodLabelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGoodLabel entities.
func (m *AppGoodLabelMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodLabelMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodLabelMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGoodLabel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodLabelMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodLabelMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodLabelMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodLabelMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodLabelMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodLabelMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodLabelMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodLabelMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodLabelMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodLabelMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodLabelMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodLabelMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodLabelMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodLabelMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodLabelMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodLabelMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodLabelMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodLabelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppGoodLabelMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppGoodLabelMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppGoodLabelMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appgoodlabel.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppGoodLabelMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appgoodlabel.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppGoodLabelMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appgoodlabel.FieldAppGoodID)
}

// SetIcon sets the "icon" field.
func (m *AppGoodLabelMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AppGoodLabelMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *AppGoodLabelMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[appgoodlabel.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *AppGoodLabelMutation) IconCleared() bool {
	_, ok := m.clearedFields[appgoodlabel.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *AppGoodLabelMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, appgoodlabel.FieldIcon)
}

// SetIconBgColor sets the "icon_bg_color" field.
func (m *AppGoodLabelMutation) SetIconBgColor(s string) {
	m.icon_bg_color = &s
}

// IconBgColor returns the value of the "icon_bg_color" field in the mutation.
func (m *AppGoodLabelMutation) IconBgColor() (r string, exists bool) {
	v := m.icon_bg_color
	if v == nil {
		return
	}
	return *v, true
}

// OldIconBgColor returns the old "icon_bg_color" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldIconBgColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconBgColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconBgColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconBgColor: %w", err)
	}
	return oldValue.IconBgColor, nil
}

// ClearIconBgColor clears the value of the "icon_bg_color" field.
func (m *AppGoodLabelMutation) ClearIconBgColor() {
	m.icon_bg_color = nil
	m.clearedFields[appgoodlabel.FieldIconBgColor] = struct{}{}
}

// IconBgColorCleared returns if the "icon_bg_color" field was cleared in this mutation.
func (m *AppGoodLabelMutation) IconBgColorCleared() bool {
	_, ok := m.clearedFields[appgoodlabel.FieldIconBgColor]
	return ok
}

// ResetIconBgColor resets all changes to the "icon_bg_color" field.
func (m *AppGoodLabelMutation) ResetIconBgColor() {
	m.icon_bg_color = nil
	delete(m.clearedFields, appgoodlabel.FieldIconBgColor)
}

// SetLabel sets the "label" field.
func (m *AppGoodLabelMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *AppGoodLabelMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ClearLabel clears the value of the "label" field.
func (m *AppGoodLabelMutation) ClearLabel() {
	m.label = nil
	m.clearedFields[appgoodlabel.FieldLabel] = struct{}{}
}

// LabelCleared returns if the "label" field was cleared in this mutation.
func (m *AppGoodLabelMutation) LabelCleared() bool {
	_, ok := m.clearedFields[appgoodlabel.FieldLabel]
	return ok
}

// ResetLabel resets all changes to the "label" field.
func (m *AppGoodLabelMutation) ResetLabel() {
	m.label = nil
	delete(m.clearedFields, appgoodlabel.FieldLabel)
}

// SetLabelBgColor sets the "label_bg_color" field.
func (m *AppGoodLabelMutation) SetLabelBgColor(s string) {
	m.label_bg_color = &s
}

// LabelBgColor returns the value of the "label_bg_color" field in the mutation.
func (m *AppGoodLabelMutation) LabelBgColor() (r string, exists bool) {
	v := m.label_bg_color
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelBgColor returns the old "label_bg_color" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldLabelBgColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelBgColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelBgColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelBgColor: %w", err)
	}
	return oldValue.LabelBgColor, nil
}

// ClearLabelBgColor clears the value of the "label_bg_color" field.
func (m *AppGoodLabelMutation) ClearLabelBgColor() {
	m.label_bg_color = nil
	m.clearedFields[appgoodlabel.FieldLabelBgColor] = struct{}{}
}

// LabelBgColorCleared returns if the "label_bg_color" field was cleared in this mutation.
func (m *AppGoodLabelMutation) LabelBgColorCleared() bool {
	_, ok := m.clearedFields[appgoodlabel.FieldLabelBgColor]
	return ok
}

// ResetLabelBgColor resets all changes to the "label_bg_color" field.
func (m *AppGoodLabelMutation) ResetLabelBgColor() {
	m.label_bg_color = nil
	delete(m.clearedFields, appgoodlabel.FieldLabelBgColor)
}

// SetIndex sets the "index" field.
func (m *AppGoodLabelMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *AppGoodLabelMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the AppGoodLabel entity.
// If the AppGoodLabel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodLabelMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *AppGoodLabelMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *AppGoodLabelMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *AppGoodLabelMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[appgoodlabel.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *AppGoodLabelMutation) IndexCleared() bool {
	_, ok := m.clearedFields[appgoodlabel.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *AppGoodLabelMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, appgoodlabel.FieldIndex)
}

// Where appends a list predicates to the AppGoodLabelMutation builder.
func (m *AppGoodLabelMutation) Where(ps ...predicate.AppGoodLabel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodLabelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodLabelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGoodLabel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodLabelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodLabelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGoodLabel).
func (m *AppGoodLabelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodLabelMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ent_id != nil {
		fields = append(fields, appgoodlabel.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appgoodlabel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgoodlabel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgoodlabel.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appgoodlabel.FieldAppGoodID)
	}
	if m.icon != nil {
		fields = append(fields, appgoodlabel.FieldIcon)
	}
	if m.icon_bg_color != nil {
		fields = append(fields, appgoodlabel.FieldIconBgColor)
	}
	if m.label != nil {
		fields = append(fields, appgoodlabel.FieldLabel)
	}
	if m.label_bg_color != nil {
		fields = append(fields, appgoodlabel.FieldLabelBgColor)
	}
	if m.index != nil {
		fields = append(fields, appgoodlabel.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodLabelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgoodlabel.FieldEntID:
		return m.EntID()
	case appgoodlabel.FieldCreatedAt:
		return m.CreatedAt()
	case appgoodlabel.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgoodlabel.FieldDeletedAt:
		return m.DeletedAt()
	case appgoodlabel.FieldAppGoodID:
		return m.AppGoodID()
	case appgoodlabel.FieldIcon:
		return m.Icon()
	case appgoodlabel.FieldIconBgColor:
		return m.IconBgColor()
	case appgoodlabel.FieldLabel:
		return m.Label()
	case appgoodlabel.FieldLabelBgColor:
		return m.LabelBgColor()
	case appgoodlabel.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodLabelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgoodlabel.FieldEntID:
		return m.OldEntID(ctx)
	case appgoodlabel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgoodlabel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgoodlabel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgoodlabel.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appgoodlabel.FieldIcon:
		return m.OldIcon(ctx)
	case appgoodlabel.FieldIconBgColor:
		return m.OldIconBgColor(ctx)
	case appgoodlabel.FieldLabel:
		return m.OldLabel(ctx)
	case appgoodlabel.FieldLabelBgColor:
		return m.OldLabelBgColor(ctx)
	case appgoodlabel.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown AppGoodLabel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodLabelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgoodlabel.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgoodlabel.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgoodlabel.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgoodlabel.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgoodlabel.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appgoodlabel.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case appgoodlabel.FieldIconBgColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconBgColor(v)
		return nil
	case appgoodlabel.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case appgoodlabel.FieldLabelBgColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelBgColor(v)
		return nil
	case appgoodlabel.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodLabel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodLabelMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgoodlabel.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgoodlabel.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgoodlabel.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, appgoodlabel.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodLabelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgoodlabel.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgoodlabel.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgoodlabel.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgoodlabel.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodLabelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgoodlabel.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgoodlabel.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgoodlabel.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgoodlabel.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodLabel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodLabelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgoodlabel.FieldAppGoodID) {
		fields = append(fields, appgoodlabel.FieldAppGoodID)
	}
	if m.FieldCleared(appgoodlabel.FieldIcon) {
		fields = append(fields, appgoodlabel.FieldIcon)
	}
	if m.FieldCleared(appgoodlabel.FieldIconBgColor) {
		fields = append(fields, appgoodlabel.FieldIconBgColor)
	}
	if m.FieldCleared(appgoodlabel.FieldLabel) {
		fields = append(fields, appgoodlabel.FieldLabel)
	}
	if m.FieldCleared(appgoodlabel.FieldLabelBgColor) {
		fields = append(fields, appgoodlabel.FieldLabelBgColor)
	}
	if m.FieldCleared(appgoodlabel.FieldIndex) {
		fields = append(fields, appgoodlabel.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodLabelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodLabelMutation) ClearField(name string) error {
	switch name {
	case appgoodlabel.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appgoodlabel.FieldIcon:
		m.ClearIcon()
		return nil
	case appgoodlabel.FieldIconBgColor:
		m.ClearIconBgColor()
		return nil
	case appgoodlabel.FieldLabel:
		m.ClearLabel()
		return nil
	case appgoodlabel.FieldLabelBgColor:
		m.ClearLabelBgColor()
		return nil
	case appgoodlabel.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodLabel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodLabelMutation) ResetField(name string) error {
	switch name {
	case appgoodlabel.FieldEntID:
		m.ResetEntID()
		return nil
	case appgoodlabel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgoodlabel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgoodlabel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgoodlabel.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appgoodlabel.FieldIcon:
		m.ResetIcon()
		return nil
	case appgoodlabel.FieldIconBgColor:
		m.ResetIconBgColor()
		return nil
	case appgoodlabel.FieldLabel:
		m.ResetLabel()
		return nil
	case appgoodlabel.FieldLabelBgColor:
		m.ResetLabelBgColor()
		return nil
	case appgoodlabel.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodLabel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodLabelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodLabelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodLabelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodLabelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodLabelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodLabelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodLabelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGoodLabel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodLabelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGoodLabel edge %s", name)
}

// AppGoodPosterMutation represents an operation that mutates the AppGoodPoster nodes in the graph.
type AppGoodPosterMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_good_id   *uuid.UUID
	poster        *string
	index         *uint8
	addindex      *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppGoodPoster, error)
	predicates    []predicate.AppGoodPoster
}

var _ ent.Mutation = (*AppGoodPosterMutation)(nil)

// appgoodposterOption allows management of the mutation configuration using functional options.
type appgoodposterOption func(*AppGoodPosterMutation)

// newAppGoodPosterMutation creates new mutation for the AppGoodPoster entity.
func newAppGoodPosterMutation(c config, op Op, opts ...appgoodposterOption) *AppGoodPosterMutation {
	m := &AppGoodPosterMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGoodPoster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodPosterID sets the ID field of the mutation.
func withAppGoodPosterID(id uint32) appgoodposterOption {
	return func(m *AppGoodPosterMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGoodPoster
		)
		m.oldValue = func(ctx context.Context) (*AppGoodPoster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGoodPoster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGoodPoster sets the old AppGoodPoster of the mutation.
func withAppGoodPoster(node *AppGoodPoster) appgoodposterOption {
	return func(m *AppGoodPosterMutation) {
		m.oldValue = func(context.Context) (*AppGoodPoster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodPosterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodPosterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGoodPoster entities.
func (m *AppGoodPosterMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodPosterMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodPosterMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGoodPoster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppGoodPosterMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppGoodPosterMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppGoodPoster entity.
// If the AppGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodPosterMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppGoodPosterMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodPosterMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodPosterMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGoodPoster entity.
// If the AppGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodPosterMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodPosterMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodPosterMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodPosterMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodPosterMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodPosterMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGoodPoster entity.
// If the AppGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodPosterMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodPosterMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodPosterMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodPosterMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodPosterMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodPosterMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGoodPoster entity.
// If the AppGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodPosterMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodPosterMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodPosterMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodPosterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppGoodPosterMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppGoodPosterMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppGoodPoster entity.
// If the AppGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodPosterMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppGoodPosterMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appgoodposter.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppGoodPosterMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appgoodposter.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppGoodPosterMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appgoodposter.FieldAppGoodID)
}

// SetPoster sets the "poster" field.
func (m *AppGoodPosterMutation) SetPoster(s string) {
	m.poster = &s
}

// Poster returns the value of the "poster" field in the mutation.
func (m *AppGoodPosterMutation) Poster() (r string, exists bool) {
	v := m.poster
	if v == nil {
		return
	}
	return *v, true
}

// OldPoster returns the old "poster" field's value of the AppGoodPoster entity.
// If the AppGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodPosterMutation) OldPoster(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoster: %w", err)
	}
	return oldValue.Poster, nil
}

// ClearPoster clears the value of the "poster" field.
func (m *AppGoodPosterMutation) ClearPoster() {
	m.poster = nil
	m.clearedFields[appgoodposter.FieldPoster] = struct{}{}
}

// PosterCleared returns if the "poster" field was cleared in this mutation.
func (m *AppGoodPosterMutation) PosterCleared() bool {
	_, ok := m.clearedFields[appgoodposter.FieldPoster]
	return ok
}

// ResetPoster resets all changes to the "poster" field.
func (m *AppGoodPosterMutation) ResetPoster() {
	m.poster = nil
	delete(m.clearedFields, appgoodposter.FieldPoster)
}

// SetIndex sets the "index" field.
func (m *AppGoodPosterMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *AppGoodPosterMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the AppGoodPoster entity.
// If the AppGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodPosterMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *AppGoodPosterMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *AppGoodPosterMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *AppGoodPosterMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[appgoodposter.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *AppGoodPosterMutation) IndexCleared() bool {
	_, ok := m.clearedFields[appgoodposter.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *AppGoodPosterMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, appgoodposter.FieldIndex)
}

// Where appends a list predicates to the AppGoodPosterMutation builder.
func (m *AppGoodPosterMutation) Where(ps ...predicate.AppGoodPoster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppGoodPosterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppGoodPosterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppGoodPoster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppGoodPosterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppGoodPosterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppGoodPoster).
func (m *AppGoodPosterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodPosterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, appgoodposter.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appgoodposter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgoodposter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgoodposter.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appgoodposter.FieldAppGoodID)
	}
	if m.poster != nil {
		fields = append(fields, appgoodposter.FieldPoster)
	}
	if m.index != nil {
		fields = append(fields, appgoodposter.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodPosterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgoodposter.FieldEntID:
		return m.EntID()
	case appgoodposter.FieldCreatedAt:
		return m.CreatedAt()
	case appgoodposter.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgoodposter.FieldDeletedAt:
		return m.DeletedAt()
	case appgoodposter.FieldAppGoodID:
		return m.AppGoodID()
	case appgoodposter.FieldPoster:
		return m.Poster()
	case appgoodposter.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodPosterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgoodposter.FieldEntID:
		return m.OldEntID(ctx)
	case appgoodposter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgoodposter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgoodposter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgoodposter.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appgoodposter.FieldPoster:
		return m.OldPoster(ctx)
	case appgoodposter.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown AppGoodPoster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodPosterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgoodposter.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appgoodposter.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgoodposter.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgoodposter.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgoodposter.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appgoodposter.FieldPoster:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoster(v)
		return nil
	case appgoodposter.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodPoster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodPosterMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgoodposter.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgoodposter.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgoodposter.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, appgoodposter.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodPosterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgoodposter.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgoodposter.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgoodposter.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgoodposter.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodPosterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgoodposter.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgoodposter.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgoodposter.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgoodposter.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AppGoodPoster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodPosterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgoodposter.FieldAppGoodID) {
		fields = append(fields, appgoodposter.FieldAppGoodID)
	}
	if m.FieldCleared(appgoodposter.FieldPoster) {
		fields = append(fields, appgoodposter.FieldPoster)
	}
	if m.FieldCleared(appgoodposter.FieldIndex) {
		fields = append(fields, appgoodposter.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodPosterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodPosterMutation) ClearField(name string) error {
	switch name {
	case appgoodposter.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appgoodposter.FieldPoster:
		m.ClearPoster()
		return nil
	case appgoodposter.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodPoster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodPosterMutation) ResetField(name string) error {
	switch name {
	case appgoodposter.FieldEntID:
		m.ResetEntID()
		return nil
	case appgoodposter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgoodposter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgoodposter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgoodposter.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appgoodposter.FieldPoster:
		m.ResetPoster()
		return nil
	case appgoodposter.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown AppGoodPoster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodPosterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodPosterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodPosterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodPosterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodPosterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodPosterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodPosterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGoodPoster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodPosterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGoodPoster edge %s", name)
}

// AppLegacyPowerRentalMutation represents an operation that mutates the AppLegacyPowerRental nodes in the graph.
type AppLegacyPowerRentalMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint32
	ent_id              *uuid.UUID
	created_at          *uint32
	addcreated_at       *int32
	updated_at          *uint32
	addupdated_at       *int32
	deleted_at          *uint32
	adddeleted_at       *int32
	app_good_id         *uuid.UUID
	technique_fee_ratio *decimal.Decimal
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*AppLegacyPowerRental, error)
	predicates          []predicate.AppLegacyPowerRental
}

var _ ent.Mutation = (*AppLegacyPowerRentalMutation)(nil)

// applegacypowerrentalOption allows management of the mutation configuration using functional options.
type applegacypowerrentalOption func(*AppLegacyPowerRentalMutation)

// newAppLegacyPowerRentalMutation creates new mutation for the AppLegacyPowerRental entity.
func newAppLegacyPowerRentalMutation(c config, op Op, opts ...applegacypowerrentalOption) *AppLegacyPowerRentalMutation {
	m := &AppLegacyPowerRentalMutation{
		config:        c,
		op:            op,
		typ:           TypeAppLegacyPowerRental,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppLegacyPowerRentalID sets the ID field of the mutation.
func withAppLegacyPowerRentalID(id uint32) applegacypowerrentalOption {
	return func(m *AppLegacyPowerRentalMutation) {
		var (
			err   error
			once  sync.Once
			value *AppLegacyPowerRental
		)
		m.oldValue = func(ctx context.Context) (*AppLegacyPowerRental, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppLegacyPowerRental.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppLegacyPowerRental sets the old AppLegacyPowerRental of the mutation.
func withAppLegacyPowerRental(node *AppLegacyPowerRental) applegacypowerrentalOption {
	return func(m *AppLegacyPowerRentalMutation) {
		m.oldValue = func(context.Context) (*AppLegacyPowerRental, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppLegacyPowerRentalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppLegacyPowerRentalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppLegacyPowerRental entities.
func (m *AppLegacyPowerRentalMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppLegacyPowerRentalMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppLegacyPowerRentalMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppLegacyPowerRental.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppLegacyPowerRentalMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppLegacyPowerRentalMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppLegacyPowerRental entity.
// If the AppLegacyPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppLegacyPowerRentalMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppLegacyPowerRentalMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppLegacyPowerRentalMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppLegacyPowerRentalMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppLegacyPowerRental entity.
// If the AppLegacyPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppLegacyPowerRentalMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppLegacyPowerRentalMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppLegacyPowerRentalMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppLegacyPowerRentalMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppLegacyPowerRentalMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppLegacyPowerRentalMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppLegacyPowerRental entity.
// If the AppLegacyPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppLegacyPowerRentalMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppLegacyPowerRentalMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppLegacyPowerRentalMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppLegacyPowerRentalMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppLegacyPowerRentalMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppLegacyPowerRentalMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppLegacyPowerRental entity.
// If the AppLegacyPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppLegacyPowerRentalMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppLegacyPowerRentalMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppLegacyPowerRentalMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppLegacyPowerRentalMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppLegacyPowerRentalMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppLegacyPowerRentalMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppLegacyPowerRental entity.
// If the AppLegacyPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppLegacyPowerRentalMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppLegacyPowerRentalMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[applegacypowerrental.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppLegacyPowerRentalMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[applegacypowerrental.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppLegacyPowerRentalMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, applegacypowerrental.FieldAppGoodID)
}

// SetTechniqueFeeRatio sets the "technique_fee_ratio" field.
func (m *AppLegacyPowerRentalMutation) SetTechniqueFeeRatio(d decimal.Decimal) {
	m.technique_fee_ratio = &d
}

// TechniqueFeeRatio returns the value of the "technique_fee_ratio" field in the mutation.
func (m *AppLegacyPowerRentalMutation) TechniqueFeeRatio() (r decimal.Decimal, exists bool) {
	v := m.technique_fee_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldTechniqueFeeRatio returns the old "technique_fee_ratio" field's value of the AppLegacyPowerRental entity.
// If the AppLegacyPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppLegacyPowerRentalMutation) OldTechniqueFeeRatio(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechniqueFeeRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechniqueFeeRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechniqueFeeRatio: %w", err)
	}
	return oldValue.TechniqueFeeRatio, nil
}

// ClearTechniqueFeeRatio clears the value of the "technique_fee_ratio" field.
func (m *AppLegacyPowerRentalMutation) ClearTechniqueFeeRatio() {
	m.technique_fee_ratio = nil
	m.clearedFields[applegacypowerrental.FieldTechniqueFeeRatio] = struct{}{}
}

// TechniqueFeeRatioCleared returns if the "technique_fee_ratio" field was cleared in this mutation.
func (m *AppLegacyPowerRentalMutation) TechniqueFeeRatioCleared() bool {
	_, ok := m.clearedFields[applegacypowerrental.FieldTechniqueFeeRatio]
	return ok
}

// ResetTechniqueFeeRatio resets all changes to the "technique_fee_ratio" field.
func (m *AppLegacyPowerRentalMutation) ResetTechniqueFeeRatio() {
	m.technique_fee_ratio = nil
	delete(m.clearedFields, applegacypowerrental.FieldTechniqueFeeRatio)
}

// Where appends a list predicates to the AppLegacyPowerRentalMutation builder.
func (m *AppLegacyPowerRentalMutation) Where(ps ...predicate.AppLegacyPowerRental) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppLegacyPowerRentalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppLegacyPowerRentalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppLegacyPowerRental, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppLegacyPowerRentalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppLegacyPowerRentalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppLegacyPowerRental).
func (m *AppLegacyPowerRentalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppLegacyPowerRentalMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.ent_id != nil {
		fields = append(fields, applegacypowerrental.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, applegacypowerrental.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, applegacypowerrental.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, applegacypowerrental.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, applegacypowerrental.FieldAppGoodID)
	}
	if m.technique_fee_ratio != nil {
		fields = append(fields, applegacypowerrental.FieldTechniqueFeeRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppLegacyPowerRentalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case applegacypowerrental.FieldEntID:
		return m.EntID()
	case applegacypowerrental.FieldCreatedAt:
		return m.CreatedAt()
	case applegacypowerrental.FieldUpdatedAt:
		return m.UpdatedAt()
	case applegacypowerrental.FieldDeletedAt:
		return m.DeletedAt()
	case applegacypowerrental.FieldAppGoodID:
		return m.AppGoodID()
	case applegacypowerrental.FieldTechniqueFeeRatio:
		return m.TechniqueFeeRatio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppLegacyPowerRentalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case applegacypowerrental.FieldEntID:
		return m.OldEntID(ctx)
	case applegacypowerrental.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case applegacypowerrental.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case applegacypowerrental.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case applegacypowerrental.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case applegacypowerrental.FieldTechniqueFeeRatio:
		return m.OldTechniqueFeeRatio(ctx)
	}
	return nil, fmt.Errorf("unknown AppLegacyPowerRental field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppLegacyPowerRentalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case applegacypowerrental.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case applegacypowerrental.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case applegacypowerrental.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case applegacypowerrental.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case applegacypowerrental.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case applegacypowerrental.FieldTechniqueFeeRatio:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechniqueFeeRatio(v)
		return nil
	}
	return fmt.Errorf("unknown AppLegacyPowerRental field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppLegacyPowerRentalMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, applegacypowerrental.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, applegacypowerrental.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, applegacypowerrental.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppLegacyPowerRentalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case applegacypowerrental.FieldCreatedAt:
		return m.AddedCreatedAt()
	case applegacypowerrental.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case applegacypowerrental.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppLegacyPowerRentalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case applegacypowerrental.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case applegacypowerrental.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case applegacypowerrental.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppLegacyPowerRental numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppLegacyPowerRentalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(applegacypowerrental.FieldAppGoodID) {
		fields = append(fields, applegacypowerrental.FieldAppGoodID)
	}
	if m.FieldCleared(applegacypowerrental.FieldTechniqueFeeRatio) {
		fields = append(fields, applegacypowerrental.FieldTechniqueFeeRatio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppLegacyPowerRentalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppLegacyPowerRentalMutation) ClearField(name string) error {
	switch name {
	case applegacypowerrental.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case applegacypowerrental.FieldTechniqueFeeRatio:
		m.ClearTechniqueFeeRatio()
		return nil
	}
	return fmt.Errorf("unknown AppLegacyPowerRental nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppLegacyPowerRentalMutation) ResetField(name string) error {
	switch name {
	case applegacypowerrental.FieldEntID:
		m.ResetEntID()
		return nil
	case applegacypowerrental.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case applegacypowerrental.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case applegacypowerrental.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case applegacypowerrental.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case applegacypowerrental.FieldTechniqueFeeRatio:
		m.ResetTechniqueFeeRatio()
		return nil
	}
	return fmt.Errorf("unknown AppLegacyPowerRental field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppLegacyPowerRentalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppLegacyPowerRentalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppLegacyPowerRentalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppLegacyPowerRentalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppLegacyPowerRentalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppLegacyPowerRentalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppLegacyPowerRentalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppLegacyPowerRental unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppLegacyPowerRentalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppLegacyPowerRental edge %s", name)
}

// AppMiningGoodStockMutation represents an operation that mutates the AppMiningGoodStock nodes in the graph.
type AppMiningGoodStockMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	ent_id               *uuid.UUID
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	app_good_stock_id    *uuid.UUID
	mining_good_stock_id *uuid.UUID
	reserved             *decimal.Decimal
	spot_quantity        *decimal.Decimal
	locked               *decimal.Decimal
	in_service           *decimal.Decimal
	wait_start           *decimal.Decimal
	sold                 *decimal.Decimal
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AppMiningGoodStock, error)
	predicates           []predicate.AppMiningGoodStock
}

var _ ent.Mutation = (*AppMiningGoodStockMutation)(nil)

// appmininggoodstockOption allows management of the mutation configuration using functional options.
type appmininggoodstockOption func(*AppMiningGoodStockMutation)

// newAppMiningGoodStockMutation creates new mutation for the AppMiningGoodStock entity.
func newAppMiningGoodStockMutation(c config, op Op, opts ...appmininggoodstockOption) *AppMiningGoodStockMutation {
	m := &AppMiningGoodStockMutation{
		config:        c,
		op:            op,
		typ:           TypeAppMiningGoodStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppMiningGoodStockID sets the ID field of the mutation.
func withAppMiningGoodStockID(id uint32) appmininggoodstockOption {
	return func(m *AppMiningGoodStockMutation) {
		var (
			err   error
			once  sync.Once
			value *AppMiningGoodStock
		)
		m.oldValue = func(ctx context.Context) (*AppMiningGoodStock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppMiningGoodStock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppMiningGoodStock sets the old AppMiningGoodStock of the mutation.
func withAppMiningGoodStock(node *AppMiningGoodStock) appmininggoodstockOption {
	return func(m *AppMiningGoodStockMutation) {
		m.oldValue = func(context.Context) (*AppMiningGoodStock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMiningGoodStockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMiningGoodStockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppMiningGoodStock entities.
func (m *AppMiningGoodStockMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMiningGoodStockMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMiningGoodStockMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppMiningGoodStock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppMiningGoodStockMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppMiningGoodStockMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppMiningGoodStockMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMiningGoodStockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMiningGoodStockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppMiningGoodStockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppMiningGoodStockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMiningGoodStockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMiningGoodStockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMiningGoodStockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppMiningGoodStockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppMiningGoodStockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMiningGoodStockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppMiningGoodStockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppMiningGoodStockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppMiningGoodStockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppMiningGoodStockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppMiningGoodStockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodStockID sets the "app_good_stock_id" field.
func (m *AppMiningGoodStockMutation) SetAppGoodStockID(u uuid.UUID) {
	m.app_good_stock_id = &u
}

// AppGoodStockID returns the value of the "app_good_stock_id" field in the mutation.
func (m *AppMiningGoodStockMutation) AppGoodStockID() (r uuid.UUID, exists bool) {
	v := m.app_good_stock_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodStockID returns the old "app_good_stock_id" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldAppGoodStockID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodStockID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodStockID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodStockID: %w", err)
	}
	return oldValue.AppGoodStockID, nil
}

// ClearAppGoodStockID clears the value of the "app_good_stock_id" field.
func (m *AppMiningGoodStockMutation) ClearAppGoodStockID() {
	m.app_good_stock_id = nil
	m.clearedFields[appmininggoodstock.FieldAppGoodStockID] = struct{}{}
}

// AppGoodStockIDCleared returns if the "app_good_stock_id" field was cleared in this mutation.
func (m *AppMiningGoodStockMutation) AppGoodStockIDCleared() bool {
	_, ok := m.clearedFields[appmininggoodstock.FieldAppGoodStockID]
	return ok
}

// ResetAppGoodStockID resets all changes to the "app_good_stock_id" field.
func (m *AppMiningGoodStockMutation) ResetAppGoodStockID() {
	m.app_good_stock_id = nil
	delete(m.clearedFields, appmininggoodstock.FieldAppGoodStockID)
}

// SetMiningGoodStockID sets the "mining_good_stock_id" field.
func (m *AppMiningGoodStockMutation) SetMiningGoodStockID(u uuid.UUID) {
	m.mining_good_stock_id = &u
}

// MiningGoodStockID returns the value of the "mining_good_stock_id" field in the mutation.
func (m *AppMiningGoodStockMutation) MiningGoodStockID() (r uuid.UUID, exists bool) {
	v := m.mining_good_stock_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMiningGoodStockID returns the old "mining_good_stock_id" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldMiningGoodStockID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiningGoodStockID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiningGoodStockID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiningGoodStockID: %w", err)
	}
	return oldValue.MiningGoodStockID, nil
}

// ClearMiningGoodStockID clears the value of the "mining_good_stock_id" field.
func (m *AppMiningGoodStockMutation) ClearMiningGoodStockID() {
	m.mining_good_stock_id = nil
	m.clearedFields[appmininggoodstock.FieldMiningGoodStockID] = struct{}{}
}

// MiningGoodStockIDCleared returns if the "mining_good_stock_id" field was cleared in this mutation.
func (m *AppMiningGoodStockMutation) MiningGoodStockIDCleared() bool {
	_, ok := m.clearedFields[appmininggoodstock.FieldMiningGoodStockID]
	return ok
}

// ResetMiningGoodStockID resets all changes to the "mining_good_stock_id" field.
func (m *AppMiningGoodStockMutation) ResetMiningGoodStockID() {
	m.mining_good_stock_id = nil
	delete(m.clearedFields, appmininggoodstock.FieldMiningGoodStockID)
}

// SetReserved sets the "reserved" field.
func (m *AppMiningGoodStockMutation) SetReserved(d decimal.Decimal) {
	m.reserved = &d
}

// Reserved returns the value of the "reserved" field in the mutation.
func (m *AppMiningGoodStockMutation) Reserved() (r decimal.Decimal, exists bool) {
	v := m.reserved
	if v == nil {
		return
	}
	return *v, true
}

// OldReserved returns the old "reserved" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldReserved(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReserved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReserved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserved: %w", err)
	}
	return oldValue.Reserved, nil
}

// ClearReserved clears the value of the "reserved" field.
func (m *AppMiningGoodStockMutation) ClearReserved() {
	m.reserved = nil
	m.clearedFields[appmininggoodstock.FieldReserved] = struct{}{}
}

// ReservedCleared returns if the "reserved" field was cleared in this mutation.
func (m *AppMiningGoodStockMutation) ReservedCleared() bool {
	_, ok := m.clearedFields[appmininggoodstock.FieldReserved]
	return ok
}

// ResetReserved resets all changes to the "reserved" field.
func (m *AppMiningGoodStockMutation) ResetReserved() {
	m.reserved = nil
	delete(m.clearedFields, appmininggoodstock.FieldReserved)
}

// SetSpotQuantity sets the "spot_quantity" field.
func (m *AppMiningGoodStockMutation) SetSpotQuantity(d decimal.Decimal) {
	m.spot_quantity = &d
}

// SpotQuantity returns the value of the "spot_quantity" field in the mutation.
func (m *AppMiningGoodStockMutation) SpotQuantity() (r decimal.Decimal, exists bool) {
	v := m.spot_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotQuantity returns the old "spot_quantity" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldSpotQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotQuantity: %w", err)
	}
	return oldValue.SpotQuantity, nil
}

// ClearSpotQuantity clears the value of the "spot_quantity" field.
func (m *AppMiningGoodStockMutation) ClearSpotQuantity() {
	m.spot_quantity = nil
	m.clearedFields[appmininggoodstock.FieldSpotQuantity] = struct{}{}
}

// SpotQuantityCleared returns if the "spot_quantity" field was cleared in this mutation.
func (m *AppMiningGoodStockMutation) SpotQuantityCleared() bool {
	_, ok := m.clearedFields[appmininggoodstock.FieldSpotQuantity]
	return ok
}

// ResetSpotQuantity resets all changes to the "spot_quantity" field.
func (m *AppMiningGoodStockMutation) ResetSpotQuantity() {
	m.spot_quantity = nil
	delete(m.clearedFields, appmininggoodstock.FieldSpotQuantity)
}

// SetLocked sets the "locked" field.
func (m *AppMiningGoodStockMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
}

// Locked returns the value of the "locked" field in the mutation.
func (m *AppMiningGoodStockMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ClearLocked clears the value of the "locked" field.
func (m *AppMiningGoodStockMutation) ClearLocked() {
	m.locked = nil
	m.clearedFields[appmininggoodstock.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *AppMiningGoodStockMutation) LockedCleared() bool {
	_, ok := m.clearedFields[appmininggoodstock.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *AppMiningGoodStockMutation) ResetLocked() {
	m.locked = nil
	delete(m.clearedFields, appmininggoodstock.FieldLocked)
}

// SetInService sets the "in_service" field.
func (m *AppMiningGoodStockMutation) SetInService(d decimal.Decimal) {
	m.in_service = &d
}

// InService returns the value of the "in_service" field in the mutation.
func (m *AppMiningGoodStockMutation) InService() (r decimal.Decimal, exists bool) {
	v := m.in_service
	if v == nil {
		return
	}
	return *v, true
}

// OldInService returns the old "in_service" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldInService(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInService: %w", err)
	}
	return oldValue.InService, nil
}

// ClearInService clears the value of the "in_service" field.
func (m *AppMiningGoodStockMutation) ClearInService() {
	m.in_service = nil
	m.clearedFields[appmininggoodstock.FieldInService] = struct{}{}
}

// InServiceCleared returns if the "in_service" field was cleared in this mutation.
func (m *AppMiningGoodStockMutation) InServiceCleared() bool {
	_, ok := m.clearedFields[appmininggoodstock.FieldInService]
	return ok
}

// ResetInService resets all changes to the "in_service" field.
func (m *AppMiningGoodStockMutation) ResetInService() {
	m.in_service = nil
	delete(m.clearedFields, appmininggoodstock.FieldInService)
}

// SetWaitStart sets the "wait_start" field.
func (m *AppMiningGoodStockMutation) SetWaitStart(d decimal.Decimal) {
	m.wait_start = &d
}

// WaitStart returns the value of the "wait_start" field in the mutation.
func (m *AppMiningGoodStockMutation) WaitStart() (r decimal.Decimal, exists bool) {
	v := m.wait_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWaitStart returns the old "wait_start" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldWaitStart(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaitStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaitStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaitStart: %w", err)
	}
	return oldValue.WaitStart, nil
}

// ClearWaitStart clears the value of the "wait_start" field.
func (m *AppMiningGoodStockMutation) ClearWaitStart() {
	m.wait_start = nil
	m.clearedFields[appmininggoodstock.FieldWaitStart] = struct{}{}
}

// WaitStartCleared returns if the "wait_start" field was cleared in this mutation.
func (m *AppMiningGoodStockMutation) WaitStartCleared() bool {
	_, ok := m.clearedFields[appmininggoodstock.FieldWaitStart]
	return ok
}

// ResetWaitStart resets all changes to the "wait_start" field.
func (m *AppMiningGoodStockMutation) ResetWaitStart() {
	m.wait_start = nil
	delete(m.clearedFields, appmininggoodstock.FieldWaitStart)
}

// SetSold sets the "sold" field.
func (m *AppMiningGoodStockMutation) SetSold(d decimal.Decimal) {
	m.sold = &d
}

// Sold returns the value of the "sold" field in the mutation.
func (m *AppMiningGoodStockMutation) Sold() (r decimal.Decimal, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the AppMiningGoodStock entity.
// If the AppMiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMiningGoodStockMutation) OldSold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// ClearSold clears the value of the "sold" field.
func (m *AppMiningGoodStockMutation) ClearSold() {
	m.sold = nil
	m.clearedFields[appmininggoodstock.FieldSold] = struct{}{}
}

// SoldCleared returns if the "sold" field was cleared in this mutation.
func (m *AppMiningGoodStockMutation) SoldCleared() bool {
	_, ok := m.clearedFields[appmininggoodstock.FieldSold]
	return ok
}

// ResetSold resets all changes to the "sold" field.
func (m *AppMiningGoodStockMutation) ResetSold() {
	m.sold = nil
	delete(m.clearedFields, appmininggoodstock.FieldSold)
}

// Where appends a list predicates to the AppMiningGoodStockMutation builder.
func (m *AppMiningGoodStockMutation) Where(ps ...predicate.AppMiningGoodStock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMiningGoodStockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMiningGoodStockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppMiningGoodStock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMiningGoodStockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMiningGoodStockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppMiningGoodStock).
func (m *AppMiningGoodStockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMiningGoodStockMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.ent_id != nil {
		fields = append(fields, appmininggoodstock.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appmininggoodstock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appmininggoodstock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appmininggoodstock.FieldDeletedAt)
	}
	if m.app_good_stock_id != nil {
		fields = append(fields, appmininggoodstock.FieldAppGoodStockID)
	}
	if m.mining_good_stock_id != nil {
		fields = append(fields, appmininggoodstock.FieldMiningGoodStockID)
	}
	if m.reserved != nil {
		fields = append(fields, appmininggoodstock.FieldReserved)
	}
	if m.spot_quantity != nil {
		fields = append(fields, appmininggoodstock.FieldSpotQuantity)
	}
	if m.locked != nil {
		fields = append(fields, appmininggoodstock.FieldLocked)
	}
	if m.in_service != nil {
		fields = append(fields, appmininggoodstock.FieldInService)
	}
	if m.wait_start != nil {
		fields = append(fields, appmininggoodstock.FieldWaitStart)
	}
	if m.sold != nil {
		fields = append(fields, appmininggoodstock.FieldSold)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMiningGoodStockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appmininggoodstock.FieldEntID:
		return m.EntID()
	case appmininggoodstock.FieldCreatedAt:
		return m.CreatedAt()
	case appmininggoodstock.FieldUpdatedAt:
		return m.UpdatedAt()
	case appmininggoodstock.FieldDeletedAt:
		return m.DeletedAt()
	case appmininggoodstock.FieldAppGoodStockID:
		return m.AppGoodStockID()
	case appmininggoodstock.FieldMiningGoodStockID:
		return m.MiningGoodStockID()
	case appmininggoodstock.FieldReserved:
		return m.Reserved()
	case appmininggoodstock.FieldSpotQuantity:
		return m.SpotQuantity()
	case appmininggoodstock.FieldLocked:
		return m.Locked()
	case appmininggoodstock.FieldInService:
		return m.InService()
	case appmininggoodstock.FieldWaitStart:
		return m.WaitStart()
	case appmininggoodstock.FieldSold:
		return m.Sold()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMiningGoodStockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appmininggoodstock.FieldEntID:
		return m.OldEntID(ctx)
	case appmininggoodstock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appmininggoodstock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appmininggoodstock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appmininggoodstock.FieldAppGoodStockID:
		return m.OldAppGoodStockID(ctx)
	case appmininggoodstock.FieldMiningGoodStockID:
		return m.OldMiningGoodStockID(ctx)
	case appmininggoodstock.FieldReserved:
		return m.OldReserved(ctx)
	case appmininggoodstock.FieldSpotQuantity:
		return m.OldSpotQuantity(ctx)
	case appmininggoodstock.FieldLocked:
		return m.OldLocked(ctx)
	case appmininggoodstock.FieldInService:
		return m.OldInService(ctx)
	case appmininggoodstock.FieldWaitStart:
		return m.OldWaitStart(ctx)
	case appmininggoodstock.FieldSold:
		return m.OldSold(ctx)
	}
	return nil, fmt.Errorf("unknown AppMiningGoodStock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMiningGoodStockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appmininggoodstock.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appmininggoodstock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appmininggoodstock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appmininggoodstock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appmininggoodstock.FieldAppGoodStockID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodStockID(v)
		return nil
	case appmininggoodstock.FieldMiningGoodStockID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiningGoodStockID(v)
		return nil
	case appmininggoodstock.FieldReserved:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserved(v)
		return nil
	case appmininggoodstock.FieldSpotQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotQuantity(v)
		return nil
	case appmininggoodstock.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case appmininggoodstock.FieldInService:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInService(v)
		return nil
	case appmininggoodstock.FieldWaitStart:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaitStart(v)
		return nil
	case appmininggoodstock.FieldSold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	}
	return fmt.Errorf("unknown AppMiningGoodStock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMiningGoodStockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appmininggoodstock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appmininggoodstock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appmininggoodstock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMiningGoodStockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appmininggoodstock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appmininggoodstock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appmininggoodstock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMiningGoodStockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appmininggoodstock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appmininggoodstock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appmininggoodstock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppMiningGoodStock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMiningGoodStockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appmininggoodstock.FieldAppGoodStockID) {
		fields = append(fields, appmininggoodstock.FieldAppGoodStockID)
	}
	if m.FieldCleared(appmininggoodstock.FieldMiningGoodStockID) {
		fields = append(fields, appmininggoodstock.FieldMiningGoodStockID)
	}
	if m.FieldCleared(appmininggoodstock.FieldReserved) {
		fields = append(fields, appmininggoodstock.FieldReserved)
	}
	if m.FieldCleared(appmininggoodstock.FieldSpotQuantity) {
		fields = append(fields, appmininggoodstock.FieldSpotQuantity)
	}
	if m.FieldCleared(appmininggoodstock.FieldLocked) {
		fields = append(fields, appmininggoodstock.FieldLocked)
	}
	if m.FieldCleared(appmininggoodstock.FieldInService) {
		fields = append(fields, appmininggoodstock.FieldInService)
	}
	if m.FieldCleared(appmininggoodstock.FieldWaitStart) {
		fields = append(fields, appmininggoodstock.FieldWaitStart)
	}
	if m.FieldCleared(appmininggoodstock.FieldSold) {
		fields = append(fields, appmininggoodstock.FieldSold)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMiningGoodStockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMiningGoodStockMutation) ClearField(name string) error {
	switch name {
	case appmininggoodstock.FieldAppGoodStockID:
		m.ClearAppGoodStockID()
		return nil
	case appmininggoodstock.FieldMiningGoodStockID:
		m.ClearMiningGoodStockID()
		return nil
	case appmininggoodstock.FieldReserved:
		m.ClearReserved()
		return nil
	case appmininggoodstock.FieldSpotQuantity:
		m.ClearSpotQuantity()
		return nil
	case appmininggoodstock.FieldLocked:
		m.ClearLocked()
		return nil
	case appmininggoodstock.FieldInService:
		m.ClearInService()
		return nil
	case appmininggoodstock.FieldWaitStart:
		m.ClearWaitStart()
		return nil
	case appmininggoodstock.FieldSold:
		m.ClearSold()
		return nil
	}
	return fmt.Errorf("unknown AppMiningGoodStock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMiningGoodStockMutation) ResetField(name string) error {
	switch name {
	case appmininggoodstock.FieldEntID:
		m.ResetEntID()
		return nil
	case appmininggoodstock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appmininggoodstock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appmininggoodstock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appmininggoodstock.FieldAppGoodStockID:
		m.ResetAppGoodStockID()
		return nil
	case appmininggoodstock.FieldMiningGoodStockID:
		m.ResetMiningGoodStockID()
		return nil
	case appmininggoodstock.FieldReserved:
		m.ResetReserved()
		return nil
	case appmininggoodstock.FieldSpotQuantity:
		m.ResetSpotQuantity()
		return nil
	case appmininggoodstock.FieldLocked:
		m.ResetLocked()
		return nil
	case appmininggoodstock.FieldInService:
		m.ResetInService()
		return nil
	case appmininggoodstock.FieldWaitStart:
		m.ResetWaitStart()
		return nil
	case appmininggoodstock.FieldSold:
		m.ResetSold()
		return nil
	}
	return fmt.Errorf("unknown AppMiningGoodStock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMiningGoodStockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMiningGoodStockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMiningGoodStockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMiningGoodStockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMiningGoodStockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMiningGoodStockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMiningGoodStockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppMiningGoodStock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMiningGoodStockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppMiningGoodStock edge %s", name)
}

// AppPowerRentalMutation represents an operation that mutates the AppPowerRental nodes in the graph.
type AppPowerRentalMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uint32
	ent_id                             *uuid.UUID
	created_at                         *uint32
	addcreated_at                      *int32
	updated_at                         *uint32
	addupdated_at                      *int32
	deleted_at                         *uint32
	adddeleted_at                      *int32
	app_good_id                        *uuid.UUID
	service_start_at                   *uint32
	addservice_start_at                *int32
	start_mode                         *string
	cancel_mode                        *string
	cancelable_before_start_seconds    *uint32
	addcancelable_before_start_seconds *int32
	enable_set_commission              *bool
	min_order_amount                   *decimal.Decimal
	max_order_amount                   *decimal.Decimal
	max_user_amount                    *decimal.Decimal
	min_order_duration_seconds         *uint32
	addmin_order_duration_seconds      *int32
	max_order_duration_seconds         *uint32
	addmax_order_duration_seconds      *int32
	unit_price                         *decimal.Decimal
	sale_start_at                      *uint32
	addsale_start_at                   *int32
	sale_end_at                        *uint32
	addsale_end_at                     *int32
	sale_mode                          *string
	fixed_duration                     *bool
	package_with_requireds             *bool
	clearedFields                      map[string]struct{}
	done                               bool
	oldValue                           func(context.Context) (*AppPowerRental, error)
	predicates                         []predicate.AppPowerRental
}

var _ ent.Mutation = (*AppPowerRentalMutation)(nil)

// apppowerrentalOption allows management of the mutation configuration using functional options.
type apppowerrentalOption func(*AppPowerRentalMutation)

// newAppPowerRentalMutation creates new mutation for the AppPowerRental entity.
func newAppPowerRentalMutation(c config, op Op, opts ...apppowerrentalOption) *AppPowerRentalMutation {
	m := &AppPowerRentalMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPowerRental,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPowerRentalID sets the ID field of the mutation.
func withAppPowerRentalID(id uint32) apppowerrentalOption {
	return func(m *AppPowerRentalMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPowerRental
		)
		m.oldValue = func(ctx context.Context) (*AppPowerRental, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPowerRental.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPowerRental sets the old AppPowerRental of the mutation.
func withAppPowerRental(node *AppPowerRental) apppowerrentalOption {
	return func(m *AppPowerRentalMutation) {
		m.oldValue = func(context.Context) (*AppPowerRental, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPowerRentalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPowerRentalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPowerRental entities.
func (m *AppPowerRentalMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPowerRentalMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPowerRentalMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPowerRental.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppPowerRentalMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppPowerRentalMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppPowerRentalMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPowerRentalMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPowerRentalMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppPowerRentalMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppPowerRentalMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPowerRentalMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPowerRentalMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPowerRentalMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppPowerRentalMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppPowerRentalMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPowerRentalMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppPowerRentalMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppPowerRentalMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppPowerRentalMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppPowerRentalMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppPowerRentalMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppPowerRentalMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppPowerRentalMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppPowerRentalMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[apppowerrental.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppPowerRentalMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppPowerRentalMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, apppowerrental.FieldAppGoodID)
}

// SetServiceStartAt sets the "service_start_at" field.
func (m *AppPowerRentalMutation) SetServiceStartAt(u uint32) {
	m.service_start_at = &u
	m.addservice_start_at = nil
}

// ServiceStartAt returns the value of the "service_start_at" field in the mutation.
func (m *AppPowerRentalMutation) ServiceStartAt() (r uint32, exists bool) {
	v := m.service_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceStartAt returns the old "service_start_at" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldServiceStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceStartAt: %w", err)
	}
	return oldValue.ServiceStartAt, nil
}

// AddServiceStartAt adds u to the "service_start_at" field.
func (m *AppPowerRentalMutation) AddServiceStartAt(u int32) {
	if m.addservice_start_at != nil {
		*m.addservice_start_at += u
	} else {
		m.addservice_start_at = &u
	}
}

// AddedServiceStartAt returns the value that was added to the "service_start_at" field in this mutation.
func (m *AppPowerRentalMutation) AddedServiceStartAt() (r int32, exists bool) {
	v := m.addservice_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearServiceStartAt clears the value of the "service_start_at" field.
func (m *AppPowerRentalMutation) ClearServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	m.clearedFields[apppowerrental.FieldServiceStartAt] = struct{}{}
}

// ServiceStartAtCleared returns if the "service_start_at" field was cleared in this mutation.
func (m *AppPowerRentalMutation) ServiceStartAtCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldServiceStartAt]
	return ok
}

// ResetServiceStartAt resets all changes to the "service_start_at" field.
func (m *AppPowerRentalMutation) ResetServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	delete(m.clearedFields, apppowerrental.FieldServiceStartAt)
}

// SetStartMode sets the "start_mode" field.
func (m *AppPowerRentalMutation) SetStartMode(s string) {
	m.start_mode = &s
}

// StartMode returns the value of the "start_mode" field in the mutation.
func (m *AppPowerRentalMutation) StartMode() (r string, exists bool) {
	v := m.start_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStartMode returns the old "start_mode" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldStartMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartMode: %w", err)
	}
	return oldValue.StartMode, nil
}

// ClearStartMode clears the value of the "start_mode" field.
func (m *AppPowerRentalMutation) ClearStartMode() {
	m.start_mode = nil
	m.clearedFields[apppowerrental.FieldStartMode] = struct{}{}
}

// StartModeCleared returns if the "start_mode" field was cleared in this mutation.
func (m *AppPowerRentalMutation) StartModeCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldStartMode]
	return ok
}

// ResetStartMode resets all changes to the "start_mode" field.
func (m *AppPowerRentalMutation) ResetStartMode() {
	m.start_mode = nil
	delete(m.clearedFields, apppowerrental.FieldStartMode)
}

// SetCancelMode sets the "cancel_mode" field.
func (m *AppPowerRentalMutation) SetCancelMode(s string) {
	m.cancel_mode = &s
}

// CancelMode returns the value of the "cancel_mode" field in the mutation.
func (m *AppPowerRentalMutation) CancelMode() (r string, exists bool) {
	v := m.cancel_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelMode returns the old "cancel_mode" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldCancelMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelMode: %w", err)
	}
	return oldValue.CancelMode, nil
}

// ClearCancelMode clears the value of the "cancel_mode" field.
func (m *AppPowerRentalMutation) ClearCancelMode() {
	m.cancel_mode = nil
	m.clearedFields[apppowerrental.FieldCancelMode] = struct{}{}
}

// CancelModeCleared returns if the "cancel_mode" field was cleared in this mutation.
func (m *AppPowerRentalMutation) CancelModeCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldCancelMode]
	return ok
}

// ResetCancelMode resets all changes to the "cancel_mode" field.
func (m *AppPowerRentalMutation) ResetCancelMode() {
	m.cancel_mode = nil
	delete(m.clearedFields, apppowerrental.FieldCancelMode)
}

// SetCancelableBeforeStartSeconds sets the "cancelable_before_start_seconds" field.
func (m *AppPowerRentalMutation) SetCancelableBeforeStartSeconds(u uint32) {
	m.cancelable_before_start_seconds = &u
	m.addcancelable_before_start_seconds = nil
}

// CancelableBeforeStartSeconds returns the value of the "cancelable_before_start_seconds" field in the mutation.
func (m *AppPowerRentalMutation) CancelableBeforeStartSeconds() (r uint32, exists bool) {
	v := m.cancelable_before_start_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelableBeforeStartSeconds returns the old "cancelable_before_start_seconds" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldCancelableBeforeStartSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelableBeforeStartSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelableBeforeStartSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelableBeforeStartSeconds: %w", err)
	}
	return oldValue.CancelableBeforeStartSeconds, nil
}

// AddCancelableBeforeStartSeconds adds u to the "cancelable_before_start_seconds" field.
func (m *AppPowerRentalMutation) AddCancelableBeforeStartSeconds(u int32) {
	if m.addcancelable_before_start_seconds != nil {
		*m.addcancelable_before_start_seconds += u
	} else {
		m.addcancelable_before_start_seconds = &u
	}
}

// AddedCancelableBeforeStartSeconds returns the value that was added to the "cancelable_before_start_seconds" field in this mutation.
func (m *AppPowerRentalMutation) AddedCancelableBeforeStartSeconds() (r int32, exists bool) {
	v := m.addcancelable_before_start_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelableBeforeStartSeconds clears the value of the "cancelable_before_start_seconds" field.
func (m *AppPowerRentalMutation) ClearCancelableBeforeStartSeconds() {
	m.cancelable_before_start_seconds = nil
	m.addcancelable_before_start_seconds = nil
	m.clearedFields[apppowerrental.FieldCancelableBeforeStartSeconds] = struct{}{}
}

// CancelableBeforeStartSecondsCleared returns if the "cancelable_before_start_seconds" field was cleared in this mutation.
func (m *AppPowerRentalMutation) CancelableBeforeStartSecondsCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldCancelableBeforeStartSeconds]
	return ok
}

// ResetCancelableBeforeStartSeconds resets all changes to the "cancelable_before_start_seconds" field.
func (m *AppPowerRentalMutation) ResetCancelableBeforeStartSeconds() {
	m.cancelable_before_start_seconds = nil
	m.addcancelable_before_start_seconds = nil
	delete(m.clearedFields, apppowerrental.FieldCancelableBeforeStartSeconds)
}

// SetEnableSetCommission sets the "enable_set_commission" field.
func (m *AppPowerRentalMutation) SetEnableSetCommission(b bool) {
	m.enable_set_commission = &b
}

// EnableSetCommission returns the value of the "enable_set_commission" field in the mutation.
func (m *AppPowerRentalMutation) EnableSetCommission() (r bool, exists bool) {
	v := m.enable_set_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableSetCommission returns the old "enable_set_commission" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldEnableSetCommission(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableSetCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableSetCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableSetCommission: %w", err)
	}
	return oldValue.EnableSetCommission, nil
}

// ClearEnableSetCommission clears the value of the "enable_set_commission" field.
func (m *AppPowerRentalMutation) ClearEnableSetCommission() {
	m.enable_set_commission = nil
	m.clearedFields[apppowerrental.FieldEnableSetCommission] = struct{}{}
}

// EnableSetCommissionCleared returns if the "enable_set_commission" field was cleared in this mutation.
func (m *AppPowerRentalMutation) EnableSetCommissionCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldEnableSetCommission]
	return ok
}

// ResetEnableSetCommission resets all changes to the "enable_set_commission" field.
func (m *AppPowerRentalMutation) ResetEnableSetCommission() {
	m.enable_set_commission = nil
	delete(m.clearedFields, apppowerrental.FieldEnableSetCommission)
}

// SetMinOrderAmount sets the "min_order_amount" field.
func (m *AppPowerRentalMutation) SetMinOrderAmount(d decimal.Decimal) {
	m.min_order_amount = &d
}

// MinOrderAmount returns the value of the "min_order_amount" field in the mutation.
func (m *AppPowerRentalMutation) MinOrderAmount() (r decimal.Decimal, exists bool) {
	v := m.min_order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMinOrderAmount returns the old "min_order_amount" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldMinOrderAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinOrderAmount: %w", err)
	}
	return oldValue.MinOrderAmount, nil
}

// ClearMinOrderAmount clears the value of the "min_order_amount" field.
func (m *AppPowerRentalMutation) ClearMinOrderAmount() {
	m.min_order_amount = nil
	m.clearedFields[apppowerrental.FieldMinOrderAmount] = struct{}{}
}

// MinOrderAmountCleared returns if the "min_order_amount" field was cleared in this mutation.
func (m *AppPowerRentalMutation) MinOrderAmountCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldMinOrderAmount]
	return ok
}

// ResetMinOrderAmount resets all changes to the "min_order_amount" field.
func (m *AppPowerRentalMutation) ResetMinOrderAmount() {
	m.min_order_amount = nil
	delete(m.clearedFields, apppowerrental.FieldMinOrderAmount)
}

// SetMaxOrderAmount sets the "max_order_amount" field.
func (m *AppPowerRentalMutation) SetMaxOrderAmount(d decimal.Decimal) {
	m.max_order_amount = &d
}

// MaxOrderAmount returns the value of the "max_order_amount" field in the mutation.
func (m *AppPowerRentalMutation) MaxOrderAmount() (r decimal.Decimal, exists bool) {
	v := m.max_order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxOrderAmount returns the old "max_order_amount" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldMaxOrderAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxOrderAmount: %w", err)
	}
	return oldValue.MaxOrderAmount, nil
}

// ClearMaxOrderAmount clears the value of the "max_order_amount" field.
func (m *AppPowerRentalMutation) ClearMaxOrderAmount() {
	m.max_order_amount = nil
	m.clearedFields[apppowerrental.FieldMaxOrderAmount] = struct{}{}
}

// MaxOrderAmountCleared returns if the "max_order_amount" field was cleared in this mutation.
func (m *AppPowerRentalMutation) MaxOrderAmountCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldMaxOrderAmount]
	return ok
}

// ResetMaxOrderAmount resets all changes to the "max_order_amount" field.
func (m *AppPowerRentalMutation) ResetMaxOrderAmount() {
	m.max_order_amount = nil
	delete(m.clearedFields, apppowerrental.FieldMaxOrderAmount)
}

// SetMaxUserAmount sets the "max_user_amount" field.
func (m *AppPowerRentalMutation) SetMaxUserAmount(d decimal.Decimal) {
	m.max_user_amount = &d
}

// MaxUserAmount returns the value of the "max_user_amount" field in the mutation.
func (m *AppPowerRentalMutation) MaxUserAmount() (r decimal.Decimal, exists bool) {
	v := m.max_user_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUserAmount returns the old "max_user_amount" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldMaxUserAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUserAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUserAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUserAmount: %w", err)
	}
	return oldValue.MaxUserAmount, nil
}

// ClearMaxUserAmount clears the value of the "max_user_amount" field.
func (m *AppPowerRentalMutation) ClearMaxUserAmount() {
	m.max_user_amount = nil
	m.clearedFields[apppowerrental.FieldMaxUserAmount] = struct{}{}
}

// MaxUserAmountCleared returns if the "max_user_amount" field was cleared in this mutation.
func (m *AppPowerRentalMutation) MaxUserAmountCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldMaxUserAmount]
	return ok
}

// ResetMaxUserAmount resets all changes to the "max_user_amount" field.
func (m *AppPowerRentalMutation) ResetMaxUserAmount() {
	m.max_user_amount = nil
	delete(m.clearedFields, apppowerrental.FieldMaxUserAmount)
}

// SetMinOrderDurationSeconds sets the "min_order_duration_seconds" field.
func (m *AppPowerRentalMutation) SetMinOrderDurationSeconds(u uint32) {
	m.min_order_duration_seconds = &u
	m.addmin_order_duration_seconds = nil
}

// MinOrderDurationSeconds returns the value of the "min_order_duration_seconds" field in the mutation.
func (m *AppPowerRentalMutation) MinOrderDurationSeconds() (r uint32, exists bool) {
	v := m.min_order_duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldMinOrderDurationSeconds returns the old "min_order_duration_seconds" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldMinOrderDurationSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinOrderDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinOrderDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinOrderDurationSeconds: %w", err)
	}
	return oldValue.MinOrderDurationSeconds, nil
}

// AddMinOrderDurationSeconds adds u to the "min_order_duration_seconds" field.
func (m *AppPowerRentalMutation) AddMinOrderDurationSeconds(u int32) {
	if m.addmin_order_duration_seconds != nil {
		*m.addmin_order_duration_seconds += u
	} else {
		m.addmin_order_duration_seconds = &u
	}
}

// AddedMinOrderDurationSeconds returns the value that was added to the "min_order_duration_seconds" field in this mutation.
func (m *AppPowerRentalMutation) AddedMinOrderDurationSeconds() (r int32, exists bool) {
	v := m.addmin_order_duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinOrderDurationSeconds clears the value of the "min_order_duration_seconds" field.
func (m *AppPowerRentalMutation) ClearMinOrderDurationSeconds() {
	m.min_order_duration_seconds = nil
	m.addmin_order_duration_seconds = nil
	m.clearedFields[apppowerrental.FieldMinOrderDurationSeconds] = struct{}{}
}

// MinOrderDurationSecondsCleared returns if the "min_order_duration_seconds" field was cleared in this mutation.
func (m *AppPowerRentalMutation) MinOrderDurationSecondsCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldMinOrderDurationSeconds]
	return ok
}

// ResetMinOrderDurationSeconds resets all changes to the "min_order_duration_seconds" field.
func (m *AppPowerRentalMutation) ResetMinOrderDurationSeconds() {
	m.min_order_duration_seconds = nil
	m.addmin_order_duration_seconds = nil
	delete(m.clearedFields, apppowerrental.FieldMinOrderDurationSeconds)
}

// SetMaxOrderDurationSeconds sets the "max_order_duration_seconds" field.
func (m *AppPowerRentalMutation) SetMaxOrderDurationSeconds(u uint32) {
	m.max_order_duration_seconds = &u
	m.addmax_order_duration_seconds = nil
}

// MaxOrderDurationSeconds returns the value of the "max_order_duration_seconds" field in the mutation.
func (m *AppPowerRentalMutation) MaxOrderDurationSeconds() (r uint32, exists bool) {
	v := m.max_order_duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxOrderDurationSeconds returns the old "max_order_duration_seconds" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldMaxOrderDurationSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxOrderDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxOrderDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxOrderDurationSeconds: %w", err)
	}
	return oldValue.MaxOrderDurationSeconds, nil
}

// AddMaxOrderDurationSeconds adds u to the "max_order_duration_seconds" field.
func (m *AppPowerRentalMutation) AddMaxOrderDurationSeconds(u int32) {
	if m.addmax_order_duration_seconds != nil {
		*m.addmax_order_duration_seconds += u
	} else {
		m.addmax_order_duration_seconds = &u
	}
}

// AddedMaxOrderDurationSeconds returns the value that was added to the "max_order_duration_seconds" field in this mutation.
func (m *AppPowerRentalMutation) AddedMaxOrderDurationSeconds() (r int32, exists bool) {
	v := m.addmax_order_duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxOrderDurationSeconds clears the value of the "max_order_duration_seconds" field.
func (m *AppPowerRentalMutation) ClearMaxOrderDurationSeconds() {
	m.max_order_duration_seconds = nil
	m.addmax_order_duration_seconds = nil
	m.clearedFields[apppowerrental.FieldMaxOrderDurationSeconds] = struct{}{}
}

// MaxOrderDurationSecondsCleared returns if the "max_order_duration_seconds" field was cleared in this mutation.
func (m *AppPowerRentalMutation) MaxOrderDurationSecondsCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldMaxOrderDurationSeconds]
	return ok
}

// ResetMaxOrderDurationSeconds resets all changes to the "max_order_duration_seconds" field.
func (m *AppPowerRentalMutation) ResetMaxOrderDurationSeconds() {
	m.max_order_duration_seconds = nil
	m.addmax_order_duration_seconds = nil
	delete(m.clearedFields, apppowerrental.FieldMaxOrderDurationSeconds)
}

// SetUnitPrice sets the "unit_price" field.
func (m *AppPowerRentalMutation) SetUnitPrice(d decimal.Decimal) {
	m.unit_price = &d
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *AppPowerRentalMutation) UnitPrice() (r decimal.Decimal, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldUnitPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// ClearUnitPrice clears the value of the "unit_price" field.
func (m *AppPowerRentalMutation) ClearUnitPrice() {
	m.unit_price = nil
	m.clearedFields[apppowerrental.FieldUnitPrice] = struct{}{}
}

// UnitPriceCleared returns if the "unit_price" field was cleared in this mutation.
func (m *AppPowerRentalMutation) UnitPriceCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldUnitPrice]
	return ok
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *AppPowerRentalMutation) ResetUnitPrice() {
	m.unit_price = nil
	delete(m.clearedFields, apppowerrental.FieldUnitPrice)
}

// SetSaleStartAt sets the "sale_start_at" field.
func (m *AppPowerRentalMutation) SetSaleStartAt(u uint32) {
	m.sale_start_at = &u
	m.addsale_start_at = nil
}

// SaleStartAt returns the value of the "sale_start_at" field in the mutation.
func (m *AppPowerRentalMutation) SaleStartAt() (r uint32, exists bool) {
	v := m.sale_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStartAt returns the old "sale_start_at" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldSaleStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStartAt: %w", err)
	}
	return oldValue.SaleStartAt, nil
}

// AddSaleStartAt adds u to the "sale_start_at" field.
func (m *AppPowerRentalMutation) AddSaleStartAt(u int32) {
	if m.addsale_start_at != nil {
		*m.addsale_start_at += u
	} else {
		m.addsale_start_at = &u
	}
}

// AddedSaleStartAt returns the value that was added to the "sale_start_at" field in this mutation.
func (m *AppPowerRentalMutation) AddedSaleStartAt() (r int32, exists bool) {
	v := m.addsale_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleStartAt clears the value of the "sale_start_at" field.
func (m *AppPowerRentalMutation) ClearSaleStartAt() {
	m.sale_start_at = nil
	m.addsale_start_at = nil
	m.clearedFields[apppowerrental.FieldSaleStartAt] = struct{}{}
}

// SaleStartAtCleared returns if the "sale_start_at" field was cleared in this mutation.
func (m *AppPowerRentalMutation) SaleStartAtCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldSaleStartAt]
	return ok
}

// ResetSaleStartAt resets all changes to the "sale_start_at" field.
func (m *AppPowerRentalMutation) ResetSaleStartAt() {
	m.sale_start_at = nil
	m.addsale_start_at = nil
	delete(m.clearedFields, apppowerrental.FieldSaleStartAt)
}

// SetSaleEndAt sets the "sale_end_at" field.
func (m *AppPowerRentalMutation) SetSaleEndAt(u uint32) {
	m.sale_end_at = &u
	m.addsale_end_at = nil
}

// SaleEndAt returns the value of the "sale_end_at" field in the mutation.
func (m *AppPowerRentalMutation) SaleEndAt() (r uint32, exists bool) {
	v := m.sale_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleEndAt returns the old "sale_end_at" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldSaleEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleEndAt: %w", err)
	}
	return oldValue.SaleEndAt, nil
}

// AddSaleEndAt adds u to the "sale_end_at" field.
func (m *AppPowerRentalMutation) AddSaleEndAt(u int32) {
	if m.addsale_end_at != nil {
		*m.addsale_end_at += u
	} else {
		m.addsale_end_at = &u
	}
}

// AddedSaleEndAt returns the value that was added to the "sale_end_at" field in this mutation.
func (m *AppPowerRentalMutation) AddedSaleEndAt() (r int32, exists bool) {
	v := m.addsale_end_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleEndAt clears the value of the "sale_end_at" field.
func (m *AppPowerRentalMutation) ClearSaleEndAt() {
	m.sale_end_at = nil
	m.addsale_end_at = nil
	m.clearedFields[apppowerrental.FieldSaleEndAt] = struct{}{}
}

// SaleEndAtCleared returns if the "sale_end_at" field was cleared in this mutation.
func (m *AppPowerRentalMutation) SaleEndAtCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldSaleEndAt]
	return ok
}

// ResetSaleEndAt resets all changes to the "sale_end_at" field.
func (m *AppPowerRentalMutation) ResetSaleEndAt() {
	m.sale_end_at = nil
	m.addsale_end_at = nil
	delete(m.clearedFields, apppowerrental.FieldSaleEndAt)
}

// SetSaleMode sets the "sale_mode" field.
func (m *AppPowerRentalMutation) SetSaleMode(s string) {
	m.sale_mode = &s
}

// SaleMode returns the value of the "sale_mode" field in the mutation.
func (m *AppPowerRentalMutation) SaleMode() (r string, exists bool) {
	v := m.sale_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleMode returns the old "sale_mode" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldSaleMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleMode: %w", err)
	}
	return oldValue.SaleMode, nil
}

// ClearSaleMode clears the value of the "sale_mode" field.
func (m *AppPowerRentalMutation) ClearSaleMode() {
	m.sale_mode = nil
	m.clearedFields[apppowerrental.FieldSaleMode] = struct{}{}
}

// SaleModeCleared returns if the "sale_mode" field was cleared in this mutation.
func (m *AppPowerRentalMutation) SaleModeCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldSaleMode]
	return ok
}

// ResetSaleMode resets all changes to the "sale_mode" field.
func (m *AppPowerRentalMutation) ResetSaleMode() {
	m.sale_mode = nil
	delete(m.clearedFields, apppowerrental.FieldSaleMode)
}

// SetFixedDuration sets the "fixed_duration" field.
func (m *AppPowerRentalMutation) SetFixedDuration(b bool) {
	m.fixed_duration = &b
}

// FixedDuration returns the value of the "fixed_duration" field in the mutation.
func (m *AppPowerRentalMutation) FixedDuration() (r bool, exists bool) {
	v := m.fixed_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedDuration returns the old "fixed_duration" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldFixedDuration(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedDuration: %w", err)
	}
	return oldValue.FixedDuration, nil
}

// ClearFixedDuration clears the value of the "fixed_duration" field.
func (m *AppPowerRentalMutation) ClearFixedDuration() {
	m.fixed_duration = nil
	m.clearedFields[apppowerrental.FieldFixedDuration] = struct{}{}
}

// FixedDurationCleared returns if the "fixed_duration" field was cleared in this mutation.
func (m *AppPowerRentalMutation) FixedDurationCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldFixedDuration]
	return ok
}

// ResetFixedDuration resets all changes to the "fixed_duration" field.
func (m *AppPowerRentalMutation) ResetFixedDuration() {
	m.fixed_duration = nil
	delete(m.clearedFields, apppowerrental.FieldFixedDuration)
}

// SetPackageWithRequireds sets the "package_with_requireds" field.
func (m *AppPowerRentalMutation) SetPackageWithRequireds(b bool) {
	m.package_with_requireds = &b
}

// PackageWithRequireds returns the value of the "package_with_requireds" field in the mutation.
func (m *AppPowerRentalMutation) PackageWithRequireds() (r bool, exists bool) {
	v := m.package_with_requireds
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageWithRequireds returns the old "package_with_requireds" field's value of the AppPowerRental entity.
// If the AppPowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPowerRentalMutation) OldPackageWithRequireds(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageWithRequireds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageWithRequireds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageWithRequireds: %w", err)
	}
	return oldValue.PackageWithRequireds, nil
}

// ClearPackageWithRequireds clears the value of the "package_with_requireds" field.
func (m *AppPowerRentalMutation) ClearPackageWithRequireds() {
	m.package_with_requireds = nil
	m.clearedFields[apppowerrental.FieldPackageWithRequireds] = struct{}{}
}

// PackageWithRequiredsCleared returns if the "package_with_requireds" field was cleared in this mutation.
func (m *AppPowerRentalMutation) PackageWithRequiredsCleared() bool {
	_, ok := m.clearedFields[apppowerrental.FieldPackageWithRequireds]
	return ok
}

// ResetPackageWithRequireds resets all changes to the "package_with_requireds" field.
func (m *AppPowerRentalMutation) ResetPackageWithRequireds() {
	m.package_with_requireds = nil
	delete(m.clearedFields, apppowerrental.FieldPackageWithRequireds)
}

// Where appends a list predicates to the AppPowerRentalMutation builder.
func (m *AppPowerRentalMutation) Where(ps ...predicate.AppPowerRental) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPowerRentalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPowerRentalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPowerRental, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPowerRentalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPowerRentalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPowerRental).
func (m *AppPowerRentalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPowerRentalMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.ent_id != nil {
		fields = append(fields, apppowerrental.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, apppowerrental.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apppowerrental.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apppowerrental.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, apppowerrental.FieldAppGoodID)
	}
	if m.service_start_at != nil {
		fields = append(fields, apppowerrental.FieldServiceStartAt)
	}
	if m.start_mode != nil {
		fields = append(fields, apppowerrental.FieldStartMode)
	}
	if m.cancel_mode != nil {
		fields = append(fields, apppowerrental.FieldCancelMode)
	}
	if m.cancelable_before_start_seconds != nil {
		fields = append(fields, apppowerrental.FieldCancelableBeforeStartSeconds)
	}
	if m.enable_set_commission != nil {
		fields = append(fields, apppowerrental.FieldEnableSetCommission)
	}
	if m.min_order_amount != nil {
		fields = append(fields, apppowerrental.FieldMinOrderAmount)
	}
	if m.max_order_amount != nil {
		fields = append(fields, apppowerrental.FieldMaxOrderAmount)
	}
	if m.max_user_amount != nil {
		fields = append(fields, apppowerrental.FieldMaxUserAmount)
	}
	if m.min_order_duration_seconds != nil {
		fields = append(fields, apppowerrental.FieldMinOrderDurationSeconds)
	}
	if m.max_order_duration_seconds != nil {
		fields = append(fields, apppowerrental.FieldMaxOrderDurationSeconds)
	}
	if m.unit_price != nil {
		fields = append(fields, apppowerrental.FieldUnitPrice)
	}
	if m.sale_start_at != nil {
		fields = append(fields, apppowerrental.FieldSaleStartAt)
	}
	if m.sale_end_at != nil {
		fields = append(fields, apppowerrental.FieldSaleEndAt)
	}
	if m.sale_mode != nil {
		fields = append(fields, apppowerrental.FieldSaleMode)
	}
	if m.fixed_duration != nil {
		fields = append(fields, apppowerrental.FieldFixedDuration)
	}
	if m.package_with_requireds != nil {
		fields = append(fields, apppowerrental.FieldPackageWithRequireds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPowerRentalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppowerrental.FieldEntID:
		return m.EntID()
	case apppowerrental.FieldCreatedAt:
		return m.CreatedAt()
	case apppowerrental.FieldUpdatedAt:
		return m.UpdatedAt()
	case apppowerrental.FieldDeletedAt:
		return m.DeletedAt()
	case apppowerrental.FieldAppGoodID:
		return m.AppGoodID()
	case apppowerrental.FieldServiceStartAt:
		return m.ServiceStartAt()
	case apppowerrental.FieldStartMode:
		return m.StartMode()
	case apppowerrental.FieldCancelMode:
		return m.CancelMode()
	case apppowerrental.FieldCancelableBeforeStartSeconds:
		return m.CancelableBeforeStartSeconds()
	case apppowerrental.FieldEnableSetCommission:
		return m.EnableSetCommission()
	case apppowerrental.FieldMinOrderAmount:
		return m.MinOrderAmount()
	case apppowerrental.FieldMaxOrderAmount:
		return m.MaxOrderAmount()
	case apppowerrental.FieldMaxUserAmount:
		return m.MaxUserAmount()
	case apppowerrental.FieldMinOrderDurationSeconds:
		return m.MinOrderDurationSeconds()
	case apppowerrental.FieldMaxOrderDurationSeconds:
		return m.MaxOrderDurationSeconds()
	case apppowerrental.FieldUnitPrice:
		return m.UnitPrice()
	case apppowerrental.FieldSaleStartAt:
		return m.SaleStartAt()
	case apppowerrental.FieldSaleEndAt:
		return m.SaleEndAt()
	case apppowerrental.FieldSaleMode:
		return m.SaleMode()
	case apppowerrental.FieldFixedDuration:
		return m.FixedDuration()
	case apppowerrental.FieldPackageWithRequireds:
		return m.PackageWithRequireds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPowerRentalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppowerrental.FieldEntID:
		return m.OldEntID(ctx)
	case apppowerrental.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apppowerrental.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apppowerrental.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apppowerrental.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case apppowerrental.FieldServiceStartAt:
		return m.OldServiceStartAt(ctx)
	case apppowerrental.FieldStartMode:
		return m.OldStartMode(ctx)
	case apppowerrental.FieldCancelMode:
		return m.OldCancelMode(ctx)
	case apppowerrental.FieldCancelableBeforeStartSeconds:
		return m.OldCancelableBeforeStartSeconds(ctx)
	case apppowerrental.FieldEnableSetCommission:
		return m.OldEnableSetCommission(ctx)
	case apppowerrental.FieldMinOrderAmount:
		return m.OldMinOrderAmount(ctx)
	case apppowerrental.FieldMaxOrderAmount:
		return m.OldMaxOrderAmount(ctx)
	case apppowerrental.FieldMaxUserAmount:
		return m.OldMaxUserAmount(ctx)
	case apppowerrental.FieldMinOrderDurationSeconds:
		return m.OldMinOrderDurationSeconds(ctx)
	case apppowerrental.FieldMaxOrderDurationSeconds:
		return m.OldMaxOrderDurationSeconds(ctx)
	case apppowerrental.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case apppowerrental.FieldSaleStartAt:
		return m.OldSaleStartAt(ctx)
	case apppowerrental.FieldSaleEndAt:
		return m.OldSaleEndAt(ctx)
	case apppowerrental.FieldSaleMode:
		return m.OldSaleMode(ctx)
	case apppowerrental.FieldFixedDuration:
		return m.OldFixedDuration(ctx)
	case apppowerrental.FieldPackageWithRequireds:
		return m.OldPackageWithRequireds(ctx)
	}
	return nil, fmt.Errorf("unknown AppPowerRental field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPowerRentalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppowerrental.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case apppowerrental.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apppowerrental.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apppowerrental.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apppowerrental.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case apppowerrental.FieldServiceStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceStartAt(v)
		return nil
	case apppowerrental.FieldStartMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartMode(v)
		return nil
	case apppowerrental.FieldCancelMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelMode(v)
		return nil
	case apppowerrental.FieldCancelableBeforeStartSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelableBeforeStartSeconds(v)
		return nil
	case apppowerrental.FieldEnableSetCommission:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableSetCommission(v)
		return nil
	case apppowerrental.FieldMinOrderAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinOrderAmount(v)
		return nil
	case apppowerrental.FieldMaxOrderAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxOrderAmount(v)
		return nil
	case apppowerrental.FieldMaxUserAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUserAmount(v)
		return nil
	case apppowerrental.FieldMinOrderDurationSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinOrderDurationSeconds(v)
		return nil
	case apppowerrental.FieldMaxOrderDurationSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxOrderDurationSeconds(v)
		return nil
	case apppowerrental.FieldUnitPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case apppowerrental.FieldSaleStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStartAt(v)
		return nil
	case apppowerrental.FieldSaleEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleEndAt(v)
		return nil
	case apppowerrental.FieldSaleMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleMode(v)
		return nil
	case apppowerrental.FieldFixedDuration:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedDuration(v)
		return nil
	case apppowerrental.FieldPackageWithRequireds:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageWithRequireds(v)
		return nil
	}
	return fmt.Errorf("unknown AppPowerRental field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPowerRentalMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, apppowerrental.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, apppowerrental.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, apppowerrental.FieldDeletedAt)
	}
	if m.addservice_start_at != nil {
		fields = append(fields, apppowerrental.FieldServiceStartAt)
	}
	if m.addcancelable_before_start_seconds != nil {
		fields = append(fields, apppowerrental.FieldCancelableBeforeStartSeconds)
	}
	if m.addmin_order_duration_seconds != nil {
		fields = append(fields, apppowerrental.FieldMinOrderDurationSeconds)
	}
	if m.addmax_order_duration_seconds != nil {
		fields = append(fields, apppowerrental.FieldMaxOrderDurationSeconds)
	}
	if m.addsale_start_at != nil {
		fields = append(fields, apppowerrental.FieldSaleStartAt)
	}
	if m.addsale_end_at != nil {
		fields = append(fields, apppowerrental.FieldSaleEndAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPowerRentalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppowerrental.FieldCreatedAt:
		return m.AddedCreatedAt()
	case apppowerrental.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case apppowerrental.FieldDeletedAt:
		return m.AddedDeletedAt()
	case apppowerrental.FieldServiceStartAt:
		return m.AddedServiceStartAt()
	case apppowerrental.FieldCancelableBeforeStartSeconds:
		return m.AddedCancelableBeforeStartSeconds()
	case apppowerrental.FieldMinOrderDurationSeconds:
		return m.AddedMinOrderDurationSeconds()
	case apppowerrental.FieldMaxOrderDurationSeconds:
		return m.AddedMaxOrderDurationSeconds()
	case apppowerrental.FieldSaleStartAt:
		return m.AddedSaleStartAt()
	case apppowerrental.FieldSaleEndAt:
		return m.AddedSaleEndAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPowerRentalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppowerrental.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case apppowerrental.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case apppowerrental.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case apppowerrental.FieldServiceStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceStartAt(v)
		return nil
	case apppowerrental.FieldCancelableBeforeStartSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelableBeforeStartSeconds(v)
		return nil
	case apppowerrental.FieldMinOrderDurationSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinOrderDurationSeconds(v)
		return nil
	case apppowerrental.FieldMaxOrderDurationSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxOrderDurationSeconds(v)
		return nil
	case apppowerrental.FieldSaleStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleStartAt(v)
		return nil
	case apppowerrental.FieldSaleEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppPowerRental numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPowerRentalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apppowerrental.FieldAppGoodID) {
		fields = append(fields, apppowerrental.FieldAppGoodID)
	}
	if m.FieldCleared(apppowerrental.FieldServiceStartAt) {
		fields = append(fields, apppowerrental.FieldServiceStartAt)
	}
	if m.FieldCleared(apppowerrental.FieldStartMode) {
		fields = append(fields, apppowerrental.FieldStartMode)
	}
	if m.FieldCleared(apppowerrental.FieldCancelMode) {
		fields = append(fields, apppowerrental.FieldCancelMode)
	}
	if m.FieldCleared(apppowerrental.FieldCancelableBeforeStartSeconds) {
		fields = append(fields, apppowerrental.FieldCancelableBeforeStartSeconds)
	}
	if m.FieldCleared(apppowerrental.FieldEnableSetCommission) {
		fields = append(fields, apppowerrental.FieldEnableSetCommission)
	}
	if m.FieldCleared(apppowerrental.FieldMinOrderAmount) {
		fields = append(fields, apppowerrental.FieldMinOrderAmount)
	}
	if m.FieldCleared(apppowerrental.FieldMaxOrderAmount) {
		fields = append(fields, apppowerrental.FieldMaxOrderAmount)
	}
	if m.FieldCleared(apppowerrental.FieldMaxUserAmount) {
		fields = append(fields, apppowerrental.FieldMaxUserAmount)
	}
	if m.FieldCleared(apppowerrental.FieldMinOrderDurationSeconds) {
		fields = append(fields, apppowerrental.FieldMinOrderDurationSeconds)
	}
	if m.FieldCleared(apppowerrental.FieldMaxOrderDurationSeconds) {
		fields = append(fields, apppowerrental.FieldMaxOrderDurationSeconds)
	}
	if m.FieldCleared(apppowerrental.FieldUnitPrice) {
		fields = append(fields, apppowerrental.FieldUnitPrice)
	}
	if m.FieldCleared(apppowerrental.FieldSaleStartAt) {
		fields = append(fields, apppowerrental.FieldSaleStartAt)
	}
	if m.FieldCleared(apppowerrental.FieldSaleEndAt) {
		fields = append(fields, apppowerrental.FieldSaleEndAt)
	}
	if m.FieldCleared(apppowerrental.FieldSaleMode) {
		fields = append(fields, apppowerrental.FieldSaleMode)
	}
	if m.FieldCleared(apppowerrental.FieldFixedDuration) {
		fields = append(fields, apppowerrental.FieldFixedDuration)
	}
	if m.FieldCleared(apppowerrental.FieldPackageWithRequireds) {
		fields = append(fields, apppowerrental.FieldPackageWithRequireds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPowerRentalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPowerRentalMutation) ClearField(name string) error {
	switch name {
	case apppowerrental.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case apppowerrental.FieldServiceStartAt:
		m.ClearServiceStartAt()
		return nil
	case apppowerrental.FieldStartMode:
		m.ClearStartMode()
		return nil
	case apppowerrental.FieldCancelMode:
		m.ClearCancelMode()
		return nil
	case apppowerrental.FieldCancelableBeforeStartSeconds:
		m.ClearCancelableBeforeStartSeconds()
		return nil
	case apppowerrental.FieldEnableSetCommission:
		m.ClearEnableSetCommission()
		return nil
	case apppowerrental.FieldMinOrderAmount:
		m.ClearMinOrderAmount()
		return nil
	case apppowerrental.FieldMaxOrderAmount:
		m.ClearMaxOrderAmount()
		return nil
	case apppowerrental.FieldMaxUserAmount:
		m.ClearMaxUserAmount()
		return nil
	case apppowerrental.FieldMinOrderDurationSeconds:
		m.ClearMinOrderDurationSeconds()
		return nil
	case apppowerrental.FieldMaxOrderDurationSeconds:
		m.ClearMaxOrderDurationSeconds()
		return nil
	case apppowerrental.FieldUnitPrice:
		m.ClearUnitPrice()
		return nil
	case apppowerrental.FieldSaleStartAt:
		m.ClearSaleStartAt()
		return nil
	case apppowerrental.FieldSaleEndAt:
		m.ClearSaleEndAt()
		return nil
	case apppowerrental.FieldSaleMode:
		m.ClearSaleMode()
		return nil
	case apppowerrental.FieldFixedDuration:
		m.ClearFixedDuration()
		return nil
	case apppowerrental.FieldPackageWithRequireds:
		m.ClearPackageWithRequireds()
		return nil
	}
	return fmt.Errorf("unknown AppPowerRental nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPowerRentalMutation) ResetField(name string) error {
	switch name {
	case apppowerrental.FieldEntID:
		m.ResetEntID()
		return nil
	case apppowerrental.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apppowerrental.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apppowerrental.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apppowerrental.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case apppowerrental.FieldServiceStartAt:
		m.ResetServiceStartAt()
		return nil
	case apppowerrental.FieldStartMode:
		m.ResetStartMode()
		return nil
	case apppowerrental.FieldCancelMode:
		m.ResetCancelMode()
		return nil
	case apppowerrental.FieldCancelableBeforeStartSeconds:
		m.ResetCancelableBeforeStartSeconds()
		return nil
	case apppowerrental.FieldEnableSetCommission:
		m.ResetEnableSetCommission()
		return nil
	case apppowerrental.FieldMinOrderAmount:
		m.ResetMinOrderAmount()
		return nil
	case apppowerrental.FieldMaxOrderAmount:
		m.ResetMaxOrderAmount()
		return nil
	case apppowerrental.FieldMaxUserAmount:
		m.ResetMaxUserAmount()
		return nil
	case apppowerrental.FieldMinOrderDurationSeconds:
		m.ResetMinOrderDurationSeconds()
		return nil
	case apppowerrental.FieldMaxOrderDurationSeconds:
		m.ResetMaxOrderDurationSeconds()
		return nil
	case apppowerrental.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case apppowerrental.FieldSaleStartAt:
		m.ResetSaleStartAt()
		return nil
	case apppowerrental.FieldSaleEndAt:
		m.ResetSaleEndAt()
		return nil
	case apppowerrental.FieldSaleMode:
		m.ResetSaleMode()
		return nil
	case apppowerrental.FieldFixedDuration:
		m.ResetFixedDuration()
		return nil
	case apppowerrental.FieldPackageWithRequireds:
		m.ResetPackageWithRequireds()
		return nil
	}
	return fmt.Errorf("unknown AppPowerRental field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPowerRentalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPowerRentalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPowerRentalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPowerRentalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPowerRentalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPowerRentalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPowerRentalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppPowerRental unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPowerRentalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppPowerRental edge %s", name)
}

// AppSimulatePowerRentalMutation represents an operation that mutates the AppSimulatePowerRental nodes in the graph.
type AppSimulatePowerRentalMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	ent_id                    *uuid.UUID
	created_at                *uint32
	addcreated_at             *int32
	updated_at                *uint32
	addupdated_at             *int32
	deleted_at                *uint32
	adddeleted_at             *int32
	app_good_id               *uuid.UUID
	coin_type_id              *uuid.UUID
	order_units               *decimal.Decimal
	order_duration_seconds    *uint32
	addorder_duration_seconds *int32
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*AppSimulatePowerRental, error)
	predicates                []predicate.AppSimulatePowerRental
}

var _ ent.Mutation = (*AppSimulatePowerRentalMutation)(nil)

// appsimulatepowerrentalOption allows management of the mutation configuration using functional options.
type appsimulatepowerrentalOption func(*AppSimulatePowerRentalMutation)

// newAppSimulatePowerRentalMutation creates new mutation for the AppSimulatePowerRental entity.
func newAppSimulatePowerRentalMutation(c config, op Op, opts ...appsimulatepowerrentalOption) *AppSimulatePowerRentalMutation {
	m := &AppSimulatePowerRentalMutation{
		config:        c,
		op:            op,
		typ:           TypeAppSimulatePowerRental,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppSimulatePowerRentalID sets the ID field of the mutation.
func withAppSimulatePowerRentalID(id uint32) appsimulatepowerrentalOption {
	return func(m *AppSimulatePowerRentalMutation) {
		var (
			err   error
			once  sync.Once
			value *AppSimulatePowerRental
		)
		m.oldValue = func(ctx context.Context) (*AppSimulatePowerRental, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppSimulatePowerRental.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppSimulatePowerRental sets the old AppSimulatePowerRental of the mutation.
func withAppSimulatePowerRental(node *AppSimulatePowerRental) appsimulatepowerrentalOption {
	return func(m *AppSimulatePowerRentalMutation) {
		m.oldValue = func(context.Context) (*AppSimulatePowerRental, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppSimulatePowerRentalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppSimulatePowerRentalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppSimulatePowerRental entities.
func (m *AppSimulatePowerRentalMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppSimulatePowerRentalMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppSimulatePowerRentalMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppSimulatePowerRental.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppSimulatePowerRentalMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppSimulatePowerRentalMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppSimulatePowerRental entity.
// If the AppSimulatePowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSimulatePowerRentalMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppSimulatePowerRentalMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppSimulatePowerRentalMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppSimulatePowerRentalMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppSimulatePowerRental entity.
// If the AppSimulatePowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSimulatePowerRentalMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppSimulatePowerRentalMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppSimulatePowerRentalMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppSimulatePowerRentalMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppSimulatePowerRentalMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppSimulatePowerRentalMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppSimulatePowerRental entity.
// If the AppSimulatePowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSimulatePowerRentalMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppSimulatePowerRentalMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppSimulatePowerRentalMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppSimulatePowerRentalMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppSimulatePowerRentalMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppSimulatePowerRentalMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppSimulatePowerRental entity.
// If the AppSimulatePowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSimulatePowerRentalMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppSimulatePowerRentalMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppSimulatePowerRentalMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppSimulatePowerRentalMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppSimulatePowerRentalMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppSimulatePowerRentalMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppSimulatePowerRental entity.
// If the AppSimulatePowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSimulatePowerRentalMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppSimulatePowerRentalMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appsimulatepowerrental.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppSimulatePowerRentalMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appsimulatepowerrental.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppSimulatePowerRentalMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appsimulatepowerrental.FieldAppGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *AppSimulatePowerRentalMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *AppSimulatePowerRentalMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the AppSimulatePowerRental entity.
// If the AppSimulatePowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSimulatePowerRentalMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *AppSimulatePowerRentalMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[appsimulatepowerrental.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *AppSimulatePowerRentalMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[appsimulatepowerrental.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *AppSimulatePowerRentalMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, appsimulatepowerrental.FieldCoinTypeID)
}

// SetOrderUnits sets the "order_units" field.
func (m *AppSimulatePowerRentalMutation) SetOrderUnits(d decimal.Decimal) {
	m.order_units = &d
}

// OrderUnits returns the value of the "order_units" field in the mutation.
func (m *AppSimulatePowerRentalMutation) OrderUnits() (r decimal.Decimal, exists bool) {
	v := m.order_units
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderUnits returns the old "order_units" field's value of the AppSimulatePowerRental entity.
// If the AppSimulatePowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSimulatePowerRentalMutation) OldOrderUnits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderUnits: %w", err)
	}
	return oldValue.OrderUnits, nil
}

// ClearOrderUnits clears the value of the "order_units" field.
func (m *AppSimulatePowerRentalMutation) ClearOrderUnits() {
	m.order_units = nil
	m.clearedFields[appsimulatepowerrental.FieldOrderUnits] = struct{}{}
}

// OrderUnitsCleared returns if the "order_units" field was cleared in this mutation.
func (m *AppSimulatePowerRentalMutation) OrderUnitsCleared() bool {
	_, ok := m.clearedFields[appsimulatepowerrental.FieldOrderUnits]
	return ok
}

// ResetOrderUnits resets all changes to the "order_units" field.
func (m *AppSimulatePowerRentalMutation) ResetOrderUnits() {
	m.order_units = nil
	delete(m.clearedFields, appsimulatepowerrental.FieldOrderUnits)
}

// SetOrderDurationSeconds sets the "order_duration_seconds" field.
func (m *AppSimulatePowerRentalMutation) SetOrderDurationSeconds(u uint32) {
	m.order_duration_seconds = &u
	m.addorder_duration_seconds = nil
}

// OrderDurationSeconds returns the value of the "order_duration_seconds" field in the mutation.
func (m *AppSimulatePowerRentalMutation) OrderDurationSeconds() (r uint32, exists bool) {
	v := m.order_duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDurationSeconds returns the old "order_duration_seconds" field's value of the AppSimulatePowerRental entity.
// If the AppSimulatePowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSimulatePowerRentalMutation) OldOrderDurationSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDurationSeconds: %w", err)
	}
	return oldValue.OrderDurationSeconds, nil
}

// AddOrderDurationSeconds adds u to the "order_duration_seconds" field.
func (m *AppSimulatePowerRentalMutation) AddOrderDurationSeconds(u int32) {
	if m.addorder_duration_seconds != nil {
		*m.addorder_duration_seconds += u
	} else {
		m.addorder_duration_seconds = &u
	}
}

// AddedOrderDurationSeconds returns the value that was added to the "order_duration_seconds" field in this mutation.
func (m *AppSimulatePowerRentalMutation) AddedOrderDurationSeconds() (r int32, exists bool) {
	v := m.addorder_duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderDurationSeconds clears the value of the "order_duration_seconds" field.
func (m *AppSimulatePowerRentalMutation) ClearOrderDurationSeconds() {
	m.order_duration_seconds = nil
	m.addorder_duration_seconds = nil
	m.clearedFields[appsimulatepowerrental.FieldOrderDurationSeconds] = struct{}{}
}

// OrderDurationSecondsCleared returns if the "order_duration_seconds" field was cleared in this mutation.
func (m *AppSimulatePowerRentalMutation) OrderDurationSecondsCleared() bool {
	_, ok := m.clearedFields[appsimulatepowerrental.FieldOrderDurationSeconds]
	return ok
}

// ResetOrderDurationSeconds resets all changes to the "order_duration_seconds" field.
func (m *AppSimulatePowerRentalMutation) ResetOrderDurationSeconds() {
	m.order_duration_seconds = nil
	m.addorder_duration_seconds = nil
	delete(m.clearedFields, appsimulatepowerrental.FieldOrderDurationSeconds)
}

// Where appends a list predicates to the AppSimulatePowerRentalMutation builder.
func (m *AppSimulatePowerRentalMutation) Where(ps ...predicate.AppSimulatePowerRental) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppSimulatePowerRentalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppSimulatePowerRentalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppSimulatePowerRental, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppSimulatePowerRentalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppSimulatePowerRentalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppSimulatePowerRental).
func (m *AppSimulatePowerRentalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppSimulatePowerRentalMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, appsimulatepowerrental.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appsimulatepowerrental.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appsimulatepowerrental.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appsimulatepowerrental.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appsimulatepowerrental.FieldAppGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, appsimulatepowerrental.FieldCoinTypeID)
	}
	if m.order_units != nil {
		fields = append(fields, appsimulatepowerrental.FieldOrderUnits)
	}
	if m.order_duration_seconds != nil {
		fields = append(fields, appsimulatepowerrental.FieldOrderDurationSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppSimulatePowerRentalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appsimulatepowerrental.FieldEntID:
		return m.EntID()
	case appsimulatepowerrental.FieldCreatedAt:
		return m.CreatedAt()
	case appsimulatepowerrental.FieldUpdatedAt:
		return m.UpdatedAt()
	case appsimulatepowerrental.FieldDeletedAt:
		return m.DeletedAt()
	case appsimulatepowerrental.FieldAppGoodID:
		return m.AppGoodID()
	case appsimulatepowerrental.FieldCoinTypeID:
		return m.CoinTypeID()
	case appsimulatepowerrental.FieldOrderUnits:
		return m.OrderUnits()
	case appsimulatepowerrental.FieldOrderDurationSeconds:
		return m.OrderDurationSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppSimulatePowerRentalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appsimulatepowerrental.FieldEntID:
		return m.OldEntID(ctx)
	case appsimulatepowerrental.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appsimulatepowerrental.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appsimulatepowerrental.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appsimulatepowerrental.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appsimulatepowerrental.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case appsimulatepowerrental.FieldOrderUnits:
		return m.OldOrderUnits(ctx)
	case appsimulatepowerrental.FieldOrderDurationSeconds:
		return m.OldOrderDurationSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown AppSimulatePowerRental field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSimulatePowerRentalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appsimulatepowerrental.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appsimulatepowerrental.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appsimulatepowerrental.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appsimulatepowerrental.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appsimulatepowerrental.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appsimulatepowerrental.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case appsimulatepowerrental.FieldOrderUnits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderUnits(v)
		return nil
	case appsimulatepowerrental.FieldOrderDurationSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown AppSimulatePowerRental field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppSimulatePowerRentalMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appsimulatepowerrental.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appsimulatepowerrental.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appsimulatepowerrental.FieldDeletedAt)
	}
	if m.addorder_duration_seconds != nil {
		fields = append(fields, appsimulatepowerrental.FieldOrderDurationSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppSimulatePowerRentalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appsimulatepowerrental.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appsimulatepowerrental.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appsimulatepowerrental.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appsimulatepowerrental.FieldOrderDurationSeconds:
		return m.AddedOrderDurationSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSimulatePowerRentalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appsimulatepowerrental.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appsimulatepowerrental.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appsimulatepowerrental.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appsimulatepowerrental.FieldOrderDurationSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown AppSimulatePowerRental numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppSimulatePowerRentalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appsimulatepowerrental.FieldAppGoodID) {
		fields = append(fields, appsimulatepowerrental.FieldAppGoodID)
	}
	if m.FieldCleared(appsimulatepowerrental.FieldCoinTypeID) {
		fields = append(fields, appsimulatepowerrental.FieldCoinTypeID)
	}
	if m.FieldCleared(appsimulatepowerrental.FieldOrderUnits) {
		fields = append(fields, appsimulatepowerrental.FieldOrderUnits)
	}
	if m.FieldCleared(appsimulatepowerrental.FieldOrderDurationSeconds) {
		fields = append(fields, appsimulatepowerrental.FieldOrderDurationSeconds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppSimulatePowerRentalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppSimulatePowerRentalMutation) ClearField(name string) error {
	switch name {
	case appsimulatepowerrental.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appsimulatepowerrental.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case appsimulatepowerrental.FieldOrderUnits:
		m.ClearOrderUnits()
		return nil
	case appsimulatepowerrental.FieldOrderDurationSeconds:
		m.ClearOrderDurationSeconds()
		return nil
	}
	return fmt.Errorf("unknown AppSimulatePowerRental nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppSimulatePowerRentalMutation) ResetField(name string) error {
	switch name {
	case appsimulatepowerrental.FieldEntID:
		m.ResetEntID()
		return nil
	case appsimulatepowerrental.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appsimulatepowerrental.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appsimulatepowerrental.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appsimulatepowerrental.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appsimulatepowerrental.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case appsimulatepowerrental.FieldOrderUnits:
		m.ResetOrderUnits()
		return nil
	case appsimulatepowerrental.FieldOrderDurationSeconds:
		m.ResetOrderDurationSeconds()
		return nil
	}
	return fmt.Errorf("unknown AppSimulatePowerRental field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppSimulatePowerRentalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppSimulatePowerRentalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppSimulatePowerRentalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppSimulatePowerRentalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppSimulatePowerRentalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppSimulatePowerRentalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppSimulatePowerRentalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppSimulatePowerRental unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppSimulatePowerRentalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppSimulatePowerRental edge %s", name)
}

// AppStockMutation represents an operation that mutates the AppStock nodes in the graph.
type AppStockMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_good_id   *uuid.UUID
	reserved      *decimal.Decimal
	spot_quantity *decimal.Decimal
	locked        *decimal.Decimal
	in_service    *decimal.Decimal
	wait_start    *decimal.Decimal
	sold          *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppStock, error)
	predicates    []predicate.AppStock
}

var _ ent.Mutation = (*AppStockMutation)(nil)

// appstockOption allows management of the mutation configuration using functional options.
type appstockOption func(*AppStockMutation)

// newAppStockMutation creates new mutation for the AppStock entity.
func newAppStockMutation(c config, op Op, opts ...appstockOption) *AppStockMutation {
	m := &AppStockMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStockID sets the ID field of the mutation.
func withAppStockID(id uint32) appstockOption {
	return func(m *AppStockMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStock
		)
		m.oldValue = func(ctx context.Context) (*AppStock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStock sets the old AppStock of the mutation.
func withAppStock(node *AppStock) appstockOption {
	return func(m *AppStockMutation) {
		m.oldValue = func(context.Context) (*AppStock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppStock entities.
func (m *AppStockMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppStockMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppStockMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppStock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppStockMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppStockMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppStockMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppStockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppStockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppStockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppStockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppStockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppStockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppStockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppStockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppStockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppStockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppStockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppStockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppStockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppStockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppStockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppStockMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppStockMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppStockMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appstock.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppStockMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appstock.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppStockMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appstock.FieldAppGoodID)
}

// SetReserved sets the "reserved" field.
func (m *AppStockMutation) SetReserved(d decimal.Decimal) {
	m.reserved = &d
}

// Reserved returns the value of the "reserved" field in the mutation.
func (m *AppStockMutation) Reserved() (r decimal.Decimal, exists bool) {
	v := m.reserved
	if v == nil {
		return
	}
	return *v, true
}

// OldReserved returns the old "reserved" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldReserved(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReserved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReserved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserved: %w", err)
	}
	return oldValue.Reserved, nil
}

// ClearReserved clears the value of the "reserved" field.
func (m *AppStockMutation) ClearReserved() {
	m.reserved = nil
	m.clearedFields[appstock.FieldReserved] = struct{}{}
}

// ReservedCleared returns if the "reserved" field was cleared in this mutation.
func (m *AppStockMutation) ReservedCleared() bool {
	_, ok := m.clearedFields[appstock.FieldReserved]
	return ok
}

// ResetReserved resets all changes to the "reserved" field.
func (m *AppStockMutation) ResetReserved() {
	m.reserved = nil
	delete(m.clearedFields, appstock.FieldReserved)
}

// SetSpotQuantity sets the "spot_quantity" field.
func (m *AppStockMutation) SetSpotQuantity(d decimal.Decimal) {
	m.spot_quantity = &d
}

// SpotQuantity returns the value of the "spot_quantity" field in the mutation.
func (m *AppStockMutation) SpotQuantity() (r decimal.Decimal, exists bool) {
	v := m.spot_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotQuantity returns the old "spot_quantity" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldSpotQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotQuantity: %w", err)
	}
	return oldValue.SpotQuantity, nil
}

// ClearSpotQuantity clears the value of the "spot_quantity" field.
func (m *AppStockMutation) ClearSpotQuantity() {
	m.spot_quantity = nil
	m.clearedFields[appstock.FieldSpotQuantity] = struct{}{}
}

// SpotQuantityCleared returns if the "spot_quantity" field was cleared in this mutation.
func (m *AppStockMutation) SpotQuantityCleared() bool {
	_, ok := m.clearedFields[appstock.FieldSpotQuantity]
	return ok
}

// ResetSpotQuantity resets all changes to the "spot_quantity" field.
func (m *AppStockMutation) ResetSpotQuantity() {
	m.spot_quantity = nil
	delete(m.clearedFields, appstock.FieldSpotQuantity)
}

// SetLocked sets the "locked" field.
func (m *AppStockMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
}

// Locked returns the value of the "locked" field in the mutation.
func (m *AppStockMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ClearLocked clears the value of the "locked" field.
func (m *AppStockMutation) ClearLocked() {
	m.locked = nil
	m.clearedFields[appstock.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *AppStockMutation) LockedCleared() bool {
	_, ok := m.clearedFields[appstock.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *AppStockMutation) ResetLocked() {
	m.locked = nil
	delete(m.clearedFields, appstock.FieldLocked)
}

// SetInService sets the "in_service" field.
func (m *AppStockMutation) SetInService(d decimal.Decimal) {
	m.in_service = &d
}

// InService returns the value of the "in_service" field in the mutation.
func (m *AppStockMutation) InService() (r decimal.Decimal, exists bool) {
	v := m.in_service
	if v == nil {
		return
	}
	return *v, true
}

// OldInService returns the old "in_service" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldInService(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInService: %w", err)
	}
	return oldValue.InService, nil
}

// ClearInService clears the value of the "in_service" field.
func (m *AppStockMutation) ClearInService() {
	m.in_service = nil
	m.clearedFields[appstock.FieldInService] = struct{}{}
}

// InServiceCleared returns if the "in_service" field was cleared in this mutation.
func (m *AppStockMutation) InServiceCleared() bool {
	_, ok := m.clearedFields[appstock.FieldInService]
	return ok
}

// ResetInService resets all changes to the "in_service" field.
func (m *AppStockMutation) ResetInService() {
	m.in_service = nil
	delete(m.clearedFields, appstock.FieldInService)
}

// SetWaitStart sets the "wait_start" field.
func (m *AppStockMutation) SetWaitStart(d decimal.Decimal) {
	m.wait_start = &d
}

// WaitStart returns the value of the "wait_start" field in the mutation.
func (m *AppStockMutation) WaitStart() (r decimal.Decimal, exists bool) {
	v := m.wait_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWaitStart returns the old "wait_start" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldWaitStart(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaitStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaitStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaitStart: %w", err)
	}
	return oldValue.WaitStart, nil
}

// ClearWaitStart clears the value of the "wait_start" field.
func (m *AppStockMutation) ClearWaitStart() {
	m.wait_start = nil
	m.clearedFields[appstock.FieldWaitStart] = struct{}{}
}

// WaitStartCleared returns if the "wait_start" field was cleared in this mutation.
func (m *AppStockMutation) WaitStartCleared() bool {
	_, ok := m.clearedFields[appstock.FieldWaitStart]
	return ok
}

// ResetWaitStart resets all changes to the "wait_start" field.
func (m *AppStockMutation) ResetWaitStart() {
	m.wait_start = nil
	delete(m.clearedFields, appstock.FieldWaitStart)
}

// SetSold sets the "sold" field.
func (m *AppStockMutation) SetSold(d decimal.Decimal) {
	m.sold = &d
}

// Sold returns the value of the "sold" field in the mutation.
func (m *AppStockMutation) Sold() (r decimal.Decimal, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldSold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// ClearSold clears the value of the "sold" field.
func (m *AppStockMutation) ClearSold() {
	m.sold = nil
	m.clearedFields[appstock.FieldSold] = struct{}{}
}

// SoldCleared returns if the "sold" field was cleared in this mutation.
func (m *AppStockMutation) SoldCleared() bool {
	_, ok := m.clearedFields[appstock.FieldSold]
	return ok
}

// ResetSold resets all changes to the "sold" field.
func (m *AppStockMutation) ResetSold() {
	m.sold = nil
	delete(m.clearedFields, appstock.FieldSold)
}

// Where appends a list predicates to the AppStockMutation builder.
func (m *AppStockMutation) Where(ps ...predicate.AppStock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppStockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppStockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppStock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppStockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppStockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppStock).
func (m *AppStockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppStockMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ent_id != nil {
		fields = append(fields, appstock.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appstock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appstock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appstock.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, appstock.FieldAppGoodID)
	}
	if m.reserved != nil {
		fields = append(fields, appstock.FieldReserved)
	}
	if m.spot_quantity != nil {
		fields = append(fields, appstock.FieldSpotQuantity)
	}
	if m.locked != nil {
		fields = append(fields, appstock.FieldLocked)
	}
	if m.in_service != nil {
		fields = append(fields, appstock.FieldInService)
	}
	if m.wait_start != nil {
		fields = append(fields, appstock.FieldWaitStart)
	}
	if m.sold != nil {
		fields = append(fields, appstock.FieldSold)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppStockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstock.FieldEntID:
		return m.EntID()
	case appstock.FieldCreatedAt:
		return m.CreatedAt()
	case appstock.FieldUpdatedAt:
		return m.UpdatedAt()
	case appstock.FieldDeletedAt:
		return m.DeletedAt()
	case appstock.FieldAppGoodID:
		return m.AppGoodID()
	case appstock.FieldReserved:
		return m.Reserved()
	case appstock.FieldSpotQuantity:
		return m.SpotQuantity()
	case appstock.FieldLocked:
		return m.Locked()
	case appstock.FieldInService:
		return m.InService()
	case appstock.FieldWaitStart:
		return m.WaitStart()
	case appstock.FieldSold:
		return m.Sold()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppStockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstock.FieldEntID:
		return m.OldEntID(ctx)
	case appstock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appstock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appstock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appstock.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appstock.FieldReserved:
		return m.OldReserved(ctx)
	case appstock.FieldSpotQuantity:
		return m.OldSpotQuantity(ctx)
	case appstock.FieldLocked:
		return m.OldLocked(ctx)
	case appstock.FieldInService:
		return m.OldInService(ctx)
	case appstock.FieldWaitStart:
		return m.OldWaitStart(ctx)
	case appstock.FieldSold:
		return m.OldSold(ctx)
	}
	return nil, fmt.Errorf("unknown AppStock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstock.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appstock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appstock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appstock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appstock.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appstock.FieldReserved:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserved(v)
		return nil
	case appstock.FieldSpotQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotQuantity(v)
		return nil
	case appstock.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case appstock.FieldInService:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInService(v)
		return nil
	case appstock.FieldWaitStart:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaitStart(v)
		return nil
	case appstock.FieldSold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	}
	return fmt.Errorf("unknown AppStock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppStockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appstock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appstock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appstock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppStockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appstock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appstock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appstock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appstock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appstock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appstock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppStock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppStockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appstock.FieldAppGoodID) {
		fields = append(fields, appstock.FieldAppGoodID)
	}
	if m.FieldCleared(appstock.FieldReserved) {
		fields = append(fields, appstock.FieldReserved)
	}
	if m.FieldCleared(appstock.FieldSpotQuantity) {
		fields = append(fields, appstock.FieldSpotQuantity)
	}
	if m.FieldCleared(appstock.FieldLocked) {
		fields = append(fields, appstock.FieldLocked)
	}
	if m.FieldCleared(appstock.FieldInService) {
		fields = append(fields, appstock.FieldInService)
	}
	if m.FieldCleared(appstock.FieldWaitStart) {
		fields = append(fields, appstock.FieldWaitStart)
	}
	if m.FieldCleared(appstock.FieldSold) {
		fields = append(fields, appstock.FieldSold)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppStockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStockMutation) ClearField(name string) error {
	switch name {
	case appstock.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appstock.FieldReserved:
		m.ClearReserved()
		return nil
	case appstock.FieldSpotQuantity:
		m.ClearSpotQuantity()
		return nil
	case appstock.FieldLocked:
		m.ClearLocked()
		return nil
	case appstock.FieldInService:
		m.ClearInService()
		return nil
	case appstock.FieldWaitStart:
		m.ClearWaitStart()
		return nil
	case appstock.FieldSold:
		m.ClearSold()
		return nil
	}
	return fmt.Errorf("unknown AppStock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppStockMutation) ResetField(name string) error {
	switch name {
	case appstock.FieldEntID:
		m.ResetEntID()
		return nil
	case appstock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appstock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appstock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appstock.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appstock.FieldReserved:
		m.ResetReserved()
		return nil
	case appstock.FieldSpotQuantity:
		m.ResetSpotQuantity()
		return nil
	case appstock.FieldLocked:
		m.ResetLocked()
		return nil
	case appstock.FieldInService:
		m.ResetInService()
		return nil
	case appstock.FieldWaitStart:
		m.ResetWaitStart()
		return nil
	case appstock.FieldSold:
		m.ResetSold()
		return nil
	}
	return fmt.Errorf("unknown AppStock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppStockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppStockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppStockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppStockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppStockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppStockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppStockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppStock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppStockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppStock edge %s", name)
}

// AppStockLockMutation represents an operation that mutates the AppStockLock nodes in the graph.
type AppStockLockMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	ent_id            *uuid.UUID
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	app_stock_id      *uuid.UUID
	app_good_id       *uuid.UUID
	units             *decimal.Decimal
	app_spot_units    *decimal.Decimal
	lock_state        *string
	charge_back_state *string
	ex_lock_id        *uuid.UUID
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*AppStockLock, error)
	predicates        []predicate.AppStockLock
}

var _ ent.Mutation = (*AppStockLockMutation)(nil)

// appstocklockOption allows management of the mutation configuration using functional options.
type appstocklockOption func(*AppStockLockMutation)

// newAppStockLockMutation creates new mutation for the AppStockLock entity.
func newAppStockLockMutation(c config, op Op, opts ...appstocklockOption) *AppStockLockMutation {
	m := &AppStockLockMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStockLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStockLockID sets the ID field of the mutation.
func withAppStockLockID(id uint32) appstocklockOption {
	return func(m *AppStockLockMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStockLock
		)
		m.oldValue = func(ctx context.Context) (*AppStockLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStockLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStockLock sets the old AppStockLock of the mutation.
func withAppStockLock(node *AppStockLock) appstocklockOption {
	return func(m *AppStockLockMutation) {
		m.oldValue = func(context.Context) (*AppStockLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStockLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStockLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppStockLock entities.
func (m *AppStockLockMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppStockLockMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppStockLockMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppStockLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppStockLockMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppStockLockMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppStockLockMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppStockLockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppStockLockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppStockLockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppStockLockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppStockLockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppStockLockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppStockLockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppStockLockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppStockLockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppStockLockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppStockLockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppStockLockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppStockLockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppStockLockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppStockLockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppStockID sets the "app_stock_id" field.
func (m *AppStockLockMutation) SetAppStockID(u uuid.UUID) {
	m.app_stock_id = &u
}

// AppStockID returns the value of the "app_stock_id" field in the mutation.
func (m *AppStockLockMutation) AppStockID() (r uuid.UUID, exists bool) {
	v := m.app_stock_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppStockID returns the old "app_stock_id" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldAppStockID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppStockID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppStockID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppStockID: %w", err)
	}
	return oldValue.AppStockID, nil
}

// ClearAppStockID clears the value of the "app_stock_id" field.
func (m *AppStockLockMutation) ClearAppStockID() {
	m.app_stock_id = nil
	m.clearedFields[appstocklock.FieldAppStockID] = struct{}{}
}

// AppStockIDCleared returns if the "app_stock_id" field was cleared in this mutation.
func (m *AppStockLockMutation) AppStockIDCleared() bool {
	_, ok := m.clearedFields[appstocklock.FieldAppStockID]
	return ok
}

// ResetAppStockID resets all changes to the "app_stock_id" field.
func (m *AppStockLockMutation) ResetAppStockID() {
	m.app_stock_id = nil
	delete(m.clearedFields, appstocklock.FieldAppStockID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppStockLockMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppStockLockMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppStockLockMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appstocklock.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppStockLockMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appstocklock.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppStockLockMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appstocklock.FieldAppGoodID)
}

// SetUnits sets the "units" field.
func (m *AppStockLockMutation) SetUnits(d decimal.Decimal) {
	m.units = &d
}

// Units returns the value of the "units" field in the mutation.
func (m *AppStockLockMutation) Units() (r decimal.Decimal, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldUnits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// ClearUnits clears the value of the "units" field.
func (m *AppStockLockMutation) ClearUnits() {
	m.units = nil
	m.clearedFields[appstocklock.FieldUnits] = struct{}{}
}

// UnitsCleared returns if the "units" field was cleared in this mutation.
func (m *AppStockLockMutation) UnitsCleared() bool {
	_, ok := m.clearedFields[appstocklock.FieldUnits]
	return ok
}

// ResetUnits resets all changes to the "units" field.
func (m *AppStockLockMutation) ResetUnits() {
	m.units = nil
	delete(m.clearedFields, appstocklock.FieldUnits)
}

// SetAppSpotUnits sets the "app_spot_units" field.
func (m *AppStockLockMutation) SetAppSpotUnits(d decimal.Decimal) {
	m.app_spot_units = &d
}

// AppSpotUnits returns the value of the "app_spot_units" field in the mutation.
func (m *AppStockLockMutation) AppSpotUnits() (r decimal.Decimal, exists bool) {
	v := m.app_spot_units
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSpotUnits returns the old "app_spot_units" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldAppSpotUnits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSpotUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSpotUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSpotUnits: %w", err)
	}
	return oldValue.AppSpotUnits, nil
}

// ClearAppSpotUnits clears the value of the "app_spot_units" field.
func (m *AppStockLockMutation) ClearAppSpotUnits() {
	m.app_spot_units = nil
	m.clearedFields[appstocklock.FieldAppSpotUnits] = struct{}{}
}

// AppSpotUnitsCleared returns if the "app_spot_units" field was cleared in this mutation.
func (m *AppStockLockMutation) AppSpotUnitsCleared() bool {
	_, ok := m.clearedFields[appstocklock.FieldAppSpotUnits]
	return ok
}

// ResetAppSpotUnits resets all changes to the "app_spot_units" field.
func (m *AppStockLockMutation) ResetAppSpotUnits() {
	m.app_spot_units = nil
	delete(m.clearedFields, appstocklock.FieldAppSpotUnits)
}

// SetLockState sets the "lock_state" field.
func (m *AppStockLockMutation) SetLockState(s string) {
	m.lock_state = &s
}

// LockState returns the value of the "lock_state" field in the mutation.
func (m *AppStockLockMutation) LockState() (r string, exists bool) {
	v := m.lock_state
	if v == nil {
		return
	}
	return *v, true
}

// OldLockState returns the old "lock_state" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldLockState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockState: %w", err)
	}
	return oldValue.LockState, nil
}

// ClearLockState clears the value of the "lock_state" field.
func (m *AppStockLockMutation) ClearLockState() {
	m.lock_state = nil
	m.clearedFields[appstocklock.FieldLockState] = struct{}{}
}

// LockStateCleared returns if the "lock_state" field was cleared in this mutation.
func (m *AppStockLockMutation) LockStateCleared() bool {
	_, ok := m.clearedFields[appstocklock.FieldLockState]
	return ok
}

// ResetLockState resets all changes to the "lock_state" field.
func (m *AppStockLockMutation) ResetLockState() {
	m.lock_state = nil
	delete(m.clearedFields, appstocklock.FieldLockState)
}

// SetChargeBackState sets the "charge_back_state" field.
func (m *AppStockLockMutation) SetChargeBackState(s string) {
	m.charge_back_state = &s
}

// ChargeBackState returns the value of the "charge_back_state" field in the mutation.
func (m *AppStockLockMutation) ChargeBackState() (r string, exists bool) {
	v := m.charge_back_state
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeBackState returns the old "charge_back_state" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldChargeBackState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeBackState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeBackState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeBackState: %w", err)
	}
	return oldValue.ChargeBackState, nil
}

// ClearChargeBackState clears the value of the "charge_back_state" field.
func (m *AppStockLockMutation) ClearChargeBackState() {
	m.charge_back_state = nil
	m.clearedFields[appstocklock.FieldChargeBackState] = struct{}{}
}

// ChargeBackStateCleared returns if the "charge_back_state" field was cleared in this mutation.
func (m *AppStockLockMutation) ChargeBackStateCleared() bool {
	_, ok := m.clearedFields[appstocklock.FieldChargeBackState]
	return ok
}

// ResetChargeBackState resets all changes to the "charge_back_state" field.
func (m *AppStockLockMutation) ResetChargeBackState() {
	m.charge_back_state = nil
	delete(m.clearedFields, appstocklock.FieldChargeBackState)
}

// SetExLockID sets the "ex_lock_id" field.
func (m *AppStockLockMutation) SetExLockID(u uuid.UUID) {
	m.ex_lock_id = &u
}

// ExLockID returns the value of the "ex_lock_id" field in the mutation.
func (m *AppStockLockMutation) ExLockID() (r uuid.UUID, exists bool) {
	v := m.ex_lock_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExLockID returns the old "ex_lock_id" field's value of the AppStockLock entity.
// If the AppStockLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockLockMutation) OldExLockID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExLockID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExLockID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExLockID: %w", err)
	}
	return oldValue.ExLockID, nil
}

// ClearExLockID clears the value of the "ex_lock_id" field.
func (m *AppStockLockMutation) ClearExLockID() {
	m.ex_lock_id = nil
	m.clearedFields[appstocklock.FieldExLockID] = struct{}{}
}

// ExLockIDCleared returns if the "ex_lock_id" field was cleared in this mutation.
func (m *AppStockLockMutation) ExLockIDCleared() bool {
	_, ok := m.clearedFields[appstocklock.FieldExLockID]
	return ok
}

// ResetExLockID resets all changes to the "ex_lock_id" field.
func (m *AppStockLockMutation) ResetExLockID() {
	m.ex_lock_id = nil
	delete(m.clearedFields, appstocklock.FieldExLockID)
}

// Where appends a list predicates to the AppStockLockMutation builder.
func (m *AppStockLockMutation) Where(ps ...predicate.AppStockLock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppStockLockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppStockLockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppStockLock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppStockLockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppStockLockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppStockLock).
func (m *AppStockLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppStockLockMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ent_id != nil {
		fields = append(fields, appstocklock.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appstocklock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appstocklock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appstocklock.FieldDeletedAt)
	}
	if m.app_stock_id != nil {
		fields = append(fields, appstocklock.FieldAppStockID)
	}
	if m.app_good_id != nil {
		fields = append(fields, appstocklock.FieldAppGoodID)
	}
	if m.units != nil {
		fields = append(fields, appstocklock.FieldUnits)
	}
	if m.app_spot_units != nil {
		fields = append(fields, appstocklock.FieldAppSpotUnits)
	}
	if m.lock_state != nil {
		fields = append(fields, appstocklock.FieldLockState)
	}
	if m.charge_back_state != nil {
		fields = append(fields, appstocklock.FieldChargeBackState)
	}
	if m.ex_lock_id != nil {
		fields = append(fields, appstocklock.FieldExLockID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppStockLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstocklock.FieldEntID:
		return m.EntID()
	case appstocklock.FieldCreatedAt:
		return m.CreatedAt()
	case appstocklock.FieldUpdatedAt:
		return m.UpdatedAt()
	case appstocklock.FieldDeletedAt:
		return m.DeletedAt()
	case appstocklock.FieldAppStockID:
		return m.AppStockID()
	case appstocklock.FieldAppGoodID:
		return m.AppGoodID()
	case appstocklock.FieldUnits:
		return m.Units()
	case appstocklock.FieldAppSpotUnits:
		return m.AppSpotUnits()
	case appstocklock.FieldLockState:
		return m.LockState()
	case appstocklock.FieldChargeBackState:
		return m.ChargeBackState()
	case appstocklock.FieldExLockID:
		return m.ExLockID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppStockLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstocklock.FieldEntID:
		return m.OldEntID(ctx)
	case appstocklock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appstocklock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appstocklock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appstocklock.FieldAppStockID:
		return m.OldAppStockID(ctx)
	case appstocklock.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appstocklock.FieldUnits:
		return m.OldUnits(ctx)
	case appstocklock.FieldAppSpotUnits:
		return m.OldAppSpotUnits(ctx)
	case appstocklock.FieldLockState:
		return m.OldLockState(ctx)
	case appstocklock.FieldChargeBackState:
		return m.OldChargeBackState(ctx)
	case appstocklock.FieldExLockID:
		return m.OldExLockID(ctx)
	}
	return nil, fmt.Errorf("unknown AppStockLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStockLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstocklock.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appstocklock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appstocklock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appstocklock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appstocklock.FieldAppStockID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppStockID(v)
		return nil
	case appstocklock.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appstocklock.FieldUnits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case appstocklock.FieldAppSpotUnits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSpotUnits(v)
		return nil
	case appstocklock.FieldLockState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockState(v)
		return nil
	case appstocklock.FieldChargeBackState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeBackState(v)
		return nil
	case appstocklock.FieldExLockID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExLockID(v)
		return nil
	}
	return fmt.Errorf("unknown AppStockLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppStockLockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appstocklock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appstocklock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appstocklock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppStockLockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appstocklock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appstocklock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appstocklock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStockLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appstocklock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appstocklock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appstocklock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppStockLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppStockLockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appstocklock.FieldAppStockID) {
		fields = append(fields, appstocklock.FieldAppStockID)
	}
	if m.FieldCleared(appstocklock.FieldAppGoodID) {
		fields = append(fields, appstocklock.FieldAppGoodID)
	}
	if m.FieldCleared(appstocklock.FieldUnits) {
		fields = append(fields, appstocklock.FieldUnits)
	}
	if m.FieldCleared(appstocklock.FieldAppSpotUnits) {
		fields = append(fields, appstocklock.FieldAppSpotUnits)
	}
	if m.FieldCleared(appstocklock.FieldLockState) {
		fields = append(fields, appstocklock.FieldLockState)
	}
	if m.FieldCleared(appstocklock.FieldChargeBackState) {
		fields = append(fields, appstocklock.FieldChargeBackState)
	}
	if m.FieldCleared(appstocklock.FieldExLockID) {
		fields = append(fields, appstocklock.FieldExLockID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppStockLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStockLockMutation) ClearField(name string) error {
	switch name {
	case appstocklock.FieldAppStockID:
		m.ClearAppStockID()
		return nil
	case appstocklock.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appstocklock.FieldUnits:
		m.ClearUnits()
		return nil
	case appstocklock.FieldAppSpotUnits:
		m.ClearAppSpotUnits()
		return nil
	case appstocklock.FieldLockState:
		m.ClearLockState()
		return nil
	case appstocklock.FieldChargeBackState:
		m.ClearChargeBackState()
		return nil
	case appstocklock.FieldExLockID:
		m.ClearExLockID()
		return nil
	}
	return fmt.Errorf("unknown AppStockLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppStockLockMutation) ResetField(name string) error {
	switch name {
	case appstocklock.FieldEntID:
		m.ResetEntID()
		return nil
	case appstocklock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appstocklock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appstocklock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appstocklock.FieldAppStockID:
		m.ResetAppStockID()
		return nil
	case appstocklock.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appstocklock.FieldUnits:
		m.ResetUnits()
		return nil
	case appstocklock.FieldAppSpotUnits:
		m.ResetAppSpotUnits()
		return nil
	case appstocklock.FieldLockState:
		m.ResetLockState()
		return nil
	case appstocklock.FieldChargeBackState:
		m.ResetChargeBackState()
		return nil
	case appstocklock.FieldExLockID:
		m.ResetExLockID()
		return nil
	}
	return fmt.Errorf("unknown AppStockLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppStockLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppStockLockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppStockLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppStockLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppStockLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppStockLockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppStockLockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppStockLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppStockLockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppStockLock edge %s", name)
}

// AppSubscriptionMutation represents an operation that mutates the AppSubscription nodes in the graph.
type AppSubscriptionMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	good_id       *uuid.UUID
	app_good_id   *uuid.UUID
	name          *string
	banner        *string
	usd_price     *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppSubscription, error)
	predicates    []predicate.AppSubscription
}

var _ ent.Mutation = (*AppSubscriptionMutation)(nil)

// appsubscriptionOption allows management of the mutation configuration using functional options.
type appsubscriptionOption func(*AppSubscriptionMutation)

// newAppSubscriptionMutation creates new mutation for the AppSubscription entity.
func newAppSubscriptionMutation(c config, op Op, opts ...appsubscriptionOption) *AppSubscriptionMutation {
	m := &AppSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppSubscriptionID sets the ID field of the mutation.
func withAppSubscriptionID(id uint32) appsubscriptionOption {
	return func(m *AppSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppSubscription
		)
		m.oldValue = func(ctx context.Context) (*AppSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppSubscription sets the old AppSubscription of the mutation.
func withAppSubscription(node *AppSubscription) appsubscriptionOption {
	return func(m *AppSubscriptionMutation) {
		m.oldValue = func(context.Context) (*AppSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppSubscription entities.
func (m *AppSubscriptionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppSubscriptionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppSubscriptionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppSubscriptionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppSubscriptionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppSubscriptionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppSubscriptionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppSubscriptionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppSubscriptionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppSubscriptionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppSubscriptionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppSubscriptionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppSubscriptionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppSubscriptionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppSubscriptionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppSubscriptionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppSubscriptionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppSubscriptionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppSubscriptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppSubscriptionMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppSubscriptionMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppSubscriptionMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appsubscription.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppSubscriptionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appsubscription.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppSubscriptionMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appsubscription.FieldAppID)
}

// SetGoodID sets the "good_id" field.
func (m *AppSubscriptionMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppSubscriptionMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *AppSubscriptionMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[appsubscription.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *AppSubscriptionMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[appsubscription.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppSubscriptionMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, appsubscription.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppSubscriptionMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppSubscriptionMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppSubscriptionMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appsubscription.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppSubscriptionMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appsubscription.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppSubscriptionMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appsubscription.FieldAppGoodID)
}

// SetName sets the "name" field.
func (m *AppSubscriptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppSubscriptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppSubscriptionMutation) ClearName() {
	m.name = nil
	m.clearedFields[appsubscription.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppSubscriptionMutation) NameCleared() bool {
	_, ok := m.clearedFields[appsubscription.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppSubscriptionMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, appsubscription.FieldName)
}

// SetBanner sets the "banner" field.
func (m *AppSubscriptionMutation) SetBanner(s string) {
	m.banner = &s
}

// Banner returns the value of the "banner" field in the mutation.
func (m *AppSubscriptionMutation) Banner() (r string, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBanner returns the old "banner" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanner: %w", err)
	}
	return oldValue.Banner, nil
}

// ClearBanner clears the value of the "banner" field.
func (m *AppSubscriptionMutation) ClearBanner() {
	m.banner = nil
	m.clearedFields[appsubscription.FieldBanner] = struct{}{}
}

// BannerCleared returns if the "banner" field was cleared in this mutation.
func (m *AppSubscriptionMutation) BannerCleared() bool {
	_, ok := m.clearedFields[appsubscription.FieldBanner]
	return ok
}

// ResetBanner resets all changes to the "banner" field.
func (m *AppSubscriptionMutation) ResetBanner() {
	m.banner = nil
	delete(m.clearedFields, appsubscription.FieldBanner)
}

// SetUsdPrice sets the "usd_price" field.
func (m *AppSubscriptionMutation) SetUsdPrice(d decimal.Decimal) {
	m.usd_price = &d
}

// UsdPrice returns the value of the "usd_price" field in the mutation.
func (m *AppSubscriptionMutation) UsdPrice() (r decimal.Decimal, exists bool) {
	v := m.usd_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdPrice returns the old "usd_price" field's value of the AppSubscription entity.
// If the AppSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionMutation) OldUsdPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdPrice: %w", err)
	}
	return oldValue.UsdPrice, nil
}

// ClearUsdPrice clears the value of the "usd_price" field.
func (m *AppSubscriptionMutation) ClearUsdPrice() {
	m.usd_price = nil
	m.clearedFields[appsubscription.FieldUsdPrice] = struct{}{}
}

// UsdPriceCleared returns if the "usd_price" field was cleared in this mutation.
func (m *AppSubscriptionMutation) UsdPriceCleared() bool {
	_, ok := m.clearedFields[appsubscription.FieldUsdPrice]
	return ok
}

// ResetUsdPrice resets all changes to the "usd_price" field.
func (m *AppSubscriptionMutation) ResetUsdPrice() {
	m.usd_price = nil
	delete(m.clearedFields, appsubscription.FieldUsdPrice)
}

// Where appends a list predicates to the AppSubscriptionMutation builder.
func (m *AppSubscriptionMutation) Where(ps ...predicate.AppSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppSubscription).
func (m *AppSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ent_id != nil {
		fields = append(fields, appsubscription.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appsubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appsubscription.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appsubscription.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appsubscription.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appsubscription.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, appsubscription.FieldAppGoodID)
	}
	if m.name != nil {
		fields = append(fields, appsubscription.FieldName)
	}
	if m.banner != nil {
		fields = append(fields, appsubscription.FieldBanner)
	}
	if m.usd_price != nil {
		fields = append(fields, appsubscription.FieldUsdPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appsubscription.FieldEntID:
		return m.EntID()
	case appsubscription.FieldCreatedAt:
		return m.CreatedAt()
	case appsubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case appsubscription.FieldDeletedAt:
		return m.DeletedAt()
	case appsubscription.FieldAppID:
		return m.AppID()
	case appsubscription.FieldGoodID:
		return m.GoodID()
	case appsubscription.FieldAppGoodID:
		return m.AppGoodID()
	case appsubscription.FieldName:
		return m.Name()
	case appsubscription.FieldBanner:
		return m.Banner()
	case appsubscription.FieldUsdPrice:
		return m.UsdPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appsubscription.FieldEntID:
		return m.OldEntID(ctx)
	case appsubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appsubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appsubscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appsubscription.FieldAppID:
		return m.OldAppID(ctx)
	case appsubscription.FieldGoodID:
		return m.OldGoodID(ctx)
	case appsubscription.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appsubscription.FieldName:
		return m.OldName(ctx)
	case appsubscription.FieldBanner:
		return m.OldBanner(ctx)
	case appsubscription.FieldUsdPrice:
		return m.OldUsdPrice(ctx)
	}
	return nil, fmt.Errorf("unknown AppSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appsubscription.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appsubscription.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appsubscription.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appsubscription.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appsubscription.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appsubscription.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appsubscription.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appsubscription.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appsubscription.FieldBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanner(v)
		return nil
	case appsubscription.FieldUsdPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdPrice(v)
		return nil
	}
	return fmt.Errorf("unknown AppSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppSubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appsubscription.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appsubscription.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appsubscription.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appsubscription.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appsubscription.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appsubscription.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appsubscription.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appsubscription.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appsubscription.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppSubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appsubscription.FieldAppID) {
		fields = append(fields, appsubscription.FieldAppID)
	}
	if m.FieldCleared(appsubscription.FieldGoodID) {
		fields = append(fields, appsubscription.FieldGoodID)
	}
	if m.FieldCleared(appsubscription.FieldAppGoodID) {
		fields = append(fields, appsubscription.FieldAppGoodID)
	}
	if m.FieldCleared(appsubscription.FieldName) {
		fields = append(fields, appsubscription.FieldName)
	}
	if m.FieldCleared(appsubscription.FieldBanner) {
		fields = append(fields, appsubscription.FieldBanner)
	}
	if m.FieldCleared(appsubscription.FieldUsdPrice) {
		fields = append(fields, appsubscription.FieldUsdPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppSubscriptionMutation) ClearField(name string) error {
	switch name {
	case appsubscription.FieldAppID:
		m.ClearAppID()
		return nil
	case appsubscription.FieldGoodID:
		m.ClearGoodID()
		return nil
	case appsubscription.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appsubscription.FieldName:
		m.ClearName()
		return nil
	case appsubscription.FieldBanner:
		m.ClearBanner()
		return nil
	case appsubscription.FieldUsdPrice:
		m.ClearUsdPrice()
		return nil
	}
	return fmt.Errorf("unknown AppSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppSubscriptionMutation) ResetField(name string) error {
	switch name {
	case appsubscription.FieldEntID:
		m.ResetEntID()
		return nil
	case appsubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appsubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appsubscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appsubscription.FieldAppID:
		m.ResetAppID()
		return nil
	case appsubscription.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appsubscription.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appsubscription.FieldName:
		m.ResetName()
		return nil
	case appsubscription.FieldBanner:
		m.ResetBanner()
		return nil
	case appsubscription.FieldUsdPrice:
		m.ResetUsdPrice()
		return nil
	}
	return fmt.Errorf("unknown AppSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppSubscriptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppSubscriptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppSubscriptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppSubscriptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppSubscription edge %s", name)
}

// AppSubscriptionOneShotMutation represents an operation that mutates the AppSubscriptionOneShot nodes in the graph.
type AppSubscriptionOneShotMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	good_id       *uuid.UUID
	app_good_id   *uuid.UUID
	name          *string
	banner        *string
	usd_price     *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppSubscriptionOneShot, error)
	predicates    []predicate.AppSubscriptionOneShot
}

var _ ent.Mutation = (*AppSubscriptionOneShotMutation)(nil)

// appsubscriptiononeshotOption allows management of the mutation configuration using functional options.
type appsubscriptiononeshotOption func(*AppSubscriptionOneShotMutation)

// newAppSubscriptionOneShotMutation creates new mutation for the AppSubscriptionOneShot entity.
func newAppSubscriptionOneShotMutation(c config, op Op, opts ...appsubscriptiononeshotOption) *AppSubscriptionOneShotMutation {
	m := &AppSubscriptionOneShotMutation{
		config:        c,
		op:            op,
		typ:           TypeAppSubscriptionOneShot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppSubscriptionOneShotID sets the ID field of the mutation.
func withAppSubscriptionOneShotID(id uint32) appsubscriptiononeshotOption {
	return func(m *AppSubscriptionOneShotMutation) {
		var (
			err   error
			once  sync.Once
			value *AppSubscriptionOneShot
		)
		m.oldValue = func(ctx context.Context) (*AppSubscriptionOneShot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppSubscriptionOneShot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppSubscriptionOneShot sets the old AppSubscriptionOneShot of the mutation.
func withAppSubscriptionOneShot(node *AppSubscriptionOneShot) appsubscriptiononeshotOption {
	return func(m *AppSubscriptionOneShotMutation) {
		m.oldValue = func(context.Context) (*AppSubscriptionOneShot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppSubscriptionOneShotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppSubscriptionOneShotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppSubscriptionOneShot entities.
func (m *AppSubscriptionOneShotMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppSubscriptionOneShotMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppSubscriptionOneShotMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppSubscriptionOneShot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *AppSubscriptionOneShotMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppSubscriptionOneShotMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppSubscriptionOneShotMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppSubscriptionOneShotMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppSubscriptionOneShotMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppSubscriptionOneShotMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppSubscriptionOneShotMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppSubscriptionOneShotMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppSubscriptionOneShotMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppSubscriptionOneShotMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppSubscriptionOneShotMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppSubscriptionOneShotMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppSubscriptionOneShotMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppSubscriptionOneShotMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppSubscriptionOneShotMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppSubscriptionOneShotMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppSubscriptionOneShotMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppSubscriptionOneShotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppSubscriptionOneShotMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppSubscriptionOneShotMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppSubscriptionOneShotMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appsubscriptiononeshot.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appsubscriptiononeshot.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppSubscriptionOneShotMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appsubscriptiononeshot.FieldAppID)
}

// SetGoodID sets the "good_id" field.
func (m *AppSubscriptionOneShotMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppSubscriptionOneShotMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *AppSubscriptionOneShotMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[appsubscriptiononeshot.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[appsubscriptiononeshot.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppSubscriptionOneShotMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, appsubscriptiononeshot.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppSubscriptionOneShotMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppSubscriptionOneShotMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppSubscriptionOneShotMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appsubscriptiononeshot.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appsubscriptiononeshot.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppSubscriptionOneShotMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appsubscriptiononeshot.FieldAppGoodID)
}

// SetName sets the "name" field.
func (m *AppSubscriptionOneShotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppSubscriptionOneShotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppSubscriptionOneShotMutation) ClearName() {
	m.name = nil
	m.clearedFields[appsubscriptiononeshot.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) NameCleared() bool {
	_, ok := m.clearedFields[appsubscriptiononeshot.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppSubscriptionOneShotMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, appsubscriptiononeshot.FieldName)
}

// SetBanner sets the "banner" field.
func (m *AppSubscriptionOneShotMutation) SetBanner(s string) {
	m.banner = &s
}

// Banner returns the value of the "banner" field in the mutation.
func (m *AppSubscriptionOneShotMutation) Banner() (r string, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBanner returns the old "banner" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanner: %w", err)
	}
	return oldValue.Banner, nil
}

// ClearBanner clears the value of the "banner" field.
func (m *AppSubscriptionOneShotMutation) ClearBanner() {
	m.banner = nil
	m.clearedFields[appsubscriptiononeshot.FieldBanner] = struct{}{}
}

// BannerCleared returns if the "banner" field was cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) BannerCleared() bool {
	_, ok := m.clearedFields[appsubscriptiononeshot.FieldBanner]
	return ok
}

// ResetBanner resets all changes to the "banner" field.
func (m *AppSubscriptionOneShotMutation) ResetBanner() {
	m.banner = nil
	delete(m.clearedFields, appsubscriptiononeshot.FieldBanner)
}

// SetUsdPrice sets the "usd_price" field.
func (m *AppSubscriptionOneShotMutation) SetUsdPrice(d decimal.Decimal) {
	m.usd_price = &d
}

// UsdPrice returns the value of the "usd_price" field in the mutation.
func (m *AppSubscriptionOneShotMutation) UsdPrice() (r decimal.Decimal, exists bool) {
	v := m.usd_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdPrice returns the old "usd_price" field's value of the AppSubscriptionOneShot entity.
// If the AppSubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscriptionOneShotMutation) OldUsdPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdPrice: %w", err)
	}
	return oldValue.UsdPrice, nil
}

// ClearUsdPrice clears the value of the "usd_price" field.
func (m *AppSubscriptionOneShotMutation) ClearUsdPrice() {
	m.usd_price = nil
	m.clearedFields[appsubscriptiononeshot.FieldUsdPrice] = struct{}{}
}

// UsdPriceCleared returns if the "usd_price" field was cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) UsdPriceCleared() bool {
	_, ok := m.clearedFields[appsubscriptiononeshot.FieldUsdPrice]
	return ok
}

// ResetUsdPrice resets all changes to the "usd_price" field.
func (m *AppSubscriptionOneShotMutation) ResetUsdPrice() {
	m.usd_price = nil
	delete(m.clearedFields, appsubscriptiononeshot.FieldUsdPrice)
}

// Where appends a list predicates to the AppSubscriptionOneShotMutation builder.
func (m *AppSubscriptionOneShotMutation) Where(ps ...predicate.AppSubscriptionOneShot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppSubscriptionOneShotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppSubscriptionOneShotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppSubscriptionOneShot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppSubscriptionOneShotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppSubscriptionOneShotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppSubscriptionOneShot).
func (m *AppSubscriptionOneShotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppSubscriptionOneShotMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ent_id != nil {
		fields = append(fields, appsubscriptiononeshot.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, appsubscriptiononeshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appsubscriptiononeshot.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appsubscriptiononeshot.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appsubscriptiononeshot.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appsubscriptiononeshot.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, appsubscriptiononeshot.FieldAppGoodID)
	}
	if m.name != nil {
		fields = append(fields, appsubscriptiononeshot.FieldName)
	}
	if m.banner != nil {
		fields = append(fields, appsubscriptiononeshot.FieldBanner)
	}
	if m.usd_price != nil {
		fields = append(fields, appsubscriptiononeshot.FieldUsdPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppSubscriptionOneShotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appsubscriptiononeshot.FieldEntID:
		return m.EntID()
	case appsubscriptiononeshot.FieldCreatedAt:
		return m.CreatedAt()
	case appsubscriptiononeshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case appsubscriptiononeshot.FieldDeletedAt:
		return m.DeletedAt()
	case appsubscriptiononeshot.FieldAppID:
		return m.AppID()
	case appsubscriptiononeshot.FieldGoodID:
		return m.GoodID()
	case appsubscriptiononeshot.FieldAppGoodID:
		return m.AppGoodID()
	case appsubscriptiononeshot.FieldName:
		return m.Name()
	case appsubscriptiononeshot.FieldBanner:
		return m.Banner()
	case appsubscriptiononeshot.FieldUsdPrice:
		return m.UsdPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppSubscriptionOneShotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appsubscriptiononeshot.FieldEntID:
		return m.OldEntID(ctx)
	case appsubscriptiononeshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appsubscriptiononeshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appsubscriptiononeshot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appsubscriptiononeshot.FieldAppID:
		return m.OldAppID(ctx)
	case appsubscriptiononeshot.FieldGoodID:
		return m.OldGoodID(ctx)
	case appsubscriptiononeshot.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appsubscriptiononeshot.FieldName:
		return m.OldName(ctx)
	case appsubscriptiononeshot.FieldBanner:
		return m.OldBanner(ctx)
	case appsubscriptiononeshot.FieldUsdPrice:
		return m.OldUsdPrice(ctx)
	}
	return nil, fmt.Errorf("unknown AppSubscriptionOneShot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSubscriptionOneShotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appsubscriptiononeshot.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appsubscriptiononeshot.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appsubscriptiononeshot.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appsubscriptiononeshot.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appsubscriptiononeshot.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appsubscriptiononeshot.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appsubscriptiononeshot.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appsubscriptiononeshot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appsubscriptiononeshot.FieldBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanner(v)
		return nil
	case appsubscriptiononeshot.FieldUsdPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdPrice(v)
		return nil
	}
	return fmt.Errorf("unknown AppSubscriptionOneShot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppSubscriptionOneShotMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appsubscriptiononeshot.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appsubscriptiononeshot.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appsubscriptiononeshot.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppSubscriptionOneShotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appsubscriptiononeshot.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appsubscriptiononeshot.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appsubscriptiononeshot.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSubscriptionOneShotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appsubscriptiononeshot.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appsubscriptiononeshot.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appsubscriptiononeshot.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppSubscriptionOneShot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppSubscriptionOneShotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appsubscriptiononeshot.FieldAppID) {
		fields = append(fields, appsubscriptiononeshot.FieldAppID)
	}
	if m.FieldCleared(appsubscriptiononeshot.FieldGoodID) {
		fields = append(fields, appsubscriptiononeshot.FieldGoodID)
	}
	if m.FieldCleared(appsubscriptiononeshot.FieldAppGoodID) {
		fields = append(fields, appsubscriptiononeshot.FieldAppGoodID)
	}
	if m.FieldCleared(appsubscriptiononeshot.FieldName) {
		fields = append(fields, appsubscriptiononeshot.FieldName)
	}
	if m.FieldCleared(appsubscriptiononeshot.FieldBanner) {
		fields = append(fields, appsubscriptiononeshot.FieldBanner)
	}
	if m.FieldCleared(appsubscriptiononeshot.FieldUsdPrice) {
		fields = append(fields, appsubscriptiononeshot.FieldUsdPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppSubscriptionOneShotMutation) ClearField(name string) error {
	switch name {
	case appsubscriptiononeshot.FieldAppID:
		m.ClearAppID()
		return nil
	case appsubscriptiononeshot.FieldGoodID:
		m.ClearGoodID()
		return nil
	case appsubscriptiononeshot.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appsubscriptiononeshot.FieldName:
		m.ClearName()
		return nil
	case appsubscriptiononeshot.FieldBanner:
		m.ClearBanner()
		return nil
	case appsubscriptiononeshot.FieldUsdPrice:
		m.ClearUsdPrice()
		return nil
	}
	return fmt.Errorf("unknown AppSubscriptionOneShot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppSubscriptionOneShotMutation) ResetField(name string) error {
	switch name {
	case appsubscriptiononeshot.FieldEntID:
		m.ResetEntID()
		return nil
	case appsubscriptiononeshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appsubscriptiononeshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appsubscriptiononeshot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appsubscriptiononeshot.FieldAppID:
		m.ResetAppID()
		return nil
	case appsubscriptiononeshot.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appsubscriptiononeshot.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appsubscriptiononeshot.FieldName:
		m.ResetName()
		return nil
	case appsubscriptiononeshot.FieldBanner:
		m.ResetBanner()
		return nil
	case appsubscriptiononeshot.FieldUsdPrice:
		m.ResetUsdPrice()
		return nil
	}
	return fmt.Errorf("unknown AppSubscriptionOneShot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppSubscriptionOneShotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppSubscriptionOneShotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppSubscriptionOneShotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppSubscriptionOneShotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppSubscriptionOneShotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppSubscriptionOneShotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppSubscriptionOneShot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppSubscriptionOneShotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppSubscriptionOneShot edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	ent_id         *uuid.UUID
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	user_id        *uuid.UUID
	app_good_id    *uuid.UUID
	order_id       *uuid.UUID
	content        *string
	reply_to_id    *uuid.UUID
	anonymous      *bool
	trial_user     *bool
	purchased_user *bool
	hide           *bool
	hide_reason    *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Comment, error)
	predicates     []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uint32) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *CommentMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CommentMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CommentMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CommentMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CommentMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CommentMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CommentMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CommentMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CommentMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CommentMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CommentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, comment.FieldUserID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *CommentMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *CommentMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *CommentMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[comment.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *CommentMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *CommentMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, comment.FieldAppGoodID)
}

// SetOrderID sets the "order_id" field.
func (m *CommentMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CommentMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *CommentMutation) ClearOrderID() {
	m.order_id = nil
	m.clearedFields[comment.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *CommentMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CommentMutation) ResetOrderID() {
	m.order_id = nil
	delete(m.clearedFields, comment.FieldOrderID)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *CommentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[comment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *CommentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[comment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, comment.FieldContent)
}

// SetReplyToID sets the "reply_to_id" field.
func (m *CommentMutation) SetReplyToID(u uuid.UUID) {
	m.reply_to_id = &u
}

// ReplyToID returns the value of the "reply_to_id" field in the mutation.
func (m *CommentMutation) ReplyToID() (r uuid.UUID, exists bool) {
	v := m.reply_to_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToID returns the old "reply_to_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyToID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToID: %w", err)
	}
	return oldValue.ReplyToID, nil
}

// ClearReplyToID clears the value of the "reply_to_id" field.
func (m *CommentMutation) ClearReplyToID() {
	m.reply_to_id = nil
	m.clearedFields[comment.FieldReplyToID] = struct{}{}
}

// ReplyToIDCleared returns if the "reply_to_id" field was cleared in this mutation.
func (m *CommentMutation) ReplyToIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyToID]
	return ok
}

// ResetReplyToID resets all changes to the "reply_to_id" field.
func (m *CommentMutation) ResetReplyToID() {
	m.reply_to_id = nil
	delete(m.clearedFields, comment.FieldReplyToID)
}

// SetAnonymous sets the "anonymous" field.
func (m *CommentMutation) SetAnonymous(b bool) {
	m.anonymous = &b
}

// Anonymous returns the value of the "anonymous" field in the mutation.
func (m *CommentMutation) Anonymous() (r bool, exists bool) {
	v := m.anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldAnonymous returns the old "anonymous" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnonymous: %w", err)
	}
	return oldValue.Anonymous, nil
}

// ClearAnonymous clears the value of the "anonymous" field.
func (m *CommentMutation) ClearAnonymous() {
	m.anonymous = nil
	m.clearedFields[comment.FieldAnonymous] = struct{}{}
}

// AnonymousCleared returns if the "anonymous" field was cleared in this mutation.
func (m *CommentMutation) AnonymousCleared() bool {
	_, ok := m.clearedFields[comment.FieldAnonymous]
	return ok
}

// ResetAnonymous resets all changes to the "anonymous" field.
func (m *CommentMutation) ResetAnonymous() {
	m.anonymous = nil
	delete(m.clearedFields, comment.FieldAnonymous)
}

// SetTrialUser sets the "trial_user" field.
func (m *CommentMutation) SetTrialUser(b bool) {
	m.trial_user = &b
}

// TrialUser returns the value of the "trial_user" field in the mutation.
func (m *CommentMutation) TrialUser() (r bool, exists bool) {
	v := m.trial_user
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialUser returns the old "trial_user" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldTrialUser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialUser: %w", err)
	}
	return oldValue.TrialUser, nil
}

// ClearTrialUser clears the value of the "trial_user" field.
func (m *CommentMutation) ClearTrialUser() {
	m.trial_user = nil
	m.clearedFields[comment.FieldTrialUser] = struct{}{}
}

// TrialUserCleared returns if the "trial_user" field was cleared in this mutation.
func (m *CommentMutation) TrialUserCleared() bool {
	_, ok := m.clearedFields[comment.FieldTrialUser]
	return ok
}

// ResetTrialUser resets all changes to the "trial_user" field.
func (m *CommentMutation) ResetTrialUser() {
	m.trial_user = nil
	delete(m.clearedFields, comment.FieldTrialUser)
}

// SetPurchasedUser sets the "purchased_user" field.
func (m *CommentMutation) SetPurchasedUser(b bool) {
	m.purchased_user = &b
}

// PurchasedUser returns the value of the "purchased_user" field in the mutation.
func (m *CommentMutation) PurchasedUser() (r bool, exists bool) {
	v := m.purchased_user
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchasedUser returns the old "purchased_user" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPurchasedUser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchasedUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchasedUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchasedUser: %w", err)
	}
	return oldValue.PurchasedUser, nil
}

// ClearPurchasedUser clears the value of the "purchased_user" field.
func (m *CommentMutation) ClearPurchasedUser() {
	m.purchased_user = nil
	m.clearedFields[comment.FieldPurchasedUser] = struct{}{}
}

// PurchasedUserCleared returns if the "purchased_user" field was cleared in this mutation.
func (m *CommentMutation) PurchasedUserCleared() bool {
	_, ok := m.clearedFields[comment.FieldPurchasedUser]
	return ok
}

// ResetPurchasedUser resets all changes to the "purchased_user" field.
func (m *CommentMutation) ResetPurchasedUser() {
	m.purchased_user = nil
	delete(m.clearedFields, comment.FieldPurchasedUser)
}

// SetHide sets the "hide" field.
func (m *CommentMutation) SetHide(b bool) {
	m.hide = &b
}

// Hide returns the value of the "hide" field in the mutation.
func (m *CommentMutation) Hide() (r bool, exists bool) {
	v := m.hide
	if v == nil {
		return
	}
	return *v, true
}

// OldHide returns the old "hide" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldHide(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHide: %w", err)
	}
	return oldValue.Hide, nil
}

// ClearHide clears the value of the "hide" field.
func (m *CommentMutation) ClearHide() {
	m.hide = nil
	m.clearedFields[comment.FieldHide] = struct{}{}
}

// HideCleared returns if the "hide" field was cleared in this mutation.
func (m *CommentMutation) HideCleared() bool {
	_, ok := m.clearedFields[comment.FieldHide]
	return ok
}

// ResetHide resets all changes to the "hide" field.
func (m *CommentMutation) ResetHide() {
	m.hide = nil
	delete(m.clearedFields, comment.FieldHide)
}

// SetHideReason sets the "hide_reason" field.
func (m *CommentMutation) SetHideReason(s string) {
	m.hide_reason = &s
}

// HideReason returns the value of the "hide_reason" field in the mutation.
func (m *CommentMutation) HideReason() (r string, exists bool) {
	v := m.hide_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldHideReason returns the old "hide_reason" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldHideReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideReason: %w", err)
	}
	return oldValue.HideReason, nil
}

// ClearHideReason clears the value of the "hide_reason" field.
func (m *CommentMutation) ClearHideReason() {
	m.hide_reason = nil
	m.clearedFields[comment.FieldHideReason] = struct{}{}
}

// HideReasonCleared returns if the "hide_reason" field was cleared in this mutation.
func (m *CommentMutation) HideReasonCleared() bool {
	_, ok := m.clearedFields[comment.FieldHideReason]
	return ok
}

// ResetHideReason resets all changes to the "hide_reason" field.
func (m *CommentMutation) ResetHideReason() {
	m.hide_reason = nil
	delete(m.clearedFields, comment.FieldHideReason)
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.ent_id != nil {
		fields = append(fields, comment.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.app_good_id != nil {
		fields = append(fields, comment.FieldAppGoodID)
	}
	if m.order_id != nil {
		fields = append(fields, comment.FieldOrderID)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.reply_to_id != nil {
		fields = append(fields, comment.FieldReplyToID)
	}
	if m.anonymous != nil {
		fields = append(fields, comment.FieldAnonymous)
	}
	if m.trial_user != nil {
		fields = append(fields, comment.FieldTrialUser)
	}
	if m.purchased_user != nil {
		fields = append(fields, comment.FieldPurchasedUser)
	}
	if m.hide != nil {
		fields = append(fields, comment.FieldHide)
	}
	if m.hide_reason != nil {
		fields = append(fields, comment.FieldHideReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldEntID:
		return m.EntID()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldAppGoodID:
		return m.AppGoodID()
	case comment.FieldOrderID:
		return m.OrderID()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldReplyToID:
		return m.ReplyToID()
	case comment.FieldAnonymous:
		return m.Anonymous()
	case comment.FieldTrialUser:
		return m.TrialUser()
	case comment.FieldPurchasedUser:
		return m.PurchasedUser()
	case comment.FieldHide:
		return m.Hide()
	case comment.FieldHideReason:
		return m.HideReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldEntID:
		return m.OldEntID(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case comment.FieldOrderID:
		return m.OldOrderID(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldReplyToID:
		return m.OldReplyToID(ctx)
	case comment.FieldAnonymous:
		return m.OldAnonymous(ctx)
	case comment.FieldTrialUser:
		return m.OldTrialUser(ctx)
	case comment.FieldPurchasedUser:
		return m.OldPurchasedUser(ctx)
	case comment.FieldHide:
		return m.OldHide(ctx)
	case comment.FieldHideReason:
		return m.OldHideReason(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case comment.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldReplyToID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToID(v)
		return nil
	case comment.FieldAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnonymous(v)
		return nil
	case comment.FieldTrialUser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialUser(v)
		return nil
	case comment.FieldPurchasedUser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchasedUser(v)
		return nil
	case comment.FieldHide:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHide(v)
		return nil
	case comment.FieldHideReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideReason(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.AddedCreatedAt()
	case comment.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case comment.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldUserID) {
		fields = append(fields, comment.FieldUserID)
	}
	if m.FieldCleared(comment.FieldAppGoodID) {
		fields = append(fields, comment.FieldAppGoodID)
	}
	if m.FieldCleared(comment.FieldOrderID) {
		fields = append(fields, comment.FieldOrderID)
	}
	if m.FieldCleared(comment.FieldContent) {
		fields = append(fields, comment.FieldContent)
	}
	if m.FieldCleared(comment.FieldReplyToID) {
		fields = append(fields, comment.FieldReplyToID)
	}
	if m.FieldCleared(comment.FieldAnonymous) {
		fields = append(fields, comment.FieldAnonymous)
	}
	if m.FieldCleared(comment.FieldTrialUser) {
		fields = append(fields, comment.FieldTrialUser)
	}
	if m.FieldCleared(comment.FieldPurchasedUser) {
		fields = append(fields, comment.FieldPurchasedUser)
	}
	if m.FieldCleared(comment.FieldHide) {
		fields = append(fields, comment.FieldHide)
	}
	if m.FieldCleared(comment.FieldHideReason) {
		fields = append(fields, comment.FieldHideReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldUserID:
		m.ClearUserID()
		return nil
	case comment.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case comment.FieldOrderID:
		m.ClearOrderID()
		return nil
	case comment.FieldContent:
		m.ClearContent()
		return nil
	case comment.FieldReplyToID:
		m.ClearReplyToID()
		return nil
	case comment.FieldAnonymous:
		m.ClearAnonymous()
		return nil
	case comment.FieldTrialUser:
		m.ClearTrialUser()
		return nil
	case comment.FieldPurchasedUser:
		m.ClearPurchasedUser()
		return nil
	case comment.FieldHide:
		m.ClearHide()
		return nil
	case comment.FieldHideReason:
		m.ClearHideReason()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldEntID:
		m.ResetEntID()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case comment.FieldOrderID:
		m.ResetOrderID()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldReplyToID:
		m.ResetReplyToID()
		return nil
	case comment.FieldAnonymous:
		m.ResetAnonymous()
		return nil
	case comment.FieldTrialUser:
		m.ResetTrialUser()
		return nil
	case comment.FieldPurchasedUser:
		m.ResetPurchasedUser()
		return nil
	case comment.FieldHide:
		m.ResetHide()
		return nil
	case comment.FieldHideReason:
		m.ResetHideReason()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Comment edge %s", name)
}

// DelegatedStakingMutation represents an operation that mutates the DelegatedStaking nodes in the graph.
type DelegatedStakingMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	ent_id               *uuid.UUID
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	good_id              *uuid.UUID
	contract_code_url    *string
	contract_code_branch *string
	contract_state       *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*DelegatedStaking, error)
	predicates           []predicate.DelegatedStaking
}

var _ ent.Mutation = (*DelegatedStakingMutation)(nil)

// delegatedstakingOption allows management of the mutation configuration using functional options.
type delegatedstakingOption func(*DelegatedStakingMutation)

// newDelegatedStakingMutation creates new mutation for the DelegatedStaking entity.
func newDelegatedStakingMutation(c config, op Op, opts ...delegatedstakingOption) *DelegatedStakingMutation {
	m := &DelegatedStakingMutation{
		config:        c,
		op:            op,
		typ:           TypeDelegatedStaking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDelegatedStakingID sets the ID field of the mutation.
func withDelegatedStakingID(id uint32) delegatedstakingOption {
	return func(m *DelegatedStakingMutation) {
		var (
			err   error
			once  sync.Once
			value *DelegatedStaking
		)
		m.oldValue = func(ctx context.Context) (*DelegatedStaking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DelegatedStaking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDelegatedStaking sets the old DelegatedStaking of the mutation.
func withDelegatedStaking(node *DelegatedStaking) delegatedstakingOption {
	return func(m *DelegatedStakingMutation) {
		m.oldValue = func(context.Context) (*DelegatedStaking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DelegatedStakingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DelegatedStakingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DelegatedStaking entities.
func (m *DelegatedStakingMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DelegatedStakingMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DelegatedStakingMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DelegatedStaking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *DelegatedStakingMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *DelegatedStakingMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the DelegatedStaking entity.
// If the DelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatedStakingMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *DelegatedStakingMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DelegatedStakingMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DelegatedStakingMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DelegatedStaking entity.
// If the DelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatedStakingMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *DelegatedStakingMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DelegatedStakingMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DelegatedStakingMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DelegatedStakingMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DelegatedStakingMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DelegatedStaking entity.
// If the DelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatedStakingMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *DelegatedStakingMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DelegatedStakingMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DelegatedStakingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DelegatedStakingMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DelegatedStakingMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DelegatedStaking entity.
// If the DelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatedStakingMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *DelegatedStakingMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DelegatedStakingMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DelegatedStakingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *DelegatedStakingMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *DelegatedStakingMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the DelegatedStaking entity.
// If the DelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatedStakingMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *DelegatedStakingMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[delegatedstaking.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *DelegatedStakingMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[delegatedstaking.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *DelegatedStakingMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, delegatedstaking.FieldGoodID)
}

// SetContractCodeURL sets the "contract_code_url" field.
func (m *DelegatedStakingMutation) SetContractCodeURL(s string) {
	m.contract_code_url = &s
}

// ContractCodeURL returns the value of the "contract_code_url" field in the mutation.
func (m *DelegatedStakingMutation) ContractCodeURL() (r string, exists bool) {
	v := m.contract_code_url
	if v == nil {
		return
	}
	return *v, true
}

// OldContractCodeURL returns the old "contract_code_url" field's value of the DelegatedStaking entity.
// If the DelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatedStakingMutation) OldContractCodeURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractCodeURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractCodeURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractCodeURL: %w", err)
	}
	return oldValue.ContractCodeURL, nil
}

// ClearContractCodeURL clears the value of the "contract_code_url" field.
func (m *DelegatedStakingMutation) ClearContractCodeURL() {
	m.contract_code_url = nil
	m.clearedFields[delegatedstaking.FieldContractCodeURL] = struct{}{}
}

// ContractCodeURLCleared returns if the "contract_code_url" field was cleared in this mutation.
func (m *DelegatedStakingMutation) ContractCodeURLCleared() bool {
	_, ok := m.clearedFields[delegatedstaking.FieldContractCodeURL]
	return ok
}

// ResetContractCodeURL resets all changes to the "contract_code_url" field.
func (m *DelegatedStakingMutation) ResetContractCodeURL() {
	m.contract_code_url = nil
	delete(m.clearedFields, delegatedstaking.FieldContractCodeURL)
}

// SetContractCodeBranch sets the "contract_code_branch" field.
func (m *DelegatedStakingMutation) SetContractCodeBranch(s string) {
	m.contract_code_branch = &s
}

// ContractCodeBranch returns the value of the "contract_code_branch" field in the mutation.
func (m *DelegatedStakingMutation) ContractCodeBranch() (r string, exists bool) {
	v := m.contract_code_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldContractCodeBranch returns the old "contract_code_branch" field's value of the DelegatedStaking entity.
// If the DelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatedStakingMutation) OldContractCodeBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractCodeBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractCodeBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractCodeBranch: %w", err)
	}
	return oldValue.ContractCodeBranch, nil
}

// ClearContractCodeBranch clears the value of the "contract_code_branch" field.
func (m *DelegatedStakingMutation) ClearContractCodeBranch() {
	m.contract_code_branch = nil
	m.clearedFields[delegatedstaking.FieldContractCodeBranch] = struct{}{}
}

// ContractCodeBranchCleared returns if the "contract_code_branch" field was cleared in this mutation.
func (m *DelegatedStakingMutation) ContractCodeBranchCleared() bool {
	_, ok := m.clearedFields[delegatedstaking.FieldContractCodeBranch]
	return ok
}

// ResetContractCodeBranch resets all changes to the "contract_code_branch" field.
func (m *DelegatedStakingMutation) ResetContractCodeBranch() {
	m.contract_code_branch = nil
	delete(m.clearedFields, delegatedstaking.FieldContractCodeBranch)
}

// SetContractState sets the "contract_state" field.
func (m *DelegatedStakingMutation) SetContractState(s string) {
	m.contract_state = &s
}

// ContractState returns the value of the "contract_state" field in the mutation.
func (m *DelegatedStakingMutation) ContractState() (r string, exists bool) {
	v := m.contract_state
	if v == nil {
		return
	}
	return *v, true
}

// OldContractState returns the old "contract_state" field's value of the DelegatedStaking entity.
// If the DelegatedStaking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatedStakingMutation) OldContractState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractState: %w", err)
	}
	return oldValue.ContractState, nil
}

// ClearContractState clears the value of the "contract_state" field.
func (m *DelegatedStakingMutation) ClearContractState() {
	m.contract_state = nil
	m.clearedFields[delegatedstaking.FieldContractState] = struct{}{}
}

// ContractStateCleared returns if the "contract_state" field was cleared in this mutation.
func (m *DelegatedStakingMutation) ContractStateCleared() bool {
	_, ok := m.clearedFields[delegatedstaking.FieldContractState]
	return ok
}

// ResetContractState resets all changes to the "contract_state" field.
func (m *DelegatedStakingMutation) ResetContractState() {
	m.contract_state = nil
	delete(m.clearedFields, delegatedstaking.FieldContractState)
}

// Where appends a list predicates to the DelegatedStakingMutation builder.
func (m *DelegatedStakingMutation) Where(ps ...predicate.DelegatedStaking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DelegatedStakingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DelegatedStakingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DelegatedStaking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DelegatedStakingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DelegatedStakingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DelegatedStaking).
func (m *DelegatedStakingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DelegatedStakingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, delegatedstaking.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, delegatedstaking.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, delegatedstaking.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, delegatedstaking.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, delegatedstaking.FieldGoodID)
	}
	if m.contract_code_url != nil {
		fields = append(fields, delegatedstaking.FieldContractCodeURL)
	}
	if m.contract_code_branch != nil {
		fields = append(fields, delegatedstaking.FieldContractCodeBranch)
	}
	if m.contract_state != nil {
		fields = append(fields, delegatedstaking.FieldContractState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DelegatedStakingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case delegatedstaking.FieldEntID:
		return m.EntID()
	case delegatedstaking.FieldCreatedAt:
		return m.CreatedAt()
	case delegatedstaking.FieldUpdatedAt:
		return m.UpdatedAt()
	case delegatedstaking.FieldDeletedAt:
		return m.DeletedAt()
	case delegatedstaking.FieldGoodID:
		return m.GoodID()
	case delegatedstaking.FieldContractCodeURL:
		return m.ContractCodeURL()
	case delegatedstaking.FieldContractCodeBranch:
		return m.ContractCodeBranch()
	case delegatedstaking.FieldContractState:
		return m.ContractState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DelegatedStakingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case delegatedstaking.FieldEntID:
		return m.OldEntID(ctx)
	case delegatedstaking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case delegatedstaking.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case delegatedstaking.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case delegatedstaking.FieldGoodID:
		return m.OldGoodID(ctx)
	case delegatedstaking.FieldContractCodeURL:
		return m.OldContractCodeURL(ctx)
	case delegatedstaking.FieldContractCodeBranch:
		return m.OldContractCodeBranch(ctx)
	case delegatedstaking.FieldContractState:
		return m.OldContractState(ctx)
	}
	return nil, fmt.Errorf("unknown DelegatedStaking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelegatedStakingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case delegatedstaking.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case delegatedstaking.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case delegatedstaking.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case delegatedstaking.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case delegatedstaking.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case delegatedstaking.FieldContractCodeURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractCodeURL(v)
		return nil
	case delegatedstaking.FieldContractCodeBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractCodeBranch(v)
		return nil
	case delegatedstaking.FieldContractState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractState(v)
		return nil
	}
	return fmt.Errorf("unknown DelegatedStaking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DelegatedStakingMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, delegatedstaking.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, delegatedstaking.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, delegatedstaking.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DelegatedStakingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case delegatedstaking.FieldCreatedAt:
		return m.AddedCreatedAt()
	case delegatedstaking.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case delegatedstaking.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelegatedStakingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case delegatedstaking.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case delegatedstaking.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case delegatedstaking.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DelegatedStaking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DelegatedStakingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(delegatedstaking.FieldGoodID) {
		fields = append(fields, delegatedstaking.FieldGoodID)
	}
	if m.FieldCleared(delegatedstaking.FieldContractCodeURL) {
		fields = append(fields, delegatedstaking.FieldContractCodeURL)
	}
	if m.FieldCleared(delegatedstaking.FieldContractCodeBranch) {
		fields = append(fields, delegatedstaking.FieldContractCodeBranch)
	}
	if m.FieldCleared(delegatedstaking.FieldContractState) {
		fields = append(fields, delegatedstaking.FieldContractState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DelegatedStakingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DelegatedStakingMutation) ClearField(name string) error {
	switch name {
	case delegatedstaking.FieldGoodID:
		m.ClearGoodID()
		return nil
	case delegatedstaking.FieldContractCodeURL:
		m.ClearContractCodeURL()
		return nil
	case delegatedstaking.FieldContractCodeBranch:
		m.ClearContractCodeBranch()
		return nil
	case delegatedstaking.FieldContractState:
		m.ClearContractState()
		return nil
	}
	return fmt.Errorf("unknown DelegatedStaking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DelegatedStakingMutation) ResetField(name string) error {
	switch name {
	case delegatedstaking.FieldEntID:
		m.ResetEntID()
		return nil
	case delegatedstaking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case delegatedstaking.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case delegatedstaking.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case delegatedstaking.FieldGoodID:
		m.ResetGoodID()
		return nil
	case delegatedstaking.FieldContractCodeURL:
		m.ResetContractCodeURL()
		return nil
	case delegatedstaking.FieldContractCodeBranch:
		m.ResetContractCodeBranch()
		return nil
	case delegatedstaking.FieldContractState:
		m.ResetContractState()
		return nil
	}
	return fmt.Errorf("unknown DelegatedStaking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DelegatedStakingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DelegatedStakingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DelegatedStakingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DelegatedStakingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DelegatedStakingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DelegatedStakingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DelegatedStakingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DelegatedStaking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DelegatedStakingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DelegatedStaking edge %s", name)
}

// DeviceInfoMutation represents an operation that mutates the DeviceInfo nodes in the graph.
type DeviceInfoMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	ent_id               *uuid.UUID
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	_type                *string
	manufacturer_id      *uuid.UUID
	power_consumption    *uint32
	addpower_consumption *int32
	shipment_at          *uint32
	addshipment_at       *int32
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*DeviceInfo, error)
	predicates           []predicate.DeviceInfo
}

var _ ent.Mutation = (*DeviceInfoMutation)(nil)

// deviceinfoOption allows management of the mutation configuration using functional options.
type deviceinfoOption func(*DeviceInfoMutation)

// newDeviceInfoMutation creates new mutation for the DeviceInfo entity.
func newDeviceInfoMutation(c config, op Op, opts ...deviceinfoOption) *DeviceInfoMutation {
	m := &DeviceInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInfoID sets the ID field of the mutation.
func withDeviceInfoID(id uint32) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInfo
		)
		m.oldValue = func(ctx context.Context) (*DeviceInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInfo sets the old DeviceInfo of the mutation.
func withDeviceInfo(node *DeviceInfo) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		m.oldValue = func(context.Context) (*DeviceInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInfo entities.
func (m *DeviceInfoMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInfoMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInfoMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *DeviceInfoMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *DeviceInfoMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *DeviceInfoMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInfoMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInfoMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *DeviceInfoMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DeviceInfoMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInfoMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInfoMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *DeviceInfoMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DeviceInfoMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceInfoMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceInfoMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *DeviceInfoMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DeviceInfoMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetType sets the "type" field.
func (m *DeviceInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *DeviceInfoMutation) ClearType() {
	m._type = nil
	m.clearedFields[deviceinfo.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *DeviceInfoMutation) TypeCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *DeviceInfoMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, deviceinfo.FieldType)
}

// SetManufacturerID sets the "manufacturer_id" field.
func (m *DeviceInfoMutation) SetManufacturerID(u uuid.UUID) {
	m.manufacturer_id = &u
}

// ManufacturerID returns the value of the "manufacturer_id" field in the mutation.
func (m *DeviceInfoMutation) ManufacturerID() (r uuid.UUID, exists bool) {
	v := m.manufacturer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturerID returns the old "manufacturer_id" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldManufacturerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturerID: %w", err)
	}
	return oldValue.ManufacturerID, nil
}

// ClearManufacturerID clears the value of the "manufacturer_id" field.
func (m *DeviceInfoMutation) ClearManufacturerID() {
	m.manufacturer_id = nil
	m.clearedFields[deviceinfo.FieldManufacturerID] = struct{}{}
}

// ManufacturerIDCleared returns if the "manufacturer_id" field was cleared in this mutation.
func (m *DeviceInfoMutation) ManufacturerIDCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldManufacturerID]
	return ok
}

// ResetManufacturerID resets all changes to the "manufacturer_id" field.
func (m *DeviceInfoMutation) ResetManufacturerID() {
	m.manufacturer_id = nil
	delete(m.clearedFields, deviceinfo.FieldManufacturerID)
}

// SetPowerConsumption sets the "power_consumption" field.
func (m *DeviceInfoMutation) SetPowerConsumption(u uint32) {
	m.power_consumption = &u
	m.addpower_consumption = nil
}

// PowerConsumption returns the value of the "power_consumption" field in the mutation.
func (m *DeviceInfoMutation) PowerConsumption() (r uint32, exists bool) {
	v := m.power_consumption
	if v == nil {
		return
	}
	return *v, true
}

// OldPowerConsumption returns the old "power_consumption" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldPowerConsumption(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPowerConsumption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPowerConsumption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPowerConsumption: %w", err)
	}
	return oldValue.PowerConsumption, nil
}

// AddPowerConsumption adds u to the "power_consumption" field.
func (m *DeviceInfoMutation) AddPowerConsumption(u int32) {
	if m.addpower_consumption != nil {
		*m.addpower_consumption += u
	} else {
		m.addpower_consumption = &u
	}
}

// AddedPowerConsumption returns the value that was added to the "power_consumption" field in this mutation.
func (m *DeviceInfoMutation) AddedPowerConsumption() (r int32, exists bool) {
	v := m.addpower_consumption
	if v == nil {
		return
	}
	return *v, true
}

// ClearPowerConsumption clears the value of the "power_consumption" field.
func (m *DeviceInfoMutation) ClearPowerConsumption() {
	m.power_consumption = nil
	m.addpower_consumption = nil
	m.clearedFields[deviceinfo.FieldPowerConsumption] = struct{}{}
}

// PowerConsumptionCleared returns if the "power_consumption" field was cleared in this mutation.
func (m *DeviceInfoMutation) PowerConsumptionCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldPowerConsumption]
	return ok
}

// ResetPowerConsumption resets all changes to the "power_consumption" field.
func (m *DeviceInfoMutation) ResetPowerConsumption() {
	m.power_consumption = nil
	m.addpower_consumption = nil
	delete(m.clearedFields, deviceinfo.FieldPowerConsumption)
}

// SetShipmentAt sets the "shipment_at" field.
func (m *DeviceInfoMutation) SetShipmentAt(u uint32) {
	m.shipment_at = &u
	m.addshipment_at = nil
}

// ShipmentAt returns the value of the "shipment_at" field in the mutation.
func (m *DeviceInfoMutation) ShipmentAt() (r uint32, exists bool) {
	v := m.shipment_at
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentAt returns the old "shipment_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldShipmentAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentAt: %w", err)
	}
	return oldValue.ShipmentAt, nil
}

// AddShipmentAt adds u to the "shipment_at" field.
func (m *DeviceInfoMutation) AddShipmentAt(u int32) {
	if m.addshipment_at != nil {
		*m.addshipment_at += u
	} else {
		m.addshipment_at = &u
	}
}

// AddedShipmentAt returns the value that was added to the "shipment_at" field in this mutation.
func (m *DeviceInfoMutation) AddedShipmentAt() (r int32, exists bool) {
	v := m.addshipment_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipmentAt clears the value of the "shipment_at" field.
func (m *DeviceInfoMutation) ClearShipmentAt() {
	m.shipment_at = nil
	m.addshipment_at = nil
	m.clearedFields[deviceinfo.FieldShipmentAt] = struct{}{}
}

// ShipmentAtCleared returns if the "shipment_at" field was cleared in this mutation.
func (m *DeviceInfoMutation) ShipmentAtCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldShipmentAt]
	return ok
}

// ResetShipmentAt resets all changes to the "shipment_at" field.
func (m *DeviceInfoMutation) ResetShipmentAt() {
	m.shipment_at = nil
	m.addshipment_at = nil
	delete(m.clearedFields, deviceinfo.FieldShipmentAt)
}

// Where appends a list predicates to the DeviceInfoMutation builder.
func (m *DeviceInfoMutation) Where(ps ...predicate.DeviceInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInfo).
func (m *DeviceInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInfoMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, deviceinfo.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, deviceinfo.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.manufacturer_id != nil {
		fields = append(fields, deviceinfo.FieldManufacturerID)
	}
	if m.power_consumption != nil {
		fields = append(fields, deviceinfo.FieldPowerConsumption)
	}
	if m.shipment_at != nil {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldEntID:
		return m.EntID()
	case deviceinfo.FieldCreatedAt:
		return m.CreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceinfo.FieldDeletedAt:
		return m.DeletedAt()
	case deviceinfo.FieldType:
		return m.GetType()
	case deviceinfo.FieldManufacturerID:
		return m.ManufacturerID()
	case deviceinfo.FieldPowerConsumption:
		return m.PowerConsumption()
	case deviceinfo.FieldShipmentAt:
		return m.ShipmentAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinfo.FieldEntID:
		return m.OldEntID(ctx)
	case deviceinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case deviceinfo.FieldType:
		return m.OldType(ctx)
	case deviceinfo.FieldManufacturerID:
		return m.OldManufacturerID(ctx)
	case deviceinfo.FieldPowerConsumption:
		return m.OldPowerConsumption(ctx)
	case deviceinfo.FieldShipmentAt:
		return m.OldShipmentAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceinfo.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case deviceinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case deviceinfo.FieldManufacturerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturerID(v)
		return nil
	case deviceinfo.FieldPowerConsumption:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPowerConsumption(v)
		return nil
	case deviceinfo.FieldShipmentAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, deviceinfo.FieldDeletedAt)
	}
	if m.addpower_consumption != nil {
		fields = append(fields, deviceinfo.FieldPowerConsumption)
	}
	if m.addshipment_at != nil {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case deviceinfo.FieldDeletedAt:
		return m.AddedDeletedAt()
	case deviceinfo.FieldPowerConsumption:
		return m.AddedPowerConsumption()
	case deviceinfo.FieldShipmentAt:
		return m.AddedShipmentAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case deviceinfo.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case deviceinfo.FieldPowerConsumption:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPowerConsumption(v)
		return nil
	case deviceinfo.FieldShipmentAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipmentAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceinfo.FieldType) {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.FieldCleared(deviceinfo.FieldManufacturerID) {
		fields = append(fields, deviceinfo.FieldManufacturerID)
	}
	if m.FieldCleared(deviceinfo.FieldPowerConsumption) {
		fields = append(fields, deviceinfo.FieldPowerConsumption)
	}
	if m.FieldCleared(deviceinfo.FieldShipmentAt) {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ClearField(name string) error {
	switch name {
	case deviceinfo.FieldType:
		m.ClearType()
		return nil
	case deviceinfo.FieldManufacturerID:
		m.ClearManufacturerID()
		return nil
	case deviceinfo.FieldPowerConsumption:
		m.ClearPowerConsumption()
		return nil
	case deviceinfo.FieldShipmentAt:
		m.ClearShipmentAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ResetField(name string) error {
	switch name {
	case deviceinfo.FieldEntID:
		m.ResetEntID()
		return nil
	case deviceinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case deviceinfo.FieldType:
		m.ResetType()
		return nil
	case deviceinfo.FieldManufacturerID:
		m.ResetManufacturerID()
		return nil
	case deviceinfo.FieldPowerConsumption:
		m.ResetPowerConsumption()
		return nil
	case deviceinfo.FieldShipmentAt:
		m.ResetShipmentAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceInfo edge %s", name)
}

// DeviceManufacturerMutation represents an operation that mutates the DeviceManufacturer nodes in the graph.
type DeviceManufacturerMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	name          *string
	logo          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DeviceManufacturer, error)
	predicates    []predicate.DeviceManufacturer
}

var _ ent.Mutation = (*DeviceManufacturerMutation)(nil)

// devicemanufacturerOption allows management of the mutation configuration using functional options.
type devicemanufacturerOption func(*DeviceManufacturerMutation)

// newDeviceManufacturerMutation creates new mutation for the DeviceManufacturer entity.
func newDeviceManufacturerMutation(c config, op Op, opts ...devicemanufacturerOption) *DeviceManufacturerMutation {
	m := &DeviceManufacturerMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceManufacturer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceManufacturerID sets the ID field of the mutation.
func withDeviceManufacturerID(id uint32) devicemanufacturerOption {
	return func(m *DeviceManufacturerMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceManufacturer
		)
		m.oldValue = func(ctx context.Context) (*DeviceManufacturer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceManufacturer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceManufacturer sets the old DeviceManufacturer of the mutation.
func withDeviceManufacturer(node *DeviceManufacturer) devicemanufacturerOption {
	return func(m *DeviceManufacturerMutation) {
		m.oldValue = func(context.Context) (*DeviceManufacturer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceManufacturerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceManufacturerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceManufacturer entities.
func (m *DeviceManufacturerMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceManufacturerMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceManufacturerMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceManufacturer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *DeviceManufacturerMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *DeviceManufacturerMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the DeviceManufacturer entity.
// If the DeviceManufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceManufacturerMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *DeviceManufacturerMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceManufacturerMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceManufacturerMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceManufacturer entity.
// If the DeviceManufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceManufacturerMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *DeviceManufacturerMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DeviceManufacturerMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceManufacturerMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceManufacturerMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceManufacturerMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceManufacturer entity.
// If the DeviceManufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceManufacturerMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *DeviceManufacturerMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DeviceManufacturerMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceManufacturerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceManufacturerMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceManufacturerMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceManufacturer entity.
// If the DeviceManufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceManufacturerMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *DeviceManufacturerMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DeviceManufacturerMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceManufacturerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *DeviceManufacturerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceManufacturerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeviceManufacturer entity.
// If the DeviceManufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceManufacturerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DeviceManufacturerMutation) ClearName() {
	m.name = nil
	m.clearedFields[devicemanufacturer.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DeviceManufacturerMutation) NameCleared() bool {
	_, ok := m.clearedFields[devicemanufacturer.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DeviceManufacturerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, devicemanufacturer.FieldName)
}

// SetLogo sets the "logo" field.
func (m *DeviceManufacturerMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *DeviceManufacturerMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the DeviceManufacturer entity.
// If the DeviceManufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceManufacturerMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *DeviceManufacturerMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[devicemanufacturer.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *DeviceManufacturerMutation) LogoCleared() bool {
	_, ok := m.clearedFields[devicemanufacturer.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *DeviceManufacturerMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, devicemanufacturer.FieldLogo)
}

// Where appends a list predicates to the DeviceManufacturerMutation builder.
func (m *DeviceManufacturerMutation) Where(ps ...predicate.DeviceManufacturer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceManufacturerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceManufacturerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceManufacturer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceManufacturerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceManufacturerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceManufacturer).
func (m *DeviceManufacturerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceManufacturerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.ent_id != nil {
		fields = append(fields, devicemanufacturer.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, devicemanufacturer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicemanufacturer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicemanufacturer.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, devicemanufacturer.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, devicemanufacturer.FieldLogo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceManufacturerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicemanufacturer.FieldEntID:
		return m.EntID()
	case devicemanufacturer.FieldCreatedAt:
		return m.CreatedAt()
	case devicemanufacturer.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicemanufacturer.FieldDeletedAt:
		return m.DeletedAt()
	case devicemanufacturer.FieldName:
		return m.Name()
	case devicemanufacturer.FieldLogo:
		return m.Logo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceManufacturerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicemanufacturer.FieldEntID:
		return m.OldEntID(ctx)
	case devicemanufacturer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicemanufacturer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicemanufacturer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicemanufacturer.FieldName:
		return m.OldName(ctx)
	case devicemanufacturer.FieldLogo:
		return m.OldLogo(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceManufacturer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceManufacturerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicemanufacturer.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case devicemanufacturer.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicemanufacturer.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicemanufacturer.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicemanufacturer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case devicemanufacturer.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceManufacturer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceManufacturerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, devicemanufacturer.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, devicemanufacturer.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, devicemanufacturer.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceManufacturerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicemanufacturer.FieldCreatedAt:
		return m.AddedCreatedAt()
	case devicemanufacturer.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case devicemanufacturer.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceManufacturerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicemanufacturer.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case devicemanufacturer.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case devicemanufacturer.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceManufacturer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceManufacturerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicemanufacturer.FieldName) {
		fields = append(fields, devicemanufacturer.FieldName)
	}
	if m.FieldCleared(devicemanufacturer.FieldLogo) {
		fields = append(fields, devicemanufacturer.FieldLogo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceManufacturerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceManufacturerMutation) ClearField(name string) error {
	switch name {
	case devicemanufacturer.FieldName:
		m.ClearName()
		return nil
	case devicemanufacturer.FieldLogo:
		m.ClearLogo()
		return nil
	}
	return fmt.Errorf("unknown DeviceManufacturer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceManufacturerMutation) ResetField(name string) error {
	switch name {
	case devicemanufacturer.FieldEntID:
		m.ResetEntID()
		return nil
	case devicemanufacturer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicemanufacturer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicemanufacturer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicemanufacturer.FieldName:
		m.ResetName()
		return nil
	case devicemanufacturer.FieldLogo:
		m.ResetLogo()
		return nil
	}
	return fmt.Errorf("unknown DeviceManufacturer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceManufacturerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceManufacturerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceManufacturerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceManufacturerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceManufacturerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceManufacturerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceManufacturerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceManufacturer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceManufacturerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceManufacturer edge %s", name)
}

// DevicePosterMutation represents an operation that mutates the DevicePoster nodes in the graph.
type DevicePosterMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	ent_id         *uuid.UUID
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	device_type_id *uuid.UUID
	poster         *string
	index          *uint8
	addindex       *int8
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*DevicePoster, error)
	predicates     []predicate.DevicePoster
}

var _ ent.Mutation = (*DevicePosterMutation)(nil)

// deviceposterOption allows management of the mutation configuration using functional options.
type deviceposterOption func(*DevicePosterMutation)

// newDevicePosterMutation creates new mutation for the DevicePoster entity.
func newDevicePosterMutation(c config, op Op, opts ...deviceposterOption) *DevicePosterMutation {
	m := &DevicePosterMutation{
		config:        c,
		op:            op,
		typ:           TypeDevicePoster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDevicePosterID sets the ID field of the mutation.
func withDevicePosterID(id uint32) deviceposterOption {
	return func(m *DevicePosterMutation) {
		var (
			err   error
			once  sync.Once
			value *DevicePoster
		)
		m.oldValue = func(ctx context.Context) (*DevicePoster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DevicePoster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevicePoster sets the old DevicePoster of the mutation.
func withDevicePoster(node *DevicePoster) deviceposterOption {
	return func(m *DevicePosterMutation) {
		m.oldValue = func(context.Context) (*DevicePoster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DevicePosterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DevicePosterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DevicePoster entities.
func (m *DevicePosterMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DevicePosterMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DevicePosterMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DevicePoster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *DevicePosterMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *DevicePosterMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the DevicePoster entity.
// If the DevicePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicePosterMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *DevicePosterMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DevicePosterMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DevicePosterMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DevicePoster entity.
// If the DevicePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicePosterMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *DevicePosterMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DevicePosterMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DevicePosterMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DevicePosterMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DevicePosterMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DevicePoster entity.
// If the DevicePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicePosterMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *DevicePosterMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DevicePosterMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DevicePosterMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DevicePosterMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DevicePosterMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DevicePoster entity.
// If the DevicePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicePosterMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *DevicePosterMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DevicePosterMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DevicePosterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeviceTypeID sets the "device_type_id" field.
func (m *DevicePosterMutation) SetDeviceTypeID(u uuid.UUID) {
	m.device_type_id = &u
}

// DeviceTypeID returns the value of the "device_type_id" field in the mutation.
func (m *DevicePosterMutation) DeviceTypeID() (r uuid.UUID, exists bool) {
	v := m.device_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceTypeID returns the old "device_type_id" field's value of the DevicePoster entity.
// If the DevicePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicePosterMutation) OldDeviceTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceTypeID: %w", err)
	}
	return oldValue.DeviceTypeID, nil
}

// ClearDeviceTypeID clears the value of the "device_type_id" field.
func (m *DevicePosterMutation) ClearDeviceTypeID() {
	m.device_type_id = nil
	m.clearedFields[deviceposter.FieldDeviceTypeID] = struct{}{}
}

// DeviceTypeIDCleared returns if the "device_type_id" field was cleared in this mutation.
func (m *DevicePosterMutation) DeviceTypeIDCleared() bool {
	_, ok := m.clearedFields[deviceposter.FieldDeviceTypeID]
	return ok
}

// ResetDeviceTypeID resets all changes to the "device_type_id" field.
func (m *DevicePosterMutation) ResetDeviceTypeID() {
	m.device_type_id = nil
	delete(m.clearedFields, deviceposter.FieldDeviceTypeID)
}

// SetPoster sets the "poster" field.
func (m *DevicePosterMutation) SetPoster(s string) {
	m.poster = &s
}

// Poster returns the value of the "poster" field in the mutation.
func (m *DevicePosterMutation) Poster() (r string, exists bool) {
	v := m.poster
	if v == nil {
		return
	}
	return *v, true
}

// OldPoster returns the old "poster" field's value of the DevicePoster entity.
// If the DevicePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicePosterMutation) OldPoster(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoster: %w", err)
	}
	return oldValue.Poster, nil
}

// ClearPoster clears the value of the "poster" field.
func (m *DevicePosterMutation) ClearPoster() {
	m.poster = nil
	m.clearedFields[deviceposter.FieldPoster] = struct{}{}
}

// PosterCleared returns if the "poster" field was cleared in this mutation.
func (m *DevicePosterMutation) PosterCleared() bool {
	_, ok := m.clearedFields[deviceposter.FieldPoster]
	return ok
}

// ResetPoster resets all changes to the "poster" field.
func (m *DevicePosterMutation) ResetPoster() {
	m.poster = nil
	delete(m.clearedFields, deviceposter.FieldPoster)
}

// SetIndex sets the "index" field.
func (m *DevicePosterMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *DevicePosterMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the DevicePoster entity.
// If the DevicePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicePosterMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *DevicePosterMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *DevicePosterMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *DevicePosterMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[deviceposter.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *DevicePosterMutation) IndexCleared() bool {
	_, ok := m.clearedFields[deviceposter.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *DevicePosterMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, deviceposter.FieldIndex)
}

// Where appends a list predicates to the DevicePosterMutation builder.
func (m *DevicePosterMutation) Where(ps ...predicate.DevicePoster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DevicePosterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DevicePosterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DevicePoster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DevicePosterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DevicePosterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DevicePoster).
func (m *DevicePosterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DevicePosterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, deviceposter.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, deviceposter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceposter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, deviceposter.FieldDeletedAt)
	}
	if m.device_type_id != nil {
		fields = append(fields, deviceposter.FieldDeviceTypeID)
	}
	if m.poster != nil {
		fields = append(fields, deviceposter.FieldPoster)
	}
	if m.index != nil {
		fields = append(fields, deviceposter.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DevicePosterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceposter.FieldEntID:
		return m.EntID()
	case deviceposter.FieldCreatedAt:
		return m.CreatedAt()
	case deviceposter.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceposter.FieldDeletedAt:
		return m.DeletedAt()
	case deviceposter.FieldDeviceTypeID:
		return m.DeviceTypeID()
	case deviceposter.FieldPoster:
		return m.Poster()
	case deviceposter.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DevicePosterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceposter.FieldEntID:
		return m.OldEntID(ctx)
	case deviceposter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceposter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceposter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case deviceposter.FieldDeviceTypeID:
		return m.OldDeviceTypeID(ctx)
	case deviceposter.FieldPoster:
		return m.OldPoster(ctx)
	case deviceposter.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown DevicePoster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DevicePosterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceposter.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case deviceposter.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceposter.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceposter.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case deviceposter.FieldDeviceTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceTypeID(v)
		return nil
	case deviceposter.FieldPoster:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoster(v)
		return nil
	case deviceposter.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown DevicePoster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DevicePosterMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, deviceposter.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, deviceposter.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, deviceposter.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, deviceposter.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DevicePosterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deviceposter.FieldCreatedAt:
		return m.AddedCreatedAt()
	case deviceposter.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case deviceposter.FieldDeletedAt:
		return m.AddedDeletedAt()
	case deviceposter.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DevicePosterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deviceposter.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case deviceposter.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case deviceposter.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case deviceposter.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown DevicePoster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DevicePosterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceposter.FieldDeviceTypeID) {
		fields = append(fields, deviceposter.FieldDeviceTypeID)
	}
	if m.FieldCleared(deviceposter.FieldPoster) {
		fields = append(fields, deviceposter.FieldPoster)
	}
	if m.FieldCleared(deviceposter.FieldIndex) {
		fields = append(fields, deviceposter.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DevicePosterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DevicePosterMutation) ClearField(name string) error {
	switch name {
	case deviceposter.FieldDeviceTypeID:
		m.ClearDeviceTypeID()
		return nil
	case deviceposter.FieldPoster:
		m.ClearPoster()
		return nil
	case deviceposter.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown DevicePoster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DevicePosterMutation) ResetField(name string) error {
	switch name {
	case deviceposter.FieldEntID:
		m.ResetEntID()
		return nil
	case deviceposter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceposter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceposter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case deviceposter.FieldDeviceTypeID:
		m.ResetDeviceTypeID()
		return nil
	case deviceposter.FieldPoster:
		m.ResetPoster()
		return nil
	case deviceposter.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown DevicePoster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DevicePosterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DevicePosterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DevicePosterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DevicePosterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DevicePosterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DevicePosterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DevicePosterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DevicePoster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DevicePosterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DevicePoster edge %s", name)
}

// ExtraInfoMutation represents an operation that mutates the ExtraInfo nodes in the graph.
type ExtraInfoMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	ent_id             *uuid.UUID
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	app_good_id        *uuid.UUID
	likes              *uint32
	addlikes           *int32
	dislikes           *uint32
	adddislikes        *int32
	recommend_count    *uint32
	addrecommend_count *int32
	comment_count      *uint32
	addcomment_count   *int32
	score_count        *uint32
	addscore_count     *int32
	score              *decimal.Decimal
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*ExtraInfo, error)
	predicates         []predicate.ExtraInfo
}

var _ ent.Mutation = (*ExtraInfoMutation)(nil)

// extrainfoOption allows management of the mutation configuration using functional options.
type extrainfoOption func(*ExtraInfoMutation)

// newExtraInfoMutation creates new mutation for the ExtraInfo entity.
func newExtraInfoMutation(c config, op Op, opts ...extrainfoOption) *ExtraInfoMutation {
	m := &ExtraInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraInfoID sets the ID field of the mutation.
func withExtraInfoID(id uint32) extrainfoOption {
	return func(m *ExtraInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraInfo
		)
		m.oldValue = func(ctx context.Context) (*ExtraInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraInfo sets the old ExtraInfo of the mutation.
func withExtraInfo(node *ExtraInfo) extrainfoOption {
	return func(m *ExtraInfoMutation) {
		m.oldValue = func(context.Context) (*ExtraInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraInfo entities.
func (m *ExtraInfoMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraInfoMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraInfoMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *ExtraInfoMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *ExtraInfoMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *ExtraInfoMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraInfoMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraInfoMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ExtraInfoMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ExtraInfoMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraInfoMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraInfoMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ExtraInfoMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ExtraInfoMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraInfoMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraInfoMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ExtraInfoMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ExtraInfoMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *ExtraInfoMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *ExtraInfoMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *ExtraInfoMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[extrainfo.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *ExtraInfoMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *ExtraInfoMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, extrainfo.FieldAppGoodID)
}

// SetLikes sets the "likes" field.
func (m *ExtraInfoMutation) SetLikes(u uint32) {
	m.likes = &u
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *ExtraInfoMutation) Likes() (r uint32, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldLikes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds u to the "likes" field.
func (m *ExtraInfoMutation) AddLikes(u int32) {
	if m.addlikes != nil {
		*m.addlikes += u
	} else {
		m.addlikes = &u
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *ExtraInfoMutation) AddedLikes() (r int32, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ClearLikes clears the value of the "likes" field.
func (m *ExtraInfoMutation) ClearLikes() {
	m.likes = nil
	m.addlikes = nil
	m.clearedFields[extrainfo.FieldLikes] = struct{}{}
}

// LikesCleared returns if the "likes" field was cleared in this mutation.
func (m *ExtraInfoMutation) LikesCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldLikes]
	return ok
}

// ResetLikes resets all changes to the "likes" field.
func (m *ExtraInfoMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
	delete(m.clearedFields, extrainfo.FieldLikes)
}

// SetDislikes sets the "dislikes" field.
func (m *ExtraInfoMutation) SetDislikes(u uint32) {
	m.dislikes = &u
	m.adddislikes = nil
}

// Dislikes returns the value of the "dislikes" field in the mutation.
func (m *ExtraInfoMutation) Dislikes() (r uint32, exists bool) {
	v := m.dislikes
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikes returns the old "dislikes" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldDislikes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikes: %w", err)
	}
	return oldValue.Dislikes, nil
}

// AddDislikes adds u to the "dislikes" field.
func (m *ExtraInfoMutation) AddDislikes(u int32) {
	if m.adddislikes != nil {
		*m.adddislikes += u
	} else {
		m.adddislikes = &u
	}
}

// AddedDislikes returns the value that was added to the "dislikes" field in this mutation.
func (m *ExtraInfoMutation) AddedDislikes() (r int32, exists bool) {
	v := m.adddislikes
	if v == nil {
		return
	}
	return *v, true
}

// ClearDislikes clears the value of the "dislikes" field.
func (m *ExtraInfoMutation) ClearDislikes() {
	m.dislikes = nil
	m.adddislikes = nil
	m.clearedFields[extrainfo.FieldDislikes] = struct{}{}
}

// DislikesCleared returns if the "dislikes" field was cleared in this mutation.
func (m *ExtraInfoMutation) DislikesCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldDislikes]
	return ok
}

// ResetDislikes resets all changes to the "dislikes" field.
func (m *ExtraInfoMutation) ResetDislikes() {
	m.dislikes = nil
	m.adddislikes = nil
	delete(m.clearedFields, extrainfo.FieldDislikes)
}

// SetRecommendCount sets the "recommend_count" field.
func (m *ExtraInfoMutation) SetRecommendCount(u uint32) {
	m.recommend_count = &u
	m.addrecommend_count = nil
}

// RecommendCount returns the value of the "recommend_count" field in the mutation.
func (m *ExtraInfoMutation) RecommendCount() (r uint32, exists bool) {
	v := m.recommend_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendCount returns the old "recommend_count" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldRecommendCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendCount: %w", err)
	}
	return oldValue.RecommendCount, nil
}

// AddRecommendCount adds u to the "recommend_count" field.
func (m *ExtraInfoMutation) AddRecommendCount(u int32) {
	if m.addrecommend_count != nil {
		*m.addrecommend_count += u
	} else {
		m.addrecommend_count = &u
	}
}

// AddedRecommendCount returns the value that was added to the "recommend_count" field in this mutation.
func (m *ExtraInfoMutation) AddedRecommendCount() (r int32, exists bool) {
	v := m.addrecommend_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecommendCount clears the value of the "recommend_count" field.
func (m *ExtraInfoMutation) ClearRecommendCount() {
	m.recommend_count = nil
	m.addrecommend_count = nil
	m.clearedFields[extrainfo.FieldRecommendCount] = struct{}{}
}

// RecommendCountCleared returns if the "recommend_count" field was cleared in this mutation.
func (m *ExtraInfoMutation) RecommendCountCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldRecommendCount]
	return ok
}

// ResetRecommendCount resets all changes to the "recommend_count" field.
func (m *ExtraInfoMutation) ResetRecommendCount() {
	m.recommend_count = nil
	m.addrecommend_count = nil
	delete(m.clearedFields, extrainfo.FieldRecommendCount)
}

// SetCommentCount sets the "comment_count" field.
func (m *ExtraInfoMutation) SetCommentCount(u uint32) {
	m.comment_count = &u
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *ExtraInfoMutation) CommentCount() (r uint32, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldCommentCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds u to the "comment_count" field.
func (m *ExtraInfoMutation) AddCommentCount(u int32) {
	if m.addcomment_count != nil {
		*m.addcomment_count += u
	} else {
		m.addcomment_count = &u
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *ExtraInfoMutation) AddedCommentCount() (r int32, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearCommentCount clears the value of the "comment_count" field.
func (m *ExtraInfoMutation) ClearCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
	m.clearedFields[extrainfo.FieldCommentCount] = struct{}{}
}

// CommentCountCleared returns if the "comment_count" field was cleared in this mutation.
func (m *ExtraInfoMutation) CommentCountCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldCommentCount]
	return ok
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *ExtraInfoMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
	delete(m.clearedFields, extrainfo.FieldCommentCount)
}

// SetScoreCount sets the "score_count" field.
func (m *ExtraInfoMutation) SetScoreCount(u uint32) {
	m.score_count = &u
	m.addscore_count = nil
}

// ScoreCount returns the value of the "score_count" field in the mutation.
func (m *ExtraInfoMutation) ScoreCount() (r uint32, exists bool) {
	v := m.score_count
	if v == nil {
		return
	}
	return *v, true
}

// OldScoreCount returns the old "score_count" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldScoreCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScoreCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScoreCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScoreCount: %w", err)
	}
	return oldValue.ScoreCount, nil
}

// AddScoreCount adds u to the "score_count" field.
func (m *ExtraInfoMutation) AddScoreCount(u int32) {
	if m.addscore_count != nil {
		*m.addscore_count += u
	} else {
		m.addscore_count = &u
	}
}

// AddedScoreCount returns the value that was added to the "score_count" field in this mutation.
func (m *ExtraInfoMutation) AddedScoreCount() (r int32, exists bool) {
	v := m.addscore_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearScoreCount clears the value of the "score_count" field.
func (m *ExtraInfoMutation) ClearScoreCount() {
	m.score_count = nil
	m.addscore_count = nil
	m.clearedFields[extrainfo.FieldScoreCount] = struct{}{}
}

// ScoreCountCleared returns if the "score_count" field was cleared in this mutation.
func (m *ExtraInfoMutation) ScoreCountCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldScoreCount]
	return ok
}

// ResetScoreCount resets all changes to the "score_count" field.
func (m *ExtraInfoMutation) ResetScoreCount() {
	m.score_count = nil
	m.addscore_count = nil
	delete(m.clearedFields, extrainfo.FieldScoreCount)
}

// SetScore sets the "score" field.
func (m *ExtraInfoMutation) SetScore(d decimal.Decimal) {
	m.score = &d
}

// Score returns the value of the "score" field in the mutation.
func (m *ExtraInfoMutation) Score() (r decimal.Decimal, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldScore(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// ClearScore clears the value of the "score" field.
func (m *ExtraInfoMutation) ClearScore() {
	m.score = nil
	m.clearedFields[extrainfo.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ExtraInfoMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ExtraInfoMutation) ResetScore() {
	m.score = nil
	delete(m.clearedFields, extrainfo.FieldScore)
}

// Where appends a list predicates to the ExtraInfoMutation builder.
func (m *ExtraInfoMutation) Where(ps ...predicate.ExtraInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExtraInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExtraInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExtraInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExtraInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExtraInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExtraInfo).
func (m *ExtraInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraInfoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ent_id != nil {
		fields = append(fields, extrainfo.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, extrainfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extrainfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extrainfo.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, extrainfo.FieldAppGoodID)
	}
	if m.likes != nil {
		fields = append(fields, extrainfo.FieldLikes)
	}
	if m.dislikes != nil {
		fields = append(fields, extrainfo.FieldDislikes)
	}
	if m.recommend_count != nil {
		fields = append(fields, extrainfo.FieldRecommendCount)
	}
	if m.comment_count != nil {
		fields = append(fields, extrainfo.FieldCommentCount)
	}
	if m.score_count != nil {
		fields = append(fields, extrainfo.FieldScoreCount)
	}
	if m.score != nil {
		fields = append(fields, extrainfo.FieldScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extrainfo.FieldEntID:
		return m.EntID()
	case extrainfo.FieldCreatedAt:
		return m.CreatedAt()
	case extrainfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case extrainfo.FieldDeletedAt:
		return m.DeletedAt()
	case extrainfo.FieldAppGoodID:
		return m.AppGoodID()
	case extrainfo.FieldLikes:
		return m.Likes()
	case extrainfo.FieldDislikes:
		return m.Dislikes()
	case extrainfo.FieldRecommendCount:
		return m.RecommendCount()
	case extrainfo.FieldCommentCount:
		return m.CommentCount()
	case extrainfo.FieldScoreCount:
		return m.ScoreCount()
	case extrainfo.FieldScore:
		return m.Score()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extrainfo.FieldEntID:
		return m.OldEntID(ctx)
	case extrainfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extrainfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extrainfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extrainfo.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case extrainfo.FieldLikes:
		return m.OldLikes(ctx)
	case extrainfo.FieldDislikes:
		return m.OldDislikes(ctx)
	case extrainfo.FieldRecommendCount:
		return m.OldRecommendCount(ctx)
	case extrainfo.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case extrainfo.FieldScoreCount:
		return m.OldScoreCount(ctx)
	case extrainfo.FieldScore:
		return m.OldScore(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extrainfo.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case extrainfo.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extrainfo.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extrainfo.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extrainfo.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case extrainfo.FieldLikes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case extrainfo.FieldDislikes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikes(v)
		return nil
	case extrainfo.FieldRecommendCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendCount(v)
		return nil
	case extrainfo.FieldCommentCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case extrainfo.FieldScoreCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScoreCount(v)
		return nil
	case extrainfo.FieldScore:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, extrainfo.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, extrainfo.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, extrainfo.FieldDeletedAt)
	}
	if m.addlikes != nil {
		fields = append(fields, extrainfo.FieldLikes)
	}
	if m.adddislikes != nil {
		fields = append(fields, extrainfo.FieldDislikes)
	}
	if m.addrecommend_count != nil {
		fields = append(fields, extrainfo.FieldRecommendCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, extrainfo.FieldCommentCount)
	}
	if m.addscore_count != nil {
		fields = append(fields, extrainfo.FieldScoreCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extrainfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case extrainfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case extrainfo.FieldDeletedAt:
		return m.AddedDeletedAt()
	case extrainfo.FieldLikes:
		return m.AddedLikes()
	case extrainfo.FieldDislikes:
		return m.AddedDislikes()
	case extrainfo.FieldRecommendCount:
		return m.AddedRecommendCount()
	case extrainfo.FieldCommentCount:
		return m.AddedCommentCount()
	case extrainfo.FieldScoreCount:
		return m.AddedScoreCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extrainfo.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case extrainfo.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case extrainfo.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case extrainfo.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	case extrainfo.FieldDislikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikes(v)
		return nil
	case extrainfo.FieldRecommendCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecommendCount(v)
		return nil
	case extrainfo.FieldCommentCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case extrainfo.FieldScoreCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScoreCount(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extrainfo.FieldAppGoodID) {
		fields = append(fields, extrainfo.FieldAppGoodID)
	}
	if m.FieldCleared(extrainfo.FieldLikes) {
		fields = append(fields, extrainfo.FieldLikes)
	}
	if m.FieldCleared(extrainfo.FieldDislikes) {
		fields = append(fields, extrainfo.FieldDislikes)
	}
	if m.FieldCleared(extrainfo.FieldRecommendCount) {
		fields = append(fields, extrainfo.FieldRecommendCount)
	}
	if m.FieldCleared(extrainfo.FieldCommentCount) {
		fields = append(fields, extrainfo.FieldCommentCount)
	}
	if m.FieldCleared(extrainfo.FieldScoreCount) {
		fields = append(fields, extrainfo.FieldScoreCount)
	}
	if m.FieldCleared(extrainfo.FieldScore) {
		fields = append(fields, extrainfo.FieldScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraInfoMutation) ClearField(name string) error {
	switch name {
	case extrainfo.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case extrainfo.FieldLikes:
		m.ClearLikes()
		return nil
	case extrainfo.FieldDislikes:
		m.ClearDislikes()
		return nil
	case extrainfo.FieldRecommendCount:
		m.ClearRecommendCount()
		return nil
	case extrainfo.FieldCommentCount:
		m.ClearCommentCount()
		return nil
	case extrainfo.FieldScoreCount:
		m.ClearScoreCount()
		return nil
	case extrainfo.FieldScore:
		m.ClearScore()
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraInfoMutation) ResetField(name string) error {
	switch name {
	case extrainfo.FieldEntID:
		m.ResetEntID()
		return nil
	case extrainfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extrainfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extrainfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extrainfo.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case extrainfo.FieldLikes:
		m.ResetLikes()
		return nil
	case extrainfo.FieldDislikes:
		m.ResetDislikes()
		return nil
	case extrainfo.FieldRecommendCount:
		m.ResetRecommendCount()
		return nil
	case extrainfo.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case extrainfo.FieldScoreCount:
		m.ResetScoreCount()
		return nil
	case extrainfo.FieldScore:
		m.ResetScore()
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExtraInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExtraInfo edge %s", name)
}

// FbmCrowdFundingMutation represents an operation that mutates the FbmCrowdFunding nodes in the graph.
type FbmCrowdFundingMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	ent_id                *uuid.UUID
	good_id               *uuid.UUID
	min_deposit_amount    *decimal.Decimal
	delivery_at           *uint32
	adddelivery_at        *int32
	target_amount         *decimal.Decimal
	deposit_start_at      *uint32
	adddeposit_start_at   *int32
	deposit_end_at        *uint32
	adddeposit_end_at     *int32
	contract_address      *string
	deposit_coin_type_id  *uuid.UUID
	redeemable            *bool
	redeem_delay_hours    *uint32
	addredeem_delay_hours *int32
	duration_display_type *string
	duration_seconds      *uint32
	addduration_seconds   *int32
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*FbmCrowdFunding, error)
	predicates            []predicate.FbmCrowdFunding
}

var _ ent.Mutation = (*FbmCrowdFundingMutation)(nil)

// fbmcrowdfundingOption allows management of the mutation configuration using functional options.
type fbmcrowdfundingOption func(*FbmCrowdFundingMutation)

// newFbmCrowdFundingMutation creates new mutation for the FbmCrowdFunding entity.
func newFbmCrowdFundingMutation(c config, op Op, opts ...fbmcrowdfundingOption) *FbmCrowdFundingMutation {
	m := &FbmCrowdFundingMutation{
		config:        c,
		op:            op,
		typ:           TypeFbmCrowdFunding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFbmCrowdFundingID sets the ID field of the mutation.
func withFbmCrowdFundingID(id uint32) fbmcrowdfundingOption {
	return func(m *FbmCrowdFundingMutation) {
		var (
			err   error
			once  sync.Once
			value *FbmCrowdFunding
		)
		m.oldValue = func(ctx context.Context) (*FbmCrowdFunding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FbmCrowdFunding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFbmCrowdFunding sets the old FbmCrowdFunding of the mutation.
func withFbmCrowdFunding(node *FbmCrowdFunding) fbmcrowdfundingOption {
	return func(m *FbmCrowdFundingMutation) {
		m.oldValue = func(context.Context) (*FbmCrowdFunding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FbmCrowdFundingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FbmCrowdFundingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FbmCrowdFunding entities.
func (m *FbmCrowdFundingMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FbmCrowdFundingMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FbmCrowdFundingMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FbmCrowdFunding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *FbmCrowdFundingMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *FbmCrowdFundingMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *FbmCrowdFundingMutation) ResetEntID() {
	m.ent_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *FbmCrowdFundingMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *FbmCrowdFundingMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *FbmCrowdFundingMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[fbmcrowdfunding.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *FbmCrowdFundingMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldGoodID)
}

// SetMinDepositAmount sets the "min_deposit_amount" field.
func (m *FbmCrowdFundingMutation) SetMinDepositAmount(d decimal.Decimal) {
	m.min_deposit_amount = &d
}

// MinDepositAmount returns the value of the "min_deposit_amount" field in the mutation.
func (m *FbmCrowdFundingMutation) MinDepositAmount() (r decimal.Decimal, exists bool) {
	v := m.min_deposit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMinDepositAmount returns the old "min_deposit_amount" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldMinDepositAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinDepositAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinDepositAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinDepositAmount: %w", err)
	}
	return oldValue.MinDepositAmount, nil
}

// ClearMinDepositAmount clears the value of the "min_deposit_amount" field.
func (m *FbmCrowdFundingMutation) ClearMinDepositAmount() {
	m.min_deposit_amount = nil
	m.clearedFields[fbmcrowdfunding.FieldMinDepositAmount] = struct{}{}
}

// MinDepositAmountCleared returns if the "min_deposit_amount" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) MinDepositAmountCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldMinDepositAmount]
	return ok
}

// ResetMinDepositAmount resets all changes to the "min_deposit_amount" field.
func (m *FbmCrowdFundingMutation) ResetMinDepositAmount() {
	m.min_deposit_amount = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldMinDepositAmount)
}

// SetDeliveryAt sets the "delivery_at" field.
func (m *FbmCrowdFundingMutation) SetDeliveryAt(u uint32) {
	m.delivery_at = &u
	m.adddelivery_at = nil
}

// DeliveryAt returns the value of the "delivery_at" field in the mutation.
func (m *FbmCrowdFundingMutation) DeliveryAt() (r uint32, exists bool) {
	v := m.delivery_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAt returns the old "delivery_at" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldDeliveryAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAt: %w", err)
	}
	return oldValue.DeliveryAt, nil
}

// AddDeliveryAt adds u to the "delivery_at" field.
func (m *FbmCrowdFundingMutation) AddDeliveryAt(u int32) {
	if m.adddelivery_at != nil {
		*m.adddelivery_at += u
	} else {
		m.adddelivery_at = &u
	}
}

// AddedDeliveryAt returns the value that was added to the "delivery_at" field in this mutation.
func (m *FbmCrowdFundingMutation) AddedDeliveryAt() (r int32, exists bool) {
	v := m.adddelivery_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryAt clears the value of the "delivery_at" field.
func (m *FbmCrowdFundingMutation) ClearDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	m.clearedFields[fbmcrowdfunding.FieldDeliveryAt] = struct{}{}
}

// DeliveryAtCleared returns if the "delivery_at" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) DeliveryAtCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldDeliveryAt]
	return ok
}

// ResetDeliveryAt resets all changes to the "delivery_at" field.
func (m *FbmCrowdFundingMutation) ResetDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldDeliveryAt)
}

// SetTargetAmount sets the "target_amount" field.
func (m *FbmCrowdFundingMutation) SetTargetAmount(d decimal.Decimal) {
	m.target_amount = &d
}

// TargetAmount returns the value of the "target_amount" field in the mutation.
func (m *FbmCrowdFundingMutation) TargetAmount() (r decimal.Decimal, exists bool) {
	v := m.target_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetAmount returns the old "target_amount" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldTargetAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetAmount: %w", err)
	}
	return oldValue.TargetAmount, nil
}

// ClearTargetAmount clears the value of the "target_amount" field.
func (m *FbmCrowdFundingMutation) ClearTargetAmount() {
	m.target_amount = nil
	m.clearedFields[fbmcrowdfunding.FieldTargetAmount] = struct{}{}
}

// TargetAmountCleared returns if the "target_amount" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) TargetAmountCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldTargetAmount]
	return ok
}

// ResetTargetAmount resets all changes to the "target_amount" field.
func (m *FbmCrowdFundingMutation) ResetTargetAmount() {
	m.target_amount = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldTargetAmount)
}

// SetDepositStartAt sets the "deposit_start_at" field.
func (m *FbmCrowdFundingMutation) SetDepositStartAt(u uint32) {
	m.deposit_start_at = &u
	m.adddeposit_start_at = nil
}

// DepositStartAt returns the value of the "deposit_start_at" field in the mutation.
func (m *FbmCrowdFundingMutation) DepositStartAt() (r uint32, exists bool) {
	v := m.deposit_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositStartAt returns the old "deposit_start_at" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldDepositStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositStartAt: %w", err)
	}
	return oldValue.DepositStartAt, nil
}

// AddDepositStartAt adds u to the "deposit_start_at" field.
func (m *FbmCrowdFundingMutation) AddDepositStartAt(u int32) {
	if m.adddeposit_start_at != nil {
		*m.adddeposit_start_at += u
	} else {
		m.adddeposit_start_at = &u
	}
}

// AddedDepositStartAt returns the value that was added to the "deposit_start_at" field in this mutation.
func (m *FbmCrowdFundingMutation) AddedDepositStartAt() (r int32, exists bool) {
	v := m.adddeposit_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepositStartAt clears the value of the "deposit_start_at" field.
func (m *FbmCrowdFundingMutation) ClearDepositStartAt() {
	m.deposit_start_at = nil
	m.adddeposit_start_at = nil
	m.clearedFields[fbmcrowdfunding.FieldDepositStartAt] = struct{}{}
}

// DepositStartAtCleared returns if the "deposit_start_at" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) DepositStartAtCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldDepositStartAt]
	return ok
}

// ResetDepositStartAt resets all changes to the "deposit_start_at" field.
func (m *FbmCrowdFundingMutation) ResetDepositStartAt() {
	m.deposit_start_at = nil
	m.adddeposit_start_at = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldDepositStartAt)
}

// SetDepositEndAt sets the "deposit_end_at" field.
func (m *FbmCrowdFundingMutation) SetDepositEndAt(u uint32) {
	m.deposit_end_at = &u
	m.adddeposit_end_at = nil
}

// DepositEndAt returns the value of the "deposit_end_at" field in the mutation.
func (m *FbmCrowdFundingMutation) DepositEndAt() (r uint32, exists bool) {
	v := m.deposit_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositEndAt returns the old "deposit_end_at" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldDepositEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositEndAt: %w", err)
	}
	return oldValue.DepositEndAt, nil
}

// AddDepositEndAt adds u to the "deposit_end_at" field.
func (m *FbmCrowdFundingMutation) AddDepositEndAt(u int32) {
	if m.adddeposit_end_at != nil {
		*m.adddeposit_end_at += u
	} else {
		m.adddeposit_end_at = &u
	}
}

// AddedDepositEndAt returns the value that was added to the "deposit_end_at" field in this mutation.
func (m *FbmCrowdFundingMutation) AddedDepositEndAt() (r int32, exists bool) {
	v := m.adddeposit_end_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepositEndAt clears the value of the "deposit_end_at" field.
func (m *FbmCrowdFundingMutation) ClearDepositEndAt() {
	m.deposit_end_at = nil
	m.adddeposit_end_at = nil
	m.clearedFields[fbmcrowdfunding.FieldDepositEndAt] = struct{}{}
}

// DepositEndAtCleared returns if the "deposit_end_at" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) DepositEndAtCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldDepositEndAt]
	return ok
}

// ResetDepositEndAt resets all changes to the "deposit_end_at" field.
func (m *FbmCrowdFundingMutation) ResetDepositEndAt() {
	m.deposit_end_at = nil
	m.adddeposit_end_at = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldDepositEndAt)
}

// SetContractAddress sets the "contract_address" field.
func (m *FbmCrowdFundingMutation) SetContractAddress(s string) {
	m.contract_address = &s
}

// ContractAddress returns the value of the "contract_address" field in the mutation.
func (m *FbmCrowdFundingMutation) ContractAddress() (r string, exists bool) {
	v := m.contract_address
	if v == nil {
		return
	}
	return *v, true
}

// OldContractAddress returns the old "contract_address" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldContractAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractAddress: %w", err)
	}
	return oldValue.ContractAddress, nil
}

// ClearContractAddress clears the value of the "contract_address" field.
func (m *FbmCrowdFundingMutation) ClearContractAddress() {
	m.contract_address = nil
	m.clearedFields[fbmcrowdfunding.FieldContractAddress] = struct{}{}
}

// ContractAddressCleared returns if the "contract_address" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) ContractAddressCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldContractAddress]
	return ok
}

// ResetContractAddress resets all changes to the "contract_address" field.
func (m *FbmCrowdFundingMutation) ResetContractAddress() {
	m.contract_address = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldContractAddress)
}

// SetDepositCoinTypeID sets the "deposit_coin_type_id" field.
func (m *FbmCrowdFundingMutation) SetDepositCoinTypeID(u uuid.UUID) {
	m.deposit_coin_type_id = &u
}

// DepositCoinTypeID returns the value of the "deposit_coin_type_id" field in the mutation.
func (m *FbmCrowdFundingMutation) DepositCoinTypeID() (r uuid.UUID, exists bool) {
	v := m.deposit_coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositCoinTypeID returns the old "deposit_coin_type_id" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldDepositCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositCoinTypeID: %w", err)
	}
	return oldValue.DepositCoinTypeID, nil
}

// ClearDepositCoinTypeID clears the value of the "deposit_coin_type_id" field.
func (m *FbmCrowdFundingMutation) ClearDepositCoinTypeID() {
	m.deposit_coin_type_id = nil
	m.clearedFields[fbmcrowdfunding.FieldDepositCoinTypeID] = struct{}{}
}

// DepositCoinTypeIDCleared returns if the "deposit_coin_type_id" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) DepositCoinTypeIDCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldDepositCoinTypeID]
	return ok
}

// ResetDepositCoinTypeID resets all changes to the "deposit_coin_type_id" field.
func (m *FbmCrowdFundingMutation) ResetDepositCoinTypeID() {
	m.deposit_coin_type_id = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldDepositCoinTypeID)
}

// SetRedeemable sets the "redeemable" field.
func (m *FbmCrowdFundingMutation) SetRedeemable(b bool) {
	m.redeemable = &b
}

// Redeemable returns the value of the "redeemable" field in the mutation.
func (m *FbmCrowdFundingMutation) Redeemable() (r bool, exists bool) {
	v := m.redeemable
	if v == nil {
		return
	}
	return *v, true
}

// OldRedeemable returns the old "redeemable" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldRedeemable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedeemable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedeemable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedeemable: %w", err)
	}
	return oldValue.Redeemable, nil
}

// ClearRedeemable clears the value of the "redeemable" field.
func (m *FbmCrowdFundingMutation) ClearRedeemable() {
	m.redeemable = nil
	m.clearedFields[fbmcrowdfunding.FieldRedeemable] = struct{}{}
}

// RedeemableCleared returns if the "redeemable" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) RedeemableCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldRedeemable]
	return ok
}

// ResetRedeemable resets all changes to the "redeemable" field.
func (m *FbmCrowdFundingMutation) ResetRedeemable() {
	m.redeemable = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldRedeemable)
}

// SetRedeemDelayHours sets the "redeem_delay_hours" field.
func (m *FbmCrowdFundingMutation) SetRedeemDelayHours(u uint32) {
	m.redeem_delay_hours = &u
	m.addredeem_delay_hours = nil
}

// RedeemDelayHours returns the value of the "redeem_delay_hours" field in the mutation.
func (m *FbmCrowdFundingMutation) RedeemDelayHours() (r uint32, exists bool) {
	v := m.redeem_delay_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRedeemDelayHours returns the old "redeem_delay_hours" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldRedeemDelayHours(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedeemDelayHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedeemDelayHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedeemDelayHours: %w", err)
	}
	return oldValue.RedeemDelayHours, nil
}

// AddRedeemDelayHours adds u to the "redeem_delay_hours" field.
func (m *FbmCrowdFundingMutation) AddRedeemDelayHours(u int32) {
	if m.addredeem_delay_hours != nil {
		*m.addredeem_delay_hours += u
	} else {
		m.addredeem_delay_hours = &u
	}
}

// AddedRedeemDelayHours returns the value that was added to the "redeem_delay_hours" field in this mutation.
func (m *FbmCrowdFundingMutation) AddedRedeemDelayHours() (r int32, exists bool) {
	v := m.addredeem_delay_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearRedeemDelayHours clears the value of the "redeem_delay_hours" field.
func (m *FbmCrowdFundingMutation) ClearRedeemDelayHours() {
	m.redeem_delay_hours = nil
	m.addredeem_delay_hours = nil
	m.clearedFields[fbmcrowdfunding.FieldRedeemDelayHours] = struct{}{}
}

// RedeemDelayHoursCleared returns if the "redeem_delay_hours" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) RedeemDelayHoursCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldRedeemDelayHours]
	return ok
}

// ResetRedeemDelayHours resets all changes to the "redeem_delay_hours" field.
func (m *FbmCrowdFundingMutation) ResetRedeemDelayHours() {
	m.redeem_delay_hours = nil
	m.addredeem_delay_hours = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldRedeemDelayHours)
}

// SetDurationDisplayType sets the "duration_display_type" field.
func (m *FbmCrowdFundingMutation) SetDurationDisplayType(s string) {
	m.duration_display_type = &s
}

// DurationDisplayType returns the value of the "duration_display_type" field in the mutation.
func (m *FbmCrowdFundingMutation) DurationDisplayType() (r string, exists bool) {
	v := m.duration_display_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDisplayType returns the old "duration_display_type" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldDurationDisplayType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDisplayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDisplayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDisplayType: %w", err)
	}
	return oldValue.DurationDisplayType, nil
}

// ClearDurationDisplayType clears the value of the "duration_display_type" field.
func (m *FbmCrowdFundingMutation) ClearDurationDisplayType() {
	m.duration_display_type = nil
	m.clearedFields[fbmcrowdfunding.FieldDurationDisplayType] = struct{}{}
}

// DurationDisplayTypeCleared returns if the "duration_display_type" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) DurationDisplayTypeCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldDurationDisplayType]
	return ok
}

// ResetDurationDisplayType resets all changes to the "duration_display_type" field.
func (m *FbmCrowdFundingMutation) ResetDurationDisplayType() {
	m.duration_display_type = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldDurationDisplayType)
}

// SetDurationSeconds sets the "duration_seconds" field.
func (m *FbmCrowdFundingMutation) SetDurationSeconds(u uint32) {
	m.duration_seconds = &u
	m.addduration_seconds = nil
}

// DurationSeconds returns the value of the "duration_seconds" field in the mutation.
func (m *FbmCrowdFundingMutation) DurationSeconds() (r uint32, exists bool) {
	v := m.duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationSeconds returns the old "duration_seconds" field's value of the FbmCrowdFunding entity.
// If the FbmCrowdFunding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FbmCrowdFundingMutation) OldDurationSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationSeconds: %w", err)
	}
	return oldValue.DurationSeconds, nil
}

// AddDurationSeconds adds u to the "duration_seconds" field.
func (m *FbmCrowdFundingMutation) AddDurationSeconds(u int32) {
	if m.addduration_seconds != nil {
		*m.addduration_seconds += u
	} else {
		m.addduration_seconds = &u
	}
}

// AddedDurationSeconds returns the value that was added to the "duration_seconds" field in this mutation.
func (m *FbmCrowdFundingMutation) AddedDurationSeconds() (r int32, exists bool) {
	v := m.addduration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationSeconds clears the value of the "duration_seconds" field.
func (m *FbmCrowdFundingMutation) ClearDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
	m.clearedFields[fbmcrowdfunding.FieldDurationSeconds] = struct{}{}
}

// DurationSecondsCleared returns if the "duration_seconds" field was cleared in this mutation.
func (m *FbmCrowdFundingMutation) DurationSecondsCleared() bool {
	_, ok := m.clearedFields[fbmcrowdfunding.FieldDurationSeconds]
	return ok
}

// ResetDurationSeconds resets all changes to the "duration_seconds" field.
func (m *FbmCrowdFundingMutation) ResetDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
	delete(m.clearedFields, fbmcrowdfunding.FieldDurationSeconds)
}

// Where appends a list predicates to the FbmCrowdFundingMutation builder.
func (m *FbmCrowdFundingMutation) Where(ps ...predicate.FbmCrowdFunding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FbmCrowdFundingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FbmCrowdFundingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FbmCrowdFunding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FbmCrowdFundingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FbmCrowdFundingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FbmCrowdFunding).
func (m *FbmCrowdFundingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FbmCrowdFundingMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.ent_id != nil {
		fields = append(fields, fbmcrowdfunding.FieldEntID)
	}
	if m.good_id != nil {
		fields = append(fields, fbmcrowdfunding.FieldGoodID)
	}
	if m.min_deposit_amount != nil {
		fields = append(fields, fbmcrowdfunding.FieldMinDepositAmount)
	}
	if m.delivery_at != nil {
		fields = append(fields, fbmcrowdfunding.FieldDeliveryAt)
	}
	if m.target_amount != nil {
		fields = append(fields, fbmcrowdfunding.FieldTargetAmount)
	}
	if m.deposit_start_at != nil {
		fields = append(fields, fbmcrowdfunding.FieldDepositStartAt)
	}
	if m.deposit_end_at != nil {
		fields = append(fields, fbmcrowdfunding.FieldDepositEndAt)
	}
	if m.contract_address != nil {
		fields = append(fields, fbmcrowdfunding.FieldContractAddress)
	}
	if m.deposit_coin_type_id != nil {
		fields = append(fields, fbmcrowdfunding.FieldDepositCoinTypeID)
	}
	if m.redeemable != nil {
		fields = append(fields, fbmcrowdfunding.FieldRedeemable)
	}
	if m.redeem_delay_hours != nil {
		fields = append(fields, fbmcrowdfunding.FieldRedeemDelayHours)
	}
	if m.duration_display_type != nil {
		fields = append(fields, fbmcrowdfunding.FieldDurationDisplayType)
	}
	if m.duration_seconds != nil {
		fields = append(fields, fbmcrowdfunding.FieldDurationSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FbmCrowdFundingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fbmcrowdfunding.FieldEntID:
		return m.EntID()
	case fbmcrowdfunding.FieldGoodID:
		return m.GoodID()
	case fbmcrowdfunding.FieldMinDepositAmount:
		return m.MinDepositAmount()
	case fbmcrowdfunding.FieldDeliveryAt:
		return m.DeliveryAt()
	case fbmcrowdfunding.FieldTargetAmount:
		return m.TargetAmount()
	case fbmcrowdfunding.FieldDepositStartAt:
		return m.DepositStartAt()
	case fbmcrowdfunding.FieldDepositEndAt:
		return m.DepositEndAt()
	case fbmcrowdfunding.FieldContractAddress:
		return m.ContractAddress()
	case fbmcrowdfunding.FieldDepositCoinTypeID:
		return m.DepositCoinTypeID()
	case fbmcrowdfunding.FieldRedeemable:
		return m.Redeemable()
	case fbmcrowdfunding.FieldRedeemDelayHours:
		return m.RedeemDelayHours()
	case fbmcrowdfunding.FieldDurationDisplayType:
		return m.DurationDisplayType()
	case fbmcrowdfunding.FieldDurationSeconds:
		return m.DurationSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FbmCrowdFundingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fbmcrowdfunding.FieldEntID:
		return m.OldEntID(ctx)
	case fbmcrowdfunding.FieldGoodID:
		return m.OldGoodID(ctx)
	case fbmcrowdfunding.FieldMinDepositAmount:
		return m.OldMinDepositAmount(ctx)
	case fbmcrowdfunding.FieldDeliveryAt:
		return m.OldDeliveryAt(ctx)
	case fbmcrowdfunding.FieldTargetAmount:
		return m.OldTargetAmount(ctx)
	case fbmcrowdfunding.FieldDepositStartAt:
		return m.OldDepositStartAt(ctx)
	case fbmcrowdfunding.FieldDepositEndAt:
		return m.OldDepositEndAt(ctx)
	case fbmcrowdfunding.FieldContractAddress:
		return m.OldContractAddress(ctx)
	case fbmcrowdfunding.FieldDepositCoinTypeID:
		return m.OldDepositCoinTypeID(ctx)
	case fbmcrowdfunding.FieldRedeemable:
		return m.OldRedeemable(ctx)
	case fbmcrowdfunding.FieldRedeemDelayHours:
		return m.OldRedeemDelayHours(ctx)
	case fbmcrowdfunding.FieldDurationDisplayType:
		return m.OldDurationDisplayType(ctx)
	case fbmcrowdfunding.FieldDurationSeconds:
		return m.OldDurationSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown FbmCrowdFunding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FbmCrowdFundingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fbmcrowdfunding.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case fbmcrowdfunding.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case fbmcrowdfunding.FieldMinDepositAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinDepositAmount(v)
		return nil
	case fbmcrowdfunding.FieldDeliveryAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAt(v)
		return nil
	case fbmcrowdfunding.FieldTargetAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetAmount(v)
		return nil
	case fbmcrowdfunding.FieldDepositStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositStartAt(v)
		return nil
	case fbmcrowdfunding.FieldDepositEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositEndAt(v)
		return nil
	case fbmcrowdfunding.FieldContractAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractAddress(v)
		return nil
	case fbmcrowdfunding.FieldDepositCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositCoinTypeID(v)
		return nil
	case fbmcrowdfunding.FieldRedeemable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedeemable(v)
		return nil
	case fbmcrowdfunding.FieldRedeemDelayHours:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedeemDelayHours(v)
		return nil
	case fbmcrowdfunding.FieldDurationDisplayType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDisplayType(v)
		return nil
	case fbmcrowdfunding.FieldDurationSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown FbmCrowdFunding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FbmCrowdFundingMutation) AddedFields() []string {
	var fields []string
	if m.adddelivery_at != nil {
		fields = append(fields, fbmcrowdfunding.FieldDeliveryAt)
	}
	if m.adddeposit_start_at != nil {
		fields = append(fields, fbmcrowdfunding.FieldDepositStartAt)
	}
	if m.adddeposit_end_at != nil {
		fields = append(fields, fbmcrowdfunding.FieldDepositEndAt)
	}
	if m.addredeem_delay_hours != nil {
		fields = append(fields, fbmcrowdfunding.FieldRedeemDelayHours)
	}
	if m.addduration_seconds != nil {
		fields = append(fields, fbmcrowdfunding.FieldDurationSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FbmCrowdFundingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fbmcrowdfunding.FieldDeliveryAt:
		return m.AddedDeliveryAt()
	case fbmcrowdfunding.FieldDepositStartAt:
		return m.AddedDepositStartAt()
	case fbmcrowdfunding.FieldDepositEndAt:
		return m.AddedDepositEndAt()
	case fbmcrowdfunding.FieldRedeemDelayHours:
		return m.AddedRedeemDelayHours()
	case fbmcrowdfunding.FieldDurationSeconds:
		return m.AddedDurationSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FbmCrowdFundingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fbmcrowdfunding.FieldDeliveryAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryAt(v)
		return nil
	case fbmcrowdfunding.FieldDepositStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepositStartAt(v)
		return nil
	case fbmcrowdfunding.FieldDepositEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepositEndAt(v)
		return nil
	case fbmcrowdfunding.FieldRedeemDelayHours:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRedeemDelayHours(v)
		return nil
	case fbmcrowdfunding.FieldDurationSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown FbmCrowdFunding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FbmCrowdFundingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fbmcrowdfunding.FieldGoodID) {
		fields = append(fields, fbmcrowdfunding.FieldGoodID)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldMinDepositAmount) {
		fields = append(fields, fbmcrowdfunding.FieldMinDepositAmount)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldDeliveryAt) {
		fields = append(fields, fbmcrowdfunding.FieldDeliveryAt)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldTargetAmount) {
		fields = append(fields, fbmcrowdfunding.FieldTargetAmount)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldDepositStartAt) {
		fields = append(fields, fbmcrowdfunding.FieldDepositStartAt)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldDepositEndAt) {
		fields = append(fields, fbmcrowdfunding.FieldDepositEndAt)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldContractAddress) {
		fields = append(fields, fbmcrowdfunding.FieldContractAddress)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldDepositCoinTypeID) {
		fields = append(fields, fbmcrowdfunding.FieldDepositCoinTypeID)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldRedeemable) {
		fields = append(fields, fbmcrowdfunding.FieldRedeemable)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldRedeemDelayHours) {
		fields = append(fields, fbmcrowdfunding.FieldRedeemDelayHours)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldDurationDisplayType) {
		fields = append(fields, fbmcrowdfunding.FieldDurationDisplayType)
	}
	if m.FieldCleared(fbmcrowdfunding.FieldDurationSeconds) {
		fields = append(fields, fbmcrowdfunding.FieldDurationSeconds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FbmCrowdFundingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FbmCrowdFundingMutation) ClearField(name string) error {
	switch name {
	case fbmcrowdfunding.FieldGoodID:
		m.ClearGoodID()
		return nil
	case fbmcrowdfunding.FieldMinDepositAmount:
		m.ClearMinDepositAmount()
		return nil
	case fbmcrowdfunding.FieldDeliveryAt:
		m.ClearDeliveryAt()
		return nil
	case fbmcrowdfunding.FieldTargetAmount:
		m.ClearTargetAmount()
		return nil
	case fbmcrowdfunding.FieldDepositStartAt:
		m.ClearDepositStartAt()
		return nil
	case fbmcrowdfunding.FieldDepositEndAt:
		m.ClearDepositEndAt()
		return nil
	case fbmcrowdfunding.FieldContractAddress:
		m.ClearContractAddress()
		return nil
	case fbmcrowdfunding.FieldDepositCoinTypeID:
		m.ClearDepositCoinTypeID()
		return nil
	case fbmcrowdfunding.FieldRedeemable:
		m.ClearRedeemable()
		return nil
	case fbmcrowdfunding.FieldRedeemDelayHours:
		m.ClearRedeemDelayHours()
		return nil
	case fbmcrowdfunding.FieldDurationDisplayType:
		m.ClearDurationDisplayType()
		return nil
	case fbmcrowdfunding.FieldDurationSeconds:
		m.ClearDurationSeconds()
		return nil
	}
	return fmt.Errorf("unknown FbmCrowdFunding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FbmCrowdFundingMutation) ResetField(name string) error {
	switch name {
	case fbmcrowdfunding.FieldEntID:
		m.ResetEntID()
		return nil
	case fbmcrowdfunding.FieldGoodID:
		m.ResetGoodID()
		return nil
	case fbmcrowdfunding.FieldMinDepositAmount:
		m.ResetMinDepositAmount()
		return nil
	case fbmcrowdfunding.FieldDeliveryAt:
		m.ResetDeliveryAt()
		return nil
	case fbmcrowdfunding.FieldTargetAmount:
		m.ResetTargetAmount()
		return nil
	case fbmcrowdfunding.FieldDepositStartAt:
		m.ResetDepositStartAt()
		return nil
	case fbmcrowdfunding.FieldDepositEndAt:
		m.ResetDepositEndAt()
		return nil
	case fbmcrowdfunding.FieldContractAddress:
		m.ResetContractAddress()
		return nil
	case fbmcrowdfunding.FieldDepositCoinTypeID:
		m.ResetDepositCoinTypeID()
		return nil
	case fbmcrowdfunding.FieldRedeemable:
		m.ResetRedeemable()
		return nil
	case fbmcrowdfunding.FieldRedeemDelayHours:
		m.ResetRedeemDelayHours()
		return nil
	case fbmcrowdfunding.FieldDurationDisplayType:
		m.ResetDurationDisplayType()
		return nil
	case fbmcrowdfunding.FieldDurationSeconds:
		m.ResetDurationSeconds()
		return nil
	}
	return fmt.Errorf("unknown FbmCrowdFunding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FbmCrowdFundingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FbmCrowdFundingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FbmCrowdFundingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FbmCrowdFundingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FbmCrowdFundingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FbmCrowdFundingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FbmCrowdFundingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FbmCrowdFunding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FbmCrowdFundingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FbmCrowdFunding edge %s", name)
}

// FeeMutation represents an operation that mutates the Fee nodes in the graph.
type FeeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	ent_id                *uuid.UUID
	created_at            *uint32
	addcreated_at         *int32
	updated_at            *uint32
	addupdated_at         *int32
	deleted_at            *uint32
	adddeleted_at         *int32
	good_id               *uuid.UUID
	settlement_type       *string
	unit_value            *decimal.Decimal
	duration_display_type *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Fee, error)
	predicates            []predicate.Fee
}

var _ ent.Mutation = (*FeeMutation)(nil)

// feeOption allows management of the mutation configuration using functional options.
type feeOption func(*FeeMutation)

// newFeeMutation creates new mutation for the Fee entity.
func newFeeMutation(c config, op Op, opts ...feeOption) *FeeMutation {
	m := &FeeMutation{
		config:        c,
		op:            op,
		typ:           TypeFee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeeID sets the ID field of the mutation.
func withFeeID(id uint32) feeOption {
	return func(m *FeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Fee
		)
		m.oldValue = func(ctx context.Context) (*Fee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFee sets the old Fee of the mutation.
func withFee(node *Fee) feeOption {
	return func(m *FeeMutation) {
		m.oldValue = func(context.Context) (*Fee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Fee entities.
func (m *FeeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *FeeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *FeeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Fee entity.
// If the Fee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *FeeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Fee entity.
// If the Fee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *FeeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FeeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Fee entity.
// If the Fee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *FeeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FeeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Fee entity.
// If the Fee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *FeeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FeeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *FeeMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *FeeMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Fee entity.
// If the Fee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeeMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *FeeMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[fee.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *FeeMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[fee.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *FeeMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, fee.FieldGoodID)
}

// SetSettlementType sets the "settlement_type" field.
func (m *FeeMutation) SetSettlementType(s string) {
	m.settlement_type = &s
}

// SettlementType returns the value of the "settlement_type" field in the mutation.
func (m *FeeMutation) SettlementType() (r string, exists bool) {
	v := m.settlement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettlementType returns the old "settlement_type" field's value of the Fee entity.
// If the Fee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeeMutation) OldSettlementType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettlementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettlementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettlementType: %w", err)
	}
	return oldValue.SettlementType, nil
}

// ClearSettlementType clears the value of the "settlement_type" field.
func (m *FeeMutation) ClearSettlementType() {
	m.settlement_type = nil
	m.clearedFields[fee.FieldSettlementType] = struct{}{}
}

// SettlementTypeCleared returns if the "settlement_type" field was cleared in this mutation.
func (m *FeeMutation) SettlementTypeCleared() bool {
	_, ok := m.clearedFields[fee.FieldSettlementType]
	return ok
}

// ResetSettlementType resets all changes to the "settlement_type" field.
func (m *FeeMutation) ResetSettlementType() {
	m.settlement_type = nil
	delete(m.clearedFields, fee.FieldSettlementType)
}

// SetUnitValue sets the "unit_value" field.
func (m *FeeMutation) SetUnitValue(d decimal.Decimal) {
	m.unit_value = &d
}

// UnitValue returns the value of the "unit_value" field in the mutation.
func (m *FeeMutation) UnitValue() (r decimal.Decimal, exists bool) {
	v := m.unit_value
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitValue returns the old "unit_value" field's value of the Fee entity.
// If the Fee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeeMutation) OldUnitValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitValue: %w", err)
	}
	return oldValue.UnitValue, nil
}

// ClearUnitValue clears the value of the "unit_value" field.
func (m *FeeMutation) ClearUnitValue() {
	m.unit_value = nil
	m.clearedFields[fee.FieldUnitValue] = struct{}{}
}

// UnitValueCleared returns if the "unit_value" field was cleared in this mutation.
func (m *FeeMutation) UnitValueCleared() bool {
	_, ok := m.clearedFields[fee.FieldUnitValue]
	return ok
}

// ResetUnitValue resets all changes to the "unit_value" field.
func (m *FeeMutation) ResetUnitValue() {
	m.unit_value = nil
	delete(m.clearedFields, fee.FieldUnitValue)
}

// SetDurationDisplayType sets the "duration_display_type" field.
func (m *FeeMutation) SetDurationDisplayType(s string) {
	m.duration_display_type = &s
}

// DurationDisplayType returns the value of the "duration_display_type" field in the mutation.
func (m *FeeMutation) DurationDisplayType() (r string, exists bool) {
	v := m.duration_display_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDisplayType returns the old "duration_display_type" field's value of the Fee entity.
// If the Fee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeeMutation) OldDurationDisplayType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDisplayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDisplayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDisplayType: %w", err)
	}
	return oldValue.DurationDisplayType, nil
}

// ClearDurationDisplayType clears the value of the "duration_display_type" field.
func (m *FeeMutation) ClearDurationDisplayType() {
	m.duration_display_type = nil
	m.clearedFields[fee.FieldDurationDisplayType] = struct{}{}
}

// DurationDisplayTypeCleared returns if the "duration_display_type" field was cleared in this mutation.
func (m *FeeMutation) DurationDisplayTypeCleared() bool {
	_, ok := m.clearedFields[fee.FieldDurationDisplayType]
	return ok
}

// ResetDurationDisplayType resets all changes to the "duration_display_type" field.
func (m *FeeMutation) ResetDurationDisplayType() {
	m.duration_display_type = nil
	delete(m.clearedFields, fee.FieldDurationDisplayType)
}

// Where appends a list predicates to the FeeMutation builder.
func (m *FeeMutation) Where(ps ...predicate.Fee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Fee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Fee).
func (m *FeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, fee.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, fee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fee.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, fee.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, fee.FieldGoodID)
	}
	if m.settlement_type != nil {
		fields = append(fields, fee.FieldSettlementType)
	}
	if m.unit_value != nil {
		fields = append(fields, fee.FieldUnitValue)
	}
	if m.duration_display_type != nil {
		fields = append(fields, fee.FieldDurationDisplayType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fee.FieldEntID:
		return m.EntID()
	case fee.FieldCreatedAt:
		return m.CreatedAt()
	case fee.FieldUpdatedAt:
		return m.UpdatedAt()
	case fee.FieldDeletedAt:
		return m.DeletedAt()
	case fee.FieldGoodID:
		return m.GoodID()
	case fee.FieldSettlementType:
		return m.SettlementType()
	case fee.FieldUnitValue:
		return m.UnitValue()
	case fee.FieldDurationDisplayType:
		return m.DurationDisplayType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fee.FieldEntID:
		return m.OldEntID(ctx)
	case fee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case fee.FieldGoodID:
		return m.OldGoodID(ctx)
	case fee.FieldSettlementType:
		return m.OldSettlementType(ctx)
	case fee.FieldUnitValue:
		return m.OldUnitValue(ctx)
	case fee.FieldDurationDisplayType:
		return m.OldDurationDisplayType(ctx)
	}
	return nil, fmt.Errorf("unknown Fee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fee.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case fee.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fee.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fee.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case fee.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case fee.FieldSettlementType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettlementType(v)
		return nil
	case fee.FieldUnitValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitValue(v)
		return nil
	case fee.FieldDurationDisplayType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDisplayType(v)
		return nil
	}
	return fmt.Errorf("unknown Fee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, fee.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, fee.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, fee.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fee.FieldCreatedAt:
		return m.AddedCreatedAt()
	case fee.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case fee.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fee.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case fee.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case fee.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Fee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fee.FieldGoodID) {
		fields = append(fields, fee.FieldGoodID)
	}
	if m.FieldCleared(fee.FieldSettlementType) {
		fields = append(fields, fee.FieldSettlementType)
	}
	if m.FieldCleared(fee.FieldUnitValue) {
		fields = append(fields, fee.FieldUnitValue)
	}
	if m.FieldCleared(fee.FieldDurationDisplayType) {
		fields = append(fields, fee.FieldDurationDisplayType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeeMutation) ClearField(name string) error {
	switch name {
	case fee.FieldGoodID:
		m.ClearGoodID()
		return nil
	case fee.FieldSettlementType:
		m.ClearSettlementType()
		return nil
	case fee.FieldUnitValue:
		m.ClearUnitValue()
		return nil
	case fee.FieldDurationDisplayType:
		m.ClearDurationDisplayType()
		return nil
	}
	return fmt.Errorf("unknown Fee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeeMutation) ResetField(name string) error {
	switch name {
	case fee.FieldEntID:
		m.ResetEntID()
		return nil
	case fee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case fee.FieldGoodID:
		m.ResetGoodID()
		return nil
	case fee.FieldSettlementType:
		m.ResetSettlementType()
		return nil
	case fee.FieldUnitValue:
		m.ResetUnitValue()
		return nil
	case fee.FieldDurationDisplayType:
		m.ResetDurationDisplayType()
		return nil
	}
	return fmt.Errorf("unknown Fee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Fee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Fee edge %s", name)
}

// GoodMutation represents an operation that mutates the Good nodes in the graph.
type GoodMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	ent_id                    *uuid.UUID
	created_at                *uint32
	addcreated_at             *int32
	updated_at                *uint32
	addupdated_at             *int32
	deleted_at                *uint32
	adddeleted_at             *int32
	device_info_id            *uuid.UUID
	coin_type_id              *uuid.UUID
	inherit_from_good_id      *uuid.UUID
	vendor_location_id        *uuid.UUID
	unit_price                *decimal.Decimal
	benefit_type              *string
	good_type                 *string
	title                     *string
	unit                      *string
	quantity_unit             *string
	unit_amount               *int32
	addunit_amount            *int32
	quantity_unit_amount      *decimal.Decimal
	delivery_at               *uint32
	adddelivery_at            *int32
	start_at                  *uint32
	addstart_at               *int32
	start_mode                *string
	test_only                 *bool
	benefit_interval_hours    *uint32
	addbenefit_interval_hours *int32
	unit_lock_deposit         *decimal.Decimal
	unit_type                 *string
	quantity_calculate_type   *string
	duration_type             *string
	duration_calculate_type   *string
	settlement_type           *string
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Good, error)
	predicates                []predicate.Good
}

var _ ent.Mutation = (*GoodMutation)(nil)

// goodOption allows management of the mutation configuration using functional options.
type goodOption func(*GoodMutation)

// newGoodMutation creates new mutation for the Good entity.
func newGoodMutation(c config, op Op, opts ...goodOption) *GoodMutation {
	m := &GoodMutation{
		config:        c,
		op:            op,
		typ:           TypeGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodID sets the ID field of the mutation.
func withGoodID(id uint32) goodOption {
	return func(m *GoodMutation) {
		var (
			err   error
			once  sync.Once
			value *Good
		)
		m.oldValue = func(ctx context.Context) (*Good, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Good.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGood sets the old Good of the mutation.
func withGood(node *Good) goodOption {
	return func(m *GoodMutation) {
		m.oldValue = func(context.Context) (*Good, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Good entities.
func (m *GoodMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Good.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *GoodMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *GoodMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info_id = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *GoodMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *GoodMutation) ResetDeviceInfoID() {
	m.device_info_id = nil
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *GoodMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *GoodMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *GoodMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
}

// SetInheritFromGoodID sets the "inherit_from_good_id" field.
func (m *GoodMutation) SetInheritFromGoodID(u uuid.UUID) {
	m.inherit_from_good_id = &u
}

// InheritFromGoodID returns the value of the "inherit_from_good_id" field in the mutation.
func (m *GoodMutation) InheritFromGoodID() (r uuid.UUID, exists bool) {
	v := m.inherit_from_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritFromGoodID returns the old "inherit_from_good_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldInheritFromGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritFromGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritFromGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritFromGoodID: %w", err)
	}
	return oldValue.InheritFromGoodID, nil
}

// ClearInheritFromGoodID clears the value of the "inherit_from_good_id" field.
func (m *GoodMutation) ClearInheritFromGoodID() {
	m.inherit_from_good_id = nil
	m.clearedFields[good.FieldInheritFromGoodID] = struct{}{}
}

// InheritFromGoodIDCleared returns if the "inherit_from_good_id" field was cleared in this mutation.
func (m *GoodMutation) InheritFromGoodIDCleared() bool {
	_, ok := m.clearedFields[good.FieldInheritFromGoodID]
	return ok
}

// ResetInheritFromGoodID resets all changes to the "inherit_from_good_id" field.
func (m *GoodMutation) ResetInheritFromGoodID() {
	m.inherit_from_good_id = nil
	delete(m.clearedFields, good.FieldInheritFromGoodID)
}

// SetVendorLocationID sets the "vendor_location_id" field.
func (m *GoodMutation) SetVendorLocationID(u uuid.UUID) {
	m.vendor_location_id = &u
}

// VendorLocationID returns the value of the "vendor_location_id" field in the mutation.
func (m *GoodMutation) VendorLocationID() (r uuid.UUID, exists bool) {
	v := m.vendor_location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorLocationID returns the old "vendor_location_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldVendorLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorLocationID: %w", err)
	}
	return oldValue.VendorLocationID, nil
}

// ResetVendorLocationID resets all changes to the "vendor_location_id" field.
func (m *GoodMutation) ResetVendorLocationID() {
	m.vendor_location_id = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *GoodMutation) SetUnitPrice(d decimal.Decimal) {
	m.unit_price = &d
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *GoodMutation) UnitPrice() (r decimal.Decimal, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnitPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// ClearUnitPrice clears the value of the "unit_price" field.
func (m *GoodMutation) ClearUnitPrice() {
	m.unit_price = nil
	m.clearedFields[good.FieldUnitPrice] = struct{}{}
}

// UnitPriceCleared returns if the "unit_price" field was cleared in this mutation.
func (m *GoodMutation) UnitPriceCleared() bool {
	_, ok := m.clearedFields[good.FieldUnitPrice]
	return ok
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *GoodMutation) ResetUnitPrice() {
	m.unit_price = nil
	delete(m.clearedFields, good.FieldUnitPrice)
}

// SetBenefitType sets the "benefit_type" field.
func (m *GoodMutation) SetBenefitType(s string) {
	m.benefit_type = &s
}

// BenefitType returns the value of the "benefit_type" field in the mutation.
func (m *GoodMutation) BenefitType() (r string, exists bool) {
	v := m.benefit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitType returns the old "benefit_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldBenefitType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitType: %w", err)
	}
	return oldValue.BenefitType, nil
}

// ClearBenefitType clears the value of the "benefit_type" field.
func (m *GoodMutation) ClearBenefitType() {
	m.benefit_type = nil
	m.clearedFields[good.FieldBenefitType] = struct{}{}
}

// BenefitTypeCleared returns if the "benefit_type" field was cleared in this mutation.
func (m *GoodMutation) BenefitTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldBenefitType]
	return ok
}

// ResetBenefitType resets all changes to the "benefit_type" field.
func (m *GoodMutation) ResetBenefitType() {
	m.benefit_type = nil
	delete(m.clearedFields, good.FieldBenefitType)
}

// SetGoodType sets the "good_type" field.
func (m *GoodMutation) SetGoodType(s string) {
	m.good_type = &s
}

// GoodType returns the value of the "good_type" field in the mutation.
func (m *GoodMutation) GoodType() (r string, exists bool) {
	v := m.good_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodType returns the old "good_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldGoodType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodType: %w", err)
	}
	return oldValue.GoodType, nil
}

// ClearGoodType clears the value of the "good_type" field.
func (m *GoodMutation) ClearGoodType() {
	m.good_type = nil
	m.clearedFields[good.FieldGoodType] = struct{}{}
}

// GoodTypeCleared returns if the "good_type" field was cleared in this mutation.
func (m *GoodMutation) GoodTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldGoodType]
	return ok
}

// ResetGoodType resets all changes to the "good_type" field.
func (m *GoodMutation) ResetGoodType() {
	m.good_type = nil
	delete(m.clearedFields, good.FieldGoodType)
}

// SetTitle sets the "title" field.
func (m *GoodMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GoodMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *GoodMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[good.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *GoodMutation) TitleCleared() bool {
	_, ok := m.clearedFields[good.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *GoodMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, good.FieldTitle)
}

// SetUnit sets the "unit" field.
func (m *GoodMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *GoodMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *GoodMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[good.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *GoodMutation) UnitCleared() bool {
	_, ok := m.clearedFields[good.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *GoodMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, good.FieldUnit)
}

// SetQuantityUnit sets the "quantity_unit" field.
func (m *GoodMutation) SetQuantityUnit(s string) {
	m.quantity_unit = &s
}

// QuantityUnit returns the value of the "quantity_unit" field in the mutation.
func (m *GoodMutation) QuantityUnit() (r string, exists bool) {
	v := m.quantity_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityUnit returns the old "quantity_unit" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldQuantityUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantityUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantityUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityUnit: %w", err)
	}
	return oldValue.QuantityUnit, nil
}

// ClearQuantityUnit clears the value of the "quantity_unit" field.
func (m *GoodMutation) ClearQuantityUnit() {
	m.quantity_unit = nil
	m.clearedFields[good.FieldQuantityUnit] = struct{}{}
}

// QuantityUnitCleared returns if the "quantity_unit" field was cleared in this mutation.
func (m *GoodMutation) QuantityUnitCleared() bool {
	_, ok := m.clearedFields[good.FieldQuantityUnit]
	return ok
}

// ResetQuantityUnit resets all changes to the "quantity_unit" field.
func (m *GoodMutation) ResetQuantityUnit() {
	m.quantity_unit = nil
	delete(m.clearedFields, good.FieldQuantityUnit)
}

// SetUnitAmount sets the "unit_amount" field.
func (m *GoodMutation) SetUnitAmount(i int32) {
	m.unit_amount = &i
	m.addunit_amount = nil
}

// UnitAmount returns the value of the "unit_amount" field in the mutation.
func (m *GoodMutation) UnitAmount() (r int32, exists bool) {
	v := m.unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitAmount returns the old "unit_amount" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnitAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitAmount: %w", err)
	}
	return oldValue.UnitAmount, nil
}

// AddUnitAmount adds i to the "unit_amount" field.
func (m *GoodMutation) AddUnitAmount(i int32) {
	if m.addunit_amount != nil {
		*m.addunit_amount += i
	} else {
		m.addunit_amount = &i
	}
}

// AddedUnitAmount returns the value that was added to the "unit_amount" field in this mutation.
func (m *GoodMutation) AddedUnitAmount() (r int32, exists bool) {
	v := m.addunit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitAmount clears the value of the "unit_amount" field.
func (m *GoodMutation) ClearUnitAmount() {
	m.unit_amount = nil
	m.addunit_amount = nil
	m.clearedFields[good.FieldUnitAmount] = struct{}{}
}

// UnitAmountCleared returns if the "unit_amount" field was cleared in this mutation.
func (m *GoodMutation) UnitAmountCleared() bool {
	_, ok := m.clearedFields[good.FieldUnitAmount]
	return ok
}

// ResetUnitAmount resets all changes to the "unit_amount" field.
func (m *GoodMutation) ResetUnitAmount() {
	m.unit_amount = nil
	m.addunit_amount = nil
	delete(m.clearedFields, good.FieldUnitAmount)
}

// SetQuantityUnitAmount sets the "quantity_unit_amount" field.
func (m *GoodMutation) SetQuantityUnitAmount(d decimal.Decimal) {
	m.quantity_unit_amount = &d
}

// QuantityUnitAmount returns the value of the "quantity_unit_amount" field in the mutation.
func (m *GoodMutation) QuantityUnitAmount() (r decimal.Decimal, exists bool) {
	v := m.quantity_unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityUnitAmount returns the old "quantity_unit_amount" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldQuantityUnitAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantityUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantityUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityUnitAmount: %w", err)
	}
	return oldValue.QuantityUnitAmount, nil
}

// ClearQuantityUnitAmount clears the value of the "quantity_unit_amount" field.
func (m *GoodMutation) ClearQuantityUnitAmount() {
	m.quantity_unit_amount = nil
	m.clearedFields[good.FieldQuantityUnitAmount] = struct{}{}
}

// QuantityUnitAmountCleared returns if the "quantity_unit_amount" field was cleared in this mutation.
func (m *GoodMutation) QuantityUnitAmountCleared() bool {
	_, ok := m.clearedFields[good.FieldQuantityUnitAmount]
	return ok
}

// ResetQuantityUnitAmount resets all changes to the "quantity_unit_amount" field.
func (m *GoodMutation) ResetQuantityUnitAmount() {
	m.quantity_unit_amount = nil
	delete(m.clearedFields, good.FieldQuantityUnitAmount)
}

// SetDeliveryAt sets the "delivery_at" field.
func (m *GoodMutation) SetDeliveryAt(u uint32) {
	m.delivery_at = &u
	m.adddelivery_at = nil
}

// DeliveryAt returns the value of the "delivery_at" field in the mutation.
func (m *GoodMutation) DeliveryAt() (r uint32, exists bool) {
	v := m.delivery_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAt returns the old "delivery_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeliveryAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAt: %w", err)
	}
	return oldValue.DeliveryAt, nil
}

// AddDeliveryAt adds u to the "delivery_at" field.
func (m *GoodMutation) AddDeliveryAt(u int32) {
	if m.adddelivery_at != nil {
		*m.adddelivery_at += u
	} else {
		m.adddelivery_at = &u
	}
}

// AddedDeliveryAt returns the value that was added to the "delivery_at" field in this mutation.
func (m *GoodMutation) AddedDeliveryAt() (r int32, exists bool) {
	v := m.adddelivery_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryAt clears the value of the "delivery_at" field.
func (m *GoodMutation) ClearDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	m.clearedFields[good.FieldDeliveryAt] = struct{}{}
}

// DeliveryAtCleared returns if the "delivery_at" field was cleared in this mutation.
func (m *GoodMutation) DeliveryAtCleared() bool {
	_, ok := m.clearedFields[good.FieldDeliveryAt]
	return ok
}

// ResetDeliveryAt resets all changes to the "delivery_at" field.
func (m *GoodMutation) ResetDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	delete(m.clearedFields, good.FieldDeliveryAt)
}

// SetStartAt sets the "start_at" field.
func (m *GoodMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *GoodMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *GoodMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *GoodMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *GoodMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[good.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *GoodMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[good.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *GoodMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, good.FieldStartAt)
}

// SetStartMode sets the "start_mode" field.
func (m *GoodMutation) SetStartMode(s string) {
	m.start_mode = &s
}

// StartMode returns the value of the "start_mode" field in the mutation.
func (m *GoodMutation) StartMode() (r string, exists bool) {
	v := m.start_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStartMode returns the old "start_mode" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldStartMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartMode: %w", err)
	}
	return oldValue.StartMode, nil
}

// ClearStartMode clears the value of the "start_mode" field.
func (m *GoodMutation) ClearStartMode() {
	m.start_mode = nil
	m.clearedFields[good.FieldStartMode] = struct{}{}
}

// StartModeCleared returns if the "start_mode" field was cleared in this mutation.
func (m *GoodMutation) StartModeCleared() bool {
	_, ok := m.clearedFields[good.FieldStartMode]
	return ok
}

// ResetStartMode resets all changes to the "start_mode" field.
func (m *GoodMutation) ResetStartMode() {
	m.start_mode = nil
	delete(m.clearedFields, good.FieldStartMode)
}

// SetTestOnly sets the "test_only" field.
func (m *GoodMutation) SetTestOnly(b bool) {
	m.test_only = &b
}

// TestOnly returns the value of the "test_only" field in the mutation.
func (m *GoodMutation) TestOnly() (r bool, exists bool) {
	v := m.test_only
	if v == nil {
		return
	}
	return *v, true
}

// OldTestOnly returns the old "test_only" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldTestOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestOnly: %w", err)
	}
	return oldValue.TestOnly, nil
}

// ClearTestOnly clears the value of the "test_only" field.
func (m *GoodMutation) ClearTestOnly() {
	m.test_only = nil
	m.clearedFields[good.FieldTestOnly] = struct{}{}
}

// TestOnlyCleared returns if the "test_only" field was cleared in this mutation.
func (m *GoodMutation) TestOnlyCleared() bool {
	_, ok := m.clearedFields[good.FieldTestOnly]
	return ok
}

// ResetTestOnly resets all changes to the "test_only" field.
func (m *GoodMutation) ResetTestOnly() {
	m.test_only = nil
	delete(m.clearedFields, good.FieldTestOnly)
}

// SetBenefitIntervalHours sets the "benefit_interval_hours" field.
func (m *GoodMutation) SetBenefitIntervalHours(u uint32) {
	m.benefit_interval_hours = &u
	m.addbenefit_interval_hours = nil
}

// BenefitIntervalHours returns the value of the "benefit_interval_hours" field in the mutation.
func (m *GoodMutation) BenefitIntervalHours() (r uint32, exists bool) {
	v := m.benefit_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitIntervalHours returns the old "benefit_interval_hours" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldBenefitIntervalHours(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitIntervalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitIntervalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitIntervalHours: %w", err)
	}
	return oldValue.BenefitIntervalHours, nil
}

// AddBenefitIntervalHours adds u to the "benefit_interval_hours" field.
func (m *GoodMutation) AddBenefitIntervalHours(u int32) {
	if m.addbenefit_interval_hours != nil {
		*m.addbenefit_interval_hours += u
	} else {
		m.addbenefit_interval_hours = &u
	}
}

// AddedBenefitIntervalHours returns the value that was added to the "benefit_interval_hours" field in this mutation.
func (m *GoodMutation) AddedBenefitIntervalHours() (r int32, exists bool) {
	v := m.addbenefit_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearBenefitIntervalHours clears the value of the "benefit_interval_hours" field.
func (m *GoodMutation) ClearBenefitIntervalHours() {
	m.benefit_interval_hours = nil
	m.addbenefit_interval_hours = nil
	m.clearedFields[good.FieldBenefitIntervalHours] = struct{}{}
}

// BenefitIntervalHoursCleared returns if the "benefit_interval_hours" field was cleared in this mutation.
func (m *GoodMutation) BenefitIntervalHoursCleared() bool {
	_, ok := m.clearedFields[good.FieldBenefitIntervalHours]
	return ok
}

// ResetBenefitIntervalHours resets all changes to the "benefit_interval_hours" field.
func (m *GoodMutation) ResetBenefitIntervalHours() {
	m.benefit_interval_hours = nil
	m.addbenefit_interval_hours = nil
	delete(m.clearedFields, good.FieldBenefitIntervalHours)
}

// SetUnitLockDeposit sets the "unit_lock_deposit" field.
func (m *GoodMutation) SetUnitLockDeposit(d decimal.Decimal) {
	m.unit_lock_deposit = &d
}

// UnitLockDeposit returns the value of the "unit_lock_deposit" field in the mutation.
func (m *GoodMutation) UnitLockDeposit() (r decimal.Decimal, exists bool) {
	v := m.unit_lock_deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitLockDeposit returns the old "unit_lock_deposit" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnitLockDeposit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitLockDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitLockDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitLockDeposit: %w", err)
	}
	return oldValue.UnitLockDeposit, nil
}

// ClearUnitLockDeposit clears the value of the "unit_lock_deposit" field.
func (m *GoodMutation) ClearUnitLockDeposit() {
	m.unit_lock_deposit = nil
	m.clearedFields[good.FieldUnitLockDeposit] = struct{}{}
}

// UnitLockDepositCleared returns if the "unit_lock_deposit" field was cleared in this mutation.
func (m *GoodMutation) UnitLockDepositCleared() bool {
	_, ok := m.clearedFields[good.FieldUnitLockDeposit]
	return ok
}

// ResetUnitLockDeposit resets all changes to the "unit_lock_deposit" field.
func (m *GoodMutation) ResetUnitLockDeposit() {
	m.unit_lock_deposit = nil
	delete(m.clearedFields, good.FieldUnitLockDeposit)
}

// SetUnitType sets the "unit_type" field.
func (m *GoodMutation) SetUnitType(s string) {
	m.unit_type = &s
}

// UnitType returns the value of the "unit_type" field in the mutation.
func (m *GoodMutation) UnitType() (r string, exists bool) {
	v := m.unit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitType returns the old "unit_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnitType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitType: %w", err)
	}
	return oldValue.UnitType, nil
}

// ClearUnitType clears the value of the "unit_type" field.
func (m *GoodMutation) ClearUnitType() {
	m.unit_type = nil
	m.clearedFields[good.FieldUnitType] = struct{}{}
}

// UnitTypeCleared returns if the "unit_type" field was cleared in this mutation.
func (m *GoodMutation) UnitTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldUnitType]
	return ok
}

// ResetUnitType resets all changes to the "unit_type" field.
func (m *GoodMutation) ResetUnitType() {
	m.unit_type = nil
	delete(m.clearedFields, good.FieldUnitType)
}

// SetQuantityCalculateType sets the "quantity_calculate_type" field.
func (m *GoodMutation) SetQuantityCalculateType(s string) {
	m.quantity_calculate_type = &s
}

// QuantityCalculateType returns the value of the "quantity_calculate_type" field in the mutation.
func (m *GoodMutation) QuantityCalculateType() (r string, exists bool) {
	v := m.quantity_calculate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityCalculateType returns the old "quantity_calculate_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldQuantityCalculateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantityCalculateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantityCalculateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityCalculateType: %w", err)
	}
	return oldValue.QuantityCalculateType, nil
}

// ClearQuantityCalculateType clears the value of the "quantity_calculate_type" field.
func (m *GoodMutation) ClearQuantityCalculateType() {
	m.quantity_calculate_type = nil
	m.clearedFields[good.FieldQuantityCalculateType] = struct{}{}
}

// QuantityCalculateTypeCleared returns if the "quantity_calculate_type" field was cleared in this mutation.
func (m *GoodMutation) QuantityCalculateTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldQuantityCalculateType]
	return ok
}

// ResetQuantityCalculateType resets all changes to the "quantity_calculate_type" field.
func (m *GoodMutation) ResetQuantityCalculateType() {
	m.quantity_calculate_type = nil
	delete(m.clearedFields, good.FieldQuantityCalculateType)
}

// SetDurationType sets the "duration_type" field.
func (m *GoodMutation) SetDurationType(s string) {
	m.duration_type = &s
}

// DurationType returns the value of the "duration_type" field in the mutation.
func (m *GoodMutation) DurationType() (r string, exists bool) {
	v := m.duration_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationType returns the old "duration_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDurationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationType: %w", err)
	}
	return oldValue.DurationType, nil
}

// ClearDurationType clears the value of the "duration_type" field.
func (m *GoodMutation) ClearDurationType() {
	m.duration_type = nil
	m.clearedFields[good.FieldDurationType] = struct{}{}
}

// DurationTypeCleared returns if the "duration_type" field was cleared in this mutation.
func (m *GoodMutation) DurationTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldDurationType]
	return ok
}

// ResetDurationType resets all changes to the "duration_type" field.
func (m *GoodMutation) ResetDurationType() {
	m.duration_type = nil
	delete(m.clearedFields, good.FieldDurationType)
}

// SetDurationCalculateType sets the "duration_calculate_type" field.
func (m *GoodMutation) SetDurationCalculateType(s string) {
	m.duration_calculate_type = &s
}

// DurationCalculateType returns the value of the "duration_calculate_type" field in the mutation.
func (m *GoodMutation) DurationCalculateType() (r string, exists bool) {
	v := m.duration_calculate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationCalculateType returns the old "duration_calculate_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDurationCalculateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationCalculateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationCalculateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationCalculateType: %w", err)
	}
	return oldValue.DurationCalculateType, nil
}

// ClearDurationCalculateType clears the value of the "duration_calculate_type" field.
func (m *GoodMutation) ClearDurationCalculateType() {
	m.duration_calculate_type = nil
	m.clearedFields[good.FieldDurationCalculateType] = struct{}{}
}

// DurationCalculateTypeCleared returns if the "duration_calculate_type" field was cleared in this mutation.
func (m *GoodMutation) DurationCalculateTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldDurationCalculateType]
	return ok
}

// ResetDurationCalculateType resets all changes to the "duration_calculate_type" field.
func (m *GoodMutation) ResetDurationCalculateType() {
	m.duration_calculate_type = nil
	delete(m.clearedFields, good.FieldDurationCalculateType)
}

// SetSettlementType sets the "settlement_type" field.
func (m *GoodMutation) SetSettlementType(s string) {
	m.settlement_type = &s
}

// SettlementType returns the value of the "settlement_type" field in the mutation.
func (m *GoodMutation) SettlementType() (r string, exists bool) {
	v := m.settlement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettlementType returns the old "settlement_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldSettlementType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettlementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettlementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettlementType: %w", err)
	}
	return oldValue.SettlementType, nil
}

// ClearSettlementType clears the value of the "settlement_type" field.
func (m *GoodMutation) ClearSettlementType() {
	m.settlement_type = nil
	m.clearedFields[good.FieldSettlementType] = struct{}{}
}

// SettlementTypeCleared returns if the "settlement_type" field was cleared in this mutation.
func (m *GoodMutation) SettlementTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldSettlementType]
	return ok
}

// ResetSettlementType resets all changes to the "settlement_type" field.
func (m *GoodMutation) ResetSettlementType() {
	m.settlement_type = nil
	delete(m.clearedFields, good.FieldSettlementType)
}

// Where appends a list predicates to the GoodMutation builder.
func (m *GoodMutation) Where(ps ...predicate.Good) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Good, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Good).
func (m *GoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.ent_id != nil {
		fields = append(fields, good.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, good.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, good.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, good.FieldDeletedAt)
	}
	if m.device_info_id != nil {
		fields = append(fields, good.FieldDeviceInfoID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, good.FieldCoinTypeID)
	}
	if m.inherit_from_good_id != nil {
		fields = append(fields, good.FieldInheritFromGoodID)
	}
	if m.vendor_location_id != nil {
		fields = append(fields, good.FieldVendorLocationID)
	}
	if m.unit_price != nil {
		fields = append(fields, good.FieldUnitPrice)
	}
	if m.benefit_type != nil {
		fields = append(fields, good.FieldBenefitType)
	}
	if m.good_type != nil {
		fields = append(fields, good.FieldGoodType)
	}
	if m.title != nil {
		fields = append(fields, good.FieldTitle)
	}
	if m.unit != nil {
		fields = append(fields, good.FieldUnit)
	}
	if m.quantity_unit != nil {
		fields = append(fields, good.FieldQuantityUnit)
	}
	if m.unit_amount != nil {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.quantity_unit_amount != nil {
		fields = append(fields, good.FieldQuantityUnitAmount)
	}
	if m.delivery_at != nil {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.start_at != nil {
		fields = append(fields, good.FieldStartAt)
	}
	if m.start_mode != nil {
		fields = append(fields, good.FieldStartMode)
	}
	if m.test_only != nil {
		fields = append(fields, good.FieldTestOnly)
	}
	if m.benefit_interval_hours != nil {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	if m.unit_lock_deposit != nil {
		fields = append(fields, good.FieldUnitLockDeposit)
	}
	if m.unit_type != nil {
		fields = append(fields, good.FieldUnitType)
	}
	if m.quantity_calculate_type != nil {
		fields = append(fields, good.FieldQuantityCalculateType)
	}
	if m.duration_type != nil {
		fields = append(fields, good.FieldDurationType)
	}
	if m.duration_calculate_type != nil {
		fields = append(fields, good.FieldDurationCalculateType)
	}
	if m.settlement_type != nil {
		fields = append(fields, good.FieldSettlementType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case good.FieldEntID:
		return m.EntID()
	case good.FieldCreatedAt:
		return m.CreatedAt()
	case good.FieldUpdatedAt:
		return m.UpdatedAt()
	case good.FieldDeletedAt:
		return m.DeletedAt()
	case good.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case good.FieldCoinTypeID:
		return m.CoinTypeID()
	case good.FieldInheritFromGoodID:
		return m.InheritFromGoodID()
	case good.FieldVendorLocationID:
		return m.VendorLocationID()
	case good.FieldUnitPrice:
		return m.UnitPrice()
	case good.FieldBenefitType:
		return m.BenefitType()
	case good.FieldGoodType:
		return m.GoodType()
	case good.FieldTitle:
		return m.Title()
	case good.FieldUnit:
		return m.Unit()
	case good.FieldQuantityUnit:
		return m.QuantityUnit()
	case good.FieldUnitAmount:
		return m.UnitAmount()
	case good.FieldQuantityUnitAmount:
		return m.QuantityUnitAmount()
	case good.FieldDeliveryAt:
		return m.DeliveryAt()
	case good.FieldStartAt:
		return m.StartAt()
	case good.FieldStartMode:
		return m.StartMode()
	case good.FieldTestOnly:
		return m.TestOnly()
	case good.FieldBenefitIntervalHours:
		return m.BenefitIntervalHours()
	case good.FieldUnitLockDeposit:
		return m.UnitLockDeposit()
	case good.FieldUnitType:
		return m.UnitType()
	case good.FieldQuantityCalculateType:
		return m.QuantityCalculateType()
	case good.FieldDurationType:
		return m.DurationType()
	case good.FieldDurationCalculateType:
		return m.DurationCalculateType()
	case good.FieldSettlementType:
		return m.SettlementType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case good.FieldEntID:
		return m.OldEntID(ctx)
	case good.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case good.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case good.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case good.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case good.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case good.FieldInheritFromGoodID:
		return m.OldInheritFromGoodID(ctx)
	case good.FieldVendorLocationID:
		return m.OldVendorLocationID(ctx)
	case good.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case good.FieldBenefitType:
		return m.OldBenefitType(ctx)
	case good.FieldGoodType:
		return m.OldGoodType(ctx)
	case good.FieldTitle:
		return m.OldTitle(ctx)
	case good.FieldUnit:
		return m.OldUnit(ctx)
	case good.FieldQuantityUnit:
		return m.OldQuantityUnit(ctx)
	case good.FieldUnitAmount:
		return m.OldUnitAmount(ctx)
	case good.FieldQuantityUnitAmount:
		return m.OldQuantityUnitAmount(ctx)
	case good.FieldDeliveryAt:
		return m.OldDeliveryAt(ctx)
	case good.FieldStartAt:
		return m.OldStartAt(ctx)
	case good.FieldStartMode:
		return m.OldStartMode(ctx)
	case good.FieldTestOnly:
		return m.OldTestOnly(ctx)
	case good.FieldBenefitIntervalHours:
		return m.OldBenefitIntervalHours(ctx)
	case good.FieldUnitLockDeposit:
		return m.OldUnitLockDeposit(ctx)
	case good.FieldUnitType:
		return m.OldUnitType(ctx)
	case good.FieldQuantityCalculateType:
		return m.OldQuantityCalculateType(ctx)
	case good.FieldDurationType:
		return m.OldDurationType(ctx)
	case good.FieldDurationCalculateType:
		return m.OldDurationCalculateType(ctx)
	case good.FieldSettlementType:
		return m.OldSettlementType(ctx)
	}
	return nil, fmt.Errorf("unknown Good field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case good.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case good.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case good.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case good.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case good.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case good.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case good.FieldInheritFromGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritFromGoodID(v)
		return nil
	case good.FieldVendorLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorLocationID(v)
		return nil
	case good.FieldUnitPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case good.FieldBenefitType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitType(v)
		return nil
	case good.FieldGoodType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodType(v)
		return nil
	case good.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case good.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case good.FieldQuantityUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityUnit(v)
		return nil
	case good.FieldUnitAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitAmount(v)
		return nil
	case good.FieldQuantityUnitAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityUnitAmount(v)
		return nil
	case good.FieldDeliveryAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAt(v)
		return nil
	case good.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case good.FieldStartMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartMode(v)
		return nil
	case good.FieldTestOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestOnly(v)
		return nil
	case good.FieldBenefitIntervalHours:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitIntervalHours(v)
		return nil
	case good.FieldUnitLockDeposit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitLockDeposit(v)
		return nil
	case good.FieldUnitType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitType(v)
		return nil
	case good.FieldQuantityCalculateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityCalculateType(v)
		return nil
	case good.FieldDurationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationType(v)
		return nil
	case good.FieldDurationCalculateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationCalculateType(v)
		return nil
	case good.FieldSettlementType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettlementType(v)
		return nil
	}
	return fmt.Errorf("unknown Good field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, good.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, good.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, good.FieldDeletedAt)
	}
	if m.addunit_amount != nil {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.adddelivery_at != nil {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, good.FieldStartAt)
	}
	if m.addbenefit_interval_hours != nil {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case good.FieldCreatedAt:
		return m.AddedCreatedAt()
	case good.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case good.FieldDeletedAt:
		return m.AddedDeletedAt()
	case good.FieldUnitAmount:
		return m.AddedUnitAmount()
	case good.FieldDeliveryAt:
		return m.AddedDeliveryAt()
	case good.FieldStartAt:
		return m.AddedStartAt()
	case good.FieldBenefitIntervalHours:
		return m.AddedBenefitIntervalHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case good.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case good.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case good.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case good.FieldUnitAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitAmount(v)
		return nil
	case good.FieldDeliveryAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryAt(v)
		return nil
	case good.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case good.FieldBenefitIntervalHours:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBenefitIntervalHours(v)
		return nil
	}
	return fmt.Errorf("unknown Good numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(good.FieldInheritFromGoodID) {
		fields = append(fields, good.FieldInheritFromGoodID)
	}
	if m.FieldCleared(good.FieldUnitPrice) {
		fields = append(fields, good.FieldUnitPrice)
	}
	if m.FieldCleared(good.FieldBenefitType) {
		fields = append(fields, good.FieldBenefitType)
	}
	if m.FieldCleared(good.FieldGoodType) {
		fields = append(fields, good.FieldGoodType)
	}
	if m.FieldCleared(good.FieldTitle) {
		fields = append(fields, good.FieldTitle)
	}
	if m.FieldCleared(good.FieldUnit) {
		fields = append(fields, good.FieldUnit)
	}
	if m.FieldCleared(good.FieldQuantityUnit) {
		fields = append(fields, good.FieldQuantityUnit)
	}
	if m.FieldCleared(good.FieldUnitAmount) {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.FieldCleared(good.FieldQuantityUnitAmount) {
		fields = append(fields, good.FieldQuantityUnitAmount)
	}
	if m.FieldCleared(good.FieldDeliveryAt) {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.FieldCleared(good.FieldStartAt) {
		fields = append(fields, good.FieldStartAt)
	}
	if m.FieldCleared(good.FieldStartMode) {
		fields = append(fields, good.FieldStartMode)
	}
	if m.FieldCleared(good.FieldTestOnly) {
		fields = append(fields, good.FieldTestOnly)
	}
	if m.FieldCleared(good.FieldBenefitIntervalHours) {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	if m.FieldCleared(good.FieldUnitLockDeposit) {
		fields = append(fields, good.FieldUnitLockDeposit)
	}
	if m.FieldCleared(good.FieldUnitType) {
		fields = append(fields, good.FieldUnitType)
	}
	if m.FieldCleared(good.FieldQuantityCalculateType) {
		fields = append(fields, good.FieldQuantityCalculateType)
	}
	if m.FieldCleared(good.FieldDurationType) {
		fields = append(fields, good.FieldDurationType)
	}
	if m.FieldCleared(good.FieldDurationCalculateType) {
		fields = append(fields, good.FieldDurationCalculateType)
	}
	if m.FieldCleared(good.FieldSettlementType) {
		fields = append(fields, good.FieldSettlementType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodMutation) ClearField(name string) error {
	switch name {
	case good.FieldInheritFromGoodID:
		m.ClearInheritFromGoodID()
		return nil
	case good.FieldUnitPrice:
		m.ClearUnitPrice()
		return nil
	case good.FieldBenefitType:
		m.ClearBenefitType()
		return nil
	case good.FieldGoodType:
		m.ClearGoodType()
		return nil
	case good.FieldTitle:
		m.ClearTitle()
		return nil
	case good.FieldUnit:
		m.ClearUnit()
		return nil
	case good.FieldQuantityUnit:
		m.ClearQuantityUnit()
		return nil
	case good.FieldUnitAmount:
		m.ClearUnitAmount()
		return nil
	case good.FieldQuantityUnitAmount:
		m.ClearQuantityUnitAmount()
		return nil
	case good.FieldDeliveryAt:
		m.ClearDeliveryAt()
		return nil
	case good.FieldStartAt:
		m.ClearStartAt()
		return nil
	case good.FieldStartMode:
		m.ClearStartMode()
		return nil
	case good.FieldTestOnly:
		m.ClearTestOnly()
		return nil
	case good.FieldBenefitIntervalHours:
		m.ClearBenefitIntervalHours()
		return nil
	case good.FieldUnitLockDeposit:
		m.ClearUnitLockDeposit()
		return nil
	case good.FieldUnitType:
		m.ClearUnitType()
		return nil
	case good.FieldQuantityCalculateType:
		m.ClearQuantityCalculateType()
		return nil
	case good.FieldDurationType:
		m.ClearDurationType()
		return nil
	case good.FieldDurationCalculateType:
		m.ClearDurationCalculateType()
		return nil
	case good.FieldSettlementType:
		m.ClearSettlementType()
		return nil
	}
	return fmt.Errorf("unknown Good nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodMutation) ResetField(name string) error {
	switch name {
	case good.FieldEntID:
		m.ResetEntID()
		return nil
	case good.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case good.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case good.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case good.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case good.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case good.FieldInheritFromGoodID:
		m.ResetInheritFromGoodID()
		return nil
	case good.FieldVendorLocationID:
		m.ResetVendorLocationID()
		return nil
	case good.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case good.FieldBenefitType:
		m.ResetBenefitType()
		return nil
	case good.FieldGoodType:
		m.ResetGoodType()
		return nil
	case good.FieldTitle:
		m.ResetTitle()
		return nil
	case good.FieldUnit:
		m.ResetUnit()
		return nil
	case good.FieldQuantityUnit:
		m.ResetQuantityUnit()
		return nil
	case good.FieldUnitAmount:
		m.ResetUnitAmount()
		return nil
	case good.FieldQuantityUnitAmount:
		m.ResetQuantityUnitAmount()
		return nil
	case good.FieldDeliveryAt:
		m.ResetDeliveryAt()
		return nil
	case good.FieldStartAt:
		m.ResetStartAt()
		return nil
	case good.FieldStartMode:
		m.ResetStartMode()
		return nil
	case good.FieldTestOnly:
		m.ResetTestOnly()
		return nil
	case good.FieldBenefitIntervalHours:
		m.ResetBenefitIntervalHours()
		return nil
	case good.FieldUnitLockDeposit:
		m.ResetUnitLockDeposit()
		return nil
	case good.FieldUnitType:
		m.ResetUnitType()
		return nil
	case good.FieldQuantityCalculateType:
		m.ResetQuantityCalculateType()
		return nil
	case good.FieldDurationType:
		m.ResetDurationType()
		return nil
	case good.FieldDurationCalculateType:
		m.ResetDurationCalculateType()
		return nil
	case good.FieldSettlementType:
		m.ResetSettlementType()
		return nil
	}
	return fmt.Errorf("unknown Good field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Good unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Good edge %s", name)
}

// GoodBaseMutation represents an operation that mutates the GoodBase nodes in the graph.
type GoodBaseMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	ent_id                    *uuid.UUID
	created_at                *uint32
	addcreated_at             *int32
	updated_at                *uint32
	addupdated_at             *int32
	deleted_at                *uint32
	adddeleted_at             *int32
	good_type                 *string
	benefit_type              *string
	name                      *string
	service_start_at          *uint32
	addservice_start_at       *int32
	start_mode                *string
	test_only                 *bool
	benefit_interval_hours    *uint32
	addbenefit_interval_hours *int32
	purchasable               *bool
	online                    *bool
	state                     *string
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*GoodBase, error)
	predicates                []predicate.GoodBase
}

var _ ent.Mutation = (*GoodBaseMutation)(nil)

// goodbaseOption allows management of the mutation configuration using functional options.
type goodbaseOption func(*GoodBaseMutation)

// newGoodBaseMutation creates new mutation for the GoodBase entity.
func newGoodBaseMutation(c config, op Op, opts ...goodbaseOption) *GoodBaseMutation {
	m := &GoodBaseMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodBase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodBaseID sets the ID field of the mutation.
func withGoodBaseID(id uint32) goodbaseOption {
	return func(m *GoodBaseMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodBase
		)
		m.oldValue = func(ctx context.Context) (*GoodBase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodBase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodBase sets the old GoodBase of the mutation.
func withGoodBase(node *GoodBase) goodbaseOption {
	return func(m *GoodBaseMutation) {
		m.oldValue = func(context.Context) (*GoodBase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodBaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodBaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodBase entities.
func (m *GoodBaseMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodBaseMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodBaseMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodBase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *GoodBaseMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodBaseMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodBaseMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodBaseMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodBaseMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodBaseMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodBaseMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodBaseMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodBaseMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodBaseMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodBaseMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodBaseMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodBaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodBaseMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodBaseMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodBaseMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodBaseMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodBaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodType sets the "good_type" field.
func (m *GoodBaseMutation) SetGoodType(s string) {
	m.good_type = &s
}

// GoodType returns the value of the "good_type" field in the mutation.
func (m *GoodBaseMutation) GoodType() (r string, exists bool) {
	v := m.good_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodType returns the old "good_type" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldGoodType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodType: %w", err)
	}
	return oldValue.GoodType, nil
}

// ClearGoodType clears the value of the "good_type" field.
func (m *GoodBaseMutation) ClearGoodType() {
	m.good_type = nil
	m.clearedFields[goodbase.FieldGoodType] = struct{}{}
}

// GoodTypeCleared returns if the "good_type" field was cleared in this mutation.
func (m *GoodBaseMutation) GoodTypeCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldGoodType]
	return ok
}

// ResetGoodType resets all changes to the "good_type" field.
func (m *GoodBaseMutation) ResetGoodType() {
	m.good_type = nil
	delete(m.clearedFields, goodbase.FieldGoodType)
}

// SetBenefitType sets the "benefit_type" field.
func (m *GoodBaseMutation) SetBenefitType(s string) {
	m.benefit_type = &s
}

// BenefitType returns the value of the "benefit_type" field in the mutation.
func (m *GoodBaseMutation) BenefitType() (r string, exists bool) {
	v := m.benefit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitType returns the old "benefit_type" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldBenefitType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitType: %w", err)
	}
	return oldValue.BenefitType, nil
}

// ClearBenefitType clears the value of the "benefit_type" field.
func (m *GoodBaseMutation) ClearBenefitType() {
	m.benefit_type = nil
	m.clearedFields[goodbase.FieldBenefitType] = struct{}{}
}

// BenefitTypeCleared returns if the "benefit_type" field was cleared in this mutation.
func (m *GoodBaseMutation) BenefitTypeCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldBenefitType]
	return ok
}

// ResetBenefitType resets all changes to the "benefit_type" field.
func (m *GoodBaseMutation) ResetBenefitType() {
	m.benefit_type = nil
	delete(m.clearedFields, goodbase.FieldBenefitType)
}

// SetName sets the "name" field.
func (m *GoodBaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GoodBaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *GoodBaseMutation) ClearName() {
	m.name = nil
	m.clearedFields[goodbase.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *GoodBaseMutation) NameCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *GoodBaseMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, goodbase.FieldName)
}

// SetServiceStartAt sets the "service_start_at" field.
func (m *GoodBaseMutation) SetServiceStartAt(u uint32) {
	m.service_start_at = &u
	m.addservice_start_at = nil
}

// ServiceStartAt returns the value of the "service_start_at" field in the mutation.
func (m *GoodBaseMutation) ServiceStartAt() (r uint32, exists bool) {
	v := m.service_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceStartAt returns the old "service_start_at" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldServiceStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceStartAt: %w", err)
	}
	return oldValue.ServiceStartAt, nil
}

// AddServiceStartAt adds u to the "service_start_at" field.
func (m *GoodBaseMutation) AddServiceStartAt(u int32) {
	if m.addservice_start_at != nil {
		*m.addservice_start_at += u
	} else {
		m.addservice_start_at = &u
	}
}

// AddedServiceStartAt returns the value that was added to the "service_start_at" field in this mutation.
func (m *GoodBaseMutation) AddedServiceStartAt() (r int32, exists bool) {
	v := m.addservice_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearServiceStartAt clears the value of the "service_start_at" field.
func (m *GoodBaseMutation) ClearServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	m.clearedFields[goodbase.FieldServiceStartAt] = struct{}{}
}

// ServiceStartAtCleared returns if the "service_start_at" field was cleared in this mutation.
func (m *GoodBaseMutation) ServiceStartAtCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldServiceStartAt]
	return ok
}

// ResetServiceStartAt resets all changes to the "service_start_at" field.
func (m *GoodBaseMutation) ResetServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	delete(m.clearedFields, goodbase.FieldServiceStartAt)
}

// SetStartMode sets the "start_mode" field.
func (m *GoodBaseMutation) SetStartMode(s string) {
	m.start_mode = &s
}

// StartMode returns the value of the "start_mode" field in the mutation.
func (m *GoodBaseMutation) StartMode() (r string, exists bool) {
	v := m.start_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStartMode returns the old "start_mode" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldStartMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartMode: %w", err)
	}
	return oldValue.StartMode, nil
}

// ClearStartMode clears the value of the "start_mode" field.
func (m *GoodBaseMutation) ClearStartMode() {
	m.start_mode = nil
	m.clearedFields[goodbase.FieldStartMode] = struct{}{}
}

// StartModeCleared returns if the "start_mode" field was cleared in this mutation.
func (m *GoodBaseMutation) StartModeCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldStartMode]
	return ok
}

// ResetStartMode resets all changes to the "start_mode" field.
func (m *GoodBaseMutation) ResetStartMode() {
	m.start_mode = nil
	delete(m.clearedFields, goodbase.FieldStartMode)
}

// SetTestOnly sets the "test_only" field.
func (m *GoodBaseMutation) SetTestOnly(b bool) {
	m.test_only = &b
}

// TestOnly returns the value of the "test_only" field in the mutation.
func (m *GoodBaseMutation) TestOnly() (r bool, exists bool) {
	v := m.test_only
	if v == nil {
		return
	}
	return *v, true
}

// OldTestOnly returns the old "test_only" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldTestOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestOnly: %w", err)
	}
	return oldValue.TestOnly, nil
}

// ClearTestOnly clears the value of the "test_only" field.
func (m *GoodBaseMutation) ClearTestOnly() {
	m.test_only = nil
	m.clearedFields[goodbase.FieldTestOnly] = struct{}{}
}

// TestOnlyCleared returns if the "test_only" field was cleared in this mutation.
func (m *GoodBaseMutation) TestOnlyCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldTestOnly]
	return ok
}

// ResetTestOnly resets all changes to the "test_only" field.
func (m *GoodBaseMutation) ResetTestOnly() {
	m.test_only = nil
	delete(m.clearedFields, goodbase.FieldTestOnly)
}

// SetBenefitIntervalHours sets the "benefit_interval_hours" field.
func (m *GoodBaseMutation) SetBenefitIntervalHours(u uint32) {
	m.benefit_interval_hours = &u
	m.addbenefit_interval_hours = nil
}

// BenefitIntervalHours returns the value of the "benefit_interval_hours" field in the mutation.
func (m *GoodBaseMutation) BenefitIntervalHours() (r uint32, exists bool) {
	v := m.benefit_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitIntervalHours returns the old "benefit_interval_hours" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldBenefitIntervalHours(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitIntervalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitIntervalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitIntervalHours: %w", err)
	}
	return oldValue.BenefitIntervalHours, nil
}

// AddBenefitIntervalHours adds u to the "benefit_interval_hours" field.
func (m *GoodBaseMutation) AddBenefitIntervalHours(u int32) {
	if m.addbenefit_interval_hours != nil {
		*m.addbenefit_interval_hours += u
	} else {
		m.addbenefit_interval_hours = &u
	}
}

// AddedBenefitIntervalHours returns the value that was added to the "benefit_interval_hours" field in this mutation.
func (m *GoodBaseMutation) AddedBenefitIntervalHours() (r int32, exists bool) {
	v := m.addbenefit_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearBenefitIntervalHours clears the value of the "benefit_interval_hours" field.
func (m *GoodBaseMutation) ClearBenefitIntervalHours() {
	m.benefit_interval_hours = nil
	m.addbenefit_interval_hours = nil
	m.clearedFields[goodbase.FieldBenefitIntervalHours] = struct{}{}
}

// BenefitIntervalHoursCleared returns if the "benefit_interval_hours" field was cleared in this mutation.
func (m *GoodBaseMutation) BenefitIntervalHoursCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldBenefitIntervalHours]
	return ok
}

// ResetBenefitIntervalHours resets all changes to the "benefit_interval_hours" field.
func (m *GoodBaseMutation) ResetBenefitIntervalHours() {
	m.benefit_interval_hours = nil
	m.addbenefit_interval_hours = nil
	delete(m.clearedFields, goodbase.FieldBenefitIntervalHours)
}

// SetPurchasable sets the "purchasable" field.
func (m *GoodBaseMutation) SetPurchasable(b bool) {
	m.purchasable = &b
}

// Purchasable returns the value of the "purchasable" field in the mutation.
func (m *GoodBaseMutation) Purchasable() (r bool, exists bool) {
	v := m.purchasable
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchasable returns the old "purchasable" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldPurchasable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchasable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchasable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchasable: %w", err)
	}
	return oldValue.Purchasable, nil
}

// ClearPurchasable clears the value of the "purchasable" field.
func (m *GoodBaseMutation) ClearPurchasable() {
	m.purchasable = nil
	m.clearedFields[goodbase.FieldPurchasable] = struct{}{}
}

// PurchasableCleared returns if the "purchasable" field was cleared in this mutation.
func (m *GoodBaseMutation) PurchasableCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldPurchasable]
	return ok
}

// ResetPurchasable resets all changes to the "purchasable" field.
func (m *GoodBaseMutation) ResetPurchasable() {
	m.purchasable = nil
	delete(m.clearedFields, goodbase.FieldPurchasable)
}

// SetOnline sets the "online" field.
func (m *GoodBaseMutation) SetOnline(b bool) {
	m.online = &b
}

// Online returns the value of the "online" field in the mutation.
func (m *GoodBaseMutation) Online() (r bool, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// ClearOnline clears the value of the "online" field.
func (m *GoodBaseMutation) ClearOnline() {
	m.online = nil
	m.clearedFields[goodbase.FieldOnline] = struct{}{}
}

// OnlineCleared returns if the "online" field was cleared in this mutation.
func (m *GoodBaseMutation) OnlineCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldOnline]
	return ok
}

// ResetOnline resets all changes to the "online" field.
func (m *GoodBaseMutation) ResetOnline() {
	m.online = nil
	delete(m.clearedFields, goodbase.FieldOnline)
}

// SetState sets the "state" field.
func (m *GoodBaseMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *GoodBaseMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the GoodBase entity.
// If the GoodBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodBaseMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *GoodBaseMutation) ClearState() {
	m.state = nil
	m.clearedFields[goodbase.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *GoodBaseMutation) StateCleared() bool {
	_, ok := m.clearedFields[goodbase.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *GoodBaseMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, goodbase.FieldState)
}

// Where appends a list predicates to the GoodBaseMutation builder.
func (m *GoodBaseMutation) Where(ps ...predicate.GoodBase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodBaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodBaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoodBase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodBaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodBaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoodBase).
func (m *GoodBaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodBaseMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.ent_id != nil {
		fields = append(fields, goodbase.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, goodbase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodbase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodbase.FieldDeletedAt)
	}
	if m.good_type != nil {
		fields = append(fields, goodbase.FieldGoodType)
	}
	if m.benefit_type != nil {
		fields = append(fields, goodbase.FieldBenefitType)
	}
	if m.name != nil {
		fields = append(fields, goodbase.FieldName)
	}
	if m.service_start_at != nil {
		fields = append(fields, goodbase.FieldServiceStartAt)
	}
	if m.start_mode != nil {
		fields = append(fields, goodbase.FieldStartMode)
	}
	if m.test_only != nil {
		fields = append(fields, goodbase.FieldTestOnly)
	}
	if m.benefit_interval_hours != nil {
		fields = append(fields, goodbase.FieldBenefitIntervalHours)
	}
	if m.purchasable != nil {
		fields = append(fields, goodbase.FieldPurchasable)
	}
	if m.online != nil {
		fields = append(fields, goodbase.FieldOnline)
	}
	if m.state != nil {
		fields = append(fields, goodbase.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodBaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodbase.FieldEntID:
		return m.EntID()
	case goodbase.FieldCreatedAt:
		return m.CreatedAt()
	case goodbase.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodbase.FieldDeletedAt:
		return m.DeletedAt()
	case goodbase.FieldGoodType:
		return m.GoodType()
	case goodbase.FieldBenefitType:
		return m.BenefitType()
	case goodbase.FieldName:
		return m.Name()
	case goodbase.FieldServiceStartAt:
		return m.ServiceStartAt()
	case goodbase.FieldStartMode:
		return m.StartMode()
	case goodbase.FieldTestOnly:
		return m.TestOnly()
	case goodbase.FieldBenefitIntervalHours:
		return m.BenefitIntervalHours()
	case goodbase.FieldPurchasable:
		return m.Purchasable()
	case goodbase.FieldOnline:
		return m.Online()
	case goodbase.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodBaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodbase.FieldEntID:
		return m.OldEntID(ctx)
	case goodbase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodbase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodbase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodbase.FieldGoodType:
		return m.OldGoodType(ctx)
	case goodbase.FieldBenefitType:
		return m.OldBenefitType(ctx)
	case goodbase.FieldName:
		return m.OldName(ctx)
	case goodbase.FieldServiceStartAt:
		return m.OldServiceStartAt(ctx)
	case goodbase.FieldStartMode:
		return m.OldStartMode(ctx)
	case goodbase.FieldTestOnly:
		return m.OldTestOnly(ctx)
	case goodbase.FieldBenefitIntervalHours:
		return m.OldBenefitIntervalHours(ctx)
	case goodbase.FieldPurchasable:
		return m.OldPurchasable(ctx)
	case goodbase.FieldOnline:
		return m.OldOnline(ctx)
	case goodbase.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown GoodBase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodBaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodbase.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodbase.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodbase.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodbase.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodbase.FieldGoodType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodType(v)
		return nil
	case goodbase.FieldBenefitType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitType(v)
		return nil
	case goodbase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case goodbase.FieldServiceStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceStartAt(v)
		return nil
	case goodbase.FieldStartMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartMode(v)
		return nil
	case goodbase.FieldTestOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestOnly(v)
		return nil
	case goodbase.FieldBenefitIntervalHours:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitIntervalHours(v)
		return nil
	case goodbase.FieldPurchasable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchasable(v)
		return nil
	case goodbase.FieldOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case goodbase.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown GoodBase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodBaseMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodbase.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodbase.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodbase.FieldDeletedAt)
	}
	if m.addservice_start_at != nil {
		fields = append(fields, goodbase.FieldServiceStartAt)
	}
	if m.addbenefit_interval_hours != nil {
		fields = append(fields, goodbase.FieldBenefitIntervalHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodBaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodbase.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodbase.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodbase.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodbase.FieldServiceStartAt:
		return m.AddedServiceStartAt()
	case goodbase.FieldBenefitIntervalHours:
		return m.AddedBenefitIntervalHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodBaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodbase.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodbase.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodbase.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodbase.FieldServiceStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceStartAt(v)
		return nil
	case goodbase.FieldBenefitIntervalHours:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBenefitIntervalHours(v)
		return nil
	}
	return fmt.Errorf("unknown GoodBase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodBaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodbase.FieldGoodType) {
		fields = append(fields, goodbase.FieldGoodType)
	}
	if m.FieldCleared(goodbase.FieldBenefitType) {
		fields = append(fields, goodbase.FieldBenefitType)
	}
	if m.FieldCleared(goodbase.FieldName) {
		fields = append(fields, goodbase.FieldName)
	}
	if m.FieldCleared(goodbase.FieldServiceStartAt) {
		fields = append(fields, goodbase.FieldServiceStartAt)
	}
	if m.FieldCleared(goodbase.FieldStartMode) {
		fields = append(fields, goodbase.FieldStartMode)
	}
	if m.FieldCleared(goodbase.FieldTestOnly) {
		fields = append(fields, goodbase.FieldTestOnly)
	}
	if m.FieldCleared(goodbase.FieldBenefitIntervalHours) {
		fields = append(fields, goodbase.FieldBenefitIntervalHours)
	}
	if m.FieldCleared(goodbase.FieldPurchasable) {
		fields = append(fields, goodbase.FieldPurchasable)
	}
	if m.FieldCleared(goodbase.FieldOnline) {
		fields = append(fields, goodbase.FieldOnline)
	}
	if m.FieldCleared(goodbase.FieldState) {
		fields = append(fields, goodbase.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodBaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodBaseMutation) ClearField(name string) error {
	switch name {
	case goodbase.FieldGoodType:
		m.ClearGoodType()
		return nil
	case goodbase.FieldBenefitType:
		m.ClearBenefitType()
		return nil
	case goodbase.FieldName:
		m.ClearName()
		return nil
	case goodbase.FieldServiceStartAt:
		m.ClearServiceStartAt()
		return nil
	case goodbase.FieldStartMode:
		m.ClearStartMode()
		return nil
	case goodbase.FieldTestOnly:
		m.ClearTestOnly()
		return nil
	case goodbase.FieldBenefitIntervalHours:
		m.ClearBenefitIntervalHours()
		return nil
	case goodbase.FieldPurchasable:
		m.ClearPurchasable()
		return nil
	case goodbase.FieldOnline:
		m.ClearOnline()
		return nil
	case goodbase.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown GoodBase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodBaseMutation) ResetField(name string) error {
	switch name {
	case goodbase.FieldEntID:
		m.ResetEntID()
		return nil
	case goodbase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodbase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodbase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodbase.FieldGoodType:
		m.ResetGoodType()
		return nil
	case goodbase.FieldBenefitType:
		m.ResetBenefitType()
		return nil
	case goodbase.FieldName:
		m.ResetName()
		return nil
	case goodbase.FieldServiceStartAt:
		m.ResetServiceStartAt()
		return nil
	case goodbase.FieldStartMode:
		m.ResetStartMode()
		return nil
	case goodbase.FieldTestOnly:
		m.ResetTestOnly()
		return nil
	case goodbase.FieldBenefitIntervalHours:
		m.ResetBenefitIntervalHours()
		return nil
	case goodbase.FieldPurchasable:
		m.ResetPurchasable()
		return nil
	case goodbase.FieldOnline:
		m.ResetOnline()
		return nil
	case goodbase.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown GoodBase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodBaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodBaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodBaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodBaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodBaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodBaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodBaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodBase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodBaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodBase edge %s", name)
}

// GoodCoinMutation represents an operation that mutates the GoodCoin nodes in the graph.
type GoodCoinMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	good_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	main          *bool
	index         *int32
	addindex      *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GoodCoin, error)
	predicates    []predicate.GoodCoin
}

var _ ent.Mutation = (*GoodCoinMutation)(nil)

// goodcoinOption allows management of the mutation configuration using functional options.
type goodcoinOption func(*GoodCoinMutation)

// newGoodCoinMutation creates new mutation for the GoodCoin entity.
func newGoodCoinMutation(c config, op Op, opts ...goodcoinOption) *GoodCoinMutation {
	m := &GoodCoinMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodCoin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodCoinID sets the ID field of the mutation.
func withGoodCoinID(id uint32) goodcoinOption {
	return func(m *GoodCoinMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodCoin
		)
		m.oldValue = func(ctx context.Context) (*GoodCoin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodCoin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodCoin sets the old GoodCoin of the mutation.
func withGoodCoin(node *GoodCoin) goodcoinOption {
	return func(m *GoodCoinMutation) {
		m.oldValue = func(context.Context) (*GoodCoin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodCoinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodCoinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodCoin entities.
func (m *GoodCoinMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodCoinMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodCoinMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodCoin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *GoodCoinMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodCoinMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodCoin entity.
// If the GoodCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodCoinMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodCoinMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodCoinMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodCoin entity.
// If the GoodCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodCoinMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodCoinMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodCoinMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodCoinMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodCoinMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodCoin entity.
// If the GoodCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodCoinMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodCoinMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodCoinMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodCoinMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodCoinMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodCoin entity.
// If the GoodCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodCoinMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodCoinMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodCoinMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodCoinMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodCoinMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodCoin entity.
// If the GoodCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodCoinMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodcoin.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodCoinMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodcoin.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodCoinMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodcoin.FieldGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *GoodCoinMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *GoodCoinMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the GoodCoin entity.
// If the GoodCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *GoodCoinMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[goodcoin.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *GoodCoinMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[goodcoin.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *GoodCoinMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, goodcoin.FieldCoinTypeID)
}

// SetMain sets the "main" field.
func (m *GoodCoinMutation) SetMain(b bool) {
	m.main = &b
}

// Main returns the value of the "main" field in the mutation.
func (m *GoodCoinMutation) Main() (r bool, exists bool) {
	v := m.main
	if v == nil {
		return
	}
	return *v, true
}

// OldMain returns the old "main" field's value of the GoodCoin entity.
// If the GoodCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinMutation) OldMain(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMain: %w", err)
	}
	return oldValue.Main, nil
}

// ClearMain clears the value of the "main" field.
func (m *GoodCoinMutation) ClearMain() {
	m.main = nil
	m.clearedFields[goodcoin.FieldMain] = struct{}{}
}

// MainCleared returns if the "main" field was cleared in this mutation.
func (m *GoodCoinMutation) MainCleared() bool {
	_, ok := m.clearedFields[goodcoin.FieldMain]
	return ok
}

// ResetMain resets all changes to the "main" field.
func (m *GoodCoinMutation) ResetMain() {
	m.main = nil
	delete(m.clearedFields, goodcoin.FieldMain)
}

// SetIndex sets the "index" field.
func (m *GoodCoinMutation) SetIndex(i int32) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *GoodCoinMutation) Index() (r int32, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the GoodCoin entity.
// If the GoodCoin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinMutation) OldIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *GoodCoinMutation) AddIndex(i int32) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *GoodCoinMutation) AddedIndex() (r int32, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *GoodCoinMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[goodcoin.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *GoodCoinMutation) IndexCleared() bool {
	_, ok := m.clearedFields[goodcoin.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *GoodCoinMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, goodcoin.FieldIndex)
}

// Where appends a list predicates to the GoodCoinMutation builder.
func (m *GoodCoinMutation) Where(ps ...predicate.GoodCoin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodCoinMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodCoinMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoodCoin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodCoinMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodCoinMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoodCoin).
func (m *GoodCoinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodCoinMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, goodcoin.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, goodcoin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodcoin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodcoin.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodcoin.FieldGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, goodcoin.FieldCoinTypeID)
	}
	if m.main != nil {
		fields = append(fields, goodcoin.FieldMain)
	}
	if m.index != nil {
		fields = append(fields, goodcoin.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodCoinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodcoin.FieldEntID:
		return m.EntID()
	case goodcoin.FieldCreatedAt:
		return m.CreatedAt()
	case goodcoin.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodcoin.FieldDeletedAt:
		return m.DeletedAt()
	case goodcoin.FieldGoodID:
		return m.GoodID()
	case goodcoin.FieldCoinTypeID:
		return m.CoinTypeID()
	case goodcoin.FieldMain:
		return m.Main()
	case goodcoin.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodCoinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodcoin.FieldEntID:
		return m.OldEntID(ctx)
	case goodcoin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodcoin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodcoin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodcoin.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodcoin.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case goodcoin.FieldMain:
		return m.OldMain(ctx)
	case goodcoin.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown GoodCoin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodCoinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodcoin.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodcoin.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodcoin.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodcoin.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodcoin.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodcoin.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case goodcoin.FieldMain:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMain(v)
		return nil
	case goodcoin.FieldIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown GoodCoin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodCoinMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodcoin.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodcoin.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodcoin.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, goodcoin.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodCoinMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodcoin.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodcoin.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodcoin.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodcoin.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodCoinMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodcoin.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodcoin.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodcoin.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodcoin.FieldIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown GoodCoin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodCoinMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodcoin.FieldGoodID) {
		fields = append(fields, goodcoin.FieldGoodID)
	}
	if m.FieldCleared(goodcoin.FieldCoinTypeID) {
		fields = append(fields, goodcoin.FieldCoinTypeID)
	}
	if m.FieldCleared(goodcoin.FieldMain) {
		fields = append(fields, goodcoin.FieldMain)
	}
	if m.FieldCleared(goodcoin.FieldIndex) {
		fields = append(fields, goodcoin.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodCoinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodCoinMutation) ClearField(name string) error {
	switch name {
	case goodcoin.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodcoin.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case goodcoin.FieldMain:
		m.ClearMain()
		return nil
	case goodcoin.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown GoodCoin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodCoinMutation) ResetField(name string) error {
	switch name {
	case goodcoin.FieldEntID:
		m.ResetEntID()
		return nil
	case goodcoin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodcoin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodcoin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodcoin.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodcoin.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case goodcoin.FieldMain:
		m.ResetMain()
		return nil
	case goodcoin.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown GoodCoin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodCoinMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodCoinMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodCoinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodCoinMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodCoinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodCoinMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodCoinMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodCoin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodCoinMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodCoin edge %s", name)
}

// GoodCoinRewardMutation represents an operation that mutates the GoodCoinReward nodes in the graph.
type GoodCoinRewardMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint32
	ent_id                   *uuid.UUID
	created_at               *uint32
	addcreated_at            *int32
	updated_at               *uint32
	addupdated_at            *int32
	deleted_at               *uint32
	adddeleted_at            *int32
	good_id                  *uuid.UUID
	coin_type_id             *uuid.UUID
	reward_tid               *uuid.UUID
	next_reward_start_amount *decimal.Decimal
	last_reward_amount       *decimal.Decimal
	last_unit_reward_amount  *decimal.Decimal
	total_reward_amount      *decimal.Decimal
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*GoodCoinReward, error)
	predicates               []predicate.GoodCoinReward
}

var _ ent.Mutation = (*GoodCoinRewardMutation)(nil)

// goodcoinrewardOption allows management of the mutation configuration using functional options.
type goodcoinrewardOption func(*GoodCoinRewardMutation)

// newGoodCoinRewardMutation creates new mutation for the GoodCoinReward entity.
func newGoodCoinRewardMutation(c config, op Op, opts ...goodcoinrewardOption) *GoodCoinRewardMutation {
	m := &GoodCoinRewardMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodCoinReward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodCoinRewardID sets the ID field of the mutation.
func withGoodCoinRewardID(id uint32) goodcoinrewardOption {
	return func(m *GoodCoinRewardMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodCoinReward
		)
		m.oldValue = func(ctx context.Context) (*GoodCoinReward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodCoinReward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodCoinReward sets the old GoodCoinReward of the mutation.
func withGoodCoinReward(node *GoodCoinReward) goodcoinrewardOption {
	return func(m *GoodCoinRewardMutation) {
		m.oldValue = func(context.Context) (*GoodCoinReward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodCoinRewardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodCoinRewardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodCoinReward entities.
func (m *GoodCoinRewardMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodCoinRewardMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodCoinRewardMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodCoinReward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *GoodCoinRewardMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodCoinRewardMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodCoinRewardMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodCoinRewardMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodCoinRewardMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodCoinRewardMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodCoinRewardMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodCoinRewardMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodCoinRewardMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodCoinRewardMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodCoinRewardMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodCoinRewardMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodCoinRewardMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodCoinRewardMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodCoinRewardMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodCoinRewardMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodCoinRewardMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodCoinRewardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodCoinRewardMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodCoinRewardMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodCoinRewardMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodcoinreward.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodCoinRewardMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodcoinreward.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodCoinRewardMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodcoinreward.FieldGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *GoodCoinRewardMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *GoodCoinRewardMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *GoodCoinRewardMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[goodcoinreward.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *GoodCoinRewardMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[goodcoinreward.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *GoodCoinRewardMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, goodcoinreward.FieldCoinTypeID)
}

// SetRewardTid sets the "reward_tid" field.
func (m *GoodCoinRewardMutation) SetRewardTid(u uuid.UUID) {
	m.reward_tid = &u
}

// RewardTid returns the value of the "reward_tid" field in the mutation.
func (m *GoodCoinRewardMutation) RewardTid() (r uuid.UUID, exists bool) {
	v := m.reward_tid
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardTid returns the old "reward_tid" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldRewardTid(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardTid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardTid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardTid: %w", err)
	}
	return oldValue.RewardTid, nil
}

// ClearRewardTid clears the value of the "reward_tid" field.
func (m *GoodCoinRewardMutation) ClearRewardTid() {
	m.reward_tid = nil
	m.clearedFields[goodcoinreward.FieldRewardTid] = struct{}{}
}

// RewardTidCleared returns if the "reward_tid" field was cleared in this mutation.
func (m *GoodCoinRewardMutation) RewardTidCleared() bool {
	_, ok := m.clearedFields[goodcoinreward.FieldRewardTid]
	return ok
}

// ResetRewardTid resets all changes to the "reward_tid" field.
func (m *GoodCoinRewardMutation) ResetRewardTid() {
	m.reward_tid = nil
	delete(m.clearedFields, goodcoinreward.FieldRewardTid)
}

// SetNextRewardStartAmount sets the "next_reward_start_amount" field.
func (m *GoodCoinRewardMutation) SetNextRewardStartAmount(d decimal.Decimal) {
	m.next_reward_start_amount = &d
}

// NextRewardStartAmount returns the value of the "next_reward_start_amount" field in the mutation.
func (m *GoodCoinRewardMutation) NextRewardStartAmount() (r decimal.Decimal, exists bool) {
	v := m.next_reward_start_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRewardStartAmount returns the old "next_reward_start_amount" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldNextRewardStartAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRewardStartAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRewardStartAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRewardStartAmount: %w", err)
	}
	return oldValue.NextRewardStartAmount, nil
}

// ClearNextRewardStartAmount clears the value of the "next_reward_start_amount" field.
func (m *GoodCoinRewardMutation) ClearNextRewardStartAmount() {
	m.next_reward_start_amount = nil
	m.clearedFields[goodcoinreward.FieldNextRewardStartAmount] = struct{}{}
}

// NextRewardStartAmountCleared returns if the "next_reward_start_amount" field was cleared in this mutation.
func (m *GoodCoinRewardMutation) NextRewardStartAmountCleared() bool {
	_, ok := m.clearedFields[goodcoinreward.FieldNextRewardStartAmount]
	return ok
}

// ResetNextRewardStartAmount resets all changes to the "next_reward_start_amount" field.
func (m *GoodCoinRewardMutation) ResetNextRewardStartAmount() {
	m.next_reward_start_amount = nil
	delete(m.clearedFields, goodcoinreward.FieldNextRewardStartAmount)
}

// SetLastRewardAmount sets the "last_reward_amount" field.
func (m *GoodCoinRewardMutation) SetLastRewardAmount(d decimal.Decimal) {
	m.last_reward_amount = &d
}

// LastRewardAmount returns the value of the "last_reward_amount" field in the mutation.
func (m *GoodCoinRewardMutation) LastRewardAmount() (r decimal.Decimal, exists bool) {
	v := m.last_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRewardAmount returns the old "last_reward_amount" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldLastRewardAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRewardAmount: %w", err)
	}
	return oldValue.LastRewardAmount, nil
}

// ClearLastRewardAmount clears the value of the "last_reward_amount" field.
func (m *GoodCoinRewardMutation) ClearLastRewardAmount() {
	m.last_reward_amount = nil
	m.clearedFields[goodcoinreward.FieldLastRewardAmount] = struct{}{}
}

// LastRewardAmountCleared returns if the "last_reward_amount" field was cleared in this mutation.
func (m *GoodCoinRewardMutation) LastRewardAmountCleared() bool {
	_, ok := m.clearedFields[goodcoinreward.FieldLastRewardAmount]
	return ok
}

// ResetLastRewardAmount resets all changes to the "last_reward_amount" field.
func (m *GoodCoinRewardMutation) ResetLastRewardAmount() {
	m.last_reward_amount = nil
	delete(m.clearedFields, goodcoinreward.FieldLastRewardAmount)
}

// SetLastUnitRewardAmount sets the "last_unit_reward_amount" field.
func (m *GoodCoinRewardMutation) SetLastUnitRewardAmount(d decimal.Decimal) {
	m.last_unit_reward_amount = &d
}

// LastUnitRewardAmount returns the value of the "last_unit_reward_amount" field in the mutation.
func (m *GoodCoinRewardMutation) LastUnitRewardAmount() (r decimal.Decimal, exists bool) {
	v := m.last_unit_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUnitRewardAmount returns the old "last_unit_reward_amount" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldLastUnitRewardAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUnitRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUnitRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUnitRewardAmount: %w", err)
	}
	return oldValue.LastUnitRewardAmount, nil
}

// ClearLastUnitRewardAmount clears the value of the "last_unit_reward_amount" field.
func (m *GoodCoinRewardMutation) ClearLastUnitRewardAmount() {
	m.last_unit_reward_amount = nil
	m.clearedFields[goodcoinreward.FieldLastUnitRewardAmount] = struct{}{}
}

// LastUnitRewardAmountCleared returns if the "last_unit_reward_amount" field was cleared in this mutation.
func (m *GoodCoinRewardMutation) LastUnitRewardAmountCleared() bool {
	_, ok := m.clearedFields[goodcoinreward.FieldLastUnitRewardAmount]
	return ok
}

// ResetLastUnitRewardAmount resets all changes to the "last_unit_reward_amount" field.
func (m *GoodCoinRewardMutation) ResetLastUnitRewardAmount() {
	m.last_unit_reward_amount = nil
	delete(m.clearedFields, goodcoinreward.FieldLastUnitRewardAmount)
}

// SetTotalRewardAmount sets the "total_reward_amount" field.
func (m *GoodCoinRewardMutation) SetTotalRewardAmount(d decimal.Decimal) {
	m.total_reward_amount = &d
}

// TotalRewardAmount returns the value of the "total_reward_amount" field in the mutation.
func (m *GoodCoinRewardMutation) TotalRewardAmount() (r decimal.Decimal, exists bool) {
	v := m.total_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRewardAmount returns the old "total_reward_amount" field's value of the GoodCoinReward entity.
// If the GoodCoinReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodCoinRewardMutation) OldTotalRewardAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRewardAmount: %w", err)
	}
	return oldValue.TotalRewardAmount, nil
}

// ClearTotalRewardAmount clears the value of the "total_reward_amount" field.
func (m *GoodCoinRewardMutation) ClearTotalRewardAmount() {
	m.total_reward_amount = nil
	m.clearedFields[goodcoinreward.FieldTotalRewardAmount] = struct{}{}
}

// TotalRewardAmountCleared returns if the "total_reward_amount" field was cleared in this mutation.
func (m *GoodCoinRewardMutation) TotalRewardAmountCleared() bool {
	_, ok := m.clearedFields[goodcoinreward.FieldTotalRewardAmount]
	return ok
}

// ResetTotalRewardAmount resets all changes to the "total_reward_amount" field.
func (m *GoodCoinRewardMutation) ResetTotalRewardAmount() {
	m.total_reward_amount = nil
	delete(m.clearedFields, goodcoinreward.FieldTotalRewardAmount)
}

// Where appends a list predicates to the GoodCoinRewardMutation builder.
func (m *GoodCoinRewardMutation) Where(ps ...predicate.GoodCoinReward) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodCoinRewardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodCoinRewardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoodCoinReward, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodCoinRewardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodCoinRewardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoodCoinReward).
func (m *GoodCoinRewardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodCoinRewardMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ent_id != nil {
		fields = append(fields, goodcoinreward.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, goodcoinreward.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodcoinreward.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodcoinreward.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodcoinreward.FieldGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, goodcoinreward.FieldCoinTypeID)
	}
	if m.reward_tid != nil {
		fields = append(fields, goodcoinreward.FieldRewardTid)
	}
	if m.next_reward_start_amount != nil {
		fields = append(fields, goodcoinreward.FieldNextRewardStartAmount)
	}
	if m.last_reward_amount != nil {
		fields = append(fields, goodcoinreward.FieldLastRewardAmount)
	}
	if m.last_unit_reward_amount != nil {
		fields = append(fields, goodcoinreward.FieldLastUnitRewardAmount)
	}
	if m.total_reward_amount != nil {
		fields = append(fields, goodcoinreward.FieldTotalRewardAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodCoinRewardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodcoinreward.FieldEntID:
		return m.EntID()
	case goodcoinreward.FieldCreatedAt:
		return m.CreatedAt()
	case goodcoinreward.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodcoinreward.FieldDeletedAt:
		return m.DeletedAt()
	case goodcoinreward.FieldGoodID:
		return m.GoodID()
	case goodcoinreward.FieldCoinTypeID:
		return m.CoinTypeID()
	case goodcoinreward.FieldRewardTid:
		return m.RewardTid()
	case goodcoinreward.FieldNextRewardStartAmount:
		return m.NextRewardStartAmount()
	case goodcoinreward.FieldLastRewardAmount:
		return m.LastRewardAmount()
	case goodcoinreward.FieldLastUnitRewardAmount:
		return m.LastUnitRewardAmount()
	case goodcoinreward.FieldTotalRewardAmount:
		return m.TotalRewardAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodCoinRewardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodcoinreward.FieldEntID:
		return m.OldEntID(ctx)
	case goodcoinreward.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodcoinreward.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodcoinreward.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodcoinreward.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodcoinreward.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case goodcoinreward.FieldRewardTid:
		return m.OldRewardTid(ctx)
	case goodcoinreward.FieldNextRewardStartAmount:
		return m.OldNextRewardStartAmount(ctx)
	case goodcoinreward.FieldLastRewardAmount:
		return m.OldLastRewardAmount(ctx)
	case goodcoinreward.FieldLastUnitRewardAmount:
		return m.OldLastUnitRewardAmount(ctx)
	case goodcoinreward.FieldTotalRewardAmount:
		return m.OldTotalRewardAmount(ctx)
	}
	return nil, fmt.Errorf("unknown GoodCoinReward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodCoinRewardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodcoinreward.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodcoinreward.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodcoinreward.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodcoinreward.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodcoinreward.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodcoinreward.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case goodcoinreward.FieldRewardTid:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardTid(v)
		return nil
	case goodcoinreward.FieldNextRewardStartAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRewardStartAmount(v)
		return nil
	case goodcoinreward.FieldLastRewardAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRewardAmount(v)
		return nil
	case goodcoinreward.FieldLastUnitRewardAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUnitRewardAmount(v)
		return nil
	case goodcoinreward.FieldTotalRewardAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRewardAmount(v)
		return nil
	}
	return fmt.Errorf("unknown GoodCoinReward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodCoinRewardMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodcoinreward.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodcoinreward.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodcoinreward.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodCoinRewardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodcoinreward.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodcoinreward.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodcoinreward.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodCoinRewardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodcoinreward.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodcoinreward.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodcoinreward.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodCoinReward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodCoinRewardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodcoinreward.FieldGoodID) {
		fields = append(fields, goodcoinreward.FieldGoodID)
	}
	if m.FieldCleared(goodcoinreward.FieldCoinTypeID) {
		fields = append(fields, goodcoinreward.FieldCoinTypeID)
	}
	if m.FieldCleared(goodcoinreward.FieldRewardTid) {
		fields = append(fields, goodcoinreward.FieldRewardTid)
	}
	if m.FieldCleared(goodcoinreward.FieldNextRewardStartAmount) {
		fields = append(fields, goodcoinreward.FieldNextRewardStartAmount)
	}
	if m.FieldCleared(goodcoinreward.FieldLastRewardAmount) {
		fields = append(fields, goodcoinreward.FieldLastRewardAmount)
	}
	if m.FieldCleared(goodcoinreward.FieldLastUnitRewardAmount) {
		fields = append(fields, goodcoinreward.FieldLastUnitRewardAmount)
	}
	if m.FieldCleared(goodcoinreward.FieldTotalRewardAmount) {
		fields = append(fields, goodcoinreward.FieldTotalRewardAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodCoinRewardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodCoinRewardMutation) ClearField(name string) error {
	switch name {
	case goodcoinreward.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodcoinreward.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case goodcoinreward.FieldRewardTid:
		m.ClearRewardTid()
		return nil
	case goodcoinreward.FieldNextRewardStartAmount:
		m.ClearNextRewardStartAmount()
		return nil
	case goodcoinreward.FieldLastRewardAmount:
		m.ClearLastRewardAmount()
		return nil
	case goodcoinreward.FieldLastUnitRewardAmount:
		m.ClearLastUnitRewardAmount()
		return nil
	case goodcoinreward.FieldTotalRewardAmount:
		m.ClearTotalRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodCoinReward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodCoinRewardMutation) ResetField(name string) error {
	switch name {
	case goodcoinreward.FieldEntID:
		m.ResetEntID()
		return nil
	case goodcoinreward.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodcoinreward.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodcoinreward.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodcoinreward.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodcoinreward.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case goodcoinreward.FieldRewardTid:
		m.ResetRewardTid()
		return nil
	case goodcoinreward.FieldNextRewardStartAmount:
		m.ResetNextRewardStartAmount()
		return nil
	case goodcoinreward.FieldLastRewardAmount:
		m.ResetLastRewardAmount()
		return nil
	case goodcoinreward.FieldLastUnitRewardAmount:
		m.ResetLastUnitRewardAmount()
		return nil
	case goodcoinreward.FieldTotalRewardAmount:
		m.ResetTotalRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodCoinReward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodCoinRewardMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodCoinRewardMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodCoinRewardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodCoinRewardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodCoinRewardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodCoinRewardMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodCoinRewardMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodCoinReward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodCoinRewardMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodCoinReward edge %s", name)
}

// GoodMalfunctionMutation represents an operation that mutates the GoodMalfunction nodes in the graph.
type GoodMalfunctionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	ent_id                *uuid.UUID
	created_at            *uint32
	addcreated_at         *int32
	updated_at            *uint32
	addupdated_at         *int32
	deleted_at            *uint32
	adddeleted_at         *int32
	good_id               *uuid.UUID
	title                 *string
	message               *string
	start_at              *uint32
	addstart_at           *int32
	duration_seconds      *uint32
	addduration_seconds   *int32
	compensate_seconds    *uint32
	addcompensate_seconds *int32
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*GoodMalfunction, error)
	predicates            []predicate.GoodMalfunction
}

var _ ent.Mutation = (*GoodMalfunctionMutation)(nil)

// goodmalfunctionOption allows management of the mutation configuration using functional options.
type goodmalfunctionOption func(*GoodMalfunctionMutation)

// newGoodMalfunctionMutation creates new mutation for the GoodMalfunction entity.
func newGoodMalfunctionMutation(c config, op Op, opts ...goodmalfunctionOption) *GoodMalfunctionMutation {
	m := &GoodMalfunctionMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodMalfunction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodMalfunctionID sets the ID field of the mutation.
func withGoodMalfunctionID(id uint32) goodmalfunctionOption {
	return func(m *GoodMalfunctionMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodMalfunction
		)
		m.oldValue = func(ctx context.Context) (*GoodMalfunction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodMalfunction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodMalfunction sets the old GoodMalfunction of the mutation.
func withGoodMalfunction(node *GoodMalfunction) goodmalfunctionOption {
	return func(m *GoodMalfunctionMutation) {
		m.oldValue = func(context.Context) (*GoodMalfunction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodMalfunctionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodMalfunctionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodMalfunction entities.
func (m *GoodMalfunctionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodMalfunctionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodMalfunctionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodMalfunction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *GoodMalfunctionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodMalfunctionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodMalfunctionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodMalfunctionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodMalfunctionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodMalfunctionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodMalfunctionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodMalfunctionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodMalfunctionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodMalfunctionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodMalfunctionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodMalfunctionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodMalfunctionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodMalfunctionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodMalfunctionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodMalfunctionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodMalfunctionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodMalfunctionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodMalfunctionMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodMalfunctionMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodMalfunctionMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodmalfunction.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodMalfunctionMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodmalfunction.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodMalfunctionMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodmalfunction.FieldGoodID)
}

// SetTitle sets the "title" field.
func (m *GoodMalfunctionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GoodMalfunctionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *GoodMalfunctionMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[goodmalfunction.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *GoodMalfunctionMutation) TitleCleared() bool {
	_, ok := m.clearedFields[goodmalfunction.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *GoodMalfunctionMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, goodmalfunction.FieldTitle)
}

// SetMessage sets the "message" field.
func (m *GoodMalfunctionMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *GoodMalfunctionMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *GoodMalfunctionMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[goodmalfunction.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *GoodMalfunctionMutation) MessageCleared() bool {
	_, ok := m.clearedFields[goodmalfunction.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *GoodMalfunctionMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, goodmalfunction.FieldMessage)
}

// SetStartAt sets the "start_at" field.
func (m *GoodMalfunctionMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *GoodMalfunctionMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *GoodMalfunctionMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *GoodMalfunctionMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *GoodMalfunctionMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[goodmalfunction.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *GoodMalfunctionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[goodmalfunction.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *GoodMalfunctionMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, goodmalfunction.FieldStartAt)
}

// SetDurationSeconds sets the "duration_seconds" field.
func (m *GoodMalfunctionMutation) SetDurationSeconds(u uint32) {
	m.duration_seconds = &u
	m.addduration_seconds = nil
}

// DurationSeconds returns the value of the "duration_seconds" field in the mutation.
func (m *GoodMalfunctionMutation) DurationSeconds() (r uint32, exists bool) {
	v := m.duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationSeconds returns the old "duration_seconds" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldDurationSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationSeconds: %w", err)
	}
	return oldValue.DurationSeconds, nil
}

// AddDurationSeconds adds u to the "duration_seconds" field.
func (m *GoodMalfunctionMutation) AddDurationSeconds(u int32) {
	if m.addduration_seconds != nil {
		*m.addduration_seconds += u
	} else {
		m.addduration_seconds = &u
	}
}

// AddedDurationSeconds returns the value that was added to the "duration_seconds" field in this mutation.
func (m *GoodMalfunctionMutation) AddedDurationSeconds() (r int32, exists bool) {
	v := m.addduration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationSeconds clears the value of the "duration_seconds" field.
func (m *GoodMalfunctionMutation) ClearDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
	m.clearedFields[goodmalfunction.FieldDurationSeconds] = struct{}{}
}

// DurationSecondsCleared returns if the "duration_seconds" field was cleared in this mutation.
func (m *GoodMalfunctionMutation) DurationSecondsCleared() bool {
	_, ok := m.clearedFields[goodmalfunction.FieldDurationSeconds]
	return ok
}

// ResetDurationSeconds resets all changes to the "duration_seconds" field.
func (m *GoodMalfunctionMutation) ResetDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
	delete(m.clearedFields, goodmalfunction.FieldDurationSeconds)
}

// SetCompensateSeconds sets the "compensate_seconds" field.
func (m *GoodMalfunctionMutation) SetCompensateSeconds(u uint32) {
	m.compensate_seconds = &u
	m.addcompensate_seconds = nil
}

// CompensateSeconds returns the value of the "compensate_seconds" field in the mutation.
func (m *GoodMalfunctionMutation) CompensateSeconds() (r uint32, exists bool) {
	v := m.compensate_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldCompensateSeconds returns the old "compensate_seconds" field's value of the GoodMalfunction entity.
// If the GoodMalfunction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMalfunctionMutation) OldCompensateSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompensateSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompensateSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompensateSeconds: %w", err)
	}
	return oldValue.CompensateSeconds, nil
}

// AddCompensateSeconds adds u to the "compensate_seconds" field.
func (m *GoodMalfunctionMutation) AddCompensateSeconds(u int32) {
	if m.addcompensate_seconds != nil {
		*m.addcompensate_seconds += u
	} else {
		m.addcompensate_seconds = &u
	}
}

// AddedCompensateSeconds returns the value that was added to the "compensate_seconds" field in this mutation.
func (m *GoodMalfunctionMutation) AddedCompensateSeconds() (r int32, exists bool) {
	v := m.addcompensate_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompensateSeconds clears the value of the "compensate_seconds" field.
func (m *GoodMalfunctionMutation) ClearCompensateSeconds() {
	m.compensate_seconds = nil
	m.addcompensate_seconds = nil
	m.clearedFields[goodmalfunction.FieldCompensateSeconds] = struct{}{}
}

// CompensateSecondsCleared returns if the "compensate_seconds" field was cleared in this mutation.
func (m *GoodMalfunctionMutation) CompensateSecondsCleared() bool {
	_, ok := m.clearedFields[goodmalfunction.FieldCompensateSeconds]
	return ok
}

// ResetCompensateSeconds resets all changes to the "compensate_seconds" field.
func (m *GoodMalfunctionMutation) ResetCompensateSeconds() {
	m.compensate_seconds = nil
	m.addcompensate_seconds = nil
	delete(m.clearedFields, goodmalfunction.FieldCompensateSeconds)
}

// Where appends a list predicates to the GoodMalfunctionMutation builder.
func (m *GoodMalfunctionMutation) Where(ps ...predicate.GoodMalfunction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodMalfunctionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodMalfunctionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoodMalfunction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodMalfunctionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodMalfunctionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoodMalfunction).
func (m *GoodMalfunctionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodMalfunctionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ent_id != nil {
		fields = append(fields, goodmalfunction.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, goodmalfunction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodmalfunction.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodmalfunction.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodmalfunction.FieldGoodID)
	}
	if m.title != nil {
		fields = append(fields, goodmalfunction.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, goodmalfunction.FieldMessage)
	}
	if m.start_at != nil {
		fields = append(fields, goodmalfunction.FieldStartAt)
	}
	if m.duration_seconds != nil {
		fields = append(fields, goodmalfunction.FieldDurationSeconds)
	}
	if m.compensate_seconds != nil {
		fields = append(fields, goodmalfunction.FieldCompensateSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodMalfunctionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodmalfunction.FieldEntID:
		return m.EntID()
	case goodmalfunction.FieldCreatedAt:
		return m.CreatedAt()
	case goodmalfunction.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodmalfunction.FieldDeletedAt:
		return m.DeletedAt()
	case goodmalfunction.FieldGoodID:
		return m.GoodID()
	case goodmalfunction.FieldTitle:
		return m.Title()
	case goodmalfunction.FieldMessage:
		return m.Message()
	case goodmalfunction.FieldStartAt:
		return m.StartAt()
	case goodmalfunction.FieldDurationSeconds:
		return m.DurationSeconds()
	case goodmalfunction.FieldCompensateSeconds:
		return m.CompensateSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodMalfunctionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodmalfunction.FieldEntID:
		return m.OldEntID(ctx)
	case goodmalfunction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodmalfunction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodmalfunction.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodmalfunction.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodmalfunction.FieldTitle:
		return m.OldTitle(ctx)
	case goodmalfunction.FieldMessage:
		return m.OldMessage(ctx)
	case goodmalfunction.FieldStartAt:
		return m.OldStartAt(ctx)
	case goodmalfunction.FieldDurationSeconds:
		return m.OldDurationSeconds(ctx)
	case goodmalfunction.FieldCompensateSeconds:
		return m.OldCompensateSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown GoodMalfunction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodMalfunctionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodmalfunction.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodmalfunction.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodmalfunction.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodmalfunction.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodmalfunction.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodmalfunction.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case goodmalfunction.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case goodmalfunction.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case goodmalfunction.FieldDurationSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationSeconds(v)
		return nil
	case goodmalfunction.FieldCompensateSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompensateSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown GoodMalfunction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodMalfunctionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodmalfunction.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodmalfunction.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodmalfunction.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, goodmalfunction.FieldStartAt)
	}
	if m.addduration_seconds != nil {
		fields = append(fields, goodmalfunction.FieldDurationSeconds)
	}
	if m.addcompensate_seconds != nil {
		fields = append(fields, goodmalfunction.FieldCompensateSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodMalfunctionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodmalfunction.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodmalfunction.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodmalfunction.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodmalfunction.FieldStartAt:
		return m.AddedStartAt()
	case goodmalfunction.FieldDurationSeconds:
		return m.AddedDurationSeconds()
	case goodmalfunction.FieldCompensateSeconds:
		return m.AddedCompensateSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodMalfunctionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodmalfunction.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodmalfunction.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodmalfunction.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodmalfunction.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case goodmalfunction.FieldDurationSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationSeconds(v)
		return nil
	case goodmalfunction.FieldCompensateSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompensateSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown GoodMalfunction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodMalfunctionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodmalfunction.FieldGoodID) {
		fields = append(fields, goodmalfunction.FieldGoodID)
	}
	if m.FieldCleared(goodmalfunction.FieldTitle) {
		fields = append(fields, goodmalfunction.FieldTitle)
	}
	if m.FieldCleared(goodmalfunction.FieldMessage) {
		fields = append(fields, goodmalfunction.FieldMessage)
	}
	if m.FieldCleared(goodmalfunction.FieldStartAt) {
		fields = append(fields, goodmalfunction.FieldStartAt)
	}
	if m.FieldCleared(goodmalfunction.FieldDurationSeconds) {
		fields = append(fields, goodmalfunction.FieldDurationSeconds)
	}
	if m.FieldCleared(goodmalfunction.FieldCompensateSeconds) {
		fields = append(fields, goodmalfunction.FieldCompensateSeconds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodMalfunctionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodMalfunctionMutation) ClearField(name string) error {
	switch name {
	case goodmalfunction.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodmalfunction.FieldTitle:
		m.ClearTitle()
		return nil
	case goodmalfunction.FieldMessage:
		m.ClearMessage()
		return nil
	case goodmalfunction.FieldStartAt:
		m.ClearStartAt()
		return nil
	case goodmalfunction.FieldDurationSeconds:
		m.ClearDurationSeconds()
		return nil
	case goodmalfunction.FieldCompensateSeconds:
		m.ClearCompensateSeconds()
		return nil
	}
	return fmt.Errorf("unknown GoodMalfunction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodMalfunctionMutation) ResetField(name string) error {
	switch name {
	case goodmalfunction.FieldEntID:
		m.ResetEntID()
		return nil
	case goodmalfunction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodmalfunction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodmalfunction.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodmalfunction.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodmalfunction.FieldTitle:
		m.ResetTitle()
		return nil
	case goodmalfunction.FieldMessage:
		m.ResetMessage()
		return nil
	case goodmalfunction.FieldStartAt:
		m.ResetStartAt()
		return nil
	case goodmalfunction.FieldDurationSeconds:
		m.ResetDurationSeconds()
		return nil
	case goodmalfunction.FieldCompensateSeconds:
		m.ResetCompensateSeconds()
		return nil
	}
	return fmt.Errorf("unknown GoodMalfunction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodMalfunctionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodMalfunctionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodMalfunctionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodMalfunctionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodMalfunctionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodMalfunctionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodMalfunctionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodMalfunction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodMalfunctionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodMalfunction edge %s", name)
}

// GoodRewardMutation represents an operation that mutates the GoodReward nodes in the graph.
type GoodRewardMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	ent_id            *uuid.UUID
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	good_id           *uuid.UUID
	reward_state      *string
	last_reward_at    *uint32
	addlast_reward_at *int32
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*GoodReward, error)
	predicates        []predicate.GoodReward
}

var _ ent.Mutation = (*GoodRewardMutation)(nil)

// goodrewardOption allows management of the mutation configuration using functional options.
type goodrewardOption func(*GoodRewardMutation)

// newGoodRewardMutation creates new mutation for the GoodReward entity.
func newGoodRewardMutation(c config, op Op, opts ...goodrewardOption) *GoodRewardMutation {
	m := &GoodRewardMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodReward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodRewardID sets the ID field of the mutation.
func withGoodRewardID(id uint32) goodrewardOption {
	return func(m *GoodRewardMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodReward
		)
		m.oldValue = func(ctx context.Context) (*GoodReward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodReward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodReward sets the old GoodReward of the mutation.
func withGoodReward(node *GoodReward) goodrewardOption {
	return func(m *GoodRewardMutation) {
		m.oldValue = func(context.Context) (*GoodReward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodRewardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodRewardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodReward entities.
func (m *GoodRewardMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodRewardMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodRewardMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodReward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *GoodRewardMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodRewardMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodRewardMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodRewardMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodRewardMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodRewardMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodRewardMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodRewardMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodRewardMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodRewardMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodRewardMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodRewardMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodRewardMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodRewardMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodRewardMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodRewardMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodRewardMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodRewardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodRewardMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodRewardMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodRewardMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodreward.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodRewardMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodRewardMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodreward.FieldGoodID)
}

// SetRewardState sets the "reward_state" field.
func (m *GoodRewardMutation) SetRewardState(s string) {
	m.reward_state = &s
}

// RewardState returns the value of the "reward_state" field in the mutation.
func (m *GoodRewardMutation) RewardState() (r string, exists bool) {
	v := m.reward_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardState returns the old "reward_state" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldRewardState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardState: %w", err)
	}
	return oldValue.RewardState, nil
}

// ClearRewardState clears the value of the "reward_state" field.
func (m *GoodRewardMutation) ClearRewardState() {
	m.reward_state = nil
	m.clearedFields[goodreward.FieldRewardState] = struct{}{}
}

// RewardStateCleared returns if the "reward_state" field was cleared in this mutation.
func (m *GoodRewardMutation) RewardStateCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldRewardState]
	return ok
}

// ResetRewardState resets all changes to the "reward_state" field.
func (m *GoodRewardMutation) ResetRewardState() {
	m.reward_state = nil
	delete(m.clearedFields, goodreward.FieldRewardState)
}

// SetLastRewardAt sets the "last_reward_at" field.
func (m *GoodRewardMutation) SetLastRewardAt(u uint32) {
	m.last_reward_at = &u
	m.addlast_reward_at = nil
}

// LastRewardAt returns the value of the "last_reward_at" field in the mutation.
func (m *GoodRewardMutation) LastRewardAt() (r uint32, exists bool) {
	v := m.last_reward_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRewardAt returns the old "last_reward_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldLastRewardAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRewardAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRewardAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRewardAt: %w", err)
	}
	return oldValue.LastRewardAt, nil
}

// AddLastRewardAt adds u to the "last_reward_at" field.
func (m *GoodRewardMutation) AddLastRewardAt(u int32) {
	if m.addlast_reward_at != nil {
		*m.addlast_reward_at += u
	} else {
		m.addlast_reward_at = &u
	}
}

// AddedLastRewardAt returns the value that was added to the "last_reward_at" field in this mutation.
func (m *GoodRewardMutation) AddedLastRewardAt() (r int32, exists bool) {
	v := m.addlast_reward_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastRewardAt clears the value of the "last_reward_at" field.
func (m *GoodRewardMutation) ClearLastRewardAt() {
	m.last_reward_at = nil
	m.addlast_reward_at = nil
	m.clearedFields[goodreward.FieldLastRewardAt] = struct{}{}
}

// LastRewardAtCleared returns if the "last_reward_at" field was cleared in this mutation.
func (m *GoodRewardMutation) LastRewardAtCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldLastRewardAt]
	return ok
}

// ResetLastRewardAt resets all changes to the "last_reward_at" field.
func (m *GoodRewardMutation) ResetLastRewardAt() {
	m.last_reward_at = nil
	m.addlast_reward_at = nil
	delete(m.clearedFields, goodreward.FieldLastRewardAt)
}

// Where appends a list predicates to the GoodRewardMutation builder.
func (m *GoodRewardMutation) Where(ps ...predicate.GoodReward) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodRewardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodRewardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoodReward, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodRewardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodRewardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoodReward).
func (m *GoodRewardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodRewardMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, goodreward.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, goodreward.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodreward.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodreward.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodreward.FieldGoodID)
	}
	if m.reward_state != nil {
		fields = append(fields, goodreward.FieldRewardState)
	}
	if m.last_reward_at != nil {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodRewardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodreward.FieldEntID:
		return m.EntID()
	case goodreward.FieldCreatedAt:
		return m.CreatedAt()
	case goodreward.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodreward.FieldDeletedAt:
		return m.DeletedAt()
	case goodreward.FieldGoodID:
		return m.GoodID()
	case goodreward.FieldRewardState:
		return m.RewardState()
	case goodreward.FieldLastRewardAt:
		return m.LastRewardAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodRewardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodreward.FieldEntID:
		return m.OldEntID(ctx)
	case goodreward.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodreward.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodreward.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodreward.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodreward.FieldRewardState:
		return m.OldRewardState(ctx)
	case goodreward.FieldLastRewardAt:
		return m.OldLastRewardAt(ctx)
	}
	return nil, fmt.Errorf("unknown GoodReward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodreward.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodreward.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodreward.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodreward.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodreward.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodreward.FieldRewardState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardState(v)
		return nil
	case goodreward.FieldLastRewardAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRewardAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodReward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodRewardMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodreward.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodreward.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodreward.FieldDeletedAt)
	}
	if m.addlast_reward_at != nil {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodRewardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodreward.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodreward.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodreward.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodreward.FieldLastRewardAt:
		return m.AddedLastRewardAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodreward.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodreward.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodreward.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodreward.FieldLastRewardAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastRewardAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodReward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodRewardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodreward.FieldGoodID) {
		fields = append(fields, goodreward.FieldGoodID)
	}
	if m.FieldCleared(goodreward.FieldRewardState) {
		fields = append(fields, goodreward.FieldRewardState)
	}
	if m.FieldCleared(goodreward.FieldLastRewardAt) {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodRewardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodRewardMutation) ClearField(name string) error {
	switch name {
	case goodreward.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodreward.FieldRewardState:
		m.ClearRewardState()
		return nil
	case goodreward.FieldLastRewardAt:
		m.ClearLastRewardAt()
		return nil
	}
	return fmt.Errorf("unknown GoodReward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodRewardMutation) ResetField(name string) error {
	switch name {
	case goodreward.FieldEntID:
		m.ResetEntID()
		return nil
	case goodreward.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodreward.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodreward.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodreward.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodreward.FieldRewardState:
		m.ResetRewardState()
		return nil
	case goodreward.FieldLastRewardAt:
		m.ResetLastRewardAt()
		return nil
	}
	return fmt.Errorf("unknown GoodReward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodRewardMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodRewardMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodRewardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodRewardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodRewardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodRewardMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodRewardMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodReward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodRewardMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodReward edge %s", name)
}

// GoodRewardHistoryMutation represents an operation that mutates the GoodRewardHistory nodes in the graph.
type GoodRewardHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	ent_id          *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	good_id         *uuid.UUID
	coin_type_id    *uuid.UUID
	reward_date     *uint32
	addreward_date  *int32
	tid             *uuid.UUID
	amount          *decimal.Decimal
	unit_amount     *decimal.Decimal
	unit_net_amount *decimal.Decimal
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*GoodRewardHistory, error)
	predicates      []predicate.GoodRewardHistory
}

var _ ent.Mutation = (*GoodRewardHistoryMutation)(nil)

// goodrewardhistoryOption allows management of the mutation configuration using functional options.
type goodrewardhistoryOption func(*GoodRewardHistoryMutation)

// newGoodRewardHistoryMutation creates new mutation for the GoodRewardHistory entity.
func newGoodRewardHistoryMutation(c config, op Op, opts ...goodrewardhistoryOption) *GoodRewardHistoryMutation {
	m := &GoodRewardHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodRewardHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodRewardHistoryID sets the ID field of the mutation.
func withGoodRewardHistoryID(id uint32) goodrewardhistoryOption {
	return func(m *GoodRewardHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodRewardHistory
		)
		m.oldValue = func(ctx context.Context) (*GoodRewardHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodRewardHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodRewardHistory sets the old GoodRewardHistory of the mutation.
func withGoodRewardHistory(node *GoodRewardHistory) goodrewardhistoryOption {
	return func(m *GoodRewardHistoryMutation) {
		m.oldValue = func(context.Context) (*GoodRewardHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodRewardHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodRewardHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodRewardHistory entities.
func (m *GoodRewardHistoryMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodRewardHistoryMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodRewardHistoryMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodRewardHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *GoodRewardHistoryMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodRewardHistoryMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodRewardHistoryMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodRewardHistoryMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodRewardHistoryMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodRewardHistoryMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodRewardHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodRewardHistoryMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodRewardHistoryMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodRewardHistoryMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodRewardHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodRewardHistoryMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodRewardHistoryMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodRewardHistoryMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodRewardHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodRewardHistoryMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodRewardHistoryMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodRewardHistoryMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodrewardhistory.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodRewardHistoryMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodrewardhistory.FieldGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *GoodRewardHistoryMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *GoodRewardHistoryMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *GoodRewardHistoryMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[goodrewardhistory.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *GoodRewardHistoryMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, goodrewardhistory.FieldCoinTypeID)
}

// SetRewardDate sets the "reward_date" field.
func (m *GoodRewardHistoryMutation) SetRewardDate(u uint32) {
	m.reward_date = &u
	m.addreward_date = nil
}

// RewardDate returns the value of the "reward_date" field in the mutation.
func (m *GoodRewardHistoryMutation) RewardDate() (r uint32, exists bool) {
	v := m.reward_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardDate returns the old "reward_date" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldRewardDate(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardDate: %w", err)
	}
	return oldValue.RewardDate, nil
}

// AddRewardDate adds u to the "reward_date" field.
func (m *GoodRewardHistoryMutation) AddRewardDate(u int32) {
	if m.addreward_date != nil {
		*m.addreward_date += u
	} else {
		m.addreward_date = &u
	}
}

// AddedRewardDate returns the value that was added to the "reward_date" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedRewardDate() (r int32, exists bool) {
	v := m.addreward_date
	if v == nil {
		return
	}
	return *v, true
}

// ClearRewardDate clears the value of the "reward_date" field.
func (m *GoodRewardHistoryMutation) ClearRewardDate() {
	m.reward_date = nil
	m.addreward_date = nil
	m.clearedFields[goodrewardhistory.FieldRewardDate] = struct{}{}
}

// RewardDateCleared returns if the "reward_date" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) RewardDateCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldRewardDate]
	return ok
}

// ResetRewardDate resets all changes to the "reward_date" field.
func (m *GoodRewardHistoryMutation) ResetRewardDate() {
	m.reward_date = nil
	m.addreward_date = nil
	delete(m.clearedFields, goodrewardhistory.FieldRewardDate)
}

// SetTid sets the "tid" field.
func (m *GoodRewardHistoryMutation) SetTid(u uuid.UUID) {
	m.tid = &u
}

// Tid returns the value of the "tid" field in the mutation.
func (m *GoodRewardHistoryMutation) Tid() (r uuid.UUID, exists bool) {
	v := m.tid
	if v == nil {
		return
	}
	return *v, true
}

// OldTid returns the old "tid" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldTid(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTid: %w", err)
	}
	return oldValue.Tid, nil
}

// ClearTid clears the value of the "tid" field.
func (m *GoodRewardHistoryMutation) ClearTid() {
	m.tid = nil
	m.clearedFields[goodrewardhistory.FieldTid] = struct{}{}
}

// TidCleared returns if the "tid" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) TidCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldTid]
	return ok
}

// ResetTid resets all changes to the "tid" field.
func (m *GoodRewardHistoryMutation) ResetTid() {
	m.tid = nil
	delete(m.clearedFields, goodrewardhistory.FieldTid)
}

// SetAmount sets the "amount" field.
func (m *GoodRewardHistoryMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GoodRewardHistoryMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *GoodRewardHistoryMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[goodrewardhistory.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) AmountCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *GoodRewardHistoryMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, goodrewardhistory.FieldAmount)
}

// SetUnitAmount sets the "unit_amount" field.
func (m *GoodRewardHistoryMutation) SetUnitAmount(d decimal.Decimal) {
	m.unit_amount = &d
}

// UnitAmount returns the value of the "unit_amount" field in the mutation.
func (m *GoodRewardHistoryMutation) UnitAmount() (r decimal.Decimal, exists bool) {
	v := m.unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitAmount returns the old "unit_amount" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldUnitAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitAmount: %w", err)
	}
	return oldValue.UnitAmount, nil
}

// ClearUnitAmount clears the value of the "unit_amount" field.
func (m *GoodRewardHistoryMutation) ClearUnitAmount() {
	m.unit_amount = nil
	m.clearedFields[goodrewardhistory.FieldUnitAmount] = struct{}{}
}

// UnitAmountCleared returns if the "unit_amount" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) UnitAmountCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldUnitAmount]
	return ok
}

// ResetUnitAmount resets all changes to the "unit_amount" field.
func (m *GoodRewardHistoryMutation) ResetUnitAmount() {
	m.unit_amount = nil
	delete(m.clearedFields, goodrewardhistory.FieldUnitAmount)
}

// SetUnitNetAmount sets the "unit_net_amount" field.
func (m *GoodRewardHistoryMutation) SetUnitNetAmount(d decimal.Decimal) {
	m.unit_net_amount = &d
}

// UnitNetAmount returns the value of the "unit_net_amount" field in the mutation.
func (m *GoodRewardHistoryMutation) UnitNetAmount() (r decimal.Decimal, exists bool) {
	v := m.unit_net_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitNetAmount returns the old "unit_net_amount" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldUnitNetAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitNetAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitNetAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitNetAmount: %w", err)
	}
	return oldValue.UnitNetAmount, nil
}

// ClearUnitNetAmount clears the value of the "unit_net_amount" field.
func (m *GoodRewardHistoryMutation) ClearUnitNetAmount() {
	m.unit_net_amount = nil
	m.clearedFields[goodrewardhistory.FieldUnitNetAmount] = struct{}{}
}

// UnitNetAmountCleared returns if the "unit_net_amount" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) UnitNetAmountCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldUnitNetAmount]
	return ok
}

// ResetUnitNetAmount resets all changes to the "unit_net_amount" field.
func (m *GoodRewardHistoryMutation) ResetUnitNetAmount() {
	m.unit_net_amount = nil
	delete(m.clearedFields, goodrewardhistory.FieldUnitNetAmount)
}

// Where appends a list predicates to the GoodRewardHistoryMutation builder.
func (m *GoodRewardHistoryMutation) Where(ps ...predicate.GoodRewardHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoodRewardHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoodRewardHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoodRewardHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoodRewardHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoodRewardHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoodRewardHistory).
func (m *GoodRewardHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodRewardHistoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ent_id != nil {
		fields = append(fields, goodrewardhistory.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, goodrewardhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodrewardhistory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodrewardhistory.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodrewardhistory.FieldGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, goodrewardhistory.FieldCoinTypeID)
	}
	if m.reward_date != nil {
		fields = append(fields, goodrewardhistory.FieldRewardDate)
	}
	if m.tid != nil {
		fields = append(fields, goodrewardhistory.FieldTid)
	}
	if m.amount != nil {
		fields = append(fields, goodrewardhistory.FieldAmount)
	}
	if m.unit_amount != nil {
		fields = append(fields, goodrewardhistory.FieldUnitAmount)
	}
	if m.unit_net_amount != nil {
		fields = append(fields, goodrewardhistory.FieldUnitNetAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodRewardHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodrewardhistory.FieldEntID:
		return m.EntID()
	case goodrewardhistory.FieldCreatedAt:
		return m.CreatedAt()
	case goodrewardhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodrewardhistory.FieldDeletedAt:
		return m.DeletedAt()
	case goodrewardhistory.FieldGoodID:
		return m.GoodID()
	case goodrewardhistory.FieldCoinTypeID:
		return m.CoinTypeID()
	case goodrewardhistory.FieldRewardDate:
		return m.RewardDate()
	case goodrewardhistory.FieldTid:
		return m.Tid()
	case goodrewardhistory.FieldAmount:
		return m.Amount()
	case goodrewardhistory.FieldUnitAmount:
		return m.UnitAmount()
	case goodrewardhistory.FieldUnitNetAmount:
		return m.UnitNetAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodRewardHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodrewardhistory.FieldEntID:
		return m.OldEntID(ctx)
	case goodrewardhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodrewardhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodrewardhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodrewardhistory.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodrewardhistory.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case goodrewardhistory.FieldRewardDate:
		return m.OldRewardDate(ctx)
	case goodrewardhistory.FieldTid:
		return m.OldTid(ctx)
	case goodrewardhistory.FieldAmount:
		return m.OldAmount(ctx)
	case goodrewardhistory.FieldUnitAmount:
		return m.OldUnitAmount(ctx)
	case goodrewardhistory.FieldUnitNetAmount:
		return m.OldUnitNetAmount(ctx)
	}
	return nil, fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodrewardhistory.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case goodrewardhistory.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodrewardhistory.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodrewardhistory.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodrewardhistory.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case goodrewardhistory.FieldRewardDate:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardDate(v)
		return nil
	case goodrewardhistory.FieldTid:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTid(v)
		return nil
	case goodrewardhistory.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case goodrewardhistory.FieldUnitAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitAmount(v)
		return nil
	case goodrewardhistory.FieldUnitNetAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitNetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodRewardHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodrewardhistory.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodrewardhistory.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodrewardhistory.FieldDeletedAt)
	}
	if m.addreward_date != nil {
		fields = append(fields, goodrewardhistory.FieldRewardDate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodRewardHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodrewardhistory.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodrewardhistory.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodrewardhistory.FieldRewardDate:
		return m.AddedRewardDate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodrewardhistory.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodrewardhistory.FieldRewardDate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRewardDate(v)
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodRewardHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodrewardhistory.FieldGoodID) {
		fields = append(fields, goodrewardhistory.FieldGoodID)
	}
	if m.FieldCleared(goodrewardhistory.FieldCoinTypeID) {
		fields = append(fields, goodrewardhistory.FieldCoinTypeID)
	}
	if m.FieldCleared(goodrewardhistory.FieldRewardDate) {
		fields = append(fields, goodrewardhistory.FieldRewardDate)
	}
	if m.FieldCleared(goodrewardhistory.FieldTid) {
		fields = append(fields, goodrewardhistory.FieldTid)
	}
	if m.FieldCleared(goodrewardhistory.FieldAmount) {
		fields = append(fields, goodrewardhistory.FieldAmount)
	}
	if m.FieldCleared(goodrewardhistory.FieldUnitAmount) {
		fields = append(fields, goodrewardhistory.FieldUnitAmount)
	}
	if m.FieldCleared(goodrewardhistory.FieldUnitNetAmount) {
		fields = append(fields, goodrewardhistory.FieldUnitNetAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodRewardHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodRewardHistoryMutation) ClearField(name string) error {
	switch name {
	case goodrewardhistory.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodrewardhistory.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case goodrewardhistory.FieldRewardDate:
		m.ClearRewardDate()
		return nil
	case goodrewardhistory.FieldTid:
		m.ClearTid()
		return nil
	case goodrewardhistory.FieldAmount:
		m.ClearAmount()
		return nil
	case goodrewardhistory.FieldUnitAmount:
		m.ClearUnitAmount()
		return nil
	case goodrewardhistory.FieldUnitNetAmount:
		m.ClearUnitNetAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodRewardHistoryMutation) ResetField(name string) error {
	switch name {
	case goodrewardhistory.FieldEntID:
		m.ResetEntID()
		return nil
	case goodrewardhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodrewardhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodrewardhistory.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodrewardhistory.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case goodrewardhistory.FieldRewardDate:
		m.ResetRewardDate()
		return nil
	case goodrewardhistory.FieldTid:
		m.ResetTid()
		return nil
	case goodrewardhistory.FieldAmount:
		m.ResetAmount()
		return nil
	case goodrewardhistory.FieldUnitAmount:
		m.ResetUnitAmount()
		return nil
	case goodrewardhistory.FieldUnitNetAmount:
		m.ResetUnitNetAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodRewardHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodRewardHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodRewardHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodRewardHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodRewardHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodRewardHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodRewardHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodRewardHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodRewardHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodRewardHistory edge %s", name)
}

// LikeMutation represents an operation that mutates the Like nodes in the graph.
type LikeMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	user_id       *uuid.UUID
	app_good_id   *uuid.UUID
	like          *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Like, error)
	predicates    []predicate.Like
}

var _ ent.Mutation = (*LikeMutation)(nil)

// likeOption allows management of the mutation configuration using functional options.
type likeOption func(*LikeMutation)

// newLikeMutation creates new mutation for the Like entity.
func newLikeMutation(c config, op Op, opts ...likeOption) *LikeMutation {
	m := &LikeMutation{
		config:        c,
		op:            op,
		typ:           TypeLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikeID sets the ID field of the mutation.
func withLikeID(id uint32) likeOption {
	return func(m *LikeMutation) {
		var (
			err   error
			once  sync.Once
			value *Like
		)
		m.oldValue = func(ctx context.Context) (*Like, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Like.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLike sets the old Like of the mutation.
func withLike(node *Like) likeOption {
	return func(m *LikeMutation) {
		m.oldValue = func(context.Context) (*Like, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Like entities.
func (m *LikeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Like.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *LikeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *LikeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *LikeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LikeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LikeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *LikeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *LikeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LikeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LikeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LikeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *LikeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *LikeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LikeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LikeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LikeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *LikeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *LikeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LikeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *LikeMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LikeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *LikeMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[like.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *LikeMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[like.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LikeMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, like.FieldUserID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *LikeMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *LikeMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *LikeMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[like.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *LikeMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[like.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *LikeMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, like.FieldAppGoodID)
}

// SetLike sets the "like" field.
func (m *LikeMutation) SetLike(b bool) {
	m.like = &b
}

// Like returns the value of the "like" field in the mutation.
func (m *LikeMutation) Like() (r bool, exists bool) {
	v := m.like
	if v == nil {
		return
	}
	return *v, true
}

// OldLike returns the old "like" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldLike(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLike is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLike requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLike: %w", err)
	}
	return oldValue.Like, nil
}

// ResetLike resets all changes to the "like" field.
func (m *LikeMutation) ResetLike() {
	m.like = nil
}

// Where appends a list predicates to the LikeMutation builder.
func (m *LikeMutation) Where(ps ...predicate.Like) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Like, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Like).
func (m *LikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, like.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, like.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, like.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, like.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, like.FieldUserID)
	}
	if m.app_good_id != nil {
		fields = append(fields, like.FieldAppGoodID)
	}
	if m.like != nil {
		fields = append(fields, like.FieldLike)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case like.FieldEntID:
		return m.EntID()
	case like.FieldCreatedAt:
		return m.CreatedAt()
	case like.FieldUpdatedAt:
		return m.UpdatedAt()
	case like.FieldDeletedAt:
		return m.DeletedAt()
	case like.FieldUserID:
		return m.UserID()
	case like.FieldAppGoodID:
		return m.AppGoodID()
	case like.FieldLike:
		return m.Like()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case like.FieldEntID:
		return m.OldEntID(ctx)
	case like.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case like.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case like.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case like.FieldUserID:
		return m.OldUserID(ctx)
	case like.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case like.FieldLike:
		return m.OldLike(ctx)
	}
	return nil, fmt.Errorf("unknown Like field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case like.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case like.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case like.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case like.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case like.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case like.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case like.FieldLike:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLike(v)
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, like.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, like.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, like.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case like.FieldCreatedAt:
		return m.AddedCreatedAt()
	case like.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case like.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case like.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case like.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case like.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Like numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(like.FieldUserID) {
		fields = append(fields, like.FieldUserID)
	}
	if m.FieldCleared(like.FieldAppGoodID) {
		fields = append(fields, like.FieldAppGoodID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikeMutation) ClearField(name string) error {
	switch name {
	case like.FieldUserID:
		m.ClearUserID()
		return nil
	case like.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	}
	return fmt.Errorf("unknown Like nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikeMutation) ResetField(name string) error {
	switch name {
	case like.FieldEntID:
		m.ResetEntID()
		return nil
	case like.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case like.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case like.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case like.FieldUserID:
		m.ResetUserID()
		return nil
	case like.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case like.FieldLike:
		m.ResetLike()
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Like unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Like edge %s", name)
}

// MiningGoodStockMutation represents an operation that mutates the MiningGoodStock nodes in the graph.
type MiningGoodStockMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	ent_id            *uuid.UUID
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	good_stock_id     *uuid.UUID
	pool_root_user_id *uuid.UUID
	pool_good_user_id *uuid.UUID
	total             *decimal.Decimal
	spot_quantity     *decimal.Decimal
	locked            *decimal.Decimal
	in_service        *decimal.Decimal
	wait_start        *decimal.Decimal
	sold              *decimal.Decimal
	app_reserved      *decimal.Decimal
	state             *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*MiningGoodStock, error)
	predicates        []predicate.MiningGoodStock
}

var _ ent.Mutation = (*MiningGoodStockMutation)(nil)

// mininggoodstockOption allows management of the mutation configuration using functional options.
type mininggoodstockOption func(*MiningGoodStockMutation)

// newMiningGoodStockMutation creates new mutation for the MiningGoodStock entity.
func newMiningGoodStockMutation(c config, op Op, opts ...mininggoodstockOption) *MiningGoodStockMutation {
	m := &MiningGoodStockMutation{
		config:        c,
		op:            op,
		typ:           TypeMiningGoodStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMiningGoodStockID sets the ID field of the mutation.
func withMiningGoodStockID(id uint32) mininggoodstockOption {
	return func(m *MiningGoodStockMutation) {
		var (
			err   error
			once  sync.Once
			value *MiningGoodStock
		)
		m.oldValue = func(ctx context.Context) (*MiningGoodStock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MiningGoodStock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMiningGoodStock sets the old MiningGoodStock of the mutation.
func withMiningGoodStock(node *MiningGoodStock) mininggoodstockOption {
	return func(m *MiningGoodStockMutation) {
		m.oldValue = func(context.Context) (*MiningGoodStock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MiningGoodStockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MiningGoodStockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MiningGoodStock entities.
func (m *MiningGoodStockMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MiningGoodStockMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MiningGoodStockMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MiningGoodStock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *MiningGoodStockMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *MiningGoodStockMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *MiningGoodStockMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MiningGoodStockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MiningGoodStockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *MiningGoodStockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *MiningGoodStockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MiningGoodStockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MiningGoodStockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MiningGoodStockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *MiningGoodStockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *MiningGoodStockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MiningGoodStockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MiningGoodStockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MiningGoodStockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *MiningGoodStockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *MiningGoodStockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MiningGoodStockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodStockID sets the "good_stock_id" field.
func (m *MiningGoodStockMutation) SetGoodStockID(u uuid.UUID) {
	m.good_stock_id = &u
}

// GoodStockID returns the value of the "good_stock_id" field in the mutation.
func (m *MiningGoodStockMutation) GoodStockID() (r uuid.UUID, exists bool) {
	v := m.good_stock_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodStockID returns the old "good_stock_id" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldGoodStockID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodStockID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodStockID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodStockID: %w", err)
	}
	return oldValue.GoodStockID, nil
}

// ClearGoodStockID clears the value of the "good_stock_id" field.
func (m *MiningGoodStockMutation) ClearGoodStockID() {
	m.good_stock_id = nil
	m.clearedFields[mininggoodstock.FieldGoodStockID] = struct{}{}
}

// GoodStockIDCleared returns if the "good_stock_id" field was cleared in this mutation.
func (m *MiningGoodStockMutation) GoodStockIDCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldGoodStockID]
	return ok
}

// ResetGoodStockID resets all changes to the "good_stock_id" field.
func (m *MiningGoodStockMutation) ResetGoodStockID() {
	m.good_stock_id = nil
	delete(m.clearedFields, mininggoodstock.FieldGoodStockID)
}

// SetPoolRootUserID sets the "pool_root_user_id" field.
func (m *MiningGoodStockMutation) SetPoolRootUserID(u uuid.UUID) {
	m.pool_root_user_id = &u
}

// PoolRootUserID returns the value of the "pool_root_user_id" field in the mutation.
func (m *MiningGoodStockMutation) PoolRootUserID() (r uuid.UUID, exists bool) {
	v := m.pool_root_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolRootUserID returns the old "pool_root_user_id" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldPoolRootUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolRootUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolRootUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolRootUserID: %w", err)
	}
	return oldValue.PoolRootUserID, nil
}

// ClearPoolRootUserID clears the value of the "pool_root_user_id" field.
func (m *MiningGoodStockMutation) ClearPoolRootUserID() {
	m.pool_root_user_id = nil
	m.clearedFields[mininggoodstock.FieldPoolRootUserID] = struct{}{}
}

// PoolRootUserIDCleared returns if the "pool_root_user_id" field was cleared in this mutation.
func (m *MiningGoodStockMutation) PoolRootUserIDCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldPoolRootUserID]
	return ok
}

// ResetPoolRootUserID resets all changes to the "pool_root_user_id" field.
func (m *MiningGoodStockMutation) ResetPoolRootUserID() {
	m.pool_root_user_id = nil
	delete(m.clearedFields, mininggoodstock.FieldPoolRootUserID)
}

// SetPoolGoodUserID sets the "pool_good_user_id" field.
func (m *MiningGoodStockMutation) SetPoolGoodUserID(u uuid.UUID) {
	m.pool_good_user_id = &u
}

// PoolGoodUserID returns the value of the "pool_good_user_id" field in the mutation.
func (m *MiningGoodStockMutation) PoolGoodUserID() (r uuid.UUID, exists bool) {
	v := m.pool_good_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolGoodUserID returns the old "pool_good_user_id" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldPoolGoodUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolGoodUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolGoodUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolGoodUserID: %w", err)
	}
	return oldValue.PoolGoodUserID, nil
}

// ClearPoolGoodUserID clears the value of the "pool_good_user_id" field.
func (m *MiningGoodStockMutation) ClearPoolGoodUserID() {
	m.pool_good_user_id = nil
	m.clearedFields[mininggoodstock.FieldPoolGoodUserID] = struct{}{}
}

// PoolGoodUserIDCleared returns if the "pool_good_user_id" field was cleared in this mutation.
func (m *MiningGoodStockMutation) PoolGoodUserIDCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldPoolGoodUserID]
	return ok
}

// ResetPoolGoodUserID resets all changes to the "pool_good_user_id" field.
func (m *MiningGoodStockMutation) ResetPoolGoodUserID() {
	m.pool_good_user_id = nil
	delete(m.clearedFields, mininggoodstock.FieldPoolGoodUserID)
}

// SetTotal sets the "total" field.
func (m *MiningGoodStockMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
}

// Total returns the value of the "total" field in the mutation.
func (m *MiningGoodStockMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ClearTotal clears the value of the "total" field.
func (m *MiningGoodStockMutation) ClearTotal() {
	m.total = nil
	m.clearedFields[mininggoodstock.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *MiningGoodStockMutation) TotalCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *MiningGoodStockMutation) ResetTotal() {
	m.total = nil
	delete(m.clearedFields, mininggoodstock.FieldTotal)
}

// SetSpotQuantity sets the "spot_quantity" field.
func (m *MiningGoodStockMutation) SetSpotQuantity(d decimal.Decimal) {
	m.spot_quantity = &d
}

// SpotQuantity returns the value of the "spot_quantity" field in the mutation.
func (m *MiningGoodStockMutation) SpotQuantity() (r decimal.Decimal, exists bool) {
	v := m.spot_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotQuantity returns the old "spot_quantity" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldSpotQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotQuantity: %w", err)
	}
	return oldValue.SpotQuantity, nil
}

// ClearSpotQuantity clears the value of the "spot_quantity" field.
func (m *MiningGoodStockMutation) ClearSpotQuantity() {
	m.spot_quantity = nil
	m.clearedFields[mininggoodstock.FieldSpotQuantity] = struct{}{}
}

// SpotQuantityCleared returns if the "spot_quantity" field was cleared in this mutation.
func (m *MiningGoodStockMutation) SpotQuantityCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldSpotQuantity]
	return ok
}

// ResetSpotQuantity resets all changes to the "spot_quantity" field.
func (m *MiningGoodStockMutation) ResetSpotQuantity() {
	m.spot_quantity = nil
	delete(m.clearedFields, mininggoodstock.FieldSpotQuantity)
}

// SetLocked sets the "locked" field.
func (m *MiningGoodStockMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
}

// Locked returns the value of the "locked" field in the mutation.
func (m *MiningGoodStockMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ClearLocked clears the value of the "locked" field.
func (m *MiningGoodStockMutation) ClearLocked() {
	m.locked = nil
	m.clearedFields[mininggoodstock.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *MiningGoodStockMutation) LockedCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *MiningGoodStockMutation) ResetLocked() {
	m.locked = nil
	delete(m.clearedFields, mininggoodstock.FieldLocked)
}

// SetInService sets the "in_service" field.
func (m *MiningGoodStockMutation) SetInService(d decimal.Decimal) {
	m.in_service = &d
}

// InService returns the value of the "in_service" field in the mutation.
func (m *MiningGoodStockMutation) InService() (r decimal.Decimal, exists bool) {
	v := m.in_service
	if v == nil {
		return
	}
	return *v, true
}

// OldInService returns the old "in_service" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldInService(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInService: %w", err)
	}
	return oldValue.InService, nil
}

// ClearInService clears the value of the "in_service" field.
func (m *MiningGoodStockMutation) ClearInService() {
	m.in_service = nil
	m.clearedFields[mininggoodstock.FieldInService] = struct{}{}
}

// InServiceCleared returns if the "in_service" field was cleared in this mutation.
func (m *MiningGoodStockMutation) InServiceCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldInService]
	return ok
}

// ResetInService resets all changes to the "in_service" field.
func (m *MiningGoodStockMutation) ResetInService() {
	m.in_service = nil
	delete(m.clearedFields, mininggoodstock.FieldInService)
}

// SetWaitStart sets the "wait_start" field.
func (m *MiningGoodStockMutation) SetWaitStart(d decimal.Decimal) {
	m.wait_start = &d
}

// WaitStart returns the value of the "wait_start" field in the mutation.
func (m *MiningGoodStockMutation) WaitStart() (r decimal.Decimal, exists bool) {
	v := m.wait_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWaitStart returns the old "wait_start" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldWaitStart(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaitStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaitStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaitStart: %w", err)
	}
	return oldValue.WaitStart, nil
}

// ClearWaitStart clears the value of the "wait_start" field.
func (m *MiningGoodStockMutation) ClearWaitStart() {
	m.wait_start = nil
	m.clearedFields[mininggoodstock.FieldWaitStart] = struct{}{}
}

// WaitStartCleared returns if the "wait_start" field was cleared in this mutation.
func (m *MiningGoodStockMutation) WaitStartCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldWaitStart]
	return ok
}

// ResetWaitStart resets all changes to the "wait_start" field.
func (m *MiningGoodStockMutation) ResetWaitStart() {
	m.wait_start = nil
	delete(m.clearedFields, mininggoodstock.FieldWaitStart)
}

// SetSold sets the "sold" field.
func (m *MiningGoodStockMutation) SetSold(d decimal.Decimal) {
	m.sold = &d
}

// Sold returns the value of the "sold" field in the mutation.
func (m *MiningGoodStockMutation) Sold() (r decimal.Decimal, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldSold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// ClearSold clears the value of the "sold" field.
func (m *MiningGoodStockMutation) ClearSold() {
	m.sold = nil
	m.clearedFields[mininggoodstock.FieldSold] = struct{}{}
}

// SoldCleared returns if the "sold" field was cleared in this mutation.
func (m *MiningGoodStockMutation) SoldCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldSold]
	return ok
}

// ResetSold resets all changes to the "sold" field.
func (m *MiningGoodStockMutation) ResetSold() {
	m.sold = nil
	delete(m.clearedFields, mininggoodstock.FieldSold)
}

// SetAppReserved sets the "app_reserved" field.
func (m *MiningGoodStockMutation) SetAppReserved(d decimal.Decimal) {
	m.app_reserved = &d
}

// AppReserved returns the value of the "app_reserved" field in the mutation.
func (m *MiningGoodStockMutation) AppReserved() (r decimal.Decimal, exists bool) {
	v := m.app_reserved
	if v == nil {
		return
	}
	return *v, true
}

// OldAppReserved returns the old "app_reserved" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldAppReserved(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppReserved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppReserved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppReserved: %w", err)
	}
	return oldValue.AppReserved, nil
}

// ClearAppReserved clears the value of the "app_reserved" field.
func (m *MiningGoodStockMutation) ClearAppReserved() {
	m.app_reserved = nil
	m.clearedFields[mininggoodstock.FieldAppReserved] = struct{}{}
}

// AppReservedCleared returns if the "app_reserved" field was cleared in this mutation.
func (m *MiningGoodStockMutation) AppReservedCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldAppReserved]
	return ok
}

// ResetAppReserved resets all changes to the "app_reserved" field.
func (m *MiningGoodStockMutation) ResetAppReserved() {
	m.app_reserved = nil
	delete(m.clearedFields, mininggoodstock.FieldAppReserved)
}

// SetState sets the "state" field.
func (m *MiningGoodStockMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *MiningGoodStockMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the MiningGoodStock entity.
// If the MiningGoodStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MiningGoodStockMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *MiningGoodStockMutation) ClearState() {
	m.state = nil
	m.clearedFields[mininggoodstock.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *MiningGoodStockMutation) StateCleared() bool {
	_, ok := m.clearedFields[mininggoodstock.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *MiningGoodStockMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, mininggoodstock.FieldState)
}

// Where appends a list predicates to the MiningGoodStockMutation builder.
func (m *MiningGoodStockMutation) Where(ps ...predicate.MiningGoodStock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MiningGoodStockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MiningGoodStockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MiningGoodStock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MiningGoodStockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MiningGoodStockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MiningGoodStock).
func (m *MiningGoodStockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MiningGoodStockMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.ent_id != nil {
		fields = append(fields, mininggoodstock.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, mininggoodstock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mininggoodstock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mininggoodstock.FieldDeletedAt)
	}
	if m.good_stock_id != nil {
		fields = append(fields, mininggoodstock.FieldGoodStockID)
	}
	if m.pool_root_user_id != nil {
		fields = append(fields, mininggoodstock.FieldPoolRootUserID)
	}
	if m.pool_good_user_id != nil {
		fields = append(fields, mininggoodstock.FieldPoolGoodUserID)
	}
	if m.total != nil {
		fields = append(fields, mininggoodstock.FieldTotal)
	}
	if m.spot_quantity != nil {
		fields = append(fields, mininggoodstock.FieldSpotQuantity)
	}
	if m.locked != nil {
		fields = append(fields, mininggoodstock.FieldLocked)
	}
	if m.in_service != nil {
		fields = append(fields, mininggoodstock.FieldInService)
	}
	if m.wait_start != nil {
		fields = append(fields, mininggoodstock.FieldWaitStart)
	}
	if m.sold != nil {
		fields = append(fields, mininggoodstock.FieldSold)
	}
	if m.app_reserved != nil {
		fields = append(fields, mininggoodstock.FieldAppReserved)
	}
	if m.state != nil {
		fields = append(fields, mininggoodstock.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MiningGoodStockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mininggoodstock.FieldEntID:
		return m.EntID()
	case mininggoodstock.FieldCreatedAt:
		return m.CreatedAt()
	case mininggoodstock.FieldUpdatedAt:
		return m.UpdatedAt()
	case mininggoodstock.FieldDeletedAt:
		return m.DeletedAt()
	case mininggoodstock.FieldGoodStockID:
		return m.GoodStockID()
	case mininggoodstock.FieldPoolRootUserID:
		return m.PoolRootUserID()
	case mininggoodstock.FieldPoolGoodUserID:
		return m.PoolGoodUserID()
	case mininggoodstock.FieldTotal:
		return m.Total()
	case mininggoodstock.FieldSpotQuantity:
		return m.SpotQuantity()
	case mininggoodstock.FieldLocked:
		return m.Locked()
	case mininggoodstock.FieldInService:
		return m.InService()
	case mininggoodstock.FieldWaitStart:
		return m.WaitStart()
	case mininggoodstock.FieldSold:
		return m.Sold()
	case mininggoodstock.FieldAppReserved:
		return m.AppReserved()
	case mininggoodstock.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MiningGoodStockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mininggoodstock.FieldEntID:
		return m.OldEntID(ctx)
	case mininggoodstock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mininggoodstock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mininggoodstock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mininggoodstock.FieldGoodStockID:
		return m.OldGoodStockID(ctx)
	case mininggoodstock.FieldPoolRootUserID:
		return m.OldPoolRootUserID(ctx)
	case mininggoodstock.FieldPoolGoodUserID:
		return m.OldPoolGoodUserID(ctx)
	case mininggoodstock.FieldTotal:
		return m.OldTotal(ctx)
	case mininggoodstock.FieldSpotQuantity:
		return m.OldSpotQuantity(ctx)
	case mininggoodstock.FieldLocked:
		return m.OldLocked(ctx)
	case mininggoodstock.FieldInService:
		return m.OldInService(ctx)
	case mininggoodstock.FieldWaitStart:
		return m.OldWaitStart(ctx)
	case mininggoodstock.FieldSold:
		return m.OldSold(ctx)
	case mininggoodstock.FieldAppReserved:
		return m.OldAppReserved(ctx)
	case mininggoodstock.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown MiningGoodStock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MiningGoodStockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mininggoodstock.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case mininggoodstock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mininggoodstock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mininggoodstock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mininggoodstock.FieldGoodStockID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodStockID(v)
		return nil
	case mininggoodstock.FieldPoolRootUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolRootUserID(v)
		return nil
	case mininggoodstock.FieldPoolGoodUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolGoodUserID(v)
		return nil
	case mininggoodstock.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case mininggoodstock.FieldSpotQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotQuantity(v)
		return nil
	case mininggoodstock.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case mininggoodstock.FieldInService:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInService(v)
		return nil
	case mininggoodstock.FieldWaitStart:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaitStart(v)
		return nil
	case mininggoodstock.FieldSold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	case mininggoodstock.FieldAppReserved:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppReserved(v)
		return nil
	case mininggoodstock.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown MiningGoodStock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MiningGoodStockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, mininggoodstock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, mininggoodstock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, mininggoodstock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MiningGoodStockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mininggoodstock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case mininggoodstock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case mininggoodstock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MiningGoodStockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mininggoodstock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case mininggoodstock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case mininggoodstock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MiningGoodStock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MiningGoodStockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mininggoodstock.FieldGoodStockID) {
		fields = append(fields, mininggoodstock.FieldGoodStockID)
	}
	if m.FieldCleared(mininggoodstock.FieldPoolRootUserID) {
		fields = append(fields, mininggoodstock.FieldPoolRootUserID)
	}
	if m.FieldCleared(mininggoodstock.FieldPoolGoodUserID) {
		fields = append(fields, mininggoodstock.FieldPoolGoodUserID)
	}
	if m.FieldCleared(mininggoodstock.FieldTotal) {
		fields = append(fields, mininggoodstock.FieldTotal)
	}
	if m.FieldCleared(mininggoodstock.FieldSpotQuantity) {
		fields = append(fields, mininggoodstock.FieldSpotQuantity)
	}
	if m.FieldCleared(mininggoodstock.FieldLocked) {
		fields = append(fields, mininggoodstock.FieldLocked)
	}
	if m.FieldCleared(mininggoodstock.FieldInService) {
		fields = append(fields, mininggoodstock.FieldInService)
	}
	if m.FieldCleared(mininggoodstock.FieldWaitStart) {
		fields = append(fields, mininggoodstock.FieldWaitStart)
	}
	if m.FieldCleared(mininggoodstock.FieldSold) {
		fields = append(fields, mininggoodstock.FieldSold)
	}
	if m.FieldCleared(mininggoodstock.FieldAppReserved) {
		fields = append(fields, mininggoodstock.FieldAppReserved)
	}
	if m.FieldCleared(mininggoodstock.FieldState) {
		fields = append(fields, mininggoodstock.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MiningGoodStockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MiningGoodStockMutation) ClearField(name string) error {
	switch name {
	case mininggoodstock.FieldGoodStockID:
		m.ClearGoodStockID()
		return nil
	case mininggoodstock.FieldPoolRootUserID:
		m.ClearPoolRootUserID()
		return nil
	case mininggoodstock.FieldPoolGoodUserID:
		m.ClearPoolGoodUserID()
		return nil
	case mininggoodstock.FieldTotal:
		m.ClearTotal()
		return nil
	case mininggoodstock.FieldSpotQuantity:
		m.ClearSpotQuantity()
		return nil
	case mininggoodstock.FieldLocked:
		m.ClearLocked()
		return nil
	case mininggoodstock.FieldInService:
		m.ClearInService()
		return nil
	case mininggoodstock.FieldWaitStart:
		m.ClearWaitStart()
		return nil
	case mininggoodstock.FieldSold:
		m.ClearSold()
		return nil
	case mininggoodstock.FieldAppReserved:
		m.ClearAppReserved()
		return nil
	case mininggoodstock.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown MiningGoodStock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MiningGoodStockMutation) ResetField(name string) error {
	switch name {
	case mininggoodstock.FieldEntID:
		m.ResetEntID()
		return nil
	case mininggoodstock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mininggoodstock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mininggoodstock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mininggoodstock.FieldGoodStockID:
		m.ResetGoodStockID()
		return nil
	case mininggoodstock.FieldPoolRootUserID:
		m.ResetPoolRootUserID()
		return nil
	case mininggoodstock.FieldPoolGoodUserID:
		m.ResetPoolGoodUserID()
		return nil
	case mininggoodstock.FieldTotal:
		m.ResetTotal()
		return nil
	case mininggoodstock.FieldSpotQuantity:
		m.ResetSpotQuantity()
		return nil
	case mininggoodstock.FieldLocked:
		m.ResetLocked()
		return nil
	case mininggoodstock.FieldInService:
		m.ResetInService()
		return nil
	case mininggoodstock.FieldWaitStart:
		m.ResetWaitStart()
		return nil
	case mininggoodstock.FieldSold:
		m.ResetSold()
		return nil
	case mininggoodstock.FieldAppReserved:
		m.ResetAppReserved()
		return nil
	case mininggoodstock.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown MiningGoodStock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MiningGoodStockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MiningGoodStockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MiningGoodStockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MiningGoodStockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MiningGoodStockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MiningGoodStockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MiningGoodStockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MiningGoodStock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MiningGoodStockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MiningGoodStock edge %s", name)
}

// PowerRentalMutation represents an operation that mutates the PowerRental nodes in the graph.
type PowerRentalMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	ent_id                *uuid.UUID
	created_at            *uint32
	addcreated_at         *int32
	updated_at            *uint32
	addupdated_at         *int32
	deleted_at            *uint32
	adddeleted_at         *int32
	good_id               *uuid.UUID
	device_type_id        *uuid.UUID
	vendor_location_id    *uuid.UUID
	unit_price            *decimal.Decimal
	quantity_unit         *string
	quantity_unit_amount  *decimal.Decimal
	delivery_at           *uint32
	adddelivery_at        *int32
	unit_lock_deposit     *decimal.Decimal
	duration_display_type *string
	stock_mode            *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*PowerRental, error)
	predicates            []predicate.PowerRental
}

var _ ent.Mutation = (*PowerRentalMutation)(nil)

// powerrentalOption allows management of the mutation configuration using functional options.
type powerrentalOption func(*PowerRentalMutation)

// newPowerRentalMutation creates new mutation for the PowerRental entity.
func newPowerRentalMutation(c config, op Op, opts ...powerrentalOption) *PowerRentalMutation {
	m := &PowerRentalMutation{
		config:        c,
		op:            op,
		typ:           TypePowerRental,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPowerRentalID sets the ID field of the mutation.
func withPowerRentalID(id uint32) powerrentalOption {
	return func(m *PowerRentalMutation) {
		var (
			err   error
			once  sync.Once
			value *PowerRental
		)
		m.oldValue = func(ctx context.Context) (*PowerRental, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PowerRental.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPowerRental sets the old PowerRental of the mutation.
func withPowerRental(node *PowerRental) powerrentalOption {
	return func(m *PowerRentalMutation) {
		m.oldValue = func(context.Context) (*PowerRental, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PowerRentalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PowerRentalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PowerRental entities.
func (m *PowerRentalMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PowerRentalMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PowerRentalMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PowerRental.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *PowerRentalMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *PowerRentalMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *PowerRentalMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PowerRentalMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PowerRentalMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *PowerRentalMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PowerRentalMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PowerRentalMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PowerRentalMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PowerRentalMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *PowerRentalMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PowerRentalMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PowerRentalMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PowerRentalMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PowerRentalMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *PowerRentalMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PowerRentalMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PowerRentalMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *PowerRentalMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *PowerRentalMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *PowerRentalMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[powerrental.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *PowerRentalMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *PowerRentalMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, powerrental.FieldGoodID)
}

// SetDeviceTypeID sets the "device_type_id" field.
func (m *PowerRentalMutation) SetDeviceTypeID(u uuid.UUID) {
	m.device_type_id = &u
}

// DeviceTypeID returns the value of the "device_type_id" field in the mutation.
func (m *PowerRentalMutation) DeviceTypeID() (r uuid.UUID, exists bool) {
	v := m.device_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceTypeID returns the old "device_type_id" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldDeviceTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceTypeID: %w", err)
	}
	return oldValue.DeviceTypeID, nil
}

// ClearDeviceTypeID clears the value of the "device_type_id" field.
func (m *PowerRentalMutation) ClearDeviceTypeID() {
	m.device_type_id = nil
	m.clearedFields[powerrental.FieldDeviceTypeID] = struct{}{}
}

// DeviceTypeIDCleared returns if the "device_type_id" field was cleared in this mutation.
func (m *PowerRentalMutation) DeviceTypeIDCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldDeviceTypeID]
	return ok
}

// ResetDeviceTypeID resets all changes to the "device_type_id" field.
func (m *PowerRentalMutation) ResetDeviceTypeID() {
	m.device_type_id = nil
	delete(m.clearedFields, powerrental.FieldDeviceTypeID)
}

// SetVendorLocationID sets the "vendor_location_id" field.
func (m *PowerRentalMutation) SetVendorLocationID(u uuid.UUID) {
	m.vendor_location_id = &u
}

// VendorLocationID returns the value of the "vendor_location_id" field in the mutation.
func (m *PowerRentalMutation) VendorLocationID() (r uuid.UUID, exists bool) {
	v := m.vendor_location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorLocationID returns the old "vendor_location_id" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldVendorLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorLocationID: %w", err)
	}
	return oldValue.VendorLocationID, nil
}

// ClearVendorLocationID clears the value of the "vendor_location_id" field.
func (m *PowerRentalMutation) ClearVendorLocationID() {
	m.vendor_location_id = nil
	m.clearedFields[powerrental.FieldVendorLocationID] = struct{}{}
}

// VendorLocationIDCleared returns if the "vendor_location_id" field was cleared in this mutation.
func (m *PowerRentalMutation) VendorLocationIDCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldVendorLocationID]
	return ok
}

// ResetVendorLocationID resets all changes to the "vendor_location_id" field.
func (m *PowerRentalMutation) ResetVendorLocationID() {
	m.vendor_location_id = nil
	delete(m.clearedFields, powerrental.FieldVendorLocationID)
}

// SetUnitPrice sets the "unit_price" field.
func (m *PowerRentalMutation) SetUnitPrice(d decimal.Decimal) {
	m.unit_price = &d
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *PowerRentalMutation) UnitPrice() (r decimal.Decimal, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldUnitPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// ClearUnitPrice clears the value of the "unit_price" field.
func (m *PowerRentalMutation) ClearUnitPrice() {
	m.unit_price = nil
	m.clearedFields[powerrental.FieldUnitPrice] = struct{}{}
}

// UnitPriceCleared returns if the "unit_price" field was cleared in this mutation.
func (m *PowerRentalMutation) UnitPriceCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldUnitPrice]
	return ok
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *PowerRentalMutation) ResetUnitPrice() {
	m.unit_price = nil
	delete(m.clearedFields, powerrental.FieldUnitPrice)
}

// SetQuantityUnit sets the "quantity_unit" field.
func (m *PowerRentalMutation) SetQuantityUnit(s string) {
	m.quantity_unit = &s
}

// QuantityUnit returns the value of the "quantity_unit" field in the mutation.
func (m *PowerRentalMutation) QuantityUnit() (r string, exists bool) {
	v := m.quantity_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityUnit returns the old "quantity_unit" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldQuantityUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantityUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantityUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityUnit: %w", err)
	}
	return oldValue.QuantityUnit, nil
}

// ClearQuantityUnit clears the value of the "quantity_unit" field.
func (m *PowerRentalMutation) ClearQuantityUnit() {
	m.quantity_unit = nil
	m.clearedFields[powerrental.FieldQuantityUnit] = struct{}{}
}

// QuantityUnitCleared returns if the "quantity_unit" field was cleared in this mutation.
func (m *PowerRentalMutation) QuantityUnitCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldQuantityUnit]
	return ok
}

// ResetQuantityUnit resets all changes to the "quantity_unit" field.
func (m *PowerRentalMutation) ResetQuantityUnit() {
	m.quantity_unit = nil
	delete(m.clearedFields, powerrental.FieldQuantityUnit)
}

// SetQuantityUnitAmount sets the "quantity_unit_amount" field.
func (m *PowerRentalMutation) SetQuantityUnitAmount(d decimal.Decimal) {
	m.quantity_unit_amount = &d
}

// QuantityUnitAmount returns the value of the "quantity_unit_amount" field in the mutation.
func (m *PowerRentalMutation) QuantityUnitAmount() (r decimal.Decimal, exists bool) {
	v := m.quantity_unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityUnitAmount returns the old "quantity_unit_amount" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldQuantityUnitAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantityUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantityUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityUnitAmount: %w", err)
	}
	return oldValue.QuantityUnitAmount, nil
}

// ClearQuantityUnitAmount clears the value of the "quantity_unit_amount" field.
func (m *PowerRentalMutation) ClearQuantityUnitAmount() {
	m.quantity_unit_amount = nil
	m.clearedFields[powerrental.FieldQuantityUnitAmount] = struct{}{}
}

// QuantityUnitAmountCleared returns if the "quantity_unit_amount" field was cleared in this mutation.
func (m *PowerRentalMutation) QuantityUnitAmountCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldQuantityUnitAmount]
	return ok
}

// ResetQuantityUnitAmount resets all changes to the "quantity_unit_amount" field.
func (m *PowerRentalMutation) ResetQuantityUnitAmount() {
	m.quantity_unit_amount = nil
	delete(m.clearedFields, powerrental.FieldQuantityUnitAmount)
}

// SetDeliveryAt sets the "delivery_at" field.
func (m *PowerRentalMutation) SetDeliveryAt(u uint32) {
	m.delivery_at = &u
	m.adddelivery_at = nil
}

// DeliveryAt returns the value of the "delivery_at" field in the mutation.
func (m *PowerRentalMutation) DeliveryAt() (r uint32, exists bool) {
	v := m.delivery_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAt returns the old "delivery_at" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldDeliveryAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAt: %w", err)
	}
	return oldValue.DeliveryAt, nil
}

// AddDeliveryAt adds u to the "delivery_at" field.
func (m *PowerRentalMutation) AddDeliveryAt(u int32) {
	if m.adddelivery_at != nil {
		*m.adddelivery_at += u
	} else {
		m.adddelivery_at = &u
	}
}

// AddedDeliveryAt returns the value that was added to the "delivery_at" field in this mutation.
func (m *PowerRentalMutation) AddedDeliveryAt() (r int32, exists bool) {
	v := m.adddelivery_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryAt clears the value of the "delivery_at" field.
func (m *PowerRentalMutation) ClearDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	m.clearedFields[powerrental.FieldDeliveryAt] = struct{}{}
}

// DeliveryAtCleared returns if the "delivery_at" field was cleared in this mutation.
func (m *PowerRentalMutation) DeliveryAtCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldDeliveryAt]
	return ok
}

// ResetDeliveryAt resets all changes to the "delivery_at" field.
func (m *PowerRentalMutation) ResetDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	delete(m.clearedFields, powerrental.FieldDeliveryAt)
}

// SetUnitLockDeposit sets the "unit_lock_deposit" field.
func (m *PowerRentalMutation) SetUnitLockDeposit(d decimal.Decimal) {
	m.unit_lock_deposit = &d
}

// UnitLockDeposit returns the value of the "unit_lock_deposit" field in the mutation.
func (m *PowerRentalMutation) UnitLockDeposit() (r decimal.Decimal, exists bool) {
	v := m.unit_lock_deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitLockDeposit returns the old "unit_lock_deposit" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldUnitLockDeposit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitLockDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitLockDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitLockDeposit: %w", err)
	}
	return oldValue.UnitLockDeposit, nil
}

// ClearUnitLockDeposit clears the value of the "unit_lock_deposit" field.
func (m *PowerRentalMutation) ClearUnitLockDeposit() {
	m.unit_lock_deposit = nil
	m.clearedFields[powerrental.FieldUnitLockDeposit] = struct{}{}
}

// UnitLockDepositCleared returns if the "unit_lock_deposit" field was cleared in this mutation.
func (m *PowerRentalMutation) UnitLockDepositCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldUnitLockDeposit]
	return ok
}

// ResetUnitLockDeposit resets all changes to the "unit_lock_deposit" field.
func (m *PowerRentalMutation) ResetUnitLockDeposit() {
	m.unit_lock_deposit = nil
	delete(m.clearedFields, powerrental.FieldUnitLockDeposit)
}

// SetDurationDisplayType sets the "duration_display_type" field.
func (m *PowerRentalMutation) SetDurationDisplayType(s string) {
	m.duration_display_type = &s
}

// DurationDisplayType returns the value of the "duration_display_type" field in the mutation.
func (m *PowerRentalMutation) DurationDisplayType() (r string, exists bool) {
	v := m.duration_display_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDisplayType returns the old "duration_display_type" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldDurationDisplayType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDisplayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDisplayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDisplayType: %w", err)
	}
	return oldValue.DurationDisplayType, nil
}

// ClearDurationDisplayType clears the value of the "duration_display_type" field.
func (m *PowerRentalMutation) ClearDurationDisplayType() {
	m.duration_display_type = nil
	m.clearedFields[powerrental.FieldDurationDisplayType] = struct{}{}
}

// DurationDisplayTypeCleared returns if the "duration_display_type" field was cleared in this mutation.
func (m *PowerRentalMutation) DurationDisplayTypeCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldDurationDisplayType]
	return ok
}

// ResetDurationDisplayType resets all changes to the "duration_display_type" field.
func (m *PowerRentalMutation) ResetDurationDisplayType() {
	m.duration_display_type = nil
	delete(m.clearedFields, powerrental.FieldDurationDisplayType)
}

// SetStockMode sets the "stock_mode" field.
func (m *PowerRentalMutation) SetStockMode(s string) {
	m.stock_mode = &s
}

// StockMode returns the value of the "stock_mode" field in the mutation.
func (m *PowerRentalMutation) StockMode() (r string, exists bool) {
	v := m.stock_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStockMode returns the old "stock_mode" field's value of the PowerRental entity.
// If the PowerRental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PowerRentalMutation) OldStockMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockMode: %w", err)
	}
	return oldValue.StockMode, nil
}

// ClearStockMode clears the value of the "stock_mode" field.
func (m *PowerRentalMutation) ClearStockMode() {
	m.stock_mode = nil
	m.clearedFields[powerrental.FieldStockMode] = struct{}{}
}

// StockModeCleared returns if the "stock_mode" field was cleared in this mutation.
func (m *PowerRentalMutation) StockModeCleared() bool {
	_, ok := m.clearedFields[powerrental.FieldStockMode]
	return ok
}

// ResetStockMode resets all changes to the "stock_mode" field.
func (m *PowerRentalMutation) ResetStockMode() {
	m.stock_mode = nil
	delete(m.clearedFields, powerrental.FieldStockMode)
}

// Where appends a list predicates to the PowerRentalMutation builder.
func (m *PowerRentalMutation) Where(ps ...predicate.PowerRental) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PowerRentalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PowerRentalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PowerRental, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PowerRentalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PowerRentalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PowerRental).
func (m *PowerRentalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PowerRentalMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.ent_id != nil {
		fields = append(fields, powerrental.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, powerrental.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, powerrental.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, powerrental.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, powerrental.FieldGoodID)
	}
	if m.device_type_id != nil {
		fields = append(fields, powerrental.FieldDeviceTypeID)
	}
	if m.vendor_location_id != nil {
		fields = append(fields, powerrental.FieldVendorLocationID)
	}
	if m.unit_price != nil {
		fields = append(fields, powerrental.FieldUnitPrice)
	}
	if m.quantity_unit != nil {
		fields = append(fields, powerrental.FieldQuantityUnit)
	}
	if m.quantity_unit_amount != nil {
		fields = append(fields, powerrental.FieldQuantityUnitAmount)
	}
	if m.delivery_at != nil {
		fields = append(fields, powerrental.FieldDeliveryAt)
	}
	if m.unit_lock_deposit != nil {
		fields = append(fields, powerrental.FieldUnitLockDeposit)
	}
	if m.duration_display_type != nil {
		fields = append(fields, powerrental.FieldDurationDisplayType)
	}
	if m.stock_mode != nil {
		fields = append(fields, powerrental.FieldStockMode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PowerRentalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case powerrental.FieldEntID:
		return m.EntID()
	case powerrental.FieldCreatedAt:
		return m.CreatedAt()
	case powerrental.FieldUpdatedAt:
		return m.UpdatedAt()
	case powerrental.FieldDeletedAt:
		return m.DeletedAt()
	case powerrental.FieldGoodID:
		return m.GoodID()
	case powerrental.FieldDeviceTypeID:
		return m.DeviceTypeID()
	case powerrental.FieldVendorLocationID:
		return m.VendorLocationID()
	case powerrental.FieldUnitPrice:
		return m.UnitPrice()
	case powerrental.FieldQuantityUnit:
		return m.QuantityUnit()
	case powerrental.FieldQuantityUnitAmount:
		return m.QuantityUnitAmount()
	case powerrental.FieldDeliveryAt:
		return m.DeliveryAt()
	case powerrental.FieldUnitLockDeposit:
		return m.UnitLockDeposit()
	case powerrental.FieldDurationDisplayType:
		return m.DurationDisplayType()
	case powerrental.FieldStockMode:
		return m.StockMode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PowerRentalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case powerrental.FieldEntID:
		return m.OldEntID(ctx)
	case powerrental.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case powerrental.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case powerrental.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case powerrental.FieldGoodID:
		return m.OldGoodID(ctx)
	case powerrental.FieldDeviceTypeID:
		return m.OldDeviceTypeID(ctx)
	case powerrental.FieldVendorLocationID:
		return m.OldVendorLocationID(ctx)
	case powerrental.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case powerrental.FieldQuantityUnit:
		return m.OldQuantityUnit(ctx)
	case powerrental.FieldQuantityUnitAmount:
		return m.OldQuantityUnitAmount(ctx)
	case powerrental.FieldDeliveryAt:
		return m.OldDeliveryAt(ctx)
	case powerrental.FieldUnitLockDeposit:
		return m.OldUnitLockDeposit(ctx)
	case powerrental.FieldDurationDisplayType:
		return m.OldDurationDisplayType(ctx)
	case powerrental.FieldStockMode:
		return m.OldStockMode(ctx)
	}
	return nil, fmt.Errorf("unknown PowerRental field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PowerRentalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case powerrental.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case powerrental.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case powerrental.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case powerrental.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case powerrental.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case powerrental.FieldDeviceTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceTypeID(v)
		return nil
	case powerrental.FieldVendorLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorLocationID(v)
		return nil
	case powerrental.FieldUnitPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case powerrental.FieldQuantityUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityUnit(v)
		return nil
	case powerrental.FieldQuantityUnitAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityUnitAmount(v)
		return nil
	case powerrental.FieldDeliveryAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAt(v)
		return nil
	case powerrental.FieldUnitLockDeposit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitLockDeposit(v)
		return nil
	case powerrental.FieldDurationDisplayType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDisplayType(v)
		return nil
	case powerrental.FieldStockMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockMode(v)
		return nil
	}
	return fmt.Errorf("unknown PowerRental field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PowerRentalMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, powerrental.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, powerrental.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, powerrental.FieldDeletedAt)
	}
	if m.adddelivery_at != nil {
		fields = append(fields, powerrental.FieldDeliveryAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PowerRentalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case powerrental.FieldCreatedAt:
		return m.AddedCreatedAt()
	case powerrental.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case powerrental.FieldDeletedAt:
		return m.AddedDeletedAt()
	case powerrental.FieldDeliveryAt:
		return m.AddedDeliveryAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PowerRentalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case powerrental.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case powerrental.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case powerrental.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case powerrental.FieldDeliveryAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryAt(v)
		return nil
	}
	return fmt.Errorf("unknown PowerRental numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PowerRentalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(powerrental.FieldGoodID) {
		fields = append(fields, powerrental.FieldGoodID)
	}
	if m.FieldCleared(powerrental.FieldDeviceTypeID) {
		fields = append(fields, powerrental.FieldDeviceTypeID)
	}
	if m.FieldCleared(powerrental.FieldVendorLocationID) {
		fields = append(fields, powerrental.FieldVendorLocationID)
	}
	if m.FieldCleared(powerrental.FieldUnitPrice) {
		fields = append(fields, powerrental.FieldUnitPrice)
	}
	if m.FieldCleared(powerrental.FieldQuantityUnit) {
		fields = append(fields, powerrental.FieldQuantityUnit)
	}
	if m.FieldCleared(powerrental.FieldQuantityUnitAmount) {
		fields = append(fields, powerrental.FieldQuantityUnitAmount)
	}
	if m.FieldCleared(powerrental.FieldDeliveryAt) {
		fields = append(fields, powerrental.FieldDeliveryAt)
	}
	if m.FieldCleared(powerrental.FieldUnitLockDeposit) {
		fields = append(fields, powerrental.FieldUnitLockDeposit)
	}
	if m.FieldCleared(powerrental.FieldDurationDisplayType) {
		fields = append(fields, powerrental.FieldDurationDisplayType)
	}
	if m.FieldCleared(powerrental.FieldStockMode) {
		fields = append(fields, powerrental.FieldStockMode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PowerRentalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PowerRentalMutation) ClearField(name string) error {
	switch name {
	case powerrental.FieldGoodID:
		m.ClearGoodID()
		return nil
	case powerrental.FieldDeviceTypeID:
		m.ClearDeviceTypeID()
		return nil
	case powerrental.FieldVendorLocationID:
		m.ClearVendorLocationID()
		return nil
	case powerrental.FieldUnitPrice:
		m.ClearUnitPrice()
		return nil
	case powerrental.FieldQuantityUnit:
		m.ClearQuantityUnit()
		return nil
	case powerrental.FieldQuantityUnitAmount:
		m.ClearQuantityUnitAmount()
		return nil
	case powerrental.FieldDeliveryAt:
		m.ClearDeliveryAt()
		return nil
	case powerrental.FieldUnitLockDeposit:
		m.ClearUnitLockDeposit()
		return nil
	case powerrental.FieldDurationDisplayType:
		m.ClearDurationDisplayType()
		return nil
	case powerrental.FieldStockMode:
		m.ClearStockMode()
		return nil
	}
	return fmt.Errorf("unknown PowerRental nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PowerRentalMutation) ResetField(name string) error {
	switch name {
	case powerrental.FieldEntID:
		m.ResetEntID()
		return nil
	case powerrental.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case powerrental.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case powerrental.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case powerrental.FieldGoodID:
		m.ResetGoodID()
		return nil
	case powerrental.FieldDeviceTypeID:
		m.ResetDeviceTypeID()
		return nil
	case powerrental.FieldVendorLocationID:
		m.ResetVendorLocationID()
		return nil
	case powerrental.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case powerrental.FieldQuantityUnit:
		m.ResetQuantityUnit()
		return nil
	case powerrental.FieldQuantityUnitAmount:
		m.ResetQuantityUnitAmount()
		return nil
	case powerrental.FieldDeliveryAt:
		m.ResetDeliveryAt()
		return nil
	case powerrental.FieldUnitLockDeposit:
		m.ResetUnitLockDeposit()
		return nil
	case powerrental.FieldDurationDisplayType:
		m.ResetDurationDisplayType()
		return nil
	case powerrental.FieldStockMode:
		m.ResetStockMode()
		return nil
	}
	return fmt.Errorf("unknown PowerRental field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PowerRentalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PowerRentalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PowerRentalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PowerRentalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PowerRentalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PowerRentalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PowerRentalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PowerRental unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PowerRentalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PowerRental edge %s", name)
}

// RecommendMutation represents an operation that mutates the Recommend nodes in the graph.
type RecommendMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	ent_id          *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	app_good_id     *uuid.UUID
	recommender_id  *uuid.UUID
	message         *string
	recommend_index *decimal.Decimal
	hide            *bool
	hide_reason     *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Recommend, error)
	predicates      []predicate.Recommend
}

var _ ent.Mutation = (*RecommendMutation)(nil)

// recommendOption allows management of the mutation configuration using functional options.
type recommendOption func(*RecommendMutation)

// newRecommendMutation creates new mutation for the Recommend entity.
func newRecommendMutation(c config, op Op, opts ...recommendOption) *RecommendMutation {
	m := &RecommendMutation{
		config:        c,
		op:            op,
		typ:           TypeRecommend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecommendID sets the ID field of the mutation.
func withRecommendID(id uint32) recommendOption {
	return func(m *RecommendMutation) {
		var (
			err   error
			once  sync.Once
			value *Recommend
		)
		m.oldValue = func(ctx context.Context) (*Recommend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recommend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecommend sets the old Recommend of the mutation.
func withRecommend(node *Recommend) recommendOption {
	return func(m *RecommendMutation) {
		m.oldValue = func(context.Context) (*Recommend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecommendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecommendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Recommend entities.
func (m *RecommendMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecommendMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecommendMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Recommend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *RecommendMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *RecommendMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *RecommendMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RecommendMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecommendMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RecommendMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RecommendMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecommendMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecommendMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecommendMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RecommendMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RecommendMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecommendMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RecommendMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RecommendMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RecommendMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RecommendMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RecommendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *RecommendMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *RecommendMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *RecommendMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[recommend.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *RecommendMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[recommend.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *RecommendMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, recommend.FieldAppGoodID)
}

// SetRecommenderID sets the "recommender_id" field.
func (m *RecommendMutation) SetRecommenderID(u uuid.UUID) {
	m.recommender_id = &u
}

// RecommenderID returns the value of the "recommender_id" field in the mutation.
func (m *RecommendMutation) RecommenderID() (r uuid.UUID, exists bool) {
	v := m.recommender_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommenderID returns the old "recommender_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldRecommenderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommenderID: %w", err)
	}
	return oldValue.RecommenderID, nil
}

// ClearRecommenderID clears the value of the "recommender_id" field.
func (m *RecommendMutation) ClearRecommenderID() {
	m.recommender_id = nil
	m.clearedFields[recommend.FieldRecommenderID] = struct{}{}
}

// RecommenderIDCleared returns if the "recommender_id" field was cleared in this mutation.
func (m *RecommendMutation) RecommenderIDCleared() bool {
	_, ok := m.clearedFields[recommend.FieldRecommenderID]
	return ok
}

// ResetRecommenderID resets all changes to the "recommender_id" field.
func (m *RecommendMutation) ResetRecommenderID() {
	m.recommender_id = nil
	delete(m.clearedFields, recommend.FieldRecommenderID)
}

// SetMessage sets the "message" field.
func (m *RecommendMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *RecommendMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *RecommendMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[recommend.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *RecommendMutation) MessageCleared() bool {
	_, ok := m.clearedFields[recommend.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *RecommendMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, recommend.FieldMessage)
}

// SetRecommendIndex sets the "recommend_index" field.
func (m *RecommendMutation) SetRecommendIndex(d decimal.Decimal) {
	m.recommend_index = &d
}

// RecommendIndex returns the value of the "recommend_index" field in the mutation.
func (m *RecommendMutation) RecommendIndex() (r decimal.Decimal, exists bool) {
	v := m.recommend_index
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendIndex returns the old "recommend_index" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldRecommendIndex(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendIndex: %w", err)
	}
	return oldValue.RecommendIndex, nil
}

// ClearRecommendIndex clears the value of the "recommend_index" field.
func (m *RecommendMutation) ClearRecommendIndex() {
	m.recommend_index = nil
	m.clearedFields[recommend.FieldRecommendIndex] = struct{}{}
}

// RecommendIndexCleared returns if the "recommend_index" field was cleared in this mutation.
func (m *RecommendMutation) RecommendIndexCleared() bool {
	_, ok := m.clearedFields[recommend.FieldRecommendIndex]
	return ok
}

// ResetRecommendIndex resets all changes to the "recommend_index" field.
func (m *RecommendMutation) ResetRecommendIndex() {
	m.recommend_index = nil
	delete(m.clearedFields, recommend.FieldRecommendIndex)
}

// SetHide sets the "hide" field.
func (m *RecommendMutation) SetHide(b bool) {
	m.hide = &b
}

// Hide returns the value of the "hide" field in the mutation.
func (m *RecommendMutation) Hide() (r bool, exists bool) {
	v := m.hide
	if v == nil {
		return
	}
	return *v, true
}

// OldHide returns the old "hide" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldHide(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHide: %w", err)
	}
	return oldValue.Hide, nil
}

// ClearHide clears the value of the "hide" field.
func (m *RecommendMutation) ClearHide() {
	m.hide = nil
	m.clearedFields[recommend.FieldHide] = struct{}{}
}

// HideCleared returns if the "hide" field was cleared in this mutation.
func (m *RecommendMutation) HideCleared() bool {
	_, ok := m.clearedFields[recommend.FieldHide]
	return ok
}

// ResetHide resets all changes to the "hide" field.
func (m *RecommendMutation) ResetHide() {
	m.hide = nil
	delete(m.clearedFields, recommend.FieldHide)
}

// SetHideReason sets the "hide_reason" field.
func (m *RecommendMutation) SetHideReason(s string) {
	m.hide_reason = &s
}

// HideReason returns the value of the "hide_reason" field in the mutation.
func (m *RecommendMutation) HideReason() (r string, exists bool) {
	v := m.hide_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldHideReason returns the old "hide_reason" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldHideReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideReason: %w", err)
	}
	return oldValue.HideReason, nil
}

// ClearHideReason clears the value of the "hide_reason" field.
func (m *RecommendMutation) ClearHideReason() {
	m.hide_reason = nil
	m.clearedFields[recommend.FieldHideReason] = struct{}{}
}

// HideReasonCleared returns if the "hide_reason" field was cleared in this mutation.
func (m *RecommendMutation) HideReasonCleared() bool {
	_, ok := m.clearedFields[recommend.FieldHideReason]
	return ok
}

// ResetHideReason resets all changes to the "hide_reason" field.
func (m *RecommendMutation) ResetHideReason() {
	m.hide_reason = nil
	delete(m.clearedFields, recommend.FieldHideReason)
}

// Where appends a list predicates to the RecommendMutation builder.
func (m *RecommendMutation) Where(ps ...predicate.Recommend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecommendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecommendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Recommend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecommendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecommendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Recommend).
func (m *RecommendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecommendMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ent_id != nil {
		fields = append(fields, recommend.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, recommend.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recommend.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, recommend.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, recommend.FieldAppGoodID)
	}
	if m.recommender_id != nil {
		fields = append(fields, recommend.FieldRecommenderID)
	}
	if m.message != nil {
		fields = append(fields, recommend.FieldMessage)
	}
	if m.recommend_index != nil {
		fields = append(fields, recommend.FieldRecommendIndex)
	}
	if m.hide != nil {
		fields = append(fields, recommend.FieldHide)
	}
	if m.hide_reason != nil {
		fields = append(fields, recommend.FieldHideReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecommendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recommend.FieldEntID:
		return m.EntID()
	case recommend.FieldCreatedAt:
		return m.CreatedAt()
	case recommend.FieldUpdatedAt:
		return m.UpdatedAt()
	case recommend.FieldDeletedAt:
		return m.DeletedAt()
	case recommend.FieldAppGoodID:
		return m.AppGoodID()
	case recommend.FieldRecommenderID:
		return m.RecommenderID()
	case recommend.FieldMessage:
		return m.Message()
	case recommend.FieldRecommendIndex:
		return m.RecommendIndex()
	case recommend.FieldHide:
		return m.Hide()
	case recommend.FieldHideReason:
		return m.HideReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecommendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recommend.FieldEntID:
		return m.OldEntID(ctx)
	case recommend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recommend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recommend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case recommend.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case recommend.FieldRecommenderID:
		return m.OldRecommenderID(ctx)
	case recommend.FieldMessage:
		return m.OldMessage(ctx)
	case recommend.FieldRecommendIndex:
		return m.OldRecommendIndex(ctx)
	case recommend.FieldHide:
		return m.OldHide(ctx)
	case recommend.FieldHideReason:
		return m.OldHideReason(ctx)
	}
	return nil, fmt.Errorf("unknown Recommend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecommendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recommend.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case recommend.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recommend.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recommend.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case recommend.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case recommend.FieldRecommenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommenderID(v)
		return nil
	case recommend.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case recommend.FieldRecommendIndex:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendIndex(v)
		return nil
	case recommend.FieldHide:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHide(v)
		return nil
	case recommend.FieldHideReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideReason(v)
		return nil
	}
	return fmt.Errorf("unknown Recommend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecommendMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, recommend.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, recommend.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, recommend.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecommendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recommend.FieldCreatedAt:
		return m.AddedCreatedAt()
	case recommend.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case recommend.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecommendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recommend.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case recommend.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case recommend.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Recommend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecommendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recommend.FieldAppGoodID) {
		fields = append(fields, recommend.FieldAppGoodID)
	}
	if m.FieldCleared(recommend.FieldRecommenderID) {
		fields = append(fields, recommend.FieldRecommenderID)
	}
	if m.FieldCleared(recommend.FieldMessage) {
		fields = append(fields, recommend.FieldMessage)
	}
	if m.FieldCleared(recommend.FieldRecommendIndex) {
		fields = append(fields, recommend.FieldRecommendIndex)
	}
	if m.FieldCleared(recommend.FieldHide) {
		fields = append(fields, recommend.FieldHide)
	}
	if m.FieldCleared(recommend.FieldHideReason) {
		fields = append(fields, recommend.FieldHideReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecommendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecommendMutation) ClearField(name string) error {
	switch name {
	case recommend.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case recommend.FieldRecommenderID:
		m.ClearRecommenderID()
		return nil
	case recommend.FieldMessage:
		m.ClearMessage()
		return nil
	case recommend.FieldRecommendIndex:
		m.ClearRecommendIndex()
		return nil
	case recommend.FieldHide:
		m.ClearHide()
		return nil
	case recommend.FieldHideReason:
		m.ClearHideReason()
		return nil
	}
	return fmt.Errorf("unknown Recommend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecommendMutation) ResetField(name string) error {
	switch name {
	case recommend.FieldEntID:
		m.ResetEntID()
		return nil
	case recommend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recommend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recommend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case recommend.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case recommend.FieldRecommenderID:
		m.ResetRecommenderID()
		return nil
	case recommend.FieldMessage:
		m.ResetMessage()
		return nil
	case recommend.FieldRecommendIndex:
		m.ResetRecommendIndex()
		return nil
	case recommend.FieldHide:
		m.ResetHide()
		return nil
	case recommend.FieldHideReason:
		m.ResetHideReason()
		return nil
	}
	return fmt.Errorf("unknown Recommend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecommendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecommendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecommendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecommendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecommendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecommendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecommendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Recommend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecommendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Recommend edge %s", name)
}

// RequiredAppGoodMutation represents an operation that mutates the RequiredAppGood nodes in the graph.
type RequiredAppGoodMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	ent_id               *uuid.UUID
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	main_app_good_id     *uuid.UUID
	required_app_good_id *uuid.UUID
	must                 *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*RequiredAppGood, error)
	predicates           []predicate.RequiredAppGood
}

var _ ent.Mutation = (*RequiredAppGoodMutation)(nil)

// requiredappgoodOption allows management of the mutation configuration using functional options.
type requiredappgoodOption func(*RequiredAppGoodMutation)

// newRequiredAppGoodMutation creates new mutation for the RequiredAppGood entity.
func newRequiredAppGoodMutation(c config, op Op, opts ...requiredappgoodOption) *RequiredAppGoodMutation {
	m := &RequiredAppGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeRequiredAppGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequiredAppGoodID sets the ID field of the mutation.
func withRequiredAppGoodID(id uint32) requiredappgoodOption {
	return func(m *RequiredAppGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *RequiredAppGood
		)
		m.oldValue = func(ctx context.Context) (*RequiredAppGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequiredAppGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequiredAppGood sets the old RequiredAppGood of the mutation.
func withRequiredAppGood(node *RequiredAppGood) requiredappgoodOption {
	return func(m *RequiredAppGoodMutation) {
		m.oldValue = func(context.Context) (*RequiredAppGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequiredAppGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequiredAppGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RequiredAppGood entities.
func (m *RequiredAppGoodMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequiredAppGoodMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequiredAppGoodMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequiredAppGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *RequiredAppGoodMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *RequiredAppGoodMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the RequiredAppGood entity.
// If the RequiredAppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredAppGoodMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *RequiredAppGoodMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RequiredAppGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequiredAppGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RequiredAppGood entity.
// If the RequiredAppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredAppGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RequiredAppGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RequiredAppGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequiredAppGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequiredAppGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequiredAppGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RequiredAppGood entity.
// If the RequiredAppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredAppGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RequiredAppGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RequiredAppGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequiredAppGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RequiredAppGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RequiredAppGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RequiredAppGood entity.
// If the RequiredAppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredAppGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RequiredAppGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RequiredAppGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RequiredAppGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMainAppGoodID sets the "main_app_good_id" field.
func (m *RequiredAppGoodMutation) SetMainAppGoodID(u uuid.UUID) {
	m.main_app_good_id = &u
}

// MainAppGoodID returns the value of the "main_app_good_id" field in the mutation.
func (m *RequiredAppGoodMutation) MainAppGoodID() (r uuid.UUID, exists bool) {
	v := m.main_app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMainAppGoodID returns the old "main_app_good_id" field's value of the RequiredAppGood entity.
// If the RequiredAppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredAppGoodMutation) OldMainAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainAppGoodID: %w", err)
	}
	return oldValue.MainAppGoodID, nil
}

// ResetMainAppGoodID resets all changes to the "main_app_good_id" field.
func (m *RequiredAppGoodMutation) ResetMainAppGoodID() {
	m.main_app_good_id = nil
}

// SetRequiredAppGoodID sets the "required_app_good_id" field.
func (m *RequiredAppGoodMutation) SetRequiredAppGoodID(u uuid.UUID) {
	m.required_app_good_id = &u
}

// RequiredAppGoodID returns the value of the "required_app_good_id" field in the mutation.
func (m *RequiredAppGoodMutation) RequiredAppGoodID() (r uuid.UUID, exists bool) {
	v := m.required_app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredAppGoodID returns the old "required_app_good_id" field's value of the RequiredAppGood entity.
// If the RequiredAppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredAppGoodMutation) OldRequiredAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredAppGoodID: %w", err)
	}
	return oldValue.RequiredAppGoodID, nil
}

// ResetRequiredAppGoodID resets all changes to the "required_app_good_id" field.
func (m *RequiredAppGoodMutation) ResetRequiredAppGoodID() {
	m.required_app_good_id = nil
}

// SetMust sets the "must" field.
func (m *RequiredAppGoodMutation) SetMust(b bool) {
	m.must = &b
}

// Must returns the value of the "must" field in the mutation.
func (m *RequiredAppGoodMutation) Must() (r bool, exists bool) {
	v := m.must
	if v == nil {
		return
	}
	return *v, true
}

// OldMust returns the old "must" field's value of the RequiredAppGood entity.
// If the RequiredAppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredAppGoodMutation) OldMust(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMust: %w", err)
	}
	return oldValue.Must, nil
}

// ClearMust clears the value of the "must" field.
func (m *RequiredAppGoodMutation) ClearMust() {
	m.must = nil
	m.clearedFields[requiredappgood.FieldMust] = struct{}{}
}

// MustCleared returns if the "must" field was cleared in this mutation.
func (m *RequiredAppGoodMutation) MustCleared() bool {
	_, ok := m.clearedFields[requiredappgood.FieldMust]
	return ok
}

// ResetMust resets all changes to the "must" field.
func (m *RequiredAppGoodMutation) ResetMust() {
	m.must = nil
	delete(m.clearedFields, requiredappgood.FieldMust)
}

// Where appends a list predicates to the RequiredAppGoodMutation builder.
func (m *RequiredAppGoodMutation) Where(ps ...predicate.RequiredAppGood) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequiredAppGoodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequiredAppGoodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RequiredAppGood, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequiredAppGoodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequiredAppGoodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RequiredAppGood).
func (m *RequiredAppGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequiredAppGoodMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, requiredappgood.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, requiredappgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, requiredappgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, requiredappgood.FieldDeletedAt)
	}
	if m.main_app_good_id != nil {
		fields = append(fields, requiredappgood.FieldMainAppGoodID)
	}
	if m.required_app_good_id != nil {
		fields = append(fields, requiredappgood.FieldRequiredAppGoodID)
	}
	if m.must != nil {
		fields = append(fields, requiredappgood.FieldMust)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequiredAppGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requiredappgood.FieldEntID:
		return m.EntID()
	case requiredappgood.FieldCreatedAt:
		return m.CreatedAt()
	case requiredappgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case requiredappgood.FieldDeletedAt:
		return m.DeletedAt()
	case requiredappgood.FieldMainAppGoodID:
		return m.MainAppGoodID()
	case requiredappgood.FieldRequiredAppGoodID:
		return m.RequiredAppGoodID()
	case requiredappgood.FieldMust:
		return m.Must()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequiredAppGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requiredappgood.FieldEntID:
		return m.OldEntID(ctx)
	case requiredappgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case requiredappgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case requiredappgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case requiredappgood.FieldMainAppGoodID:
		return m.OldMainAppGoodID(ctx)
	case requiredappgood.FieldRequiredAppGoodID:
		return m.OldRequiredAppGoodID(ctx)
	case requiredappgood.FieldMust:
		return m.OldMust(ctx)
	}
	return nil, fmt.Errorf("unknown RequiredAppGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequiredAppGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requiredappgood.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case requiredappgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case requiredappgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case requiredappgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case requiredappgood.FieldMainAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainAppGoodID(v)
		return nil
	case requiredappgood.FieldRequiredAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredAppGoodID(v)
		return nil
	case requiredappgood.FieldMust:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMust(v)
		return nil
	}
	return fmt.Errorf("unknown RequiredAppGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequiredAppGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, requiredappgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, requiredappgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, requiredappgood.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequiredAppGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case requiredappgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case requiredappgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case requiredappgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequiredAppGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case requiredappgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case requiredappgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case requiredappgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RequiredAppGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequiredAppGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(requiredappgood.FieldMust) {
		fields = append(fields, requiredappgood.FieldMust)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequiredAppGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequiredAppGoodMutation) ClearField(name string) error {
	switch name {
	case requiredappgood.FieldMust:
		m.ClearMust()
		return nil
	}
	return fmt.Errorf("unknown RequiredAppGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequiredAppGoodMutation) ResetField(name string) error {
	switch name {
	case requiredappgood.FieldEntID:
		m.ResetEntID()
		return nil
	case requiredappgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case requiredappgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case requiredappgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case requiredappgood.FieldMainAppGoodID:
		m.ResetMainAppGoodID()
		return nil
	case requiredappgood.FieldRequiredAppGoodID:
		m.ResetRequiredAppGoodID()
		return nil
	case requiredappgood.FieldMust:
		m.ResetMust()
		return nil
	}
	return fmt.Errorf("unknown RequiredAppGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequiredAppGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequiredAppGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequiredAppGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequiredAppGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequiredAppGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequiredAppGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequiredAppGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RequiredAppGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequiredAppGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RequiredAppGood edge %s", name)
}

// RequiredGoodMutation represents an operation that mutates the RequiredGood nodes in the graph.
type RequiredGoodMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	ent_id           *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	main_good_id     *uuid.UUID
	required_good_id *uuid.UUID
	must             *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*RequiredGood, error)
	predicates       []predicate.RequiredGood
}

var _ ent.Mutation = (*RequiredGoodMutation)(nil)

// requiredgoodOption allows management of the mutation configuration using functional options.
type requiredgoodOption func(*RequiredGoodMutation)

// newRequiredGoodMutation creates new mutation for the RequiredGood entity.
func newRequiredGoodMutation(c config, op Op, opts ...requiredgoodOption) *RequiredGoodMutation {
	m := &RequiredGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeRequiredGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequiredGoodID sets the ID field of the mutation.
func withRequiredGoodID(id uint32) requiredgoodOption {
	return func(m *RequiredGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *RequiredGood
		)
		m.oldValue = func(ctx context.Context) (*RequiredGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequiredGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequiredGood sets the old RequiredGood of the mutation.
func withRequiredGood(node *RequiredGood) requiredgoodOption {
	return func(m *RequiredGoodMutation) {
		m.oldValue = func(context.Context) (*RequiredGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequiredGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequiredGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RequiredGood entities.
func (m *RequiredGoodMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequiredGoodMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequiredGoodMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequiredGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *RequiredGoodMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *RequiredGoodMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *RequiredGoodMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RequiredGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequiredGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RequiredGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RequiredGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequiredGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequiredGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequiredGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RequiredGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RequiredGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequiredGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RequiredGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RequiredGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RequiredGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RequiredGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RequiredGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMainGoodID sets the "main_good_id" field.
func (m *RequiredGoodMutation) SetMainGoodID(u uuid.UUID) {
	m.main_good_id = &u
}

// MainGoodID returns the value of the "main_good_id" field in the mutation.
func (m *RequiredGoodMutation) MainGoodID() (r uuid.UUID, exists bool) {
	v := m.main_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMainGoodID returns the old "main_good_id" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldMainGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainGoodID: %w", err)
	}
	return oldValue.MainGoodID, nil
}

// ResetMainGoodID resets all changes to the "main_good_id" field.
func (m *RequiredGoodMutation) ResetMainGoodID() {
	m.main_good_id = nil
}

// SetRequiredGoodID sets the "required_good_id" field.
func (m *RequiredGoodMutation) SetRequiredGoodID(u uuid.UUID) {
	m.required_good_id = &u
}

// RequiredGoodID returns the value of the "required_good_id" field in the mutation.
func (m *RequiredGoodMutation) RequiredGoodID() (r uuid.UUID, exists bool) {
	v := m.required_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredGoodID returns the old "required_good_id" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldRequiredGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredGoodID: %w", err)
	}
	return oldValue.RequiredGoodID, nil
}

// ResetRequiredGoodID resets all changes to the "required_good_id" field.
func (m *RequiredGoodMutation) ResetRequiredGoodID() {
	m.required_good_id = nil
}

// SetMust sets the "must" field.
func (m *RequiredGoodMutation) SetMust(b bool) {
	m.must = &b
}

// Must returns the value of the "must" field in the mutation.
func (m *RequiredGoodMutation) Must() (r bool, exists bool) {
	v := m.must
	if v == nil {
		return
	}
	return *v, true
}

// OldMust returns the old "must" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldMust(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMust: %w", err)
	}
	return oldValue.Must, nil
}

// ClearMust clears the value of the "must" field.
func (m *RequiredGoodMutation) ClearMust() {
	m.must = nil
	m.clearedFields[requiredgood.FieldMust] = struct{}{}
}

// MustCleared returns if the "must" field was cleared in this mutation.
func (m *RequiredGoodMutation) MustCleared() bool {
	_, ok := m.clearedFields[requiredgood.FieldMust]
	return ok
}

// ResetMust resets all changes to the "must" field.
func (m *RequiredGoodMutation) ResetMust() {
	m.must = nil
	delete(m.clearedFields, requiredgood.FieldMust)
}

// Where appends a list predicates to the RequiredGoodMutation builder.
func (m *RequiredGoodMutation) Where(ps ...predicate.RequiredGood) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequiredGoodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequiredGoodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RequiredGood, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequiredGoodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequiredGoodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RequiredGood).
func (m *RequiredGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequiredGoodMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, requiredgood.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, requiredgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, requiredgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, requiredgood.FieldDeletedAt)
	}
	if m.main_good_id != nil {
		fields = append(fields, requiredgood.FieldMainGoodID)
	}
	if m.required_good_id != nil {
		fields = append(fields, requiredgood.FieldRequiredGoodID)
	}
	if m.must != nil {
		fields = append(fields, requiredgood.FieldMust)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequiredGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requiredgood.FieldEntID:
		return m.EntID()
	case requiredgood.FieldCreatedAt:
		return m.CreatedAt()
	case requiredgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case requiredgood.FieldDeletedAt:
		return m.DeletedAt()
	case requiredgood.FieldMainGoodID:
		return m.MainGoodID()
	case requiredgood.FieldRequiredGoodID:
		return m.RequiredGoodID()
	case requiredgood.FieldMust:
		return m.Must()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequiredGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requiredgood.FieldEntID:
		return m.OldEntID(ctx)
	case requiredgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case requiredgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case requiredgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case requiredgood.FieldMainGoodID:
		return m.OldMainGoodID(ctx)
	case requiredgood.FieldRequiredGoodID:
		return m.OldRequiredGoodID(ctx)
	case requiredgood.FieldMust:
		return m.OldMust(ctx)
	}
	return nil, fmt.Errorf("unknown RequiredGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequiredGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requiredgood.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case requiredgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case requiredgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case requiredgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case requiredgood.FieldMainGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainGoodID(v)
		return nil
	case requiredgood.FieldRequiredGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredGoodID(v)
		return nil
	case requiredgood.FieldMust:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMust(v)
		return nil
	}
	return fmt.Errorf("unknown RequiredGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequiredGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, requiredgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, requiredgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, requiredgood.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequiredGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case requiredgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case requiredgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case requiredgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequiredGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case requiredgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case requiredgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case requiredgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RequiredGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequiredGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(requiredgood.FieldMust) {
		fields = append(fields, requiredgood.FieldMust)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequiredGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequiredGoodMutation) ClearField(name string) error {
	switch name {
	case requiredgood.FieldMust:
		m.ClearMust()
		return nil
	}
	return fmt.Errorf("unknown RequiredGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequiredGoodMutation) ResetField(name string) error {
	switch name {
	case requiredgood.FieldEntID:
		m.ResetEntID()
		return nil
	case requiredgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case requiredgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case requiredgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case requiredgood.FieldMainGoodID:
		m.ResetMainGoodID()
		return nil
	case requiredgood.FieldRequiredGoodID:
		m.ResetRequiredGoodID()
		return nil
	case requiredgood.FieldMust:
		m.ResetMust()
		return nil
	}
	return fmt.Errorf("unknown RequiredGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequiredGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequiredGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequiredGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequiredGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequiredGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequiredGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequiredGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RequiredGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequiredGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RequiredGood edge %s", name)
}

// ScoreMutation represents an operation that mutates the Score nodes in the graph.
type ScoreMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	user_id       *uuid.UUID
	app_good_id   *uuid.UUID
	score         *decimal.Decimal
	comment_id    *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Score, error)
	predicates    []predicate.Score
}

var _ ent.Mutation = (*ScoreMutation)(nil)

// scoreOption allows management of the mutation configuration using functional options.
type scoreOption func(*ScoreMutation)

// newScoreMutation creates new mutation for the Score entity.
func newScoreMutation(c config, op Op, opts ...scoreOption) *ScoreMutation {
	m := &ScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScoreID sets the ID field of the mutation.
func withScoreID(id uint32) scoreOption {
	return func(m *ScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Score
		)
		m.oldValue = func(ctx context.Context) (*Score, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Score.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScore sets the old Score of the mutation.
func withScore(node *Score) scoreOption {
	return func(m *ScoreMutation) {
		m.oldValue = func(context.Context) (*Score, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Score entities.
func (m *ScoreMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScoreMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScoreMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Score.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *ScoreMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *ScoreMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *ScoreMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ScoreMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScoreMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ScoreMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ScoreMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScoreMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScoreMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScoreMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ScoreMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ScoreMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScoreMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScoreMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ScoreMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ScoreMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScoreMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ScoreMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ScoreMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ScoreMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[score.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ScoreMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[score.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ScoreMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, score.FieldUserID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *ScoreMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *ScoreMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *ScoreMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[score.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *ScoreMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[score.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *ScoreMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, score.FieldAppGoodID)
}

// SetScore sets the "score" field.
func (m *ScoreMutation) SetScore(d decimal.Decimal) {
	m.score = &d
}

// Score returns the value of the "score" field in the mutation.
func (m *ScoreMutation) Score() (r decimal.Decimal, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldScore(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// ClearScore clears the value of the "score" field.
func (m *ScoreMutation) ClearScore() {
	m.score = nil
	m.clearedFields[score.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ScoreMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[score.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ScoreMutation) ResetScore() {
	m.score = nil
	delete(m.clearedFields, score.FieldScore)
}

// SetCommentID sets the "comment_id" field.
func (m *ScoreMutation) SetCommentID(u uuid.UUID) {
	m.comment_id = &u
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *ScoreMutation) CommentID() (r uuid.UUID, exists bool) {
	v := m.comment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentID returns the old "comment_id" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldCommentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentID: %w", err)
	}
	return oldValue.CommentID, nil
}

// ClearCommentID clears the value of the "comment_id" field.
func (m *ScoreMutation) ClearCommentID() {
	m.comment_id = nil
	m.clearedFields[score.FieldCommentID] = struct{}{}
}

// CommentIDCleared returns if the "comment_id" field was cleared in this mutation.
func (m *ScoreMutation) CommentIDCleared() bool {
	_, ok := m.clearedFields[score.FieldCommentID]
	return ok
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *ScoreMutation) ResetCommentID() {
	m.comment_id = nil
	delete(m.clearedFields, score.FieldCommentID)
}

// Where appends a list predicates to the ScoreMutation builder.
func (m *ScoreMutation) Where(ps ...predicate.Score) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Score, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Score).
func (m *ScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScoreMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, score.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, score.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, score.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, score.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, score.FieldUserID)
	}
	if m.app_good_id != nil {
		fields = append(fields, score.FieldAppGoodID)
	}
	if m.score != nil {
		fields = append(fields, score.FieldScore)
	}
	if m.comment_id != nil {
		fields = append(fields, score.FieldCommentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case score.FieldEntID:
		return m.EntID()
	case score.FieldCreatedAt:
		return m.CreatedAt()
	case score.FieldUpdatedAt:
		return m.UpdatedAt()
	case score.FieldDeletedAt:
		return m.DeletedAt()
	case score.FieldUserID:
		return m.UserID()
	case score.FieldAppGoodID:
		return m.AppGoodID()
	case score.FieldScore:
		return m.Score()
	case score.FieldCommentID:
		return m.CommentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case score.FieldEntID:
		return m.OldEntID(ctx)
	case score.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case score.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case score.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case score.FieldUserID:
		return m.OldUserID(ctx)
	case score.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case score.FieldScore:
		return m.OldScore(ctx)
	case score.FieldCommentID:
		return m.OldCommentID(ctx)
	}
	return nil, fmt.Errorf("unknown Score field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case score.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case score.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case score.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case score.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case score.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case score.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case score.FieldScore:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case score.FieldCommentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	}
	return fmt.Errorf("unknown Score field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScoreMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, score.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, score.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, score.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case score.FieldCreatedAt:
		return m.AddedCreatedAt()
	case score.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case score.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case score.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case score.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case score.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Score numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(score.FieldUserID) {
		fields = append(fields, score.FieldUserID)
	}
	if m.FieldCleared(score.FieldAppGoodID) {
		fields = append(fields, score.FieldAppGoodID)
	}
	if m.FieldCleared(score.FieldScore) {
		fields = append(fields, score.FieldScore)
	}
	if m.FieldCleared(score.FieldCommentID) {
		fields = append(fields, score.FieldCommentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScoreMutation) ClearField(name string) error {
	switch name {
	case score.FieldUserID:
		m.ClearUserID()
		return nil
	case score.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case score.FieldScore:
		m.ClearScore()
		return nil
	case score.FieldCommentID:
		m.ClearCommentID()
		return nil
	}
	return fmt.Errorf("unknown Score nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScoreMutation) ResetField(name string) error {
	switch name {
	case score.FieldEntID:
		m.ResetEntID()
		return nil
	case score.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case score.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case score.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case score.FieldUserID:
		m.ResetUserID()
		return nil
	case score.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case score.FieldScore:
		m.ResetScore()
		return nil
	case score.FieldCommentID:
		m.ResetCommentID()
		return nil
	}
	return fmt.Errorf("unknown Score field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScoreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScoreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScoreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScoreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Score unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScoreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Score edge %s", name)
}

// StockMutation represents an operation that mutates the Stock nodes in the graph.
type StockMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	good_id       *uuid.UUID
	total         *decimal.Decimal
	spot_quantity *decimal.Decimal
	locked        *decimal.Decimal
	in_service    *decimal.Decimal
	wait_start    *decimal.Decimal
	sold          *decimal.Decimal
	app_reserved  *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Stock, error)
	predicates    []predicate.Stock
}

var _ ent.Mutation = (*StockMutation)(nil)

// stockOption allows management of the mutation configuration using functional options.
type stockOption func(*StockMutation)

// newStockMutation creates new mutation for the Stock entity.
func newStockMutation(c config, op Op, opts ...stockOption) *StockMutation {
	m := &StockMutation{
		config:        c,
		op:            op,
		typ:           TypeStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockID sets the ID field of the mutation.
func withStockID(id uint32) stockOption {
	return func(m *StockMutation) {
		var (
			err   error
			once  sync.Once
			value *Stock
		)
		m.oldValue = func(ctx context.Context) (*Stock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStock sets the old Stock of the mutation.
func withStock(node *Stock) stockOption {
	return func(m *StockMutation) {
		m.oldValue = func(context.Context) (*Stock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stock entities.
func (m *StockMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *StockMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *StockMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *StockMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *StockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *StockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *StockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *StockMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *StockMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *StockMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[stock.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *StockMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *StockMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, stock.FieldGoodID)
}

// SetTotal sets the "total" field.
func (m *StockMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
}

// Total returns the value of the "total" field in the mutation.
func (m *StockMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ClearTotal clears the value of the "total" field.
func (m *StockMutation) ClearTotal() {
	m.total = nil
	m.clearedFields[stock.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *StockMutation) TotalCleared() bool {
	_, ok := m.clearedFields[stock.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *StockMutation) ResetTotal() {
	m.total = nil
	delete(m.clearedFields, stock.FieldTotal)
}

// SetSpotQuantity sets the "spot_quantity" field.
func (m *StockMutation) SetSpotQuantity(d decimal.Decimal) {
	m.spot_quantity = &d
}

// SpotQuantity returns the value of the "spot_quantity" field in the mutation.
func (m *StockMutation) SpotQuantity() (r decimal.Decimal, exists bool) {
	v := m.spot_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotQuantity returns the old "spot_quantity" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldSpotQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotQuantity: %w", err)
	}
	return oldValue.SpotQuantity, nil
}

// ClearSpotQuantity clears the value of the "spot_quantity" field.
func (m *StockMutation) ClearSpotQuantity() {
	m.spot_quantity = nil
	m.clearedFields[stock.FieldSpotQuantity] = struct{}{}
}

// SpotQuantityCleared returns if the "spot_quantity" field was cleared in this mutation.
func (m *StockMutation) SpotQuantityCleared() bool {
	_, ok := m.clearedFields[stock.FieldSpotQuantity]
	return ok
}

// ResetSpotQuantity resets all changes to the "spot_quantity" field.
func (m *StockMutation) ResetSpotQuantity() {
	m.spot_quantity = nil
	delete(m.clearedFields, stock.FieldSpotQuantity)
}

// SetLocked sets the "locked" field.
func (m *StockMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
}

// Locked returns the value of the "locked" field in the mutation.
func (m *StockMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ClearLocked clears the value of the "locked" field.
func (m *StockMutation) ClearLocked() {
	m.locked = nil
	m.clearedFields[stock.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *StockMutation) LockedCleared() bool {
	_, ok := m.clearedFields[stock.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *StockMutation) ResetLocked() {
	m.locked = nil
	delete(m.clearedFields, stock.FieldLocked)
}

// SetInService sets the "in_service" field.
func (m *StockMutation) SetInService(d decimal.Decimal) {
	m.in_service = &d
}

// InService returns the value of the "in_service" field in the mutation.
func (m *StockMutation) InService() (r decimal.Decimal, exists bool) {
	v := m.in_service
	if v == nil {
		return
	}
	return *v, true
}

// OldInService returns the old "in_service" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldInService(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInService: %w", err)
	}
	return oldValue.InService, nil
}

// ClearInService clears the value of the "in_service" field.
func (m *StockMutation) ClearInService() {
	m.in_service = nil
	m.clearedFields[stock.FieldInService] = struct{}{}
}

// InServiceCleared returns if the "in_service" field was cleared in this mutation.
func (m *StockMutation) InServiceCleared() bool {
	_, ok := m.clearedFields[stock.FieldInService]
	return ok
}

// ResetInService resets all changes to the "in_service" field.
func (m *StockMutation) ResetInService() {
	m.in_service = nil
	delete(m.clearedFields, stock.FieldInService)
}

// SetWaitStart sets the "wait_start" field.
func (m *StockMutation) SetWaitStart(d decimal.Decimal) {
	m.wait_start = &d
}

// WaitStart returns the value of the "wait_start" field in the mutation.
func (m *StockMutation) WaitStart() (r decimal.Decimal, exists bool) {
	v := m.wait_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWaitStart returns the old "wait_start" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldWaitStart(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaitStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaitStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaitStart: %w", err)
	}
	return oldValue.WaitStart, nil
}

// ClearWaitStart clears the value of the "wait_start" field.
func (m *StockMutation) ClearWaitStart() {
	m.wait_start = nil
	m.clearedFields[stock.FieldWaitStart] = struct{}{}
}

// WaitStartCleared returns if the "wait_start" field was cleared in this mutation.
func (m *StockMutation) WaitStartCleared() bool {
	_, ok := m.clearedFields[stock.FieldWaitStart]
	return ok
}

// ResetWaitStart resets all changes to the "wait_start" field.
func (m *StockMutation) ResetWaitStart() {
	m.wait_start = nil
	delete(m.clearedFields, stock.FieldWaitStart)
}

// SetSold sets the "sold" field.
func (m *StockMutation) SetSold(d decimal.Decimal) {
	m.sold = &d
}

// Sold returns the value of the "sold" field in the mutation.
func (m *StockMutation) Sold() (r decimal.Decimal, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldSold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// ClearSold clears the value of the "sold" field.
func (m *StockMutation) ClearSold() {
	m.sold = nil
	m.clearedFields[stock.FieldSold] = struct{}{}
}

// SoldCleared returns if the "sold" field was cleared in this mutation.
func (m *StockMutation) SoldCleared() bool {
	_, ok := m.clearedFields[stock.FieldSold]
	return ok
}

// ResetSold resets all changes to the "sold" field.
func (m *StockMutation) ResetSold() {
	m.sold = nil
	delete(m.clearedFields, stock.FieldSold)
}

// SetAppReserved sets the "app_reserved" field.
func (m *StockMutation) SetAppReserved(d decimal.Decimal) {
	m.app_reserved = &d
}

// AppReserved returns the value of the "app_reserved" field in the mutation.
func (m *StockMutation) AppReserved() (r decimal.Decimal, exists bool) {
	v := m.app_reserved
	if v == nil {
		return
	}
	return *v, true
}

// OldAppReserved returns the old "app_reserved" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldAppReserved(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppReserved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppReserved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppReserved: %w", err)
	}
	return oldValue.AppReserved, nil
}

// ClearAppReserved clears the value of the "app_reserved" field.
func (m *StockMutation) ClearAppReserved() {
	m.app_reserved = nil
	m.clearedFields[stock.FieldAppReserved] = struct{}{}
}

// AppReservedCleared returns if the "app_reserved" field was cleared in this mutation.
func (m *StockMutation) AppReservedCleared() bool {
	_, ok := m.clearedFields[stock.FieldAppReserved]
	return ok
}

// ResetAppReserved resets all changes to the "app_reserved" field.
func (m *StockMutation) ResetAppReserved() {
	m.app_reserved = nil
	delete(m.clearedFields, stock.FieldAppReserved)
}

// Where appends a list predicates to the StockMutation builder.
func (m *StockMutation) Where(ps ...predicate.Stock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stock).
func (m *StockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.ent_id != nil {
		fields = append(fields, stock.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, stock.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, stock.FieldGoodID)
	}
	if m.total != nil {
		fields = append(fields, stock.FieldTotal)
	}
	if m.spot_quantity != nil {
		fields = append(fields, stock.FieldSpotQuantity)
	}
	if m.locked != nil {
		fields = append(fields, stock.FieldLocked)
	}
	if m.in_service != nil {
		fields = append(fields, stock.FieldInService)
	}
	if m.wait_start != nil {
		fields = append(fields, stock.FieldWaitStart)
	}
	if m.sold != nil {
		fields = append(fields, stock.FieldSold)
	}
	if m.app_reserved != nil {
		fields = append(fields, stock.FieldAppReserved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldEntID:
		return m.EntID()
	case stock.FieldCreatedAt:
		return m.CreatedAt()
	case stock.FieldUpdatedAt:
		return m.UpdatedAt()
	case stock.FieldDeletedAt:
		return m.DeletedAt()
	case stock.FieldGoodID:
		return m.GoodID()
	case stock.FieldTotal:
		return m.Total()
	case stock.FieldSpotQuantity:
		return m.SpotQuantity()
	case stock.FieldLocked:
		return m.Locked()
	case stock.FieldInService:
		return m.InService()
	case stock.FieldWaitStart:
		return m.WaitStart()
	case stock.FieldSold:
		return m.Sold()
	case stock.FieldAppReserved:
		return m.AppReserved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stock.FieldEntID:
		return m.OldEntID(ctx)
	case stock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case stock.FieldGoodID:
		return m.OldGoodID(ctx)
	case stock.FieldTotal:
		return m.OldTotal(ctx)
	case stock.FieldSpotQuantity:
		return m.OldSpotQuantity(ctx)
	case stock.FieldLocked:
		return m.OldLocked(ctx)
	case stock.FieldInService:
		return m.OldInService(ctx)
	case stock.FieldWaitStart:
		return m.OldWaitStart(ctx)
	case stock.FieldSold:
		return m.OldSold(ctx)
	case stock.FieldAppReserved:
		return m.OldAppReserved(ctx)
	}
	return nil, fmt.Errorf("unknown Stock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stock.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case stock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case stock.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case stock.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case stock.FieldSpotQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotQuantity(v)
		return nil
	case stock.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case stock.FieldInService:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInService(v)
		return nil
	case stock.FieldWaitStart:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaitStart(v)
		return nil
	case stock.FieldSold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	case stock.FieldAppReserved:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppReserved(v)
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, stock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case stock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case stock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case stock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Stock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stock.FieldGoodID) {
		fields = append(fields, stock.FieldGoodID)
	}
	if m.FieldCleared(stock.FieldTotal) {
		fields = append(fields, stock.FieldTotal)
	}
	if m.FieldCleared(stock.FieldSpotQuantity) {
		fields = append(fields, stock.FieldSpotQuantity)
	}
	if m.FieldCleared(stock.FieldLocked) {
		fields = append(fields, stock.FieldLocked)
	}
	if m.FieldCleared(stock.FieldInService) {
		fields = append(fields, stock.FieldInService)
	}
	if m.FieldCleared(stock.FieldWaitStart) {
		fields = append(fields, stock.FieldWaitStart)
	}
	if m.FieldCleared(stock.FieldSold) {
		fields = append(fields, stock.FieldSold)
	}
	if m.FieldCleared(stock.FieldAppReserved) {
		fields = append(fields, stock.FieldAppReserved)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMutation) ClearField(name string) error {
	switch name {
	case stock.FieldGoodID:
		m.ClearGoodID()
		return nil
	case stock.FieldTotal:
		m.ClearTotal()
		return nil
	case stock.FieldSpotQuantity:
		m.ClearSpotQuantity()
		return nil
	case stock.FieldLocked:
		m.ClearLocked()
		return nil
	case stock.FieldInService:
		m.ClearInService()
		return nil
	case stock.FieldWaitStart:
		m.ClearWaitStart()
		return nil
	case stock.FieldSold:
		m.ClearSold()
		return nil
	case stock.FieldAppReserved:
		m.ClearAppReserved()
		return nil
	}
	return fmt.Errorf("unknown Stock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMutation) ResetField(name string) error {
	switch name {
	case stock.FieldEntID:
		m.ResetEntID()
		return nil
	case stock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case stock.FieldGoodID:
		m.ResetGoodID()
		return nil
	case stock.FieldTotal:
		m.ResetTotal()
		return nil
	case stock.FieldSpotQuantity:
		m.ResetSpotQuantity()
		return nil
	case stock.FieldLocked:
		m.ResetLocked()
		return nil
	case stock.FieldInService:
		m.ResetInService()
		return nil
	case stock.FieldWaitStart:
		m.ResetWaitStart()
		return nil
	case stock.FieldSold:
		m.ResetSold()
		return nil
	case stock.FieldAppReserved:
		m.ResetAppReserved()
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Stock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Stock edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint32
	ent_id                *uuid.UUID
	created_at            *uint32
	addcreated_at         *int32
	updated_at            *uint32
	addupdated_at         *int32
	deleted_at            *uint32
	adddeleted_at         *int32
	good_id               *uuid.UUID
	good_type             *string
	name                  *string
	duration_display_type *string
	duration_units        *uint32
	addduration_units     *int32
	duration_quota        *uint32
	addduration_quota     *int32
	daily_bonus_quota     *uint32
	adddaily_bonus_quota  *int32
	usd_price             *decimal.Decimal
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Subscription, error)
	predicates            []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id uint32) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *SubscriptionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *SubscriptionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *SubscriptionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *SubscriptionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SubscriptionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *SubscriptionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SubscriptionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *SubscriptionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SubscriptionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *SubscriptionMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *SubscriptionMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *SubscriptionMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[subscription.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *SubscriptionMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *SubscriptionMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, subscription.FieldGoodID)
}

// SetGoodType sets the "good_type" field.
func (m *SubscriptionMutation) SetGoodType(s string) {
	m.good_type = &s
}

// GoodType returns the value of the "good_type" field in the mutation.
func (m *SubscriptionMutation) GoodType() (r string, exists bool) {
	v := m.good_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodType returns the old "good_type" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldGoodType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodType: %w", err)
	}
	return oldValue.GoodType, nil
}

// ClearGoodType clears the value of the "good_type" field.
func (m *SubscriptionMutation) ClearGoodType() {
	m.good_type = nil
	m.clearedFields[subscription.FieldGoodType] = struct{}{}
}

// GoodTypeCleared returns if the "good_type" field was cleared in this mutation.
func (m *SubscriptionMutation) GoodTypeCleared() bool {
	_, ok := m.clearedFields[subscription.FieldGoodType]
	return ok
}

// ResetGoodType resets all changes to the "good_type" field.
func (m *SubscriptionMutation) ResetGoodType() {
	m.good_type = nil
	delete(m.clearedFields, subscription.FieldGoodType)
}

// SetName sets the "name" field.
func (m *SubscriptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubscriptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *SubscriptionMutation) ClearName() {
	m.name = nil
	m.clearedFields[subscription.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *SubscriptionMutation) NameCleared() bool {
	_, ok := m.clearedFields[subscription.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *SubscriptionMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, subscription.FieldName)
}

// SetDurationDisplayType sets the "duration_display_type" field.
func (m *SubscriptionMutation) SetDurationDisplayType(s string) {
	m.duration_display_type = &s
}

// DurationDisplayType returns the value of the "duration_display_type" field in the mutation.
func (m *SubscriptionMutation) DurationDisplayType() (r string, exists bool) {
	v := m.duration_display_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDisplayType returns the old "duration_display_type" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDurationDisplayType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDisplayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDisplayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDisplayType: %w", err)
	}
	return oldValue.DurationDisplayType, nil
}

// ClearDurationDisplayType clears the value of the "duration_display_type" field.
func (m *SubscriptionMutation) ClearDurationDisplayType() {
	m.duration_display_type = nil
	m.clearedFields[subscription.FieldDurationDisplayType] = struct{}{}
}

// DurationDisplayTypeCleared returns if the "duration_display_type" field was cleared in this mutation.
func (m *SubscriptionMutation) DurationDisplayTypeCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDurationDisplayType]
	return ok
}

// ResetDurationDisplayType resets all changes to the "duration_display_type" field.
func (m *SubscriptionMutation) ResetDurationDisplayType() {
	m.duration_display_type = nil
	delete(m.clearedFields, subscription.FieldDurationDisplayType)
}

// SetDurationUnits sets the "duration_units" field.
func (m *SubscriptionMutation) SetDurationUnits(u uint32) {
	m.duration_units = &u
	m.addduration_units = nil
}

// DurationUnits returns the value of the "duration_units" field in the mutation.
func (m *SubscriptionMutation) DurationUnits() (r uint32, exists bool) {
	v := m.duration_units
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationUnits returns the old "duration_units" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDurationUnits(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationUnits: %w", err)
	}
	return oldValue.DurationUnits, nil
}

// AddDurationUnits adds u to the "duration_units" field.
func (m *SubscriptionMutation) AddDurationUnits(u int32) {
	if m.addduration_units != nil {
		*m.addduration_units += u
	} else {
		m.addduration_units = &u
	}
}

// AddedDurationUnits returns the value that was added to the "duration_units" field in this mutation.
func (m *SubscriptionMutation) AddedDurationUnits() (r int32, exists bool) {
	v := m.addduration_units
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationUnits clears the value of the "duration_units" field.
func (m *SubscriptionMutation) ClearDurationUnits() {
	m.duration_units = nil
	m.addduration_units = nil
	m.clearedFields[subscription.FieldDurationUnits] = struct{}{}
}

// DurationUnitsCleared returns if the "duration_units" field was cleared in this mutation.
func (m *SubscriptionMutation) DurationUnitsCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDurationUnits]
	return ok
}

// ResetDurationUnits resets all changes to the "duration_units" field.
func (m *SubscriptionMutation) ResetDurationUnits() {
	m.duration_units = nil
	m.addduration_units = nil
	delete(m.clearedFields, subscription.FieldDurationUnits)
}

// SetDurationQuota sets the "duration_quota" field.
func (m *SubscriptionMutation) SetDurationQuota(u uint32) {
	m.duration_quota = &u
	m.addduration_quota = nil
}

// DurationQuota returns the value of the "duration_quota" field in the mutation.
func (m *SubscriptionMutation) DurationQuota() (r uint32, exists bool) {
	v := m.duration_quota
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationQuota returns the old "duration_quota" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDurationQuota(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationQuota is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationQuota requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationQuota: %w", err)
	}
	return oldValue.DurationQuota, nil
}

// AddDurationQuota adds u to the "duration_quota" field.
func (m *SubscriptionMutation) AddDurationQuota(u int32) {
	if m.addduration_quota != nil {
		*m.addduration_quota += u
	} else {
		m.addduration_quota = &u
	}
}

// AddedDurationQuota returns the value that was added to the "duration_quota" field in this mutation.
func (m *SubscriptionMutation) AddedDurationQuota() (r int32, exists bool) {
	v := m.addduration_quota
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationQuota clears the value of the "duration_quota" field.
func (m *SubscriptionMutation) ClearDurationQuota() {
	m.duration_quota = nil
	m.addduration_quota = nil
	m.clearedFields[subscription.FieldDurationQuota] = struct{}{}
}

// DurationQuotaCleared returns if the "duration_quota" field was cleared in this mutation.
func (m *SubscriptionMutation) DurationQuotaCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDurationQuota]
	return ok
}

// ResetDurationQuota resets all changes to the "duration_quota" field.
func (m *SubscriptionMutation) ResetDurationQuota() {
	m.duration_quota = nil
	m.addduration_quota = nil
	delete(m.clearedFields, subscription.FieldDurationQuota)
}

// SetDailyBonusQuota sets the "daily_bonus_quota" field.
func (m *SubscriptionMutation) SetDailyBonusQuota(u uint32) {
	m.daily_bonus_quota = &u
	m.adddaily_bonus_quota = nil
}

// DailyBonusQuota returns the value of the "daily_bonus_quota" field in the mutation.
func (m *SubscriptionMutation) DailyBonusQuota() (r uint32, exists bool) {
	v := m.daily_bonus_quota
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyBonusQuota returns the old "daily_bonus_quota" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDailyBonusQuota(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyBonusQuota is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyBonusQuota requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyBonusQuota: %w", err)
	}
	return oldValue.DailyBonusQuota, nil
}

// AddDailyBonusQuota adds u to the "daily_bonus_quota" field.
func (m *SubscriptionMutation) AddDailyBonusQuota(u int32) {
	if m.adddaily_bonus_quota != nil {
		*m.adddaily_bonus_quota += u
	} else {
		m.adddaily_bonus_quota = &u
	}
}

// AddedDailyBonusQuota returns the value that was added to the "daily_bonus_quota" field in this mutation.
func (m *SubscriptionMutation) AddedDailyBonusQuota() (r int32, exists bool) {
	v := m.adddaily_bonus_quota
	if v == nil {
		return
	}
	return *v, true
}

// ClearDailyBonusQuota clears the value of the "daily_bonus_quota" field.
func (m *SubscriptionMutation) ClearDailyBonusQuota() {
	m.daily_bonus_quota = nil
	m.adddaily_bonus_quota = nil
	m.clearedFields[subscription.FieldDailyBonusQuota] = struct{}{}
}

// DailyBonusQuotaCleared returns if the "daily_bonus_quota" field was cleared in this mutation.
func (m *SubscriptionMutation) DailyBonusQuotaCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDailyBonusQuota]
	return ok
}

// ResetDailyBonusQuota resets all changes to the "daily_bonus_quota" field.
func (m *SubscriptionMutation) ResetDailyBonusQuota() {
	m.daily_bonus_quota = nil
	m.adddaily_bonus_quota = nil
	delete(m.clearedFields, subscription.FieldDailyBonusQuota)
}

// SetUsdPrice sets the "usd_price" field.
func (m *SubscriptionMutation) SetUsdPrice(d decimal.Decimal) {
	m.usd_price = &d
}

// UsdPrice returns the value of the "usd_price" field in the mutation.
func (m *SubscriptionMutation) UsdPrice() (r decimal.Decimal, exists bool) {
	v := m.usd_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdPrice returns the old "usd_price" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUsdPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdPrice: %w", err)
	}
	return oldValue.UsdPrice, nil
}

// ClearUsdPrice clears the value of the "usd_price" field.
func (m *SubscriptionMutation) ClearUsdPrice() {
	m.usd_price = nil
	m.clearedFields[subscription.FieldUsdPrice] = struct{}{}
}

// UsdPriceCleared returns if the "usd_price" field was cleared in this mutation.
func (m *SubscriptionMutation) UsdPriceCleared() bool {
	_, ok := m.clearedFields[subscription.FieldUsdPrice]
	return ok
}

// ResetUsdPrice resets all changes to the "usd_price" field.
func (m *SubscriptionMutation) ResetUsdPrice() {
	m.usd_price = nil
	delete(m.clearedFields, subscription.FieldUsdPrice)
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.ent_id != nil {
		fields = append(fields, subscription.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, subscription.FieldGoodID)
	}
	if m.good_type != nil {
		fields = append(fields, subscription.FieldGoodType)
	}
	if m.name != nil {
		fields = append(fields, subscription.FieldName)
	}
	if m.duration_display_type != nil {
		fields = append(fields, subscription.FieldDurationDisplayType)
	}
	if m.duration_units != nil {
		fields = append(fields, subscription.FieldDurationUnits)
	}
	if m.duration_quota != nil {
		fields = append(fields, subscription.FieldDurationQuota)
	}
	if m.daily_bonus_quota != nil {
		fields = append(fields, subscription.FieldDailyBonusQuota)
	}
	if m.usd_price != nil {
		fields = append(fields, subscription.FieldUsdPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldEntID:
		return m.EntID()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscription.FieldDeletedAt:
		return m.DeletedAt()
	case subscription.FieldGoodID:
		return m.GoodID()
	case subscription.FieldGoodType:
		return m.GoodType()
	case subscription.FieldName:
		return m.Name()
	case subscription.FieldDurationDisplayType:
		return m.DurationDisplayType()
	case subscription.FieldDurationUnits:
		return m.DurationUnits()
	case subscription.FieldDurationQuota:
		return m.DurationQuota()
	case subscription.FieldDailyBonusQuota:
		return m.DailyBonusQuota()
	case subscription.FieldUsdPrice:
		return m.UsdPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldEntID:
		return m.OldEntID(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscription.FieldGoodID:
		return m.OldGoodID(ctx)
	case subscription.FieldGoodType:
		return m.OldGoodType(ctx)
	case subscription.FieldName:
		return m.OldName(ctx)
	case subscription.FieldDurationDisplayType:
		return m.OldDurationDisplayType(ctx)
	case subscription.FieldDurationUnits:
		return m.OldDurationUnits(ctx)
	case subscription.FieldDurationQuota:
		return m.OldDurationQuota(ctx)
	case subscription.FieldDailyBonusQuota:
		return m.OldDailyBonusQuota(ctx)
	case subscription.FieldUsdPrice:
		return m.OldUsdPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscription.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscription.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case subscription.FieldGoodType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodType(v)
		return nil
	case subscription.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subscription.FieldDurationDisplayType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDisplayType(v)
		return nil
	case subscription.FieldDurationUnits:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationUnits(v)
		return nil
	case subscription.FieldDurationQuota:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationQuota(v)
		return nil
	case subscription.FieldDailyBonusQuota:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyBonusQuota(v)
		return nil
	case subscription.FieldUsdPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.addduration_units != nil {
		fields = append(fields, subscription.FieldDurationUnits)
	}
	if m.addduration_quota != nil {
		fields = append(fields, subscription.FieldDurationQuota)
	}
	if m.adddaily_bonus_quota != nil {
		fields = append(fields, subscription.FieldDailyBonusQuota)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldCreatedAt:
		return m.AddedCreatedAt()
	case subscription.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case subscription.FieldDeletedAt:
		return m.AddedDeletedAt()
	case subscription.FieldDurationUnits:
		return m.AddedDurationUnits()
	case subscription.FieldDurationQuota:
		return m.AddedDurationQuota()
	case subscription.FieldDailyBonusQuota:
		return m.AddedDailyBonusQuota()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case subscription.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case subscription.FieldDurationUnits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationUnits(v)
		return nil
	case subscription.FieldDurationQuota:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationQuota(v)
		return nil
	case subscription.FieldDailyBonusQuota:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyBonusQuota(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldGoodID) {
		fields = append(fields, subscription.FieldGoodID)
	}
	if m.FieldCleared(subscription.FieldGoodType) {
		fields = append(fields, subscription.FieldGoodType)
	}
	if m.FieldCleared(subscription.FieldName) {
		fields = append(fields, subscription.FieldName)
	}
	if m.FieldCleared(subscription.FieldDurationDisplayType) {
		fields = append(fields, subscription.FieldDurationDisplayType)
	}
	if m.FieldCleared(subscription.FieldDurationUnits) {
		fields = append(fields, subscription.FieldDurationUnits)
	}
	if m.FieldCleared(subscription.FieldDurationQuota) {
		fields = append(fields, subscription.FieldDurationQuota)
	}
	if m.FieldCleared(subscription.FieldDailyBonusQuota) {
		fields = append(fields, subscription.FieldDailyBonusQuota)
	}
	if m.FieldCleared(subscription.FieldUsdPrice) {
		fields = append(fields, subscription.FieldUsdPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldGoodID:
		m.ClearGoodID()
		return nil
	case subscription.FieldGoodType:
		m.ClearGoodType()
		return nil
	case subscription.FieldName:
		m.ClearName()
		return nil
	case subscription.FieldDurationDisplayType:
		m.ClearDurationDisplayType()
		return nil
	case subscription.FieldDurationUnits:
		m.ClearDurationUnits()
		return nil
	case subscription.FieldDurationQuota:
		m.ClearDurationQuota()
		return nil
	case subscription.FieldDailyBonusQuota:
		m.ClearDailyBonusQuota()
		return nil
	case subscription.FieldUsdPrice:
		m.ClearUsdPrice()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldEntID:
		m.ResetEntID()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscription.FieldGoodID:
		m.ResetGoodID()
		return nil
	case subscription.FieldGoodType:
		m.ResetGoodType()
		return nil
	case subscription.FieldName:
		m.ResetName()
		return nil
	case subscription.FieldDurationDisplayType:
		m.ResetDurationDisplayType()
		return nil
	case subscription.FieldDurationUnits:
		m.ResetDurationUnits()
		return nil
	case subscription.FieldDurationQuota:
		m.ResetDurationQuota()
		return nil
	case subscription.FieldDailyBonusQuota:
		m.ResetDailyBonusQuota()
		return nil
	case subscription.FieldUsdPrice:
		m.ResetUsdPrice()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// SubscriptionOneShotMutation represents an operation that mutates the SubscriptionOneShot nodes in the graph.
type SubscriptionOneShotMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	ent_id          *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	good_id         *uuid.UUID
	good_type       *string
	name            *string
	quota           *uint32
	addquota        *int32
	usd_price       *decimal.Decimal
	life_seconds    *uint32
	addlife_seconds *int32
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*SubscriptionOneShot, error)
	predicates      []predicate.SubscriptionOneShot
}

var _ ent.Mutation = (*SubscriptionOneShotMutation)(nil)

// subscriptiononeshotOption allows management of the mutation configuration using functional options.
type subscriptiononeshotOption func(*SubscriptionOneShotMutation)

// newSubscriptionOneShotMutation creates new mutation for the SubscriptionOneShot entity.
func newSubscriptionOneShotMutation(c config, op Op, opts ...subscriptiononeshotOption) *SubscriptionOneShotMutation {
	m := &SubscriptionOneShotMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionOneShot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionOneShotID sets the ID field of the mutation.
func withSubscriptionOneShotID(id uint32) subscriptiononeshotOption {
	return func(m *SubscriptionOneShotMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionOneShot
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionOneShot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionOneShot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionOneShot sets the old SubscriptionOneShot of the mutation.
func withSubscriptionOneShot(node *SubscriptionOneShot) subscriptiononeshotOption {
	return func(m *SubscriptionOneShotMutation) {
		m.oldValue = func(context.Context) (*SubscriptionOneShot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionOneShotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionOneShotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionOneShot entities.
func (m *SubscriptionOneShotMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionOneShotMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionOneShotMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionOneShot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *SubscriptionOneShotMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *SubscriptionOneShotMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *SubscriptionOneShotMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionOneShotMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionOneShotMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *SubscriptionOneShotMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SubscriptionOneShotMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionOneShotMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionOneShotMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionOneShotMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *SubscriptionOneShotMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SubscriptionOneShotMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionOneShotMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionOneShotMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionOneShotMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *SubscriptionOneShotMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SubscriptionOneShotMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionOneShotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *SubscriptionOneShotMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *SubscriptionOneShotMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *SubscriptionOneShotMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[subscriptiononeshot.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *SubscriptionOneShotMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[subscriptiononeshot.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *SubscriptionOneShotMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, subscriptiononeshot.FieldGoodID)
}

// SetGoodType sets the "good_type" field.
func (m *SubscriptionOneShotMutation) SetGoodType(s string) {
	m.good_type = &s
}

// GoodType returns the value of the "good_type" field in the mutation.
func (m *SubscriptionOneShotMutation) GoodType() (r string, exists bool) {
	v := m.good_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodType returns the old "good_type" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldGoodType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodType: %w", err)
	}
	return oldValue.GoodType, nil
}

// ClearGoodType clears the value of the "good_type" field.
func (m *SubscriptionOneShotMutation) ClearGoodType() {
	m.good_type = nil
	m.clearedFields[subscriptiononeshot.FieldGoodType] = struct{}{}
}

// GoodTypeCleared returns if the "good_type" field was cleared in this mutation.
func (m *SubscriptionOneShotMutation) GoodTypeCleared() bool {
	_, ok := m.clearedFields[subscriptiononeshot.FieldGoodType]
	return ok
}

// ResetGoodType resets all changes to the "good_type" field.
func (m *SubscriptionOneShotMutation) ResetGoodType() {
	m.good_type = nil
	delete(m.clearedFields, subscriptiononeshot.FieldGoodType)
}

// SetName sets the "name" field.
func (m *SubscriptionOneShotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubscriptionOneShotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *SubscriptionOneShotMutation) ClearName() {
	m.name = nil
	m.clearedFields[subscriptiononeshot.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *SubscriptionOneShotMutation) NameCleared() bool {
	_, ok := m.clearedFields[subscriptiononeshot.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *SubscriptionOneShotMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, subscriptiononeshot.FieldName)
}

// SetQuota sets the "quota" field.
func (m *SubscriptionOneShotMutation) SetQuota(u uint32) {
	m.quota = &u
	m.addquota = nil
}

// Quota returns the value of the "quota" field in the mutation.
func (m *SubscriptionOneShotMutation) Quota() (r uint32, exists bool) {
	v := m.quota
	if v == nil {
		return
	}
	return *v, true
}

// OldQuota returns the old "quota" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldQuota(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuota is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuota requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuota: %w", err)
	}
	return oldValue.Quota, nil
}

// AddQuota adds u to the "quota" field.
func (m *SubscriptionOneShotMutation) AddQuota(u int32) {
	if m.addquota != nil {
		*m.addquota += u
	} else {
		m.addquota = &u
	}
}

// AddedQuota returns the value that was added to the "quota" field in this mutation.
func (m *SubscriptionOneShotMutation) AddedQuota() (r int32, exists bool) {
	v := m.addquota
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuota clears the value of the "quota" field.
func (m *SubscriptionOneShotMutation) ClearQuota() {
	m.quota = nil
	m.addquota = nil
	m.clearedFields[subscriptiononeshot.FieldQuota] = struct{}{}
}

// QuotaCleared returns if the "quota" field was cleared in this mutation.
func (m *SubscriptionOneShotMutation) QuotaCleared() bool {
	_, ok := m.clearedFields[subscriptiononeshot.FieldQuota]
	return ok
}

// ResetQuota resets all changes to the "quota" field.
func (m *SubscriptionOneShotMutation) ResetQuota() {
	m.quota = nil
	m.addquota = nil
	delete(m.clearedFields, subscriptiononeshot.FieldQuota)
}

// SetUsdPrice sets the "usd_price" field.
func (m *SubscriptionOneShotMutation) SetUsdPrice(d decimal.Decimal) {
	m.usd_price = &d
}

// UsdPrice returns the value of the "usd_price" field in the mutation.
func (m *SubscriptionOneShotMutation) UsdPrice() (r decimal.Decimal, exists bool) {
	v := m.usd_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdPrice returns the old "usd_price" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldUsdPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdPrice: %w", err)
	}
	return oldValue.UsdPrice, nil
}

// ClearUsdPrice clears the value of the "usd_price" field.
func (m *SubscriptionOneShotMutation) ClearUsdPrice() {
	m.usd_price = nil
	m.clearedFields[subscriptiononeshot.FieldUsdPrice] = struct{}{}
}

// UsdPriceCleared returns if the "usd_price" field was cleared in this mutation.
func (m *SubscriptionOneShotMutation) UsdPriceCleared() bool {
	_, ok := m.clearedFields[subscriptiononeshot.FieldUsdPrice]
	return ok
}

// ResetUsdPrice resets all changes to the "usd_price" field.
func (m *SubscriptionOneShotMutation) ResetUsdPrice() {
	m.usd_price = nil
	delete(m.clearedFields, subscriptiononeshot.FieldUsdPrice)
}

// SetLifeSeconds sets the "life_seconds" field.
func (m *SubscriptionOneShotMutation) SetLifeSeconds(u uint32) {
	m.life_seconds = &u
	m.addlife_seconds = nil
}

// LifeSeconds returns the value of the "life_seconds" field in the mutation.
func (m *SubscriptionOneShotMutation) LifeSeconds() (r uint32, exists bool) {
	v := m.life_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldLifeSeconds returns the old "life_seconds" field's value of the SubscriptionOneShot entity.
// If the SubscriptionOneShot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionOneShotMutation) OldLifeSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifeSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifeSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifeSeconds: %w", err)
	}
	return oldValue.LifeSeconds, nil
}

// AddLifeSeconds adds u to the "life_seconds" field.
func (m *SubscriptionOneShotMutation) AddLifeSeconds(u int32) {
	if m.addlife_seconds != nil {
		*m.addlife_seconds += u
	} else {
		m.addlife_seconds = &u
	}
}

// AddedLifeSeconds returns the value that was added to the "life_seconds" field in this mutation.
func (m *SubscriptionOneShotMutation) AddedLifeSeconds() (r int32, exists bool) {
	v := m.addlife_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearLifeSeconds clears the value of the "life_seconds" field.
func (m *SubscriptionOneShotMutation) ClearLifeSeconds() {
	m.life_seconds = nil
	m.addlife_seconds = nil
	m.clearedFields[subscriptiononeshot.FieldLifeSeconds] = struct{}{}
}

// LifeSecondsCleared returns if the "life_seconds" field was cleared in this mutation.
func (m *SubscriptionOneShotMutation) LifeSecondsCleared() bool {
	_, ok := m.clearedFields[subscriptiononeshot.FieldLifeSeconds]
	return ok
}

// ResetLifeSeconds resets all changes to the "life_seconds" field.
func (m *SubscriptionOneShotMutation) ResetLifeSeconds() {
	m.life_seconds = nil
	m.addlife_seconds = nil
	delete(m.clearedFields, subscriptiononeshot.FieldLifeSeconds)
}

// Where appends a list predicates to the SubscriptionOneShotMutation builder.
func (m *SubscriptionOneShotMutation) Where(ps ...predicate.SubscriptionOneShot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionOneShotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionOneShotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionOneShot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionOneShotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionOneShotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionOneShot).
func (m *SubscriptionOneShotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionOneShotMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.ent_id != nil {
		fields = append(fields, subscriptiononeshot.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, subscriptiononeshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriptiononeshot.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriptiononeshot.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, subscriptiononeshot.FieldGoodID)
	}
	if m.good_type != nil {
		fields = append(fields, subscriptiononeshot.FieldGoodType)
	}
	if m.name != nil {
		fields = append(fields, subscriptiononeshot.FieldName)
	}
	if m.quota != nil {
		fields = append(fields, subscriptiononeshot.FieldQuota)
	}
	if m.usd_price != nil {
		fields = append(fields, subscriptiononeshot.FieldUsdPrice)
	}
	if m.life_seconds != nil {
		fields = append(fields, subscriptiononeshot.FieldLifeSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionOneShotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptiononeshot.FieldEntID:
		return m.EntID()
	case subscriptiononeshot.FieldCreatedAt:
		return m.CreatedAt()
	case subscriptiononeshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriptiononeshot.FieldDeletedAt:
		return m.DeletedAt()
	case subscriptiononeshot.FieldGoodID:
		return m.GoodID()
	case subscriptiononeshot.FieldGoodType:
		return m.GoodType()
	case subscriptiononeshot.FieldName:
		return m.Name()
	case subscriptiononeshot.FieldQuota:
		return m.Quota()
	case subscriptiononeshot.FieldUsdPrice:
		return m.UsdPrice()
	case subscriptiononeshot.FieldLifeSeconds:
		return m.LifeSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionOneShotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptiononeshot.FieldEntID:
		return m.OldEntID(ctx)
	case subscriptiononeshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriptiononeshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriptiononeshot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriptiononeshot.FieldGoodID:
		return m.OldGoodID(ctx)
	case subscriptiononeshot.FieldGoodType:
		return m.OldGoodType(ctx)
	case subscriptiononeshot.FieldName:
		return m.OldName(ctx)
	case subscriptiononeshot.FieldQuota:
		return m.OldQuota(ctx)
	case subscriptiononeshot.FieldUsdPrice:
		return m.OldUsdPrice(ctx)
	case subscriptiononeshot.FieldLifeSeconds:
		return m.OldLifeSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionOneShot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionOneShotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptiononeshot.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case subscriptiononeshot.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriptiononeshot.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriptiononeshot.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriptiononeshot.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case subscriptiononeshot.FieldGoodType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodType(v)
		return nil
	case subscriptiononeshot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subscriptiononeshot.FieldQuota:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuota(v)
		return nil
	case subscriptiononeshot.FieldUsdPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdPrice(v)
		return nil
	case subscriptiononeshot.FieldLifeSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifeSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionOneShot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionOneShotMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, subscriptiononeshot.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, subscriptiononeshot.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, subscriptiononeshot.FieldDeletedAt)
	}
	if m.addquota != nil {
		fields = append(fields, subscriptiononeshot.FieldQuota)
	}
	if m.addlife_seconds != nil {
		fields = append(fields, subscriptiononeshot.FieldLifeSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionOneShotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscriptiononeshot.FieldCreatedAt:
		return m.AddedCreatedAt()
	case subscriptiononeshot.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case subscriptiononeshot.FieldDeletedAt:
		return m.AddedDeletedAt()
	case subscriptiononeshot.FieldQuota:
		return m.AddedQuota()
	case subscriptiononeshot.FieldLifeSeconds:
		return m.AddedLifeSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionOneShotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscriptiononeshot.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case subscriptiononeshot.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case subscriptiononeshot.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case subscriptiononeshot.FieldQuota:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuota(v)
		return nil
	case subscriptiononeshot.FieldLifeSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLifeSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionOneShot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionOneShotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptiononeshot.FieldGoodID) {
		fields = append(fields, subscriptiononeshot.FieldGoodID)
	}
	if m.FieldCleared(subscriptiononeshot.FieldGoodType) {
		fields = append(fields, subscriptiononeshot.FieldGoodType)
	}
	if m.FieldCleared(subscriptiononeshot.FieldName) {
		fields = append(fields, subscriptiononeshot.FieldName)
	}
	if m.FieldCleared(subscriptiononeshot.FieldQuota) {
		fields = append(fields, subscriptiononeshot.FieldQuota)
	}
	if m.FieldCleared(subscriptiononeshot.FieldUsdPrice) {
		fields = append(fields, subscriptiononeshot.FieldUsdPrice)
	}
	if m.FieldCleared(subscriptiononeshot.FieldLifeSeconds) {
		fields = append(fields, subscriptiononeshot.FieldLifeSeconds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionOneShotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionOneShotMutation) ClearField(name string) error {
	switch name {
	case subscriptiononeshot.FieldGoodID:
		m.ClearGoodID()
		return nil
	case subscriptiononeshot.FieldGoodType:
		m.ClearGoodType()
		return nil
	case subscriptiononeshot.FieldName:
		m.ClearName()
		return nil
	case subscriptiononeshot.FieldQuota:
		m.ClearQuota()
		return nil
	case subscriptiononeshot.FieldUsdPrice:
		m.ClearUsdPrice()
		return nil
	case subscriptiononeshot.FieldLifeSeconds:
		m.ClearLifeSeconds()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionOneShot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionOneShotMutation) ResetField(name string) error {
	switch name {
	case subscriptiononeshot.FieldEntID:
		m.ResetEntID()
		return nil
	case subscriptiononeshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriptiononeshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriptiononeshot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriptiononeshot.FieldGoodID:
		m.ResetGoodID()
		return nil
	case subscriptiononeshot.FieldGoodType:
		m.ResetGoodType()
		return nil
	case subscriptiononeshot.FieldName:
		m.ResetName()
		return nil
	case subscriptiononeshot.FieldQuota:
		m.ResetQuota()
		return nil
	case subscriptiononeshot.FieldUsdPrice:
		m.ResetUsdPrice()
		return nil
	case subscriptiononeshot.FieldLifeSeconds:
		m.ResetLifeSeconds()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionOneShot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionOneShotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionOneShotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionOneShotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionOneShotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionOneShotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionOneShotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionOneShotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SubscriptionOneShot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionOneShotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SubscriptionOneShot edge %s", name)
}

// TopMostMutation represents an operation that mutates the TopMost nodes in the graph.
type TopMostMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	top_most_type *string
	title         *string
	message       *string
	target_url    *string
	start_at      *uint32
	addstart_at   *int32
	end_at        *uint32
	addend_at     *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TopMost, error)
	predicates    []predicate.TopMost
}

var _ ent.Mutation = (*TopMostMutation)(nil)

// topmostOption allows management of the mutation configuration using functional options.
type topmostOption func(*TopMostMutation)

// newTopMostMutation creates new mutation for the TopMost entity.
func newTopMostMutation(c config, op Op, opts ...topmostOption) *TopMostMutation {
	m := &TopMostMutation{
		config:        c,
		op:            op,
		typ:           TypeTopMost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopMostID sets the ID field of the mutation.
func withTopMostID(id uint32) topmostOption {
	return func(m *TopMostMutation) {
		var (
			err   error
			once  sync.Once
			value *TopMost
		)
		m.oldValue = func(ctx context.Context) (*TopMost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopMost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopMost sets the old TopMost of the mutation.
func withTopMost(node *TopMost) topmostOption {
	return func(m *TopMostMutation) {
		m.oldValue = func(context.Context) (*TopMost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopMostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopMostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopMost entities.
func (m *TopMostMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopMostMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopMostMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopMost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *TopMostMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *TopMostMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *TopMostMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TopMostMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopMostMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TopMostMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TopMostMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopMostMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopMostMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopMostMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TopMostMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TopMostMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopMostMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TopMostMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TopMostMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TopMostMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TopMostMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TopMostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *TopMostMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *TopMostMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *TopMostMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[topmost.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *TopMostMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[topmost.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *TopMostMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, topmost.FieldAppID)
}

// SetTopMostType sets the "top_most_type" field.
func (m *TopMostMutation) SetTopMostType(s string) {
	m.top_most_type = &s
}

// TopMostType returns the value of the "top_most_type" field in the mutation.
func (m *TopMostMutation) TopMostType() (r string, exists bool) {
	v := m.top_most_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTopMostType returns the old "top_most_type" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldTopMostType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopMostType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopMostType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopMostType: %w", err)
	}
	return oldValue.TopMostType, nil
}

// ClearTopMostType clears the value of the "top_most_type" field.
func (m *TopMostMutation) ClearTopMostType() {
	m.top_most_type = nil
	m.clearedFields[topmost.FieldTopMostType] = struct{}{}
}

// TopMostTypeCleared returns if the "top_most_type" field was cleared in this mutation.
func (m *TopMostMutation) TopMostTypeCleared() bool {
	_, ok := m.clearedFields[topmost.FieldTopMostType]
	return ok
}

// ResetTopMostType resets all changes to the "top_most_type" field.
func (m *TopMostMutation) ResetTopMostType() {
	m.top_most_type = nil
	delete(m.clearedFields, topmost.FieldTopMostType)
}

// SetTitle sets the "title" field.
func (m *TopMostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TopMostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *TopMostMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[topmost.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *TopMostMutation) TitleCleared() bool {
	_, ok := m.clearedFields[topmost.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *TopMostMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, topmost.FieldTitle)
}

// SetMessage sets the "message" field.
func (m *TopMostMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *TopMostMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *TopMostMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[topmost.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *TopMostMutation) MessageCleared() bool {
	_, ok := m.clearedFields[topmost.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *TopMostMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, topmost.FieldMessage)
}

// SetTargetURL sets the "target_url" field.
func (m *TopMostMutation) SetTargetURL(s string) {
	m.target_url = &s
}

// TargetURL returns the value of the "target_url" field in the mutation.
func (m *TopMostMutation) TargetURL() (r string, exists bool) {
	v := m.target_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetURL returns the old "target_url" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldTargetURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetURL: %w", err)
	}
	return oldValue.TargetURL, nil
}

// ClearTargetURL clears the value of the "target_url" field.
func (m *TopMostMutation) ClearTargetURL() {
	m.target_url = nil
	m.clearedFields[topmost.FieldTargetURL] = struct{}{}
}

// TargetURLCleared returns if the "target_url" field was cleared in this mutation.
func (m *TopMostMutation) TargetURLCleared() bool {
	_, ok := m.clearedFields[topmost.FieldTargetURL]
	return ok
}

// ResetTargetURL resets all changes to the "target_url" field.
func (m *TopMostMutation) ResetTargetURL() {
	m.target_url = nil
	delete(m.clearedFields, topmost.FieldTargetURL)
}

// SetStartAt sets the "start_at" field.
func (m *TopMostMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *TopMostMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *TopMostMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *TopMostMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *TopMostMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[topmost.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *TopMostMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[topmost.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *TopMostMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, topmost.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *TopMostMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *TopMostMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *TopMostMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *TopMostMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *TopMostMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[topmost.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *TopMostMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[topmost.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *TopMostMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, topmost.FieldEndAt)
}

// Where appends a list predicates to the TopMostMutation builder.
func (m *TopMostMutation) Where(ps ...predicate.TopMost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopMostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopMostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TopMost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopMostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopMostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TopMost).
func (m *TopMostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopMostMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ent_id != nil {
		fields = append(fields, topmost.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, topmost.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topmost.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, topmost.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, topmost.FieldAppID)
	}
	if m.top_most_type != nil {
		fields = append(fields, topmost.FieldTopMostType)
	}
	if m.title != nil {
		fields = append(fields, topmost.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, topmost.FieldMessage)
	}
	if m.target_url != nil {
		fields = append(fields, topmost.FieldTargetURL)
	}
	if m.start_at != nil {
		fields = append(fields, topmost.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, topmost.FieldEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopMostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topmost.FieldEntID:
		return m.EntID()
	case topmost.FieldCreatedAt:
		return m.CreatedAt()
	case topmost.FieldUpdatedAt:
		return m.UpdatedAt()
	case topmost.FieldDeletedAt:
		return m.DeletedAt()
	case topmost.FieldAppID:
		return m.AppID()
	case topmost.FieldTopMostType:
		return m.TopMostType()
	case topmost.FieldTitle:
		return m.Title()
	case topmost.FieldMessage:
		return m.Message()
	case topmost.FieldTargetURL:
		return m.TargetURL()
	case topmost.FieldStartAt:
		return m.StartAt()
	case topmost.FieldEndAt:
		return m.EndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopMostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topmost.FieldEntID:
		return m.OldEntID(ctx)
	case topmost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topmost.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topmost.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topmost.FieldAppID:
		return m.OldAppID(ctx)
	case topmost.FieldTopMostType:
		return m.OldTopMostType(ctx)
	case topmost.FieldTitle:
		return m.OldTitle(ctx)
	case topmost.FieldMessage:
		return m.OldMessage(ctx)
	case topmost.FieldTargetURL:
		return m.OldTargetURL(ctx)
	case topmost.FieldStartAt:
		return m.OldStartAt(ctx)
	case topmost.FieldEndAt:
		return m.OldEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown TopMost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topmost.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case topmost.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topmost.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topmost.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topmost.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case topmost.FieldTopMostType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopMostType(v)
		return nil
	case topmost.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case topmost.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case topmost.FieldTargetURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetURL(v)
		return nil
	case topmost.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case topmost.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown TopMost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopMostMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, topmost.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, topmost.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, topmost.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, topmost.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, topmost.FieldEndAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopMostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case topmost.FieldCreatedAt:
		return m.AddedCreatedAt()
	case topmost.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case topmost.FieldDeletedAt:
		return m.AddedDeletedAt()
	case topmost.FieldStartAt:
		return m.AddedStartAt()
	case topmost.FieldEndAt:
		return m.AddedEndAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case topmost.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case topmost.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case topmost.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case topmost.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case topmost.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown TopMost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopMostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topmost.FieldAppID) {
		fields = append(fields, topmost.FieldAppID)
	}
	if m.FieldCleared(topmost.FieldTopMostType) {
		fields = append(fields, topmost.FieldTopMostType)
	}
	if m.FieldCleared(topmost.FieldTitle) {
		fields = append(fields, topmost.FieldTitle)
	}
	if m.FieldCleared(topmost.FieldMessage) {
		fields = append(fields, topmost.FieldMessage)
	}
	if m.FieldCleared(topmost.FieldTargetURL) {
		fields = append(fields, topmost.FieldTargetURL)
	}
	if m.FieldCleared(topmost.FieldStartAt) {
		fields = append(fields, topmost.FieldStartAt)
	}
	if m.FieldCleared(topmost.FieldEndAt) {
		fields = append(fields, topmost.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopMostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopMostMutation) ClearField(name string) error {
	switch name {
	case topmost.FieldAppID:
		m.ClearAppID()
		return nil
	case topmost.FieldTopMostType:
		m.ClearTopMostType()
		return nil
	case topmost.FieldTitle:
		m.ClearTitle()
		return nil
	case topmost.FieldMessage:
		m.ClearMessage()
		return nil
	case topmost.FieldTargetURL:
		m.ClearTargetURL()
		return nil
	case topmost.FieldStartAt:
		m.ClearStartAt()
		return nil
	case topmost.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown TopMost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopMostMutation) ResetField(name string) error {
	switch name {
	case topmost.FieldEntID:
		m.ResetEntID()
		return nil
	case topmost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topmost.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topmost.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topmost.FieldAppID:
		m.ResetAppID()
		return nil
	case topmost.FieldTopMostType:
		m.ResetTopMostType()
		return nil
	case topmost.FieldTitle:
		m.ResetTitle()
		return nil
	case topmost.FieldMessage:
		m.ResetMessage()
		return nil
	case topmost.FieldTargetURL:
		m.ResetTargetURL()
		return nil
	case topmost.FieldStartAt:
		m.ResetStartAt()
		return nil
	case topmost.FieldEndAt:
		m.ResetEndAt()
		return nil
	}
	return fmt.Errorf("unknown TopMost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopMostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopMostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopMostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopMostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopMostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopMostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopMostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TopMost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopMostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TopMost edge %s", name)
}

// TopMostConstraintMutation represents an operation that mutates the TopMostConstraint nodes in the graph.
type TopMostConstraintMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	top_most_id   *uuid.UUID
	constraint    *string
	target_value  *decimal.Decimal
	index         *uint8
	addindex      *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TopMostConstraint, error)
	predicates    []predicate.TopMostConstraint
}

var _ ent.Mutation = (*TopMostConstraintMutation)(nil)

// topmostconstraintOption allows management of the mutation configuration using functional options.
type topmostconstraintOption func(*TopMostConstraintMutation)

// newTopMostConstraintMutation creates new mutation for the TopMostConstraint entity.
func newTopMostConstraintMutation(c config, op Op, opts ...topmostconstraintOption) *TopMostConstraintMutation {
	m := &TopMostConstraintMutation{
		config:        c,
		op:            op,
		typ:           TypeTopMostConstraint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopMostConstraintID sets the ID field of the mutation.
func withTopMostConstraintID(id uint32) topmostconstraintOption {
	return func(m *TopMostConstraintMutation) {
		var (
			err   error
			once  sync.Once
			value *TopMostConstraint
		)
		m.oldValue = func(ctx context.Context) (*TopMostConstraint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopMostConstraint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopMostConstraint sets the old TopMostConstraint of the mutation.
func withTopMostConstraint(node *TopMostConstraint) topmostconstraintOption {
	return func(m *TopMostConstraintMutation) {
		m.oldValue = func(context.Context) (*TopMostConstraint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopMostConstraintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopMostConstraintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopMostConstraint entities.
func (m *TopMostConstraintMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopMostConstraintMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopMostConstraintMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopMostConstraint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *TopMostConstraintMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *TopMostConstraintMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the TopMostConstraint entity.
// If the TopMostConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostConstraintMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *TopMostConstraintMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TopMostConstraintMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopMostConstraintMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TopMostConstraint entity.
// If the TopMostConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostConstraintMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TopMostConstraintMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TopMostConstraintMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopMostConstraintMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopMostConstraintMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopMostConstraintMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TopMostConstraint entity.
// If the TopMostConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostConstraintMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TopMostConstraintMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TopMostConstraintMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopMostConstraintMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TopMostConstraintMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TopMostConstraintMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TopMostConstraint entity.
// If the TopMostConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostConstraintMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TopMostConstraintMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TopMostConstraintMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TopMostConstraintMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTopMostID sets the "top_most_id" field.
func (m *TopMostConstraintMutation) SetTopMostID(u uuid.UUID) {
	m.top_most_id = &u
}

// TopMostID returns the value of the "top_most_id" field in the mutation.
func (m *TopMostConstraintMutation) TopMostID() (r uuid.UUID, exists bool) {
	v := m.top_most_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopMostID returns the old "top_most_id" field's value of the TopMostConstraint entity.
// If the TopMostConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostConstraintMutation) OldTopMostID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopMostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopMostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopMostID: %w", err)
	}
	return oldValue.TopMostID, nil
}

// ClearTopMostID clears the value of the "top_most_id" field.
func (m *TopMostConstraintMutation) ClearTopMostID() {
	m.top_most_id = nil
	m.clearedFields[topmostconstraint.FieldTopMostID] = struct{}{}
}

// TopMostIDCleared returns if the "top_most_id" field was cleared in this mutation.
func (m *TopMostConstraintMutation) TopMostIDCleared() bool {
	_, ok := m.clearedFields[topmostconstraint.FieldTopMostID]
	return ok
}

// ResetTopMostID resets all changes to the "top_most_id" field.
func (m *TopMostConstraintMutation) ResetTopMostID() {
	m.top_most_id = nil
	delete(m.clearedFields, topmostconstraint.FieldTopMostID)
}

// SetConstraint sets the "constraint" field.
func (m *TopMostConstraintMutation) SetConstraint(s string) {
	m.constraint = &s
}

// Constraint returns the value of the "constraint" field in the mutation.
func (m *TopMostConstraintMutation) Constraint() (r string, exists bool) {
	v := m.constraint
	if v == nil {
		return
	}
	return *v, true
}

// OldConstraint returns the old "constraint" field's value of the TopMostConstraint entity.
// If the TopMostConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostConstraintMutation) OldConstraint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstraint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstraint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstraint: %w", err)
	}
	return oldValue.Constraint, nil
}

// ClearConstraint clears the value of the "constraint" field.
func (m *TopMostConstraintMutation) ClearConstraint() {
	m.constraint = nil
	m.clearedFields[topmostconstraint.FieldConstraint] = struct{}{}
}

// ConstraintCleared returns if the "constraint" field was cleared in this mutation.
func (m *TopMostConstraintMutation) ConstraintCleared() bool {
	_, ok := m.clearedFields[topmostconstraint.FieldConstraint]
	return ok
}

// ResetConstraint resets all changes to the "constraint" field.
func (m *TopMostConstraintMutation) ResetConstraint() {
	m.constraint = nil
	delete(m.clearedFields, topmostconstraint.FieldConstraint)
}

// SetTargetValue sets the "target_value" field.
func (m *TopMostConstraintMutation) SetTargetValue(d decimal.Decimal) {
	m.target_value = &d
}

// TargetValue returns the value of the "target_value" field in the mutation.
func (m *TopMostConstraintMutation) TargetValue() (r decimal.Decimal, exists bool) {
	v := m.target_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetValue returns the old "target_value" field's value of the TopMostConstraint entity.
// If the TopMostConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostConstraintMutation) OldTargetValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetValue: %w", err)
	}
	return oldValue.TargetValue, nil
}

// ClearTargetValue clears the value of the "target_value" field.
func (m *TopMostConstraintMutation) ClearTargetValue() {
	m.target_value = nil
	m.clearedFields[topmostconstraint.FieldTargetValue] = struct{}{}
}

// TargetValueCleared returns if the "target_value" field was cleared in this mutation.
func (m *TopMostConstraintMutation) TargetValueCleared() bool {
	_, ok := m.clearedFields[topmostconstraint.FieldTargetValue]
	return ok
}

// ResetTargetValue resets all changes to the "target_value" field.
func (m *TopMostConstraintMutation) ResetTargetValue() {
	m.target_value = nil
	delete(m.clearedFields, topmostconstraint.FieldTargetValue)
}

// SetIndex sets the "index" field.
func (m *TopMostConstraintMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *TopMostConstraintMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the TopMostConstraint entity.
// If the TopMostConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostConstraintMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *TopMostConstraintMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *TopMostConstraintMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *TopMostConstraintMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[topmostconstraint.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *TopMostConstraintMutation) IndexCleared() bool {
	_, ok := m.clearedFields[topmostconstraint.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *TopMostConstraintMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, topmostconstraint.FieldIndex)
}

// Where appends a list predicates to the TopMostConstraintMutation builder.
func (m *TopMostConstraintMutation) Where(ps ...predicate.TopMostConstraint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopMostConstraintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopMostConstraintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TopMostConstraint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopMostConstraintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopMostConstraintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TopMostConstraint).
func (m *TopMostConstraintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopMostConstraintMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, topmostconstraint.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, topmostconstraint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topmostconstraint.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, topmostconstraint.FieldDeletedAt)
	}
	if m.top_most_id != nil {
		fields = append(fields, topmostconstraint.FieldTopMostID)
	}
	if m.constraint != nil {
		fields = append(fields, topmostconstraint.FieldConstraint)
	}
	if m.target_value != nil {
		fields = append(fields, topmostconstraint.FieldTargetValue)
	}
	if m.index != nil {
		fields = append(fields, topmostconstraint.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopMostConstraintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topmostconstraint.FieldEntID:
		return m.EntID()
	case topmostconstraint.FieldCreatedAt:
		return m.CreatedAt()
	case topmostconstraint.FieldUpdatedAt:
		return m.UpdatedAt()
	case topmostconstraint.FieldDeletedAt:
		return m.DeletedAt()
	case topmostconstraint.FieldTopMostID:
		return m.TopMostID()
	case topmostconstraint.FieldConstraint:
		return m.Constraint()
	case topmostconstraint.FieldTargetValue:
		return m.TargetValue()
	case topmostconstraint.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopMostConstraintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topmostconstraint.FieldEntID:
		return m.OldEntID(ctx)
	case topmostconstraint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topmostconstraint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topmostconstraint.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topmostconstraint.FieldTopMostID:
		return m.OldTopMostID(ctx)
	case topmostconstraint.FieldConstraint:
		return m.OldConstraint(ctx)
	case topmostconstraint.FieldTargetValue:
		return m.OldTargetValue(ctx)
	case topmostconstraint.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown TopMostConstraint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostConstraintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topmostconstraint.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case topmostconstraint.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topmostconstraint.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topmostconstraint.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topmostconstraint.FieldTopMostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopMostID(v)
		return nil
	case topmostconstraint.FieldConstraint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstraint(v)
		return nil
	case topmostconstraint.FieldTargetValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetValue(v)
		return nil
	case topmostconstraint.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostConstraint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopMostConstraintMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, topmostconstraint.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, topmostconstraint.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, topmostconstraint.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, topmostconstraint.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopMostConstraintMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case topmostconstraint.FieldCreatedAt:
		return m.AddedCreatedAt()
	case topmostconstraint.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case topmostconstraint.FieldDeletedAt:
		return m.AddedDeletedAt()
	case topmostconstraint.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostConstraintMutation) AddField(name string, value ent.Value) error {
	switch name {
	case topmostconstraint.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case topmostconstraint.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case topmostconstraint.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case topmostconstraint.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostConstraint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopMostConstraintMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topmostconstraint.FieldTopMostID) {
		fields = append(fields, topmostconstraint.FieldTopMostID)
	}
	if m.FieldCleared(topmostconstraint.FieldConstraint) {
		fields = append(fields, topmostconstraint.FieldConstraint)
	}
	if m.FieldCleared(topmostconstraint.FieldTargetValue) {
		fields = append(fields, topmostconstraint.FieldTargetValue)
	}
	if m.FieldCleared(topmostconstraint.FieldIndex) {
		fields = append(fields, topmostconstraint.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopMostConstraintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopMostConstraintMutation) ClearField(name string) error {
	switch name {
	case topmostconstraint.FieldTopMostID:
		m.ClearTopMostID()
		return nil
	case topmostconstraint.FieldConstraint:
		m.ClearConstraint()
		return nil
	case topmostconstraint.FieldTargetValue:
		m.ClearTargetValue()
		return nil
	case topmostconstraint.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown TopMostConstraint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopMostConstraintMutation) ResetField(name string) error {
	switch name {
	case topmostconstraint.FieldEntID:
		m.ResetEntID()
		return nil
	case topmostconstraint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topmostconstraint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topmostconstraint.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topmostconstraint.FieldTopMostID:
		m.ResetTopMostID()
		return nil
	case topmostconstraint.FieldConstraint:
		m.ResetConstraint()
		return nil
	case topmostconstraint.FieldTargetValue:
		m.ResetTargetValue()
		return nil
	case topmostconstraint.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown TopMostConstraint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopMostConstraintMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopMostConstraintMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopMostConstraintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopMostConstraintMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopMostConstraintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopMostConstraintMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopMostConstraintMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TopMostConstraint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopMostConstraintMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TopMostConstraint edge %s", name)
}

// TopMostGoodMutation represents an operation that mutates the TopMostGood nodes in the graph.
type TopMostGoodMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	ent_id           *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	app_good_id      *uuid.UUID
	top_most_id      *uuid.UUID
	display_index    *uint32
	adddisplay_index *int32
	unit_price       *decimal.Decimal
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TopMostGood, error)
	predicates       []predicate.TopMostGood
}

var _ ent.Mutation = (*TopMostGoodMutation)(nil)

// topmostgoodOption allows management of the mutation configuration using functional options.
type topmostgoodOption func(*TopMostGoodMutation)

// newTopMostGoodMutation creates new mutation for the TopMostGood entity.
func newTopMostGoodMutation(c config, op Op, opts ...topmostgoodOption) *TopMostGoodMutation {
	m := &TopMostGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeTopMostGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopMostGoodID sets the ID field of the mutation.
func withTopMostGoodID(id uint32) topmostgoodOption {
	return func(m *TopMostGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *TopMostGood
		)
		m.oldValue = func(ctx context.Context) (*TopMostGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopMostGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopMostGood sets the old TopMostGood of the mutation.
func withTopMostGood(node *TopMostGood) topmostgoodOption {
	return func(m *TopMostGoodMutation) {
		m.oldValue = func(context.Context) (*TopMostGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopMostGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopMostGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopMostGood entities.
func (m *TopMostGoodMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopMostGoodMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopMostGoodMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopMostGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *TopMostGoodMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *TopMostGoodMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *TopMostGoodMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TopMostGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopMostGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TopMostGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TopMostGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopMostGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopMostGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopMostGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TopMostGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TopMostGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopMostGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TopMostGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TopMostGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TopMostGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TopMostGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TopMostGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *TopMostGoodMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *TopMostGoodMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *TopMostGoodMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[topmostgood.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *TopMostGoodMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[topmostgood.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *TopMostGoodMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, topmostgood.FieldAppGoodID)
}

// SetTopMostID sets the "top_most_id" field.
func (m *TopMostGoodMutation) SetTopMostID(u uuid.UUID) {
	m.top_most_id = &u
}

// TopMostID returns the value of the "top_most_id" field in the mutation.
func (m *TopMostGoodMutation) TopMostID() (r uuid.UUID, exists bool) {
	v := m.top_most_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopMostID returns the old "top_most_id" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldTopMostID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopMostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopMostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopMostID: %w", err)
	}
	return oldValue.TopMostID, nil
}

// ClearTopMostID clears the value of the "top_most_id" field.
func (m *TopMostGoodMutation) ClearTopMostID() {
	m.top_most_id = nil
	m.clearedFields[topmostgood.FieldTopMostID] = struct{}{}
}

// TopMostIDCleared returns if the "top_most_id" field was cleared in this mutation.
func (m *TopMostGoodMutation) TopMostIDCleared() bool {
	_, ok := m.clearedFields[topmostgood.FieldTopMostID]
	return ok
}

// ResetTopMostID resets all changes to the "top_most_id" field.
func (m *TopMostGoodMutation) ResetTopMostID() {
	m.top_most_id = nil
	delete(m.clearedFields, topmostgood.FieldTopMostID)
}

// SetDisplayIndex sets the "display_index" field.
func (m *TopMostGoodMutation) SetDisplayIndex(u uint32) {
	m.display_index = &u
	m.adddisplay_index = nil
}

// DisplayIndex returns the value of the "display_index" field in the mutation.
func (m *TopMostGoodMutation) DisplayIndex() (r uint32, exists bool) {
	v := m.display_index
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayIndex returns the old "display_index" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldDisplayIndex(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayIndex: %w", err)
	}
	return oldValue.DisplayIndex, nil
}

// AddDisplayIndex adds u to the "display_index" field.
func (m *TopMostGoodMutation) AddDisplayIndex(u int32) {
	if m.adddisplay_index != nil {
		*m.adddisplay_index += u
	} else {
		m.adddisplay_index = &u
	}
}

// AddedDisplayIndex returns the value that was added to the "display_index" field in this mutation.
func (m *TopMostGoodMutation) AddedDisplayIndex() (r int32, exists bool) {
	v := m.adddisplay_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayIndex clears the value of the "display_index" field.
func (m *TopMostGoodMutation) ClearDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	m.clearedFields[topmostgood.FieldDisplayIndex] = struct{}{}
}

// DisplayIndexCleared returns if the "display_index" field was cleared in this mutation.
func (m *TopMostGoodMutation) DisplayIndexCleared() bool {
	_, ok := m.clearedFields[topmostgood.FieldDisplayIndex]
	return ok
}

// ResetDisplayIndex resets all changes to the "display_index" field.
func (m *TopMostGoodMutation) ResetDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	delete(m.clearedFields, topmostgood.FieldDisplayIndex)
}

// SetUnitPrice sets the "unit_price" field.
func (m *TopMostGoodMutation) SetUnitPrice(d decimal.Decimal) {
	m.unit_price = &d
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *TopMostGoodMutation) UnitPrice() (r decimal.Decimal, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldUnitPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// ClearUnitPrice clears the value of the "unit_price" field.
func (m *TopMostGoodMutation) ClearUnitPrice() {
	m.unit_price = nil
	m.clearedFields[topmostgood.FieldUnitPrice] = struct{}{}
}

// UnitPriceCleared returns if the "unit_price" field was cleared in this mutation.
func (m *TopMostGoodMutation) UnitPriceCleared() bool {
	_, ok := m.clearedFields[topmostgood.FieldUnitPrice]
	return ok
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *TopMostGoodMutation) ResetUnitPrice() {
	m.unit_price = nil
	delete(m.clearedFields, topmostgood.FieldUnitPrice)
}

// Where appends a list predicates to the TopMostGoodMutation builder.
func (m *TopMostGoodMutation) Where(ps ...predicate.TopMostGood) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopMostGoodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopMostGoodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TopMostGood, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopMostGoodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopMostGoodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TopMostGood).
func (m *TopMostGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopMostGoodMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, topmostgood.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, topmostgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topmostgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, topmostgood.FieldDeletedAt)
	}
	if m.app_good_id != nil {
		fields = append(fields, topmostgood.FieldAppGoodID)
	}
	if m.top_most_id != nil {
		fields = append(fields, topmostgood.FieldTopMostID)
	}
	if m.display_index != nil {
		fields = append(fields, topmostgood.FieldDisplayIndex)
	}
	if m.unit_price != nil {
		fields = append(fields, topmostgood.FieldUnitPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopMostGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topmostgood.FieldEntID:
		return m.EntID()
	case topmostgood.FieldCreatedAt:
		return m.CreatedAt()
	case topmostgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case topmostgood.FieldDeletedAt:
		return m.DeletedAt()
	case topmostgood.FieldAppGoodID:
		return m.AppGoodID()
	case topmostgood.FieldTopMostID:
		return m.TopMostID()
	case topmostgood.FieldDisplayIndex:
		return m.DisplayIndex()
	case topmostgood.FieldUnitPrice:
		return m.UnitPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopMostGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topmostgood.FieldEntID:
		return m.OldEntID(ctx)
	case topmostgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topmostgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topmostgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topmostgood.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case topmostgood.FieldTopMostID:
		return m.OldTopMostID(ctx)
	case topmostgood.FieldDisplayIndex:
		return m.OldDisplayIndex(ctx)
	case topmostgood.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	}
	return nil, fmt.Errorf("unknown TopMostGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topmostgood.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case topmostgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topmostgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topmostgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topmostgood.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case topmostgood.FieldTopMostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopMostID(v)
		return nil
	case topmostgood.FieldDisplayIndex:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayIndex(v)
		return nil
	case topmostgood.FieldUnitPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopMostGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, topmostgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, topmostgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, topmostgood.FieldDeletedAt)
	}
	if m.adddisplay_index != nil {
		fields = append(fields, topmostgood.FieldDisplayIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopMostGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case topmostgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case topmostgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case topmostgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	case topmostgood.FieldDisplayIndex:
		return m.AddedDisplayIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case topmostgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case topmostgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case topmostgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case topmostgood.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopMostGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topmostgood.FieldAppGoodID) {
		fields = append(fields, topmostgood.FieldAppGoodID)
	}
	if m.FieldCleared(topmostgood.FieldTopMostID) {
		fields = append(fields, topmostgood.FieldTopMostID)
	}
	if m.FieldCleared(topmostgood.FieldDisplayIndex) {
		fields = append(fields, topmostgood.FieldDisplayIndex)
	}
	if m.FieldCleared(topmostgood.FieldUnitPrice) {
		fields = append(fields, topmostgood.FieldUnitPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopMostGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopMostGoodMutation) ClearField(name string) error {
	switch name {
	case topmostgood.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case topmostgood.FieldTopMostID:
		m.ClearTopMostID()
		return nil
	case topmostgood.FieldDisplayIndex:
		m.ClearDisplayIndex()
		return nil
	case topmostgood.FieldUnitPrice:
		m.ClearUnitPrice()
		return nil
	}
	return fmt.Errorf("unknown TopMostGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopMostGoodMutation) ResetField(name string) error {
	switch name {
	case topmostgood.FieldEntID:
		m.ResetEntID()
		return nil
	case topmostgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topmostgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topmostgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topmostgood.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case topmostgood.FieldTopMostID:
		m.ResetTopMostID()
		return nil
	case topmostgood.FieldDisplayIndex:
		m.ResetDisplayIndex()
		return nil
	case topmostgood.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	}
	return fmt.Errorf("unknown TopMostGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopMostGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopMostGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopMostGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopMostGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopMostGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopMostGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopMostGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TopMostGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopMostGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TopMostGood edge %s", name)
}

// TopMostGoodConstraintMutation represents an operation that mutates the TopMostGoodConstraint nodes in the graph.
type TopMostGoodConstraintMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	ent_id           *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	top_most_good_id *uuid.UUID
	constraint       *string
	target_value     *decimal.Decimal
	index            *uint8
	addindex         *int8
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TopMostGoodConstraint, error)
	predicates       []predicate.TopMostGoodConstraint
}

var _ ent.Mutation = (*TopMostGoodConstraintMutation)(nil)

// topmostgoodconstraintOption allows management of the mutation configuration using functional options.
type topmostgoodconstraintOption func(*TopMostGoodConstraintMutation)

// newTopMostGoodConstraintMutation creates new mutation for the TopMostGoodConstraint entity.
func newTopMostGoodConstraintMutation(c config, op Op, opts ...topmostgoodconstraintOption) *TopMostGoodConstraintMutation {
	m := &TopMostGoodConstraintMutation{
		config:        c,
		op:            op,
		typ:           TypeTopMostGoodConstraint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopMostGoodConstraintID sets the ID field of the mutation.
func withTopMostGoodConstraintID(id uint32) topmostgoodconstraintOption {
	return func(m *TopMostGoodConstraintMutation) {
		var (
			err   error
			once  sync.Once
			value *TopMostGoodConstraint
		)
		m.oldValue = func(ctx context.Context) (*TopMostGoodConstraint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopMostGoodConstraint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopMostGoodConstraint sets the old TopMostGoodConstraint of the mutation.
func withTopMostGoodConstraint(node *TopMostGoodConstraint) topmostgoodconstraintOption {
	return func(m *TopMostGoodConstraintMutation) {
		m.oldValue = func(context.Context) (*TopMostGoodConstraint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopMostGoodConstraintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopMostGoodConstraintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopMostGoodConstraint entities.
func (m *TopMostGoodConstraintMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopMostGoodConstraintMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopMostGoodConstraintMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopMostGoodConstraint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *TopMostGoodConstraintMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *TopMostGoodConstraintMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the TopMostGoodConstraint entity.
// If the TopMostGoodConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodConstraintMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *TopMostGoodConstraintMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TopMostGoodConstraintMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopMostGoodConstraintMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TopMostGoodConstraint entity.
// If the TopMostGoodConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodConstraintMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TopMostGoodConstraintMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TopMostGoodConstraintMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopMostGoodConstraintMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopMostGoodConstraintMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopMostGoodConstraintMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TopMostGoodConstraint entity.
// If the TopMostGoodConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodConstraintMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TopMostGoodConstraintMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TopMostGoodConstraintMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopMostGoodConstraintMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TopMostGoodConstraintMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TopMostGoodConstraintMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TopMostGoodConstraint entity.
// If the TopMostGoodConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodConstraintMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TopMostGoodConstraintMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TopMostGoodConstraintMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TopMostGoodConstraintMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTopMostGoodID sets the "top_most_good_id" field.
func (m *TopMostGoodConstraintMutation) SetTopMostGoodID(u uuid.UUID) {
	m.top_most_good_id = &u
}

// TopMostGoodID returns the value of the "top_most_good_id" field in the mutation.
func (m *TopMostGoodConstraintMutation) TopMostGoodID() (r uuid.UUID, exists bool) {
	v := m.top_most_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopMostGoodID returns the old "top_most_good_id" field's value of the TopMostGoodConstraint entity.
// If the TopMostGoodConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodConstraintMutation) OldTopMostGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopMostGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopMostGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopMostGoodID: %w", err)
	}
	return oldValue.TopMostGoodID, nil
}

// ClearTopMostGoodID clears the value of the "top_most_good_id" field.
func (m *TopMostGoodConstraintMutation) ClearTopMostGoodID() {
	m.top_most_good_id = nil
	m.clearedFields[topmostgoodconstraint.FieldTopMostGoodID] = struct{}{}
}

// TopMostGoodIDCleared returns if the "top_most_good_id" field was cleared in this mutation.
func (m *TopMostGoodConstraintMutation) TopMostGoodIDCleared() bool {
	_, ok := m.clearedFields[topmostgoodconstraint.FieldTopMostGoodID]
	return ok
}

// ResetTopMostGoodID resets all changes to the "top_most_good_id" field.
func (m *TopMostGoodConstraintMutation) ResetTopMostGoodID() {
	m.top_most_good_id = nil
	delete(m.clearedFields, topmostgoodconstraint.FieldTopMostGoodID)
}

// SetConstraint sets the "constraint" field.
func (m *TopMostGoodConstraintMutation) SetConstraint(s string) {
	m.constraint = &s
}

// Constraint returns the value of the "constraint" field in the mutation.
func (m *TopMostGoodConstraintMutation) Constraint() (r string, exists bool) {
	v := m.constraint
	if v == nil {
		return
	}
	return *v, true
}

// OldConstraint returns the old "constraint" field's value of the TopMostGoodConstraint entity.
// If the TopMostGoodConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodConstraintMutation) OldConstraint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstraint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstraint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstraint: %w", err)
	}
	return oldValue.Constraint, nil
}

// ClearConstraint clears the value of the "constraint" field.
func (m *TopMostGoodConstraintMutation) ClearConstraint() {
	m.constraint = nil
	m.clearedFields[topmostgoodconstraint.FieldConstraint] = struct{}{}
}

// ConstraintCleared returns if the "constraint" field was cleared in this mutation.
func (m *TopMostGoodConstraintMutation) ConstraintCleared() bool {
	_, ok := m.clearedFields[topmostgoodconstraint.FieldConstraint]
	return ok
}

// ResetConstraint resets all changes to the "constraint" field.
func (m *TopMostGoodConstraintMutation) ResetConstraint() {
	m.constraint = nil
	delete(m.clearedFields, topmostgoodconstraint.FieldConstraint)
}

// SetTargetValue sets the "target_value" field.
func (m *TopMostGoodConstraintMutation) SetTargetValue(d decimal.Decimal) {
	m.target_value = &d
}

// TargetValue returns the value of the "target_value" field in the mutation.
func (m *TopMostGoodConstraintMutation) TargetValue() (r decimal.Decimal, exists bool) {
	v := m.target_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetValue returns the old "target_value" field's value of the TopMostGoodConstraint entity.
// If the TopMostGoodConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodConstraintMutation) OldTargetValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetValue: %w", err)
	}
	return oldValue.TargetValue, nil
}

// ClearTargetValue clears the value of the "target_value" field.
func (m *TopMostGoodConstraintMutation) ClearTargetValue() {
	m.target_value = nil
	m.clearedFields[topmostgoodconstraint.FieldTargetValue] = struct{}{}
}

// TargetValueCleared returns if the "target_value" field was cleared in this mutation.
func (m *TopMostGoodConstraintMutation) TargetValueCleared() bool {
	_, ok := m.clearedFields[topmostgoodconstraint.FieldTargetValue]
	return ok
}

// ResetTargetValue resets all changes to the "target_value" field.
func (m *TopMostGoodConstraintMutation) ResetTargetValue() {
	m.target_value = nil
	delete(m.clearedFields, topmostgoodconstraint.FieldTargetValue)
}

// SetIndex sets the "index" field.
func (m *TopMostGoodConstraintMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *TopMostGoodConstraintMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the TopMostGoodConstraint entity.
// If the TopMostGoodConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodConstraintMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *TopMostGoodConstraintMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *TopMostGoodConstraintMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *TopMostGoodConstraintMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[topmostgoodconstraint.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *TopMostGoodConstraintMutation) IndexCleared() bool {
	_, ok := m.clearedFields[topmostgoodconstraint.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *TopMostGoodConstraintMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, topmostgoodconstraint.FieldIndex)
}

// Where appends a list predicates to the TopMostGoodConstraintMutation builder.
func (m *TopMostGoodConstraintMutation) Where(ps ...predicate.TopMostGoodConstraint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopMostGoodConstraintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopMostGoodConstraintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TopMostGoodConstraint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopMostGoodConstraintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopMostGoodConstraintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TopMostGoodConstraint).
func (m *TopMostGoodConstraintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopMostGoodConstraintMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.ent_id != nil {
		fields = append(fields, topmostgoodconstraint.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, topmostgoodconstraint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topmostgoodconstraint.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, topmostgoodconstraint.FieldDeletedAt)
	}
	if m.top_most_good_id != nil {
		fields = append(fields, topmostgoodconstraint.FieldTopMostGoodID)
	}
	if m.constraint != nil {
		fields = append(fields, topmostgoodconstraint.FieldConstraint)
	}
	if m.target_value != nil {
		fields = append(fields, topmostgoodconstraint.FieldTargetValue)
	}
	if m.index != nil {
		fields = append(fields, topmostgoodconstraint.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopMostGoodConstraintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topmostgoodconstraint.FieldEntID:
		return m.EntID()
	case topmostgoodconstraint.FieldCreatedAt:
		return m.CreatedAt()
	case topmostgoodconstraint.FieldUpdatedAt:
		return m.UpdatedAt()
	case topmostgoodconstraint.FieldDeletedAt:
		return m.DeletedAt()
	case topmostgoodconstraint.FieldTopMostGoodID:
		return m.TopMostGoodID()
	case topmostgoodconstraint.FieldConstraint:
		return m.Constraint()
	case topmostgoodconstraint.FieldTargetValue:
		return m.TargetValue()
	case topmostgoodconstraint.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopMostGoodConstraintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topmostgoodconstraint.FieldEntID:
		return m.OldEntID(ctx)
	case topmostgoodconstraint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topmostgoodconstraint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topmostgoodconstraint.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topmostgoodconstraint.FieldTopMostGoodID:
		return m.OldTopMostGoodID(ctx)
	case topmostgoodconstraint.FieldConstraint:
		return m.OldConstraint(ctx)
	case topmostgoodconstraint.FieldTargetValue:
		return m.OldTargetValue(ctx)
	case topmostgoodconstraint.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown TopMostGoodConstraint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostGoodConstraintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topmostgoodconstraint.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case topmostgoodconstraint.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topmostgoodconstraint.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topmostgoodconstraint.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topmostgoodconstraint.FieldTopMostGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopMostGoodID(v)
		return nil
	case topmostgoodconstraint.FieldConstraint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstraint(v)
		return nil
	case topmostgoodconstraint.FieldTargetValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetValue(v)
		return nil
	case topmostgoodconstraint.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostGoodConstraint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopMostGoodConstraintMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, topmostgoodconstraint.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, topmostgoodconstraint.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, topmostgoodconstraint.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, topmostgoodconstraint.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopMostGoodConstraintMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case topmostgoodconstraint.FieldCreatedAt:
		return m.AddedCreatedAt()
	case topmostgoodconstraint.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case topmostgoodconstraint.FieldDeletedAt:
		return m.AddedDeletedAt()
	case topmostgoodconstraint.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostGoodConstraintMutation) AddField(name string, value ent.Value) error {
	switch name {
	case topmostgoodconstraint.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case topmostgoodconstraint.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case topmostgoodconstraint.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case topmostgoodconstraint.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostGoodConstraint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopMostGoodConstraintMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topmostgoodconstraint.FieldTopMostGoodID) {
		fields = append(fields, topmostgoodconstraint.FieldTopMostGoodID)
	}
	if m.FieldCleared(topmostgoodconstraint.FieldConstraint) {
		fields = append(fields, topmostgoodconstraint.FieldConstraint)
	}
	if m.FieldCleared(topmostgoodconstraint.FieldTargetValue) {
		fields = append(fields, topmostgoodconstraint.FieldTargetValue)
	}
	if m.FieldCleared(topmostgoodconstraint.FieldIndex) {
		fields = append(fields, topmostgoodconstraint.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopMostGoodConstraintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopMostGoodConstraintMutation) ClearField(name string) error {
	switch name {
	case topmostgoodconstraint.FieldTopMostGoodID:
		m.ClearTopMostGoodID()
		return nil
	case topmostgoodconstraint.FieldConstraint:
		m.ClearConstraint()
		return nil
	case topmostgoodconstraint.FieldTargetValue:
		m.ClearTargetValue()
		return nil
	case topmostgoodconstraint.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown TopMostGoodConstraint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopMostGoodConstraintMutation) ResetField(name string) error {
	switch name {
	case topmostgoodconstraint.FieldEntID:
		m.ResetEntID()
		return nil
	case topmostgoodconstraint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topmostgoodconstraint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topmostgoodconstraint.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topmostgoodconstraint.FieldTopMostGoodID:
		m.ResetTopMostGoodID()
		return nil
	case topmostgoodconstraint.FieldConstraint:
		m.ResetConstraint()
		return nil
	case topmostgoodconstraint.FieldTargetValue:
		m.ResetTargetValue()
		return nil
	case topmostgoodconstraint.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown TopMostGoodConstraint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopMostGoodConstraintMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopMostGoodConstraintMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopMostGoodConstraintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopMostGoodConstraintMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopMostGoodConstraintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopMostGoodConstraintMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopMostGoodConstraintMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TopMostGoodConstraint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopMostGoodConstraintMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TopMostGoodConstraint edge %s", name)
}

// TopMostGoodPosterMutation represents an operation that mutates the TopMostGoodPoster nodes in the graph.
type TopMostGoodPosterMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	ent_id           *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	top_most_good_id *uuid.UUID
	poster           *string
	index            *uint8
	addindex         *int8
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TopMostGoodPoster, error)
	predicates       []predicate.TopMostGoodPoster
}

var _ ent.Mutation = (*TopMostGoodPosterMutation)(nil)

// topmostgoodposterOption allows management of the mutation configuration using functional options.
type topmostgoodposterOption func(*TopMostGoodPosterMutation)

// newTopMostGoodPosterMutation creates new mutation for the TopMostGoodPoster entity.
func newTopMostGoodPosterMutation(c config, op Op, opts ...topmostgoodposterOption) *TopMostGoodPosterMutation {
	m := &TopMostGoodPosterMutation{
		config:        c,
		op:            op,
		typ:           TypeTopMostGoodPoster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopMostGoodPosterID sets the ID field of the mutation.
func withTopMostGoodPosterID(id uint32) topmostgoodposterOption {
	return func(m *TopMostGoodPosterMutation) {
		var (
			err   error
			once  sync.Once
			value *TopMostGoodPoster
		)
		m.oldValue = func(ctx context.Context) (*TopMostGoodPoster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopMostGoodPoster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopMostGoodPoster sets the old TopMostGoodPoster of the mutation.
func withTopMostGoodPoster(node *TopMostGoodPoster) topmostgoodposterOption {
	return func(m *TopMostGoodPosterMutation) {
		m.oldValue = func(context.Context) (*TopMostGoodPoster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopMostGoodPosterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopMostGoodPosterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopMostGoodPoster entities.
func (m *TopMostGoodPosterMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopMostGoodPosterMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopMostGoodPosterMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopMostGoodPoster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *TopMostGoodPosterMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *TopMostGoodPosterMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the TopMostGoodPoster entity.
// If the TopMostGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodPosterMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *TopMostGoodPosterMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TopMostGoodPosterMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopMostGoodPosterMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TopMostGoodPoster entity.
// If the TopMostGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodPosterMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TopMostGoodPosterMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TopMostGoodPosterMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopMostGoodPosterMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopMostGoodPosterMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopMostGoodPosterMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TopMostGoodPoster entity.
// If the TopMostGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodPosterMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TopMostGoodPosterMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TopMostGoodPosterMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopMostGoodPosterMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TopMostGoodPosterMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TopMostGoodPosterMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TopMostGoodPoster entity.
// If the TopMostGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodPosterMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TopMostGoodPosterMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TopMostGoodPosterMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TopMostGoodPosterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTopMostGoodID sets the "top_most_good_id" field.
func (m *TopMostGoodPosterMutation) SetTopMostGoodID(u uuid.UUID) {
	m.top_most_good_id = &u
}

// TopMostGoodID returns the value of the "top_most_good_id" field in the mutation.
func (m *TopMostGoodPosterMutation) TopMostGoodID() (r uuid.UUID, exists bool) {
	v := m.top_most_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopMostGoodID returns the old "top_most_good_id" field's value of the TopMostGoodPoster entity.
// If the TopMostGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodPosterMutation) OldTopMostGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopMostGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopMostGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopMostGoodID: %w", err)
	}
	return oldValue.TopMostGoodID, nil
}

// ClearTopMostGoodID clears the value of the "top_most_good_id" field.
func (m *TopMostGoodPosterMutation) ClearTopMostGoodID() {
	m.top_most_good_id = nil
	m.clearedFields[topmostgoodposter.FieldTopMostGoodID] = struct{}{}
}

// TopMostGoodIDCleared returns if the "top_most_good_id" field was cleared in this mutation.
func (m *TopMostGoodPosterMutation) TopMostGoodIDCleared() bool {
	_, ok := m.clearedFields[topmostgoodposter.FieldTopMostGoodID]
	return ok
}

// ResetTopMostGoodID resets all changes to the "top_most_good_id" field.
func (m *TopMostGoodPosterMutation) ResetTopMostGoodID() {
	m.top_most_good_id = nil
	delete(m.clearedFields, topmostgoodposter.FieldTopMostGoodID)
}

// SetPoster sets the "poster" field.
func (m *TopMostGoodPosterMutation) SetPoster(s string) {
	m.poster = &s
}

// Poster returns the value of the "poster" field in the mutation.
func (m *TopMostGoodPosterMutation) Poster() (r string, exists bool) {
	v := m.poster
	if v == nil {
		return
	}
	return *v, true
}

// OldPoster returns the old "poster" field's value of the TopMostGoodPoster entity.
// If the TopMostGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodPosterMutation) OldPoster(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoster: %w", err)
	}
	return oldValue.Poster, nil
}

// ClearPoster clears the value of the "poster" field.
func (m *TopMostGoodPosterMutation) ClearPoster() {
	m.poster = nil
	m.clearedFields[topmostgoodposter.FieldPoster] = struct{}{}
}

// PosterCleared returns if the "poster" field was cleared in this mutation.
func (m *TopMostGoodPosterMutation) PosterCleared() bool {
	_, ok := m.clearedFields[topmostgoodposter.FieldPoster]
	return ok
}

// ResetPoster resets all changes to the "poster" field.
func (m *TopMostGoodPosterMutation) ResetPoster() {
	m.poster = nil
	delete(m.clearedFields, topmostgoodposter.FieldPoster)
}

// SetIndex sets the "index" field.
func (m *TopMostGoodPosterMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *TopMostGoodPosterMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the TopMostGoodPoster entity.
// If the TopMostGoodPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodPosterMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *TopMostGoodPosterMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *TopMostGoodPosterMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *TopMostGoodPosterMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[topmostgoodposter.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *TopMostGoodPosterMutation) IndexCleared() bool {
	_, ok := m.clearedFields[topmostgoodposter.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *TopMostGoodPosterMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, topmostgoodposter.FieldIndex)
}

// Where appends a list predicates to the TopMostGoodPosterMutation builder.
func (m *TopMostGoodPosterMutation) Where(ps ...predicate.TopMostGoodPoster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopMostGoodPosterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopMostGoodPosterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TopMostGoodPoster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopMostGoodPosterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopMostGoodPosterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TopMostGoodPoster).
func (m *TopMostGoodPosterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopMostGoodPosterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, topmostgoodposter.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, topmostgoodposter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topmostgoodposter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, topmostgoodposter.FieldDeletedAt)
	}
	if m.top_most_good_id != nil {
		fields = append(fields, topmostgoodposter.FieldTopMostGoodID)
	}
	if m.poster != nil {
		fields = append(fields, topmostgoodposter.FieldPoster)
	}
	if m.index != nil {
		fields = append(fields, topmostgoodposter.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopMostGoodPosterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topmostgoodposter.FieldEntID:
		return m.EntID()
	case topmostgoodposter.FieldCreatedAt:
		return m.CreatedAt()
	case topmostgoodposter.FieldUpdatedAt:
		return m.UpdatedAt()
	case topmostgoodposter.FieldDeletedAt:
		return m.DeletedAt()
	case topmostgoodposter.FieldTopMostGoodID:
		return m.TopMostGoodID()
	case topmostgoodposter.FieldPoster:
		return m.Poster()
	case topmostgoodposter.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopMostGoodPosterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topmostgoodposter.FieldEntID:
		return m.OldEntID(ctx)
	case topmostgoodposter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topmostgoodposter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topmostgoodposter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topmostgoodposter.FieldTopMostGoodID:
		return m.OldTopMostGoodID(ctx)
	case topmostgoodposter.FieldPoster:
		return m.OldPoster(ctx)
	case topmostgoodposter.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown TopMostGoodPoster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostGoodPosterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topmostgoodposter.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case topmostgoodposter.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topmostgoodposter.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topmostgoodposter.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topmostgoodposter.FieldTopMostGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopMostGoodID(v)
		return nil
	case topmostgoodposter.FieldPoster:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoster(v)
		return nil
	case topmostgoodposter.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostGoodPoster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopMostGoodPosterMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, topmostgoodposter.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, topmostgoodposter.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, topmostgoodposter.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, topmostgoodposter.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopMostGoodPosterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case topmostgoodposter.FieldCreatedAt:
		return m.AddedCreatedAt()
	case topmostgoodposter.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case topmostgoodposter.FieldDeletedAt:
		return m.AddedDeletedAt()
	case topmostgoodposter.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostGoodPosterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case topmostgoodposter.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case topmostgoodposter.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case topmostgoodposter.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case topmostgoodposter.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostGoodPoster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopMostGoodPosterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topmostgoodposter.FieldTopMostGoodID) {
		fields = append(fields, topmostgoodposter.FieldTopMostGoodID)
	}
	if m.FieldCleared(topmostgoodposter.FieldPoster) {
		fields = append(fields, topmostgoodposter.FieldPoster)
	}
	if m.FieldCleared(topmostgoodposter.FieldIndex) {
		fields = append(fields, topmostgoodposter.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopMostGoodPosterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopMostGoodPosterMutation) ClearField(name string) error {
	switch name {
	case topmostgoodposter.FieldTopMostGoodID:
		m.ClearTopMostGoodID()
		return nil
	case topmostgoodposter.FieldPoster:
		m.ClearPoster()
		return nil
	case topmostgoodposter.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown TopMostGoodPoster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopMostGoodPosterMutation) ResetField(name string) error {
	switch name {
	case topmostgoodposter.FieldEntID:
		m.ResetEntID()
		return nil
	case topmostgoodposter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topmostgoodposter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topmostgoodposter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topmostgoodposter.FieldTopMostGoodID:
		m.ResetTopMostGoodID()
		return nil
	case topmostgoodposter.FieldPoster:
		m.ResetPoster()
		return nil
	case topmostgoodposter.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown TopMostGoodPoster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopMostGoodPosterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopMostGoodPosterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopMostGoodPosterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopMostGoodPosterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopMostGoodPosterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopMostGoodPosterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopMostGoodPosterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TopMostGoodPoster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopMostGoodPosterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TopMostGoodPoster edge %s", name)
}

// TopMostPosterMutation represents an operation that mutates the TopMostPoster nodes in the graph.
type TopMostPosterMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	top_most_id   *uuid.UUID
	poster        *string
	index         *uint8
	addindex      *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TopMostPoster, error)
	predicates    []predicate.TopMostPoster
}

var _ ent.Mutation = (*TopMostPosterMutation)(nil)

// topmostposterOption allows management of the mutation configuration using functional options.
type topmostposterOption func(*TopMostPosterMutation)

// newTopMostPosterMutation creates new mutation for the TopMostPoster entity.
func newTopMostPosterMutation(c config, op Op, opts ...topmostposterOption) *TopMostPosterMutation {
	m := &TopMostPosterMutation{
		config:        c,
		op:            op,
		typ:           TypeTopMostPoster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopMostPosterID sets the ID field of the mutation.
func withTopMostPosterID(id uint32) topmostposterOption {
	return func(m *TopMostPosterMutation) {
		var (
			err   error
			once  sync.Once
			value *TopMostPoster
		)
		m.oldValue = func(ctx context.Context) (*TopMostPoster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopMostPoster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopMostPoster sets the old TopMostPoster of the mutation.
func withTopMostPoster(node *TopMostPoster) topmostposterOption {
	return func(m *TopMostPosterMutation) {
		m.oldValue = func(context.Context) (*TopMostPoster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopMostPosterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopMostPosterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopMostPoster entities.
func (m *TopMostPosterMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopMostPosterMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopMostPosterMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopMostPoster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *TopMostPosterMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *TopMostPosterMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the TopMostPoster entity.
// If the TopMostPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostPosterMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *TopMostPosterMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TopMostPosterMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopMostPosterMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TopMostPoster entity.
// If the TopMostPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostPosterMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TopMostPosterMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TopMostPosterMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopMostPosterMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopMostPosterMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopMostPosterMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TopMostPoster entity.
// If the TopMostPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostPosterMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TopMostPosterMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TopMostPosterMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopMostPosterMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TopMostPosterMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TopMostPosterMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TopMostPoster entity.
// If the TopMostPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostPosterMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TopMostPosterMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TopMostPosterMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TopMostPosterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTopMostID sets the "top_most_id" field.
func (m *TopMostPosterMutation) SetTopMostID(u uuid.UUID) {
	m.top_most_id = &u
}

// TopMostID returns the value of the "top_most_id" field in the mutation.
func (m *TopMostPosterMutation) TopMostID() (r uuid.UUID, exists bool) {
	v := m.top_most_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopMostID returns the old "top_most_id" field's value of the TopMostPoster entity.
// If the TopMostPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostPosterMutation) OldTopMostID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopMostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopMostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopMostID: %w", err)
	}
	return oldValue.TopMostID, nil
}

// ClearTopMostID clears the value of the "top_most_id" field.
func (m *TopMostPosterMutation) ClearTopMostID() {
	m.top_most_id = nil
	m.clearedFields[topmostposter.FieldTopMostID] = struct{}{}
}

// TopMostIDCleared returns if the "top_most_id" field was cleared in this mutation.
func (m *TopMostPosterMutation) TopMostIDCleared() bool {
	_, ok := m.clearedFields[topmostposter.FieldTopMostID]
	return ok
}

// ResetTopMostID resets all changes to the "top_most_id" field.
func (m *TopMostPosterMutation) ResetTopMostID() {
	m.top_most_id = nil
	delete(m.clearedFields, topmostposter.FieldTopMostID)
}

// SetPoster sets the "poster" field.
func (m *TopMostPosterMutation) SetPoster(s string) {
	m.poster = &s
}

// Poster returns the value of the "poster" field in the mutation.
func (m *TopMostPosterMutation) Poster() (r string, exists bool) {
	v := m.poster
	if v == nil {
		return
	}
	return *v, true
}

// OldPoster returns the old "poster" field's value of the TopMostPoster entity.
// If the TopMostPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostPosterMutation) OldPoster(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoster: %w", err)
	}
	return oldValue.Poster, nil
}

// ClearPoster clears the value of the "poster" field.
func (m *TopMostPosterMutation) ClearPoster() {
	m.poster = nil
	m.clearedFields[topmostposter.FieldPoster] = struct{}{}
}

// PosterCleared returns if the "poster" field was cleared in this mutation.
func (m *TopMostPosterMutation) PosterCleared() bool {
	_, ok := m.clearedFields[topmostposter.FieldPoster]
	return ok
}

// ResetPoster resets all changes to the "poster" field.
func (m *TopMostPosterMutation) ResetPoster() {
	m.poster = nil
	delete(m.clearedFields, topmostposter.FieldPoster)
}

// SetIndex sets the "index" field.
func (m *TopMostPosterMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *TopMostPosterMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the TopMostPoster entity.
// If the TopMostPoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostPosterMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *TopMostPosterMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *TopMostPosterMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *TopMostPosterMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[topmostposter.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *TopMostPosterMutation) IndexCleared() bool {
	_, ok := m.clearedFields[topmostposter.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *TopMostPosterMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, topmostposter.FieldIndex)
}

// Where appends a list predicates to the TopMostPosterMutation builder.
func (m *TopMostPosterMutation) Where(ps ...predicate.TopMostPoster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopMostPosterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopMostPosterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TopMostPoster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopMostPosterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopMostPosterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TopMostPoster).
func (m *TopMostPosterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopMostPosterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.ent_id != nil {
		fields = append(fields, topmostposter.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, topmostposter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topmostposter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, topmostposter.FieldDeletedAt)
	}
	if m.top_most_id != nil {
		fields = append(fields, topmostposter.FieldTopMostID)
	}
	if m.poster != nil {
		fields = append(fields, topmostposter.FieldPoster)
	}
	if m.index != nil {
		fields = append(fields, topmostposter.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopMostPosterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topmostposter.FieldEntID:
		return m.EntID()
	case topmostposter.FieldCreatedAt:
		return m.CreatedAt()
	case topmostposter.FieldUpdatedAt:
		return m.UpdatedAt()
	case topmostposter.FieldDeletedAt:
		return m.DeletedAt()
	case topmostposter.FieldTopMostID:
		return m.TopMostID()
	case topmostposter.FieldPoster:
		return m.Poster()
	case topmostposter.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopMostPosterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topmostposter.FieldEntID:
		return m.OldEntID(ctx)
	case topmostposter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topmostposter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topmostposter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topmostposter.FieldTopMostID:
		return m.OldTopMostID(ctx)
	case topmostposter.FieldPoster:
		return m.OldPoster(ctx)
	case topmostposter.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown TopMostPoster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostPosterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topmostposter.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case topmostposter.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topmostposter.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topmostposter.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topmostposter.FieldTopMostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopMostID(v)
		return nil
	case topmostposter.FieldPoster:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoster(v)
		return nil
	case topmostposter.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostPoster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopMostPosterMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, topmostposter.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, topmostposter.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, topmostposter.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, topmostposter.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopMostPosterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case topmostposter.FieldCreatedAt:
		return m.AddedCreatedAt()
	case topmostposter.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case topmostposter.FieldDeletedAt:
		return m.AddedDeletedAt()
	case topmostposter.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostPosterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case topmostposter.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case topmostposter.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case topmostposter.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case topmostposter.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostPoster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopMostPosterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topmostposter.FieldTopMostID) {
		fields = append(fields, topmostposter.FieldTopMostID)
	}
	if m.FieldCleared(topmostposter.FieldPoster) {
		fields = append(fields, topmostposter.FieldPoster)
	}
	if m.FieldCleared(topmostposter.FieldIndex) {
		fields = append(fields, topmostposter.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopMostPosterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopMostPosterMutation) ClearField(name string) error {
	switch name {
	case topmostposter.FieldTopMostID:
		m.ClearTopMostID()
		return nil
	case topmostposter.FieldPoster:
		m.ClearPoster()
		return nil
	case topmostposter.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown TopMostPoster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopMostPosterMutation) ResetField(name string) error {
	switch name {
	case topmostposter.FieldEntID:
		m.ResetEntID()
		return nil
	case topmostposter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topmostposter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topmostposter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topmostposter.FieldTopMostID:
		m.ResetTopMostID()
		return nil
	case topmostposter.FieldPoster:
		m.ResetPoster()
		return nil
	case topmostposter.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown TopMostPoster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopMostPosterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopMostPosterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopMostPosterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopMostPosterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopMostPosterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopMostPosterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopMostPosterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TopMostPoster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopMostPosterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TopMostPoster edge %s", name)
}

// VendorBrandMutation represents an operation that mutates the VendorBrand nodes in the graph.
type VendorBrandMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	name          *string
	logo          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VendorBrand, error)
	predicates    []predicate.VendorBrand
}

var _ ent.Mutation = (*VendorBrandMutation)(nil)

// vendorbrandOption allows management of the mutation configuration using functional options.
type vendorbrandOption func(*VendorBrandMutation)

// newVendorBrandMutation creates new mutation for the VendorBrand entity.
func newVendorBrandMutation(c config, op Op, opts ...vendorbrandOption) *VendorBrandMutation {
	m := &VendorBrandMutation{
		config:        c,
		op:            op,
		typ:           TypeVendorBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVendorBrandID sets the ID field of the mutation.
func withVendorBrandID(id uint32) vendorbrandOption {
	return func(m *VendorBrandMutation) {
		var (
			err   error
			once  sync.Once
			value *VendorBrand
		)
		m.oldValue = func(ctx context.Context) (*VendorBrand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VendorBrand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVendorBrand sets the old VendorBrand of the mutation.
func withVendorBrand(node *VendorBrand) vendorbrandOption {
	return func(m *VendorBrandMutation) {
		m.oldValue = func(context.Context) (*VendorBrand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VendorBrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VendorBrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VendorBrand entities.
func (m *VendorBrandMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VendorBrandMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VendorBrandMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VendorBrand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *VendorBrandMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *VendorBrandMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *VendorBrandMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VendorBrandMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VendorBrandMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *VendorBrandMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *VendorBrandMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VendorBrandMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VendorBrandMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VendorBrandMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *VendorBrandMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *VendorBrandMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VendorBrandMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VendorBrandMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VendorBrandMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *VendorBrandMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *VendorBrandMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VendorBrandMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *VendorBrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VendorBrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VendorBrandMutation) ClearName() {
	m.name = nil
	m.clearedFields[vendorbrand.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VendorBrandMutation) NameCleared() bool {
	_, ok := m.clearedFields[vendorbrand.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VendorBrandMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, vendorbrand.FieldName)
}

// SetLogo sets the "logo" field.
func (m *VendorBrandMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *VendorBrandMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *VendorBrandMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[vendorbrand.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *VendorBrandMutation) LogoCleared() bool {
	_, ok := m.clearedFields[vendorbrand.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *VendorBrandMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, vendorbrand.FieldLogo)
}

// Where appends a list predicates to the VendorBrandMutation builder.
func (m *VendorBrandMutation) Where(ps ...predicate.VendorBrand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VendorBrandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VendorBrandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VendorBrand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VendorBrandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VendorBrandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VendorBrand).
func (m *VendorBrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VendorBrandMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.ent_id != nil {
		fields = append(fields, vendorbrand.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, vendorbrand.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vendorbrand.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vendorbrand.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, vendorbrand.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, vendorbrand.FieldLogo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VendorBrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vendorbrand.FieldEntID:
		return m.EntID()
	case vendorbrand.FieldCreatedAt:
		return m.CreatedAt()
	case vendorbrand.FieldUpdatedAt:
		return m.UpdatedAt()
	case vendorbrand.FieldDeletedAt:
		return m.DeletedAt()
	case vendorbrand.FieldName:
		return m.Name()
	case vendorbrand.FieldLogo:
		return m.Logo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VendorBrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vendorbrand.FieldEntID:
		return m.OldEntID(ctx)
	case vendorbrand.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vendorbrand.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vendorbrand.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vendorbrand.FieldName:
		return m.OldName(ctx)
	case vendorbrand.FieldLogo:
		return m.OldLogo(ctx)
	}
	return nil, fmt.Errorf("unknown VendorBrand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorBrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vendorbrand.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case vendorbrand.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vendorbrand.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vendorbrand.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vendorbrand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vendorbrand.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	}
	return fmt.Errorf("unknown VendorBrand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VendorBrandMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, vendorbrand.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, vendorbrand.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, vendorbrand.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VendorBrandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vendorbrand.FieldCreatedAt:
		return m.AddedCreatedAt()
	case vendorbrand.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case vendorbrand.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorBrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vendorbrand.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case vendorbrand.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case vendorbrand.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VendorBrand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VendorBrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vendorbrand.FieldName) {
		fields = append(fields, vendorbrand.FieldName)
	}
	if m.FieldCleared(vendorbrand.FieldLogo) {
		fields = append(fields, vendorbrand.FieldLogo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VendorBrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VendorBrandMutation) ClearField(name string) error {
	switch name {
	case vendorbrand.FieldName:
		m.ClearName()
		return nil
	case vendorbrand.FieldLogo:
		m.ClearLogo()
		return nil
	}
	return fmt.Errorf("unknown VendorBrand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VendorBrandMutation) ResetField(name string) error {
	switch name {
	case vendorbrand.FieldEntID:
		m.ResetEntID()
		return nil
	case vendorbrand.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vendorbrand.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vendorbrand.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vendorbrand.FieldName:
		m.ResetName()
		return nil
	case vendorbrand.FieldLogo:
		m.ResetLogo()
		return nil
	}
	return fmt.Errorf("unknown VendorBrand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VendorBrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VendorBrandMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VendorBrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VendorBrandMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VendorBrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VendorBrandMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VendorBrandMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VendorBrand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VendorBrandMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VendorBrand edge %s", name)
}

// VendorLocationMutation represents an operation that mutates the VendorLocation nodes in the graph.
type VendorLocationMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	ent_id        *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	country       *string
	province      *string
	city          *string
	address       *string
	brand_id      *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VendorLocation, error)
	predicates    []predicate.VendorLocation
}

var _ ent.Mutation = (*VendorLocationMutation)(nil)

// vendorlocationOption allows management of the mutation configuration using functional options.
type vendorlocationOption func(*VendorLocationMutation)

// newVendorLocationMutation creates new mutation for the VendorLocation entity.
func newVendorLocationMutation(c config, op Op, opts ...vendorlocationOption) *VendorLocationMutation {
	m := &VendorLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeVendorLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVendorLocationID sets the ID field of the mutation.
func withVendorLocationID(id uint32) vendorlocationOption {
	return func(m *VendorLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *VendorLocation
		)
		m.oldValue = func(ctx context.Context) (*VendorLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VendorLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVendorLocation sets the old VendorLocation of the mutation.
func withVendorLocation(node *VendorLocation) vendorlocationOption {
	return func(m *VendorLocationMutation) {
		m.oldValue = func(context.Context) (*VendorLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VendorLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VendorLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VendorLocation entities.
func (m *VendorLocationMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VendorLocationMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VendorLocationMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VendorLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntID sets the "ent_id" field.
func (m *VendorLocationMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *VendorLocationMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *VendorLocationMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VendorLocationMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VendorLocationMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *VendorLocationMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *VendorLocationMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VendorLocationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VendorLocationMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VendorLocationMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *VendorLocationMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *VendorLocationMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VendorLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VendorLocationMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VendorLocationMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *VendorLocationMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *VendorLocationMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VendorLocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCountry sets the "country" field.
func (m *VendorLocationMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *VendorLocationMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *VendorLocationMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[vendorlocation.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *VendorLocationMutation) CountryCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *VendorLocationMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, vendorlocation.FieldCountry)
}

// SetProvince sets the "province" field.
func (m *VendorLocationMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *VendorLocationMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *VendorLocationMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[vendorlocation.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *VendorLocationMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *VendorLocationMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, vendorlocation.FieldProvince)
}

// SetCity sets the "city" field.
func (m *VendorLocationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *VendorLocationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *VendorLocationMutation) ClearCity() {
	m.city = nil
	m.clearedFields[vendorlocation.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *VendorLocationMutation) CityCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *VendorLocationMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, vendorlocation.FieldCity)
}

// SetAddress sets the "address" field.
func (m *VendorLocationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *VendorLocationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *VendorLocationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[vendorlocation.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *VendorLocationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *VendorLocationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, vendorlocation.FieldAddress)
}

// SetBrandID sets the "brand_id" field.
func (m *VendorLocationMutation) SetBrandID(u uuid.UUID) {
	m.brand_id = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *VendorLocationMutation) BrandID() (r uuid.UUID, exists bool) {
	v := m.brand_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldBrandID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *VendorLocationMutation) ClearBrandID() {
	m.brand_id = nil
	m.clearedFields[vendorlocation.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *VendorLocationMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *VendorLocationMutation) ResetBrandID() {
	m.brand_id = nil
	delete(m.clearedFields, vendorlocation.FieldBrandID)
}

// Where appends a list predicates to the VendorLocationMutation builder.
func (m *VendorLocationMutation) Where(ps ...predicate.VendorLocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VendorLocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VendorLocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VendorLocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VendorLocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VendorLocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VendorLocation).
func (m *VendorLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VendorLocationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.ent_id != nil {
		fields = append(fields, vendorlocation.FieldEntID)
	}
	if m.created_at != nil {
		fields = append(fields, vendorlocation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vendorlocation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vendorlocation.FieldDeletedAt)
	}
	if m.country != nil {
		fields = append(fields, vendorlocation.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, vendorlocation.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, vendorlocation.FieldCity)
	}
	if m.address != nil {
		fields = append(fields, vendorlocation.FieldAddress)
	}
	if m.brand_id != nil {
		fields = append(fields, vendorlocation.FieldBrandID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VendorLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vendorlocation.FieldEntID:
		return m.EntID()
	case vendorlocation.FieldCreatedAt:
		return m.CreatedAt()
	case vendorlocation.FieldUpdatedAt:
		return m.UpdatedAt()
	case vendorlocation.FieldDeletedAt:
		return m.DeletedAt()
	case vendorlocation.FieldCountry:
		return m.Country()
	case vendorlocation.FieldProvince:
		return m.Province()
	case vendorlocation.FieldCity:
		return m.City()
	case vendorlocation.FieldAddress:
		return m.Address()
	case vendorlocation.FieldBrandID:
		return m.BrandID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VendorLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vendorlocation.FieldEntID:
		return m.OldEntID(ctx)
	case vendorlocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vendorlocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vendorlocation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vendorlocation.FieldCountry:
		return m.OldCountry(ctx)
	case vendorlocation.FieldProvince:
		return m.OldProvince(ctx)
	case vendorlocation.FieldCity:
		return m.OldCity(ctx)
	case vendorlocation.FieldAddress:
		return m.OldAddress(ctx)
	case vendorlocation.FieldBrandID:
		return m.OldBrandID(ctx)
	}
	return nil, fmt.Errorf("unknown VendorLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vendorlocation.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case vendorlocation.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vendorlocation.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vendorlocation.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vendorlocation.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case vendorlocation.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case vendorlocation.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case vendorlocation.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case vendorlocation.FieldBrandID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	}
	return fmt.Errorf("unknown VendorLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VendorLocationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, vendorlocation.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, vendorlocation.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, vendorlocation.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VendorLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vendorlocation.FieldCreatedAt:
		return m.AddedCreatedAt()
	case vendorlocation.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case vendorlocation.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vendorlocation.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case vendorlocation.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case vendorlocation.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VendorLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VendorLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vendorlocation.FieldCountry) {
		fields = append(fields, vendorlocation.FieldCountry)
	}
	if m.FieldCleared(vendorlocation.FieldProvince) {
		fields = append(fields, vendorlocation.FieldProvince)
	}
	if m.FieldCleared(vendorlocation.FieldCity) {
		fields = append(fields, vendorlocation.FieldCity)
	}
	if m.FieldCleared(vendorlocation.FieldAddress) {
		fields = append(fields, vendorlocation.FieldAddress)
	}
	if m.FieldCleared(vendorlocation.FieldBrandID) {
		fields = append(fields, vendorlocation.FieldBrandID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VendorLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VendorLocationMutation) ClearField(name string) error {
	switch name {
	case vendorlocation.FieldCountry:
		m.ClearCountry()
		return nil
	case vendorlocation.FieldProvince:
		m.ClearProvince()
		return nil
	case vendorlocation.FieldCity:
		m.ClearCity()
		return nil
	case vendorlocation.FieldAddress:
		m.ClearAddress()
		return nil
	case vendorlocation.FieldBrandID:
		m.ClearBrandID()
		return nil
	}
	return fmt.Errorf("unknown VendorLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VendorLocationMutation) ResetField(name string) error {
	switch name {
	case vendorlocation.FieldEntID:
		m.ResetEntID()
		return nil
	case vendorlocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vendorlocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vendorlocation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vendorlocation.FieldCountry:
		m.ResetCountry()
		return nil
	case vendorlocation.FieldProvince:
		m.ResetProvince()
		return nil
	case vendorlocation.FieldCity:
		m.ResetCity()
		return nil
	case vendorlocation.FieldAddress:
		m.ResetAddress()
		return nil
	case vendorlocation.FieldBrandID:
		m.ResetBrandID()
		return nil
	}
	return fmt.Errorf("unknown VendorLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VendorLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VendorLocationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VendorLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VendorLocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VendorLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VendorLocationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VendorLocationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VendorLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VendorLocationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VendorLocation edge %s", name)
}
