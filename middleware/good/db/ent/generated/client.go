// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appdefaultgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appdelegatedstaking"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appfee"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgoodbase"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgooddescription"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgooddisplaycolor"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgooddisplayname"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgoodlabel"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appgoodposter"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/applegacypowerrental"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appmininggoodstock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/apppowerrental"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appsimulatepowerrental"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appstock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appstocklock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appsubscription"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/appsubscriptiononeshot"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/comment"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/delegatedstaking"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/deviceinfo"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/devicemanufacturer"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/deviceposter"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/extrainfo"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/fbmcrowdfunding"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/fee"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/good"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodbase"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodcoin"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodcoinreward"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodmalfunction"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodreward"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/goodrewardhistory"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/like"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/mininggoodstock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/powerrental"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/recommend"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/requiredappgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/requiredgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/score"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/stock"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/subscription"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/subscriptiononeshot"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmost"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostconstraint"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostgood"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostgoodconstraint"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostgoodposter"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/topmostposter"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/vendorbrand"
	"github.com/NpoolPlatform/kunman/middleware/good/db/ent/generated/vendorlocation"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AppDefaultGood is the client for interacting with the AppDefaultGood builders.
	AppDefaultGood *AppDefaultGoodClient
	// AppDelegatedStaking is the client for interacting with the AppDelegatedStaking builders.
	AppDelegatedStaking *AppDelegatedStakingClient
	// AppFee is the client for interacting with the AppFee builders.
	AppFee *AppFeeClient
	// AppGood is the client for interacting with the AppGood builders.
	AppGood *AppGoodClient
	// AppGoodBase is the client for interacting with the AppGoodBase builders.
	AppGoodBase *AppGoodBaseClient
	// AppGoodDescription is the client for interacting with the AppGoodDescription builders.
	AppGoodDescription *AppGoodDescriptionClient
	// AppGoodDisplayColor is the client for interacting with the AppGoodDisplayColor builders.
	AppGoodDisplayColor *AppGoodDisplayColorClient
	// AppGoodDisplayName is the client for interacting with the AppGoodDisplayName builders.
	AppGoodDisplayName *AppGoodDisplayNameClient
	// AppGoodLabel is the client for interacting with the AppGoodLabel builders.
	AppGoodLabel *AppGoodLabelClient
	// AppGoodPoster is the client for interacting with the AppGoodPoster builders.
	AppGoodPoster *AppGoodPosterClient
	// AppLegacyPowerRental is the client for interacting with the AppLegacyPowerRental builders.
	AppLegacyPowerRental *AppLegacyPowerRentalClient
	// AppMiningGoodStock is the client for interacting with the AppMiningGoodStock builders.
	AppMiningGoodStock *AppMiningGoodStockClient
	// AppPowerRental is the client for interacting with the AppPowerRental builders.
	AppPowerRental *AppPowerRentalClient
	// AppSimulatePowerRental is the client for interacting with the AppSimulatePowerRental builders.
	AppSimulatePowerRental *AppSimulatePowerRentalClient
	// AppStock is the client for interacting with the AppStock builders.
	AppStock *AppStockClient
	// AppStockLock is the client for interacting with the AppStockLock builders.
	AppStockLock *AppStockLockClient
	// AppSubscription is the client for interacting with the AppSubscription builders.
	AppSubscription *AppSubscriptionClient
	// AppSubscriptionOneShot is the client for interacting with the AppSubscriptionOneShot builders.
	AppSubscriptionOneShot *AppSubscriptionOneShotClient
	// Comment is the client for interacting with the Comment builders.
	Comment *CommentClient
	// DelegatedStaking is the client for interacting with the DelegatedStaking builders.
	DelegatedStaking *DelegatedStakingClient
	// DeviceInfo is the client for interacting with the DeviceInfo builders.
	DeviceInfo *DeviceInfoClient
	// DeviceManufacturer is the client for interacting with the DeviceManufacturer builders.
	DeviceManufacturer *DeviceManufacturerClient
	// DevicePoster is the client for interacting with the DevicePoster builders.
	DevicePoster *DevicePosterClient
	// ExtraInfo is the client for interacting with the ExtraInfo builders.
	ExtraInfo *ExtraInfoClient
	// FbmCrowdFunding is the client for interacting with the FbmCrowdFunding builders.
	FbmCrowdFunding *FbmCrowdFundingClient
	// Fee is the client for interacting with the Fee builders.
	Fee *FeeClient
	// Good is the client for interacting with the Good builders.
	Good *GoodClient
	// GoodBase is the client for interacting with the GoodBase builders.
	GoodBase *GoodBaseClient
	// GoodCoin is the client for interacting with the GoodCoin builders.
	GoodCoin *GoodCoinClient
	// GoodCoinReward is the client for interacting with the GoodCoinReward builders.
	GoodCoinReward *GoodCoinRewardClient
	// GoodMalfunction is the client for interacting with the GoodMalfunction builders.
	GoodMalfunction *GoodMalfunctionClient
	// GoodReward is the client for interacting with the GoodReward builders.
	GoodReward *GoodRewardClient
	// GoodRewardHistory is the client for interacting with the GoodRewardHistory builders.
	GoodRewardHistory *GoodRewardHistoryClient
	// Like is the client for interacting with the Like builders.
	Like *LikeClient
	// MiningGoodStock is the client for interacting with the MiningGoodStock builders.
	MiningGoodStock *MiningGoodStockClient
	// PowerRental is the client for interacting with the PowerRental builders.
	PowerRental *PowerRentalClient
	// Recommend is the client for interacting with the Recommend builders.
	Recommend *RecommendClient
	// RequiredAppGood is the client for interacting with the RequiredAppGood builders.
	RequiredAppGood *RequiredAppGoodClient
	// RequiredGood is the client for interacting with the RequiredGood builders.
	RequiredGood *RequiredGoodClient
	// Score is the client for interacting with the Score builders.
	Score *ScoreClient
	// Stock is the client for interacting with the Stock builders.
	Stock *StockClient
	// Subscription is the client for interacting with the Subscription builders.
	Subscription *SubscriptionClient
	// SubscriptionOneShot is the client for interacting with the SubscriptionOneShot builders.
	SubscriptionOneShot *SubscriptionOneShotClient
	// TopMost is the client for interacting with the TopMost builders.
	TopMost *TopMostClient
	// TopMostConstraint is the client for interacting with the TopMostConstraint builders.
	TopMostConstraint *TopMostConstraintClient
	// TopMostGood is the client for interacting with the TopMostGood builders.
	TopMostGood *TopMostGoodClient
	// TopMostGoodConstraint is the client for interacting with the TopMostGoodConstraint builders.
	TopMostGoodConstraint *TopMostGoodConstraintClient
	// TopMostGoodPoster is the client for interacting with the TopMostGoodPoster builders.
	TopMostGoodPoster *TopMostGoodPosterClient
	// TopMostPoster is the client for interacting with the TopMostPoster builders.
	TopMostPoster *TopMostPosterClient
	// VendorBrand is the client for interacting with the VendorBrand builders.
	VendorBrand *VendorBrandClient
	// VendorLocation is the client for interacting with the VendorLocation builders.
	VendorLocation *VendorLocationClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AppDefaultGood = NewAppDefaultGoodClient(c.config)
	c.AppDelegatedStaking = NewAppDelegatedStakingClient(c.config)
	c.AppFee = NewAppFeeClient(c.config)
	c.AppGood = NewAppGoodClient(c.config)
	c.AppGoodBase = NewAppGoodBaseClient(c.config)
	c.AppGoodDescription = NewAppGoodDescriptionClient(c.config)
	c.AppGoodDisplayColor = NewAppGoodDisplayColorClient(c.config)
	c.AppGoodDisplayName = NewAppGoodDisplayNameClient(c.config)
	c.AppGoodLabel = NewAppGoodLabelClient(c.config)
	c.AppGoodPoster = NewAppGoodPosterClient(c.config)
	c.AppLegacyPowerRental = NewAppLegacyPowerRentalClient(c.config)
	c.AppMiningGoodStock = NewAppMiningGoodStockClient(c.config)
	c.AppPowerRental = NewAppPowerRentalClient(c.config)
	c.AppSimulatePowerRental = NewAppSimulatePowerRentalClient(c.config)
	c.AppStock = NewAppStockClient(c.config)
	c.AppStockLock = NewAppStockLockClient(c.config)
	c.AppSubscription = NewAppSubscriptionClient(c.config)
	c.AppSubscriptionOneShot = NewAppSubscriptionOneShotClient(c.config)
	c.Comment = NewCommentClient(c.config)
	c.DelegatedStaking = NewDelegatedStakingClient(c.config)
	c.DeviceInfo = NewDeviceInfoClient(c.config)
	c.DeviceManufacturer = NewDeviceManufacturerClient(c.config)
	c.DevicePoster = NewDevicePosterClient(c.config)
	c.ExtraInfo = NewExtraInfoClient(c.config)
	c.FbmCrowdFunding = NewFbmCrowdFundingClient(c.config)
	c.Fee = NewFeeClient(c.config)
	c.Good = NewGoodClient(c.config)
	c.GoodBase = NewGoodBaseClient(c.config)
	c.GoodCoin = NewGoodCoinClient(c.config)
	c.GoodCoinReward = NewGoodCoinRewardClient(c.config)
	c.GoodMalfunction = NewGoodMalfunctionClient(c.config)
	c.GoodReward = NewGoodRewardClient(c.config)
	c.GoodRewardHistory = NewGoodRewardHistoryClient(c.config)
	c.Like = NewLikeClient(c.config)
	c.MiningGoodStock = NewMiningGoodStockClient(c.config)
	c.PowerRental = NewPowerRentalClient(c.config)
	c.Recommend = NewRecommendClient(c.config)
	c.RequiredAppGood = NewRequiredAppGoodClient(c.config)
	c.RequiredGood = NewRequiredGoodClient(c.config)
	c.Score = NewScoreClient(c.config)
	c.Stock = NewStockClient(c.config)
	c.Subscription = NewSubscriptionClient(c.config)
	c.SubscriptionOneShot = NewSubscriptionOneShotClient(c.config)
	c.TopMost = NewTopMostClient(c.config)
	c.TopMostConstraint = NewTopMostConstraintClient(c.config)
	c.TopMostGood = NewTopMostGoodClient(c.config)
	c.TopMostGoodConstraint = NewTopMostGoodConstraintClient(c.config)
	c.TopMostGoodPoster = NewTopMostGoodPosterClient(c.config)
	c.TopMostPoster = NewTopMostPosterClient(c.config)
	c.VendorBrand = NewVendorBrandClient(c.config)
	c.VendorLocation = NewVendorLocationClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("generated: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("generated: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		AppDefaultGood:         NewAppDefaultGoodClient(cfg),
		AppDelegatedStaking:    NewAppDelegatedStakingClient(cfg),
		AppFee:                 NewAppFeeClient(cfg),
		AppGood:                NewAppGoodClient(cfg),
		AppGoodBase:            NewAppGoodBaseClient(cfg),
		AppGoodDescription:     NewAppGoodDescriptionClient(cfg),
		AppGoodDisplayColor:    NewAppGoodDisplayColorClient(cfg),
		AppGoodDisplayName:     NewAppGoodDisplayNameClient(cfg),
		AppGoodLabel:           NewAppGoodLabelClient(cfg),
		AppGoodPoster:          NewAppGoodPosterClient(cfg),
		AppLegacyPowerRental:   NewAppLegacyPowerRentalClient(cfg),
		AppMiningGoodStock:     NewAppMiningGoodStockClient(cfg),
		AppPowerRental:         NewAppPowerRentalClient(cfg),
		AppSimulatePowerRental: NewAppSimulatePowerRentalClient(cfg),
		AppStock:               NewAppStockClient(cfg),
		AppStockLock:           NewAppStockLockClient(cfg),
		AppSubscription:        NewAppSubscriptionClient(cfg),
		AppSubscriptionOneShot: NewAppSubscriptionOneShotClient(cfg),
		Comment:                NewCommentClient(cfg),
		DelegatedStaking:       NewDelegatedStakingClient(cfg),
		DeviceInfo:             NewDeviceInfoClient(cfg),
		DeviceManufacturer:     NewDeviceManufacturerClient(cfg),
		DevicePoster:           NewDevicePosterClient(cfg),
		ExtraInfo:              NewExtraInfoClient(cfg),
		FbmCrowdFunding:        NewFbmCrowdFundingClient(cfg),
		Fee:                    NewFeeClient(cfg),
		Good:                   NewGoodClient(cfg),
		GoodBase:               NewGoodBaseClient(cfg),
		GoodCoin:               NewGoodCoinClient(cfg),
		GoodCoinReward:         NewGoodCoinRewardClient(cfg),
		GoodMalfunction:        NewGoodMalfunctionClient(cfg),
		GoodReward:             NewGoodRewardClient(cfg),
		GoodRewardHistory:      NewGoodRewardHistoryClient(cfg),
		Like:                   NewLikeClient(cfg),
		MiningGoodStock:        NewMiningGoodStockClient(cfg),
		PowerRental:            NewPowerRentalClient(cfg),
		Recommend:              NewRecommendClient(cfg),
		RequiredAppGood:        NewRequiredAppGoodClient(cfg),
		RequiredGood:           NewRequiredGoodClient(cfg),
		Score:                  NewScoreClient(cfg),
		Stock:                  NewStockClient(cfg),
		Subscription:           NewSubscriptionClient(cfg),
		SubscriptionOneShot:    NewSubscriptionOneShotClient(cfg),
		TopMost:                NewTopMostClient(cfg),
		TopMostConstraint:      NewTopMostConstraintClient(cfg),
		TopMostGood:            NewTopMostGoodClient(cfg),
		TopMostGoodConstraint:  NewTopMostGoodConstraintClient(cfg),
		TopMostGoodPoster:      NewTopMostGoodPosterClient(cfg),
		TopMostPoster:          NewTopMostPosterClient(cfg),
		VendorBrand:            NewVendorBrandClient(cfg),
		VendorLocation:         NewVendorLocationClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		AppDefaultGood:         NewAppDefaultGoodClient(cfg),
		AppDelegatedStaking:    NewAppDelegatedStakingClient(cfg),
		AppFee:                 NewAppFeeClient(cfg),
		AppGood:                NewAppGoodClient(cfg),
		AppGoodBase:            NewAppGoodBaseClient(cfg),
		AppGoodDescription:     NewAppGoodDescriptionClient(cfg),
		AppGoodDisplayColor:    NewAppGoodDisplayColorClient(cfg),
		AppGoodDisplayName:     NewAppGoodDisplayNameClient(cfg),
		AppGoodLabel:           NewAppGoodLabelClient(cfg),
		AppGoodPoster:          NewAppGoodPosterClient(cfg),
		AppLegacyPowerRental:   NewAppLegacyPowerRentalClient(cfg),
		AppMiningGoodStock:     NewAppMiningGoodStockClient(cfg),
		AppPowerRental:         NewAppPowerRentalClient(cfg),
		AppSimulatePowerRental: NewAppSimulatePowerRentalClient(cfg),
		AppStock:               NewAppStockClient(cfg),
		AppStockLock:           NewAppStockLockClient(cfg),
		AppSubscription:        NewAppSubscriptionClient(cfg),
		AppSubscriptionOneShot: NewAppSubscriptionOneShotClient(cfg),
		Comment:                NewCommentClient(cfg),
		DelegatedStaking:       NewDelegatedStakingClient(cfg),
		DeviceInfo:             NewDeviceInfoClient(cfg),
		DeviceManufacturer:     NewDeviceManufacturerClient(cfg),
		DevicePoster:           NewDevicePosterClient(cfg),
		ExtraInfo:              NewExtraInfoClient(cfg),
		FbmCrowdFunding:        NewFbmCrowdFundingClient(cfg),
		Fee:                    NewFeeClient(cfg),
		Good:                   NewGoodClient(cfg),
		GoodBase:               NewGoodBaseClient(cfg),
		GoodCoin:               NewGoodCoinClient(cfg),
		GoodCoinReward:         NewGoodCoinRewardClient(cfg),
		GoodMalfunction:        NewGoodMalfunctionClient(cfg),
		GoodReward:             NewGoodRewardClient(cfg),
		GoodRewardHistory:      NewGoodRewardHistoryClient(cfg),
		Like:                   NewLikeClient(cfg),
		MiningGoodStock:        NewMiningGoodStockClient(cfg),
		PowerRental:            NewPowerRentalClient(cfg),
		Recommend:              NewRecommendClient(cfg),
		RequiredAppGood:        NewRequiredAppGoodClient(cfg),
		RequiredGood:           NewRequiredGoodClient(cfg),
		Score:                  NewScoreClient(cfg),
		Stock:                  NewStockClient(cfg),
		Subscription:           NewSubscriptionClient(cfg),
		SubscriptionOneShot:    NewSubscriptionOneShotClient(cfg),
		TopMost:                NewTopMostClient(cfg),
		TopMostConstraint:      NewTopMostConstraintClient(cfg),
		TopMostGood:            NewTopMostGoodClient(cfg),
		TopMostGoodConstraint:  NewTopMostGoodConstraintClient(cfg),
		TopMostGoodPoster:      NewTopMostGoodPosterClient(cfg),
		TopMostPoster:          NewTopMostPosterClient(cfg),
		VendorBrand:            NewVendorBrandClient(cfg),
		VendorLocation:         NewVendorLocationClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AppDefaultGood.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AppDefaultGood, c.AppDelegatedStaking, c.AppFee, c.AppGood, c.AppGoodBase,
		c.AppGoodDescription, c.AppGoodDisplayColor, c.AppGoodDisplayName,
		c.AppGoodLabel, c.AppGoodPoster, c.AppLegacyPowerRental, c.AppMiningGoodStock,
		c.AppPowerRental, c.AppSimulatePowerRental, c.AppStock, c.AppStockLock,
		c.AppSubscription, c.AppSubscriptionOneShot, c.Comment, c.DelegatedStaking,
		c.DeviceInfo, c.DeviceManufacturer, c.DevicePoster, c.ExtraInfo,
		c.FbmCrowdFunding, c.Fee, c.Good, c.GoodBase, c.GoodCoin, c.GoodCoinReward,
		c.GoodMalfunction, c.GoodReward, c.GoodRewardHistory, c.Like,
		c.MiningGoodStock, c.PowerRental, c.Recommend, c.RequiredAppGood,
		c.RequiredGood, c.Score, c.Stock, c.Subscription, c.SubscriptionOneShot,
		c.TopMost, c.TopMostConstraint, c.TopMostGood, c.TopMostGoodConstraint,
		c.TopMostGoodPoster, c.TopMostPoster, c.VendorBrand, c.VendorLocation,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AppDefaultGood, c.AppDelegatedStaking, c.AppFee, c.AppGood, c.AppGoodBase,
		c.AppGoodDescription, c.AppGoodDisplayColor, c.AppGoodDisplayName,
		c.AppGoodLabel, c.AppGoodPoster, c.AppLegacyPowerRental, c.AppMiningGoodStock,
		c.AppPowerRental, c.AppSimulatePowerRental, c.AppStock, c.AppStockLock,
		c.AppSubscription, c.AppSubscriptionOneShot, c.Comment, c.DelegatedStaking,
		c.DeviceInfo, c.DeviceManufacturer, c.DevicePoster, c.ExtraInfo,
		c.FbmCrowdFunding, c.Fee, c.Good, c.GoodBase, c.GoodCoin, c.GoodCoinReward,
		c.GoodMalfunction, c.GoodReward, c.GoodRewardHistory, c.Like,
		c.MiningGoodStock, c.PowerRental, c.Recommend, c.RequiredAppGood,
		c.RequiredGood, c.Score, c.Stock, c.Subscription, c.SubscriptionOneShot,
		c.TopMost, c.TopMostConstraint, c.TopMostGood, c.TopMostGoodConstraint,
		c.TopMostGoodPoster, c.TopMostPoster, c.VendorBrand, c.VendorLocation,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AppDefaultGoodMutation:
		return c.AppDefaultGood.mutate(ctx, m)
	case *AppDelegatedStakingMutation:
		return c.AppDelegatedStaking.mutate(ctx, m)
	case *AppFeeMutation:
		return c.AppFee.mutate(ctx, m)
	case *AppGoodMutation:
		return c.AppGood.mutate(ctx, m)
	case *AppGoodBaseMutation:
		return c.AppGoodBase.mutate(ctx, m)
	case *AppGoodDescriptionMutation:
		return c.AppGoodDescription.mutate(ctx, m)
	case *AppGoodDisplayColorMutation:
		return c.AppGoodDisplayColor.mutate(ctx, m)
	case *AppGoodDisplayNameMutation:
		return c.AppGoodDisplayName.mutate(ctx, m)
	case *AppGoodLabelMutation:
		return c.AppGoodLabel.mutate(ctx, m)
	case *AppGoodPosterMutation:
		return c.AppGoodPoster.mutate(ctx, m)
	case *AppLegacyPowerRentalMutation:
		return c.AppLegacyPowerRental.mutate(ctx, m)
	case *AppMiningGoodStockMutation:
		return c.AppMiningGoodStock.mutate(ctx, m)
	case *AppPowerRentalMutation:
		return c.AppPowerRental.mutate(ctx, m)
	case *AppSimulatePowerRentalMutation:
		return c.AppSimulatePowerRental.mutate(ctx, m)
	case *AppStockMutation:
		return c.AppStock.mutate(ctx, m)
	case *AppStockLockMutation:
		return c.AppStockLock.mutate(ctx, m)
	case *AppSubscriptionMutation:
		return c.AppSubscription.mutate(ctx, m)
	case *AppSubscriptionOneShotMutation:
		return c.AppSubscriptionOneShot.mutate(ctx, m)
	case *CommentMutation:
		return c.Comment.mutate(ctx, m)
	case *DelegatedStakingMutation:
		return c.DelegatedStaking.mutate(ctx, m)
	case *DeviceInfoMutation:
		return c.DeviceInfo.mutate(ctx, m)
	case *DeviceManufacturerMutation:
		return c.DeviceManufacturer.mutate(ctx, m)
	case *DevicePosterMutation:
		return c.DevicePoster.mutate(ctx, m)
	case *ExtraInfoMutation:
		return c.ExtraInfo.mutate(ctx, m)
	case *FbmCrowdFundingMutation:
		return c.FbmCrowdFunding.mutate(ctx, m)
	case *FeeMutation:
		return c.Fee.mutate(ctx, m)
	case *GoodMutation:
		return c.Good.mutate(ctx, m)
	case *GoodBaseMutation:
		return c.GoodBase.mutate(ctx, m)
	case *GoodCoinMutation:
		return c.GoodCoin.mutate(ctx, m)
	case *GoodCoinRewardMutation:
		return c.GoodCoinReward.mutate(ctx, m)
	case *GoodMalfunctionMutation:
		return c.GoodMalfunction.mutate(ctx, m)
	case *GoodRewardMutation:
		return c.GoodReward.mutate(ctx, m)
	case *GoodRewardHistoryMutation:
		return c.GoodRewardHistory.mutate(ctx, m)
	case *LikeMutation:
		return c.Like.mutate(ctx, m)
	case *MiningGoodStockMutation:
		return c.MiningGoodStock.mutate(ctx, m)
	case *PowerRentalMutation:
		return c.PowerRental.mutate(ctx, m)
	case *RecommendMutation:
		return c.Recommend.mutate(ctx, m)
	case *RequiredAppGoodMutation:
		return c.RequiredAppGood.mutate(ctx, m)
	case *RequiredGoodMutation:
		return c.RequiredGood.mutate(ctx, m)
	case *ScoreMutation:
		return c.Score.mutate(ctx, m)
	case *StockMutation:
		return c.Stock.mutate(ctx, m)
	case *SubscriptionMutation:
		return c.Subscription.mutate(ctx, m)
	case *SubscriptionOneShotMutation:
		return c.SubscriptionOneShot.mutate(ctx, m)
	case *TopMostMutation:
		return c.TopMost.mutate(ctx, m)
	case *TopMostConstraintMutation:
		return c.TopMostConstraint.mutate(ctx, m)
	case *TopMostGoodMutation:
		return c.TopMostGood.mutate(ctx, m)
	case *TopMostGoodConstraintMutation:
		return c.TopMostGoodConstraint.mutate(ctx, m)
	case *TopMostGoodPosterMutation:
		return c.TopMostGoodPoster.mutate(ctx, m)
	case *TopMostPosterMutation:
		return c.TopMostPoster.mutate(ctx, m)
	case *VendorBrandMutation:
		return c.VendorBrand.mutate(ctx, m)
	case *VendorLocationMutation:
		return c.VendorLocation.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("generated: unknown mutation type %T", m)
	}
}

// AppDefaultGoodClient is a client for the AppDefaultGood schema.
type AppDefaultGoodClient struct {
	config
}

// NewAppDefaultGoodClient returns a client for the AppDefaultGood from the given config.
func NewAppDefaultGoodClient(c config) *AppDefaultGoodClient {
	return &AppDefaultGoodClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appdefaultgood.Hooks(f(g(h())))`.
func (c *AppDefaultGoodClient) Use(hooks ...Hook) {
	c.hooks.AppDefaultGood = append(c.hooks.AppDefaultGood, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appdefaultgood.Intercept(f(g(h())))`.
func (c *AppDefaultGoodClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppDefaultGood = append(c.inters.AppDefaultGood, interceptors...)
}

// Create returns a builder for creating a AppDefaultGood entity.
func (c *AppDefaultGoodClient) Create() *AppDefaultGoodCreate {
	mutation := newAppDefaultGoodMutation(c.config, OpCreate)
	return &AppDefaultGoodCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppDefaultGood entities.
func (c *AppDefaultGoodClient) CreateBulk(builders ...*AppDefaultGoodCreate) *AppDefaultGoodCreateBulk {
	return &AppDefaultGoodCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppDefaultGoodClient) MapCreateBulk(slice any, setFunc func(*AppDefaultGoodCreate, int)) *AppDefaultGoodCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppDefaultGoodCreateBulk{err: fmt.Errorf("calling to AppDefaultGoodClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppDefaultGoodCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppDefaultGoodCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppDefaultGood.
func (c *AppDefaultGoodClient) Update() *AppDefaultGoodUpdate {
	mutation := newAppDefaultGoodMutation(c.config, OpUpdate)
	return &AppDefaultGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppDefaultGoodClient) UpdateOne(adg *AppDefaultGood) *AppDefaultGoodUpdateOne {
	mutation := newAppDefaultGoodMutation(c.config, OpUpdateOne, withAppDefaultGood(adg))
	return &AppDefaultGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppDefaultGoodClient) UpdateOneID(id uint32) *AppDefaultGoodUpdateOne {
	mutation := newAppDefaultGoodMutation(c.config, OpUpdateOne, withAppDefaultGoodID(id))
	return &AppDefaultGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppDefaultGood.
func (c *AppDefaultGoodClient) Delete() *AppDefaultGoodDelete {
	mutation := newAppDefaultGoodMutation(c.config, OpDelete)
	return &AppDefaultGoodDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppDefaultGoodClient) DeleteOne(adg *AppDefaultGood) *AppDefaultGoodDeleteOne {
	return c.DeleteOneID(adg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppDefaultGoodClient) DeleteOneID(id uint32) *AppDefaultGoodDeleteOne {
	builder := c.Delete().Where(appdefaultgood.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDefaultGoodDeleteOne{builder}
}

// Query returns a query builder for AppDefaultGood.
func (c *AppDefaultGoodClient) Query() *AppDefaultGoodQuery {
	return &AppDefaultGoodQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppDefaultGood},
		inters: c.Interceptors(),
	}
}

// Get returns a AppDefaultGood entity by its id.
func (c *AppDefaultGoodClient) Get(ctx context.Context, id uint32) (*AppDefaultGood, error) {
	return c.Query().Where(appdefaultgood.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppDefaultGoodClient) GetX(ctx context.Context, id uint32) *AppDefaultGood {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppDefaultGoodClient) Hooks() []Hook {
	return c.hooks.AppDefaultGood
}

// Interceptors returns the client interceptors.
func (c *AppDefaultGoodClient) Interceptors() []Interceptor {
	return c.inters.AppDefaultGood
}

func (c *AppDefaultGoodClient) mutate(ctx context.Context, m *AppDefaultGoodMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppDefaultGoodCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppDefaultGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppDefaultGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDefaultGoodDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppDefaultGood mutation op: %q", m.Op())
	}
}

// AppDelegatedStakingClient is a client for the AppDelegatedStaking schema.
type AppDelegatedStakingClient struct {
	config
}

// NewAppDelegatedStakingClient returns a client for the AppDelegatedStaking from the given config.
func NewAppDelegatedStakingClient(c config) *AppDelegatedStakingClient {
	return &AppDelegatedStakingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appdelegatedstaking.Hooks(f(g(h())))`.
func (c *AppDelegatedStakingClient) Use(hooks ...Hook) {
	c.hooks.AppDelegatedStaking = append(c.hooks.AppDelegatedStaking, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appdelegatedstaking.Intercept(f(g(h())))`.
func (c *AppDelegatedStakingClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppDelegatedStaking = append(c.inters.AppDelegatedStaking, interceptors...)
}

// Create returns a builder for creating a AppDelegatedStaking entity.
func (c *AppDelegatedStakingClient) Create() *AppDelegatedStakingCreate {
	mutation := newAppDelegatedStakingMutation(c.config, OpCreate)
	return &AppDelegatedStakingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppDelegatedStaking entities.
func (c *AppDelegatedStakingClient) CreateBulk(builders ...*AppDelegatedStakingCreate) *AppDelegatedStakingCreateBulk {
	return &AppDelegatedStakingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppDelegatedStakingClient) MapCreateBulk(slice any, setFunc func(*AppDelegatedStakingCreate, int)) *AppDelegatedStakingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppDelegatedStakingCreateBulk{err: fmt.Errorf("calling to AppDelegatedStakingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppDelegatedStakingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppDelegatedStakingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppDelegatedStaking.
func (c *AppDelegatedStakingClient) Update() *AppDelegatedStakingUpdate {
	mutation := newAppDelegatedStakingMutation(c.config, OpUpdate)
	return &AppDelegatedStakingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppDelegatedStakingClient) UpdateOne(ads *AppDelegatedStaking) *AppDelegatedStakingUpdateOne {
	mutation := newAppDelegatedStakingMutation(c.config, OpUpdateOne, withAppDelegatedStaking(ads))
	return &AppDelegatedStakingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppDelegatedStakingClient) UpdateOneID(id uint32) *AppDelegatedStakingUpdateOne {
	mutation := newAppDelegatedStakingMutation(c.config, OpUpdateOne, withAppDelegatedStakingID(id))
	return &AppDelegatedStakingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppDelegatedStaking.
func (c *AppDelegatedStakingClient) Delete() *AppDelegatedStakingDelete {
	mutation := newAppDelegatedStakingMutation(c.config, OpDelete)
	return &AppDelegatedStakingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppDelegatedStakingClient) DeleteOne(ads *AppDelegatedStaking) *AppDelegatedStakingDeleteOne {
	return c.DeleteOneID(ads.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppDelegatedStakingClient) DeleteOneID(id uint32) *AppDelegatedStakingDeleteOne {
	builder := c.Delete().Where(appdelegatedstaking.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDelegatedStakingDeleteOne{builder}
}

// Query returns a query builder for AppDelegatedStaking.
func (c *AppDelegatedStakingClient) Query() *AppDelegatedStakingQuery {
	return &AppDelegatedStakingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppDelegatedStaking},
		inters: c.Interceptors(),
	}
}

// Get returns a AppDelegatedStaking entity by its id.
func (c *AppDelegatedStakingClient) Get(ctx context.Context, id uint32) (*AppDelegatedStaking, error) {
	return c.Query().Where(appdelegatedstaking.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppDelegatedStakingClient) GetX(ctx context.Context, id uint32) *AppDelegatedStaking {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppDelegatedStakingClient) Hooks() []Hook {
	return c.hooks.AppDelegatedStaking
}

// Interceptors returns the client interceptors.
func (c *AppDelegatedStakingClient) Interceptors() []Interceptor {
	return c.inters.AppDelegatedStaking
}

func (c *AppDelegatedStakingClient) mutate(ctx context.Context, m *AppDelegatedStakingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppDelegatedStakingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppDelegatedStakingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppDelegatedStakingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDelegatedStakingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppDelegatedStaking mutation op: %q", m.Op())
	}
}

// AppFeeClient is a client for the AppFee schema.
type AppFeeClient struct {
	config
}

// NewAppFeeClient returns a client for the AppFee from the given config.
func NewAppFeeClient(c config) *AppFeeClient {
	return &AppFeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appfee.Hooks(f(g(h())))`.
func (c *AppFeeClient) Use(hooks ...Hook) {
	c.hooks.AppFee = append(c.hooks.AppFee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appfee.Intercept(f(g(h())))`.
func (c *AppFeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppFee = append(c.inters.AppFee, interceptors...)
}

// Create returns a builder for creating a AppFee entity.
func (c *AppFeeClient) Create() *AppFeeCreate {
	mutation := newAppFeeMutation(c.config, OpCreate)
	return &AppFeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppFee entities.
func (c *AppFeeClient) CreateBulk(builders ...*AppFeeCreate) *AppFeeCreateBulk {
	return &AppFeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppFeeClient) MapCreateBulk(slice any, setFunc func(*AppFeeCreate, int)) *AppFeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppFeeCreateBulk{err: fmt.Errorf("calling to AppFeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppFeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppFeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppFee.
func (c *AppFeeClient) Update() *AppFeeUpdate {
	mutation := newAppFeeMutation(c.config, OpUpdate)
	return &AppFeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppFeeClient) UpdateOne(af *AppFee) *AppFeeUpdateOne {
	mutation := newAppFeeMutation(c.config, OpUpdateOne, withAppFee(af))
	return &AppFeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppFeeClient) UpdateOneID(id uint32) *AppFeeUpdateOne {
	mutation := newAppFeeMutation(c.config, OpUpdateOne, withAppFeeID(id))
	return &AppFeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppFee.
func (c *AppFeeClient) Delete() *AppFeeDelete {
	mutation := newAppFeeMutation(c.config, OpDelete)
	return &AppFeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppFeeClient) DeleteOne(af *AppFee) *AppFeeDeleteOne {
	return c.DeleteOneID(af.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppFeeClient) DeleteOneID(id uint32) *AppFeeDeleteOne {
	builder := c.Delete().Where(appfee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppFeeDeleteOne{builder}
}

// Query returns a query builder for AppFee.
func (c *AppFeeClient) Query() *AppFeeQuery {
	return &AppFeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppFee},
		inters: c.Interceptors(),
	}
}

// Get returns a AppFee entity by its id.
func (c *AppFeeClient) Get(ctx context.Context, id uint32) (*AppFee, error) {
	return c.Query().Where(appfee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppFeeClient) GetX(ctx context.Context, id uint32) *AppFee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppFeeClient) Hooks() []Hook {
	return c.hooks.AppFee
}

// Interceptors returns the client interceptors.
func (c *AppFeeClient) Interceptors() []Interceptor {
	return c.inters.AppFee
}

func (c *AppFeeClient) mutate(ctx context.Context, m *AppFeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppFeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppFeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppFeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppFeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppFee mutation op: %q", m.Op())
	}
}

// AppGoodClient is a client for the AppGood schema.
type AppGoodClient struct {
	config
}

// NewAppGoodClient returns a client for the AppGood from the given config.
func NewAppGoodClient(c config) *AppGoodClient {
	return &AppGoodClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgood.Hooks(f(g(h())))`.
func (c *AppGoodClient) Use(hooks ...Hook) {
	c.hooks.AppGood = append(c.hooks.AppGood, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgood.Intercept(f(g(h())))`.
func (c *AppGoodClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGood = append(c.inters.AppGood, interceptors...)
}

// Create returns a builder for creating a AppGood entity.
func (c *AppGoodClient) Create() *AppGoodCreate {
	mutation := newAppGoodMutation(c.config, OpCreate)
	return &AppGoodCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGood entities.
func (c *AppGoodClient) CreateBulk(builders ...*AppGoodCreate) *AppGoodCreateBulk {
	return &AppGoodCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodClient) MapCreateBulk(slice any, setFunc func(*AppGoodCreate, int)) *AppGoodCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodCreateBulk{err: fmt.Errorf("calling to AppGoodClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGood.
func (c *AppGoodClient) Update() *AppGoodUpdate {
	mutation := newAppGoodMutation(c.config, OpUpdate)
	return &AppGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodClient) UpdateOne(ag *AppGood) *AppGoodUpdateOne {
	mutation := newAppGoodMutation(c.config, OpUpdateOne, withAppGood(ag))
	return &AppGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodClient) UpdateOneID(id uint32) *AppGoodUpdateOne {
	mutation := newAppGoodMutation(c.config, OpUpdateOne, withAppGoodID(id))
	return &AppGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGood.
func (c *AppGoodClient) Delete() *AppGoodDelete {
	mutation := newAppGoodMutation(c.config, OpDelete)
	return &AppGoodDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodClient) DeleteOne(ag *AppGood) *AppGoodDeleteOne {
	return c.DeleteOneID(ag.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodClient) DeleteOneID(id uint32) *AppGoodDeleteOne {
	builder := c.Delete().Where(appgood.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodDeleteOne{builder}
}

// Query returns a query builder for AppGood.
func (c *AppGoodClient) Query() *AppGoodQuery {
	return &AppGoodQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGood},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGood entity by its id.
func (c *AppGoodClient) Get(ctx context.Context, id uint32) (*AppGood, error) {
	return c.Query().Where(appgood.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodClient) GetX(ctx context.Context, id uint32) *AppGood {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodClient) Hooks() []Hook {
	return c.hooks.AppGood
}

// Interceptors returns the client interceptors.
func (c *AppGoodClient) Interceptors() []Interceptor {
	return c.inters.AppGood
}

func (c *AppGoodClient) mutate(ctx context.Context, m *AppGoodMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGood mutation op: %q", m.Op())
	}
}

// AppGoodBaseClient is a client for the AppGoodBase schema.
type AppGoodBaseClient struct {
	config
}

// NewAppGoodBaseClient returns a client for the AppGoodBase from the given config.
func NewAppGoodBaseClient(c config) *AppGoodBaseClient {
	return &AppGoodBaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgoodbase.Hooks(f(g(h())))`.
func (c *AppGoodBaseClient) Use(hooks ...Hook) {
	c.hooks.AppGoodBase = append(c.hooks.AppGoodBase, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgoodbase.Intercept(f(g(h())))`.
func (c *AppGoodBaseClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGoodBase = append(c.inters.AppGoodBase, interceptors...)
}

// Create returns a builder for creating a AppGoodBase entity.
func (c *AppGoodBaseClient) Create() *AppGoodBaseCreate {
	mutation := newAppGoodBaseMutation(c.config, OpCreate)
	return &AppGoodBaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGoodBase entities.
func (c *AppGoodBaseClient) CreateBulk(builders ...*AppGoodBaseCreate) *AppGoodBaseCreateBulk {
	return &AppGoodBaseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodBaseClient) MapCreateBulk(slice any, setFunc func(*AppGoodBaseCreate, int)) *AppGoodBaseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodBaseCreateBulk{err: fmt.Errorf("calling to AppGoodBaseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodBaseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodBaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGoodBase.
func (c *AppGoodBaseClient) Update() *AppGoodBaseUpdate {
	mutation := newAppGoodBaseMutation(c.config, OpUpdate)
	return &AppGoodBaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodBaseClient) UpdateOne(agb *AppGoodBase) *AppGoodBaseUpdateOne {
	mutation := newAppGoodBaseMutation(c.config, OpUpdateOne, withAppGoodBase(agb))
	return &AppGoodBaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodBaseClient) UpdateOneID(id uint32) *AppGoodBaseUpdateOne {
	mutation := newAppGoodBaseMutation(c.config, OpUpdateOne, withAppGoodBaseID(id))
	return &AppGoodBaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGoodBase.
func (c *AppGoodBaseClient) Delete() *AppGoodBaseDelete {
	mutation := newAppGoodBaseMutation(c.config, OpDelete)
	return &AppGoodBaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodBaseClient) DeleteOne(agb *AppGoodBase) *AppGoodBaseDeleteOne {
	return c.DeleteOneID(agb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodBaseClient) DeleteOneID(id uint32) *AppGoodBaseDeleteOne {
	builder := c.Delete().Where(appgoodbase.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodBaseDeleteOne{builder}
}

// Query returns a query builder for AppGoodBase.
func (c *AppGoodBaseClient) Query() *AppGoodBaseQuery {
	return &AppGoodBaseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGoodBase},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGoodBase entity by its id.
func (c *AppGoodBaseClient) Get(ctx context.Context, id uint32) (*AppGoodBase, error) {
	return c.Query().Where(appgoodbase.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodBaseClient) GetX(ctx context.Context, id uint32) *AppGoodBase {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodBaseClient) Hooks() []Hook {
	return c.hooks.AppGoodBase
}

// Interceptors returns the client interceptors.
func (c *AppGoodBaseClient) Interceptors() []Interceptor {
	return c.inters.AppGoodBase
}

func (c *AppGoodBaseClient) mutate(ctx context.Context, m *AppGoodBaseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodBaseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodBaseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodBaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodBaseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGoodBase mutation op: %q", m.Op())
	}
}

// AppGoodDescriptionClient is a client for the AppGoodDescription schema.
type AppGoodDescriptionClient struct {
	config
}

// NewAppGoodDescriptionClient returns a client for the AppGoodDescription from the given config.
func NewAppGoodDescriptionClient(c config) *AppGoodDescriptionClient {
	return &AppGoodDescriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgooddescription.Hooks(f(g(h())))`.
func (c *AppGoodDescriptionClient) Use(hooks ...Hook) {
	c.hooks.AppGoodDescription = append(c.hooks.AppGoodDescription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgooddescription.Intercept(f(g(h())))`.
func (c *AppGoodDescriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGoodDescription = append(c.inters.AppGoodDescription, interceptors...)
}

// Create returns a builder for creating a AppGoodDescription entity.
func (c *AppGoodDescriptionClient) Create() *AppGoodDescriptionCreate {
	mutation := newAppGoodDescriptionMutation(c.config, OpCreate)
	return &AppGoodDescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGoodDescription entities.
func (c *AppGoodDescriptionClient) CreateBulk(builders ...*AppGoodDescriptionCreate) *AppGoodDescriptionCreateBulk {
	return &AppGoodDescriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodDescriptionClient) MapCreateBulk(slice any, setFunc func(*AppGoodDescriptionCreate, int)) *AppGoodDescriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodDescriptionCreateBulk{err: fmt.Errorf("calling to AppGoodDescriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodDescriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodDescriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGoodDescription.
func (c *AppGoodDescriptionClient) Update() *AppGoodDescriptionUpdate {
	mutation := newAppGoodDescriptionMutation(c.config, OpUpdate)
	return &AppGoodDescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodDescriptionClient) UpdateOne(agd *AppGoodDescription) *AppGoodDescriptionUpdateOne {
	mutation := newAppGoodDescriptionMutation(c.config, OpUpdateOne, withAppGoodDescription(agd))
	return &AppGoodDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodDescriptionClient) UpdateOneID(id uint32) *AppGoodDescriptionUpdateOne {
	mutation := newAppGoodDescriptionMutation(c.config, OpUpdateOne, withAppGoodDescriptionID(id))
	return &AppGoodDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGoodDescription.
func (c *AppGoodDescriptionClient) Delete() *AppGoodDescriptionDelete {
	mutation := newAppGoodDescriptionMutation(c.config, OpDelete)
	return &AppGoodDescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodDescriptionClient) DeleteOne(agd *AppGoodDescription) *AppGoodDescriptionDeleteOne {
	return c.DeleteOneID(agd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodDescriptionClient) DeleteOneID(id uint32) *AppGoodDescriptionDeleteOne {
	builder := c.Delete().Where(appgooddescription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodDescriptionDeleteOne{builder}
}

// Query returns a query builder for AppGoodDescription.
func (c *AppGoodDescriptionClient) Query() *AppGoodDescriptionQuery {
	return &AppGoodDescriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGoodDescription},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGoodDescription entity by its id.
func (c *AppGoodDescriptionClient) Get(ctx context.Context, id uint32) (*AppGoodDescription, error) {
	return c.Query().Where(appgooddescription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodDescriptionClient) GetX(ctx context.Context, id uint32) *AppGoodDescription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodDescriptionClient) Hooks() []Hook {
	return c.hooks.AppGoodDescription
}

// Interceptors returns the client interceptors.
func (c *AppGoodDescriptionClient) Interceptors() []Interceptor {
	return c.inters.AppGoodDescription
}

func (c *AppGoodDescriptionClient) mutate(ctx context.Context, m *AppGoodDescriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodDescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodDescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodDescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGoodDescription mutation op: %q", m.Op())
	}
}

// AppGoodDisplayColorClient is a client for the AppGoodDisplayColor schema.
type AppGoodDisplayColorClient struct {
	config
}

// NewAppGoodDisplayColorClient returns a client for the AppGoodDisplayColor from the given config.
func NewAppGoodDisplayColorClient(c config) *AppGoodDisplayColorClient {
	return &AppGoodDisplayColorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgooddisplaycolor.Hooks(f(g(h())))`.
func (c *AppGoodDisplayColorClient) Use(hooks ...Hook) {
	c.hooks.AppGoodDisplayColor = append(c.hooks.AppGoodDisplayColor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgooddisplaycolor.Intercept(f(g(h())))`.
func (c *AppGoodDisplayColorClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGoodDisplayColor = append(c.inters.AppGoodDisplayColor, interceptors...)
}

// Create returns a builder for creating a AppGoodDisplayColor entity.
func (c *AppGoodDisplayColorClient) Create() *AppGoodDisplayColorCreate {
	mutation := newAppGoodDisplayColorMutation(c.config, OpCreate)
	return &AppGoodDisplayColorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGoodDisplayColor entities.
func (c *AppGoodDisplayColorClient) CreateBulk(builders ...*AppGoodDisplayColorCreate) *AppGoodDisplayColorCreateBulk {
	return &AppGoodDisplayColorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodDisplayColorClient) MapCreateBulk(slice any, setFunc func(*AppGoodDisplayColorCreate, int)) *AppGoodDisplayColorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodDisplayColorCreateBulk{err: fmt.Errorf("calling to AppGoodDisplayColorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodDisplayColorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodDisplayColorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGoodDisplayColor.
func (c *AppGoodDisplayColorClient) Update() *AppGoodDisplayColorUpdate {
	mutation := newAppGoodDisplayColorMutation(c.config, OpUpdate)
	return &AppGoodDisplayColorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodDisplayColorClient) UpdateOne(agdc *AppGoodDisplayColor) *AppGoodDisplayColorUpdateOne {
	mutation := newAppGoodDisplayColorMutation(c.config, OpUpdateOne, withAppGoodDisplayColor(agdc))
	return &AppGoodDisplayColorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodDisplayColorClient) UpdateOneID(id uint32) *AppGoodDisplayColorUpdateOne {
	mutation := newAppGoodDisplayColorMutation(c.config, OpUpdateOne, withAppGoodDisplayColorID(id))
	return &AppGoodDisplayColorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGoodDisplayColor.
func (c *AppGoodDisplayColorClient) Delete() *AppGoodDisplayColorDelete {
	mutation := newAppGoodDisplayColorMutation(c.config, OpDelete)
	return &AppGoodDisplayColorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodDisplayColorClient) DeleteOne(agdc *AppGoodDisplayColor) *AppGoodDisplayColorDeleteOne {
	return c.DeleteOneID(agdc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodDisplayColorClient) DeleteOneID(id uint32) *AppGoodDisplayColorDeleteOne {
	builder := c.Delete().Where(appgooddisplaycolor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodDisplayColorDeleteOne{builder}
}

// Query returns a query builder for AppGoodDisplayColor.
func (c *AppGoodDisplayColorClient) Query() *AppGoodDisplayColorQuery {
	return &AppGoodDisplayColorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGoodDisplayColor},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGoodDisplayColor entity by its id.
func (c *AppGoodDisplayColorClient) Get(ctx context.Context, id uint32) (*AppGoodDisplayColor, error) {
	return c.Query().Where(appgooddisplaycolor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodDisplayColorClient) GetX(ctx context.Context, id uint32) *AppGoodDisplayColor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodDisplayColorClient) Hooks() []Hook {
	return c.hooks.AppGoodDisplayColor
}

// Interceptors returns the client interceptors.
func (c *AppGoodDisplayColorClient) Interceptors() []Interceptor {
	return c.inters.AppGoodDisplayColor
}

func (c *AppGoodDisplayColorClient) mutate(ctx context.Context, m *AppGoodDisplayColorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodDisplayColorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodDisplayColorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodDisplayColorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodDisplayColorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGoodDisplayColor mutation op: %q", m.Op())
	}
}

// AppGoodDisplayNameClient is a client for the AppGoodDisplayName schema.
type AppGoodDisplayNameClient struct {
	config
}

// NewAppGoodDisplayNameClient returns a client for the AppGoodDisplayName from the given config.
func NewAppGoodDisplayNameClient(c config) *AppGoodDisplayNameClient {
	return &AppGoodDisplayNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgooddisplayname.Hooks(f(g(h())))`.
func (c *AppGoodDisplayNameClient) Use(hooks ...Hook) {
	c.hooks.AppGoodDisplayName = append(c.hooks.AppGoodDisplayName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgooddisplayname.Intercept(f(g(h())))`.
func (c *AppGoodDisplayNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGoodDisplayName = append(c.inters.AppGoodDisplayName, interceptors...)
}

// Create returns a builder for creating a AppGoodDisplayName entity.
func (c *AppGoodDisplayNameClient) Create() *AppGoodDisplayNameCreate {
	mutation := newAppGoodDisplayNameMutation(c.config, OpCreate)
	return &AppGoodDisplayNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGoodDisplayName entities.
func (c *AppGoodDisplayNameClient) CreateBulk(builders ...*AppGoodDisplayNameCreate) *AppGoodDisplayNameCreateBulk {
	return &AppGoodDisplayNameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodDisplayNameClient) MapCreateBulk(slice any, setFunc func(*AppGoodDisplayNameCreate, int)) *AppGoodDisplayNameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodDisplayNameCreateBulk{err: fmt.Errorf("calling to AppGoodDisplayNameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodDisplayNameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodDisplayNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGoodDisplayName.
func (c *AppGoodDisplayNameClient) Update() *AppGoodDisplayNameUpdate {
	mutation := newAppGoodDisplayNameMutation(c.config, OpUpdate)
	return &AppGoodDisplayNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodDisplayNameClient) UpdateOne(agdn *AppGoodDisplayName) *AppGoodDisplayNameUpdateOne {
	mutation := newAppGoodDisplayNameMutation(c.config, OpUpdateOne, withAppGoodDisplayName(agdn))
	return &AppGoodDisplayNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodDisplayNameClient) UpdateOneID(id uint32) *AppGoodDisplayNameUpdateOne {
	mutation := newAppGoodDisplayNameMutation(c.config, OpUpdateOne, withAppGoodDisplayNameID(id))
	return &AppGoodDisplayNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGoodDisplayName.
func (c *AppGoodDisplayNameClient) Delete() *AppGoodDisplayNameDelete {
	mutation := newAppGoodDisplayNameMutation(c.config, OpDelete)
	return &AppGoodDisplayNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodDisplayNameClient) DeleteOne(agdn *AppGoodDisplayName) *AppGoodDisplayNameDeleteOne {
	return c.DeleteOneID(agdn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodDisplayNameClient) DeleteOneID(id uint32) *AppGoodDisplayNameDeleteOne {
	builder := c.Delete().Where(appgooddisplayname.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodDisplayNameDeleteOne{builder}
}

// Query returns a query builder for AppGoodDisplayName.
func (c *AppGoodDisplayNameClient) Query() *AppGoodDisplayNameQuery {
	return &AppGoodDisplayNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGoodDisplayName},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGoodDisplayName entity by its id.
func (c *AppGoodDisplayNameClient) Get(ctx context.Context, id uint32) (*AppGoodDisplayName, error) {
	return c.Query().Where(appgooddisplayname.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodDisplayNameClient) GetX(ctx context.Context, id uint32) *AppGoodDisplayName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodDisplayNameClient) Hooks() []Hook {
	return c.hooks.AppGoodDisplayName
}

// Interceptors returns the client interceptors.
func (c *AppGoodDisplayNameClient) Interceptors() []Interceptor {
	return c.inters.AppGoodDisplayName
}

func (c *AppGoodDisplayNameClient) mutate(ctx context.Context, m *AppGoodDisplayNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodDisplayNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodDisplayNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodDisplayNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodDisplayNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGoodDisplayName mutation op: %q", m.Op())
	}
}

// AppGoodLabelClient is a client for the AppGoodLabel schema.
type AppGoodLabelClient struct {
	config
}

// NewAppGoodLabelClient returns a client for the AppGoodLabel from the given config.
func NewAppGoodLabelClient(c config) *AppGoodLabelClient {
	return &AppGoodLabelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgoodlabel.Hooks(f(g(h())))`.
func (c *AppGoodLabelClient) Use(hooks ...Hook) {
	c.hooks.AppGoodLabel = append(c.hooks.AppGoodLabel, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgoodlabel.Intercept(f(g(h())))`.
func (c *AppGoodLabelClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGoodLabel = append(c.inters.AppGoodLabel, interceptors...)
}

// Create returns a builder for creating a AppGoodLabel entity.
func (c *AppGoodLabelClient) Create() *AppGoodLabelCreate {
	mutation := newAppGoodLabelMutation(c.config, OpCreate)
	return &AppGoodLabelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGoodLabel entities.
func (c *AppGoodLabelClient) CreateBulk(builders ...*AppGoodLabelCreate) *AppGoodLabelCreateBulk {
	return &AppGoodLabelCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodLabelClient) MapCreateBulk(slice any, setFunc func(*AppGoodLabelCreate, int)) *AppGoodLabelCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodLabelCreateBulk{err: fmt.Errorf("calling to AppGoodLabelClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodLabelCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodLabelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGoodLabel.
func (c *AppGoodLabelClient) Update() *AppGoodLabelUpdate {
	mutation := newAppGoodLabelMutation(c.config, OpUpdate)
	return &AppGoodLabelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodLabelClient) UpdateOne(agl *AppGoodLabel) *AppGoodLabelUpdateOne {
	mutation := newAppGoodLabelMutation(c.config, OpUpdateOne, withAppGoodLabel(agl))
	return &AppGoodLabelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodLabelClient) UpdateOneID(id uint32) *AppGoodLabelUpdateOne {
	mutation := newAppGoodLabelMutation(c.config, OpUpdateOne, withAppGoodLabelID(id))
	return &AppGoodLabelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGoodLabel.
func (c *AppGoodLabelClient) Delete() *AppGoodLabelDelete {
	mutation := newAppGoodLabelMutation(c.config, OpDelete)
	return &AppGoodLabelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodLabelClient) DeleteOne(agl *AppGoodLabel) *AppGoodLabelDeleteOne {
	return c.DeleteOneID(agl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodLabelClient) DeleteOneID(id uint32) *AppGoodLabelDeleteOne {
	builder := c.Delete().Where(appgoodlabel.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodLabelDeleteOne{builder}
}

// Query returns a query builder for AppGoodLabel.
func (c *AppGoodLabelClient) Query() *AppGoodLabelQuery {
	return &AppGoodLabelQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGoodLabel},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGoodLabel entity by its id.
func (c *AppGoodLabelClient) Get(ctx context.Context, id uint32) (*AppGoodLabel, error) {
	return c.Query().Where(appgoodlabel.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodLabelClient) GetX(ctx context.Context, id uint32) *AppGoodLabel {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodLabelClient) Hooks() []Hook {
	return c.hooks.AppGoodLabel
}

// Interceptors returns the client interceptors.
func (c *AppGoodLabelClient) Interceptors() []Interceptor {
	return c.inters.AppGoodLabel
}

func (c *AppGoodLabelClient) mutate(ctx context.Context, m *AppGoodLabelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodLabelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodLabelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodLabelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodLabelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGoodLabel mutation op: %q", m.Op())
	}
}

// AppGoodPosterClient is a client for the AppGoodPoster schema.
type AppGoodPosterClient struct {
	config
}

// NewAppGoodPosterClient returns a client for the AppGoodPoster from the given config.
func NewAppGoodPosterClient(c config) *AppGoodPosterClient {
	return &AppGoodPosterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appgoodposter.Hooks(f(g(h())))`.
func (c *AppGoodPosterClient) Use(hooks ...Hook) {
	c.hooks.AppGoodPoster = append(c.hooks.AppGoodPoster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appgoodposter.Intercept(f(g(h())))`.
func (c *AppGoodPosterClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppGoodPoster = append(c.inters.AppGoodPoster, interceptors...)
}

// Create returns a builder for creating a AppGoodPoster entity.
func (c *AppGoodPosterClient) Create() *AppGoodPosterCreate {
	mutation := newAppGoodPosterMutation(c.config, OpCreate)
	return &AppGoodPosterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppGoodPoster entities.
func (c *AppGoodPosterClient) CreateBulk(builders ...*AppGoodPosterCreate) *AppGoodPosterCreateBulk {
	return &AppGoodPosterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppGoodPosterClient) MapCreateBulk(slice any, setFunc func(*AppGoodPosterCreate, int)) *AppGoodPosterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppGoodPosterCreateBulk{err: fmt.Errorf("calling to AppGoodPosterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppGoodPosterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppGoodPosterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppGoodPoster.
func (c *AppGoodPosterClient) Update() *AppGoodPosterUpdate {
	mutation := newAppGoodPosterMutation(c.config, OpUpdate)
	return &AppGoodPosterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppGoodPosterClient) UpdateOne(agp *AppGoodPoster) *AppGoodPosterUpdateOne {
	mutation := newAppGoodPosterMutation(c.config, OpUpdateOne, withAppGoodPoster(agp))
	return &AppGoodPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppGoodPosterClient) UpdateOneID(id uint32) *AppGoodPosterUpdateOne {
	mutation := newAppGoodPosterMutation(c.config, OpUpdateOne, withAppGoodPosterID(id))
	return &AppGoodPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppGoodPoster.
func (c *AppGoodPosterClient) Delete() *AppGoodPosterDelete {
	mutation := newAppGoodPosterMutation(c.config, OpDelete)
	return &AppGoodPosterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppGoodPosterClient) DeleteOne(agp *AppGoodPoster) *AppGoodPosterDeleteOne {
	return c.DeleteOneID(agp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppGoodPosterClient) DeleteOneID(id uint32) *AppGoodPosterDeleteOne {
	builder := c.Delete().Where(appgoodposter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppGoodPosterDeleteOne{builder}
}

// Query returns a query builder for AppGoodPoster.
func (c *AppGoodPosterClient) Query() *AppGoodPosterQuery {
	return &AppGoodPosterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppGoodPoster},
		inters: c.Interceptors(),
	}
}

// Get returns a AppGoodPoster entity by its id.
func (c *AppGoodPosterClient) Get(ctx context.Context, id uint32) (*AppGoodPoster, error) {
	return c.Query().Where(appgoodposter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppGoodPosterClient) GetX(ctx context.Context, id uint32) *AppGoodPoster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppGoodPosterClient) Hooks() []Hook {
	return c.hooks.AppGoodPoster
}

// Interceptors returns the client interceptors.
func (c *AppGoodPosterClient) Interceptors() []Interceptor {
	return c.inters.AppGoodPoster
}

func (c *AppGoodPosterClient) mutate(ctx context.Context, m *AppGoodPosterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppGoodPosterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppGoodPosterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppGoodPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppGoodPosterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppGoodPoster mutation op: %q", m.Op())
	}
}

// AppLegacyPowerRentalClient is a client for the AppLegacyPowerRental schema.
type AppLegacyPowerRentalClient struct {
	config
}

// NewAppLegacyPowerRentalClient returns a client for the AppLegacyPowerRental from the given config.
func NewAppLegacyPowerRentalClient(c config) *AppLegacyPowerRentalClient {
	return &AppLegacyPowerRentalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `applegacypowerrental.Hooks(f(g(h())))`.
func (c *AppLegacyPowerRentalClient) Use(hooks ...Hook) {
	c.hooks.AppLegacyPowerRental = append(c.hooks.AppLegacyPowerRental, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `applegacypowerrental.Intercept(f(g(h())))`.
func (c *AppLegacyPowerRentalClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppLegacyPowerRental = append(c.inters.AppLegacyPowerRental, interceptors...)
}

// Create returns a builder for creating a AppLegacyPowerRental entity.
func (c *AppLegacyPowerRentalClient) Create() *AppLegacyPowerRentalCreate {
	mutation := newAppLegacyPowerRentalMutation(c.config, OpCreate)
	return &AppLegacyPowerRentalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppLegacyPowerRental entities.
func (c *AppLegacyPowerRentalClient) CreateBulk(builders ...*AppLegacyPowerRentalCreate) *AppLegacyPowerRentalCreateBulk {
	return &AppLegacyPowerRentalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppLegacyPowerRentalClient) MapCreateBulk(slice any, setFunc func(*AppLegacyPowerRentalCreate, int)) *AppLegacyPowerRentalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppLegacyPowerRentalCreateBulk{err: fmt.Errorf("calling to AppLegacyPowerRentalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppLegacyPowerRentalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppLegacyPowerRentalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppLegacyPowerRental.
func (c *AppLegacyPowerRentalClient) Update() *AppLegacyPowerRentalUpdate {
	mutation := newAppLegacyPowerRentalMutation(c.config, OpUpdate)
	return &AppLegacyPowerRentalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppLegacyPowerRentalClient) UpdateOne(alpr *AppLegacyPowerRental) *AppLegacyPowerRentalUpdateOne {
	mutation := newAppLegacyPowerRentalMutation(c.config, OpUpdateOne, withAppLegacyPowerRental(alpr))
	return &AppLegacyPowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppLegacyPowerRentalClient) UpdateOneID(id uint32) *AppLegacyPowerRentalUpdateOne {
	mutation := newAppLegacyPowerRentalMutation(c.config, OpUpdateOne, withAppLegacyPowerRentalID(id))
	return &AppLegacyPowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppLegacyPowerRental.
func (c *AppLegacyPowerRentalClient) Delete() *AppLegacyPowerRentalDelete {
	mutation := newAppLegacyPowerRentalMutation(c.config, OpDelete)
	return &AppLegacyPowerRentalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppLegacyPowerRentalClient) DeleteOne(alpr *AppLegacyPowerRental) *AppLegacyPowerRentalDeleteOne {
	return c.DeleteOneID(alpr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppLegacyPowerRentalClient) DeleteOneID(id uint32) *AppLegacyPowerRentalDeleteOne {
	builder := c.Delete().Where(applegacypowerrental.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppLegacyPowerRentalDeleteOne{builder}
}

// Query returns a query builder for AppLegacyPowerRental.
func (c *AppLegacyPowerRentalClient) Query() *AppLegacyPowerRentalQuery {
	return &AppLegacyPowerRentalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppLegacyPowerRental},
		inters: c.Interceptors(),
	}
}

// Get returns a AppLegacyPowerRental entity by its id.
func (c *AppLegacyPowerRentalClient) Get(ctx context.Context, id uint32) (*AppLegacyPowerRental, error) {
	return c.Query().Where(applegacypowerrental.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppLegacyPowerRentalClient) GetX(ctx context.Context, id uint32) *AppLegacyPowerRental {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppLegacyPowerRentalClient) Hooks() []Hook {
	return c.hooks.AppLegacyPowerRental
}

// Interceptors returns the client interceptors.
func (c *AppLegacyPowerRentalClient) Interceptors() []Interceptor {
	return c.inters.AppLegacyPowerRental
}

func (c *AppLegacyPowerRentalClient) mutate(ctx context.Context, m *AppLegacyPowerRentalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppLegacyPowerRentalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppLegacyPowerRentalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppLegacyPowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppLegacyPowerRentalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppLegacyPowerRental mutation op: %q", m.Op())
	}
}

// AppMiningGoodStockClient is a client for the AppMiningGoodStock schema.
type AppMiningGoodStockClient struct {
	config
}

// NewAppMiningGoodStockClient returns a client for the AppMiningGoodStock from the given config.
func NewAppMiningGoodStockClient(c config) *AppMiningGoodStockClient {
	return &AppMiningGoodStockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appmininggoodstock.Hooks(f(g(h())))`.
func (c *AppMiningGoodStockClient) Use(hooks ...Hook) {
	c.hooks.AppMiningGoodStock = append(c.hooks.AppMiningGoodStock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appmininggoodstock.Intercept(f(g(h())))`.
func (c *AppMiningGoodStockClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppMiningGoodStock = append(c.inters.AppMiningGoodStock, interceptors...)
}

// Create returns a builder for creating a AppMiningGoodStock entity.
func (c *AppMiningGoodStockClient) Create() *AppMiningGoodStockCreate {
	mutation := newAppMiningGoodStockMutation(c.config, OpCreate)
	return &AppMiningGoodStockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppMiningGoodStock entities.
func (c *AppMiningGoodStockClient) CreateBulk(builders ...*AppMiningGoodStockCreate) *AppMiningGoodStockCreateBulk {
	return &AppMiningGoodStockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppMiningGoodStockClient) MapCreateBulk(slice any, setFunc func(*AppMiningGoodStockCreate, int)) *AppMiningGoodStockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppMiningGoodStockCreateBulk{err: fmt.Errorf("calling to AppMiningGoodStockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppMiningGoodStockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppMiningGoodStockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppMiningGoodStock.
func (c *AppMiningGoodStockClient) Update() *AppMiningGoodStockUpdate {
	mutation := newAppMiningGoodStockMutation(c.config, OpUpdate)
	return &AppMiningGoodStockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppMiningGoodStockClient) UpdateOne(amgs *AppMiningGoodStock) *AppMiningGoodStockUpdateOne {
	mutation := newAppMiningGoodStockMutation(c.config, OpUpdateOne, withAppMiningGoodStock(amgs))
	return &AppMiningGoodStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppMiningGoodStockClient) UpdateOneID(id uint32) *AppMiningGoodStockUpdateOne {
	mutation := newAppMiningGoodStockMutation(c.config, OpUpdateOne, withAppMiningGoodStockID(id))
	return &AppMiningGoodStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppMiningGoodStock.
func (c *AppMiningGoodStockClient) Delete() *AppMiningGoodStockDelete {
	mutation := newAppMiningGoodStockMutation(c.config, OpDelete)
	return &AppMiningGoodStockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppMiningGoodStockClient) DeleteOne(amgs *AppMiningGoodStock) *AppMiningGoodStockDeleteOne {
	return c.DeleteOneID(amgs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppMiningGoodStockClient) DeleteOneID(id uint32) *AppMiningGoodStockDeleteOne {
	builder := c.Delete().Where(appmininggoodstock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppMiningGoodStockDeleteOne{builder}
}

// Query returns a query builder for AppMiningGoodStock.
func (c *AppMiningGoodStockClient) Query() *AppMiningGoodStockQuery {
	return &AppMiningGoodStockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppMiningGoodStock},
		inters: c.Interceptors(),
	}
}

// Get returns a AppMiningGoodStock entity by its id.
func (c *AppMiningGoodStockClient) Get(ctx context.Context, id uint32) (*AppMiningGoodStock, error) {
	return c.Query().Where(appmininggoodstock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppMiningGoodStockClient) GetX(ctx context.Context, id uint32) *AppMiningGoodStock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppMiningGoodStockClient) Hooks() []Hook {
	return c.hooks.AppMiningGoodStock
}

// Interceptors returns the client interceptors.
func (c *AppMiningGoodStockClient) Interceptors() []Interceptor {
	return c.inters.AppMiningGoodStock
}

func (c *AppMiningGoodStockClient) mutate(ctx context.Context, m *AppMiningGoodStockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppMiningGoodStockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppMiningGoodStockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppMiningGoodStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppMiningGoodStockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppMiningGoodStock mutation op: %q", m.Op())
	}
}

// AppPowerRentalClient is a client for the AppPowerRental schema.
type AppPowerRentalClient struct {
	config
}

// NewAppPowerRentalClient returns a client for the AppPowerRental from the given config.
func NewAppPowerRentalClient(c config) *AppPowerRentalClient {
	return &AppPowerRentalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apppowerrental.Hooks(f(g(h())))`.
func (c *AppPowerRentalClient) Use(hooks ...Hook) {
	c.hooks.AppPowerRental = append(c.hooks.AppPowerRental, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apppowerrental.Intercept(f(g(h())))`.
func (c *AppPowerRentalClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppPowerRental = append(c.inters.AppPowerRental, interceptors...)
}

// Create returns a builder for creating a AppPowerRental entity.
func (c *AppPowerRentalClient) Create() *AppPowerRentalCreate {
	mutation := newAppPowerRentalMutation(c.config, OpCreate)
	return &AppPowerRentalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppPowerRental entities.
func (c *AppPowerRentalClient) CreateBulk(builders ...*AppPowerRentalCreate) *AppPowerRentalCreateBulk {
	return &AppPowerRentalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppPowerRentalClient) MapCreateBulk(slice any, setFunc func(*AppPowerRentalCreate, int)) *AppPowerRentalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppPowerRentalCreateBulk{err: fmt.Errorf("calling to AppPowerRentalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppPowerRentalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppPowerRentalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppPowerRental.
func (c *AppPowerRentalClient) Update() *AppPowerRentalUpdate {
	mutation := newAppPowerRentalMutation(c.config, OpUpdate)
	return &AppPowerRentalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppPowerRentalClient) UpdateOne(apr *AppPowerRental) *AppPowerRentalUpdateOne {
	mutation := newAppPowerRentalMutation(c.config, OpUpdateOne, withAppPowerRental(apr))
	return &AppPowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppPowerRentalClient) UpdateOneID(id uint32) *AppPowerRentalUpdateOne {
	mutation := newAppPowerRentalMutation(c.config, OpUpdateOne, withAppPowerRentalID(id))
	return &AppPowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppPowerRental.
func (c *AppPowerRentalClient) Delete() *AppPowerRentalDelete {
	mutation := newAppPowerRentalMutation(c.config, OpDelete)
	return &AppPowerRentalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppPowerRentalClient) DeleteOne(apr *AppPowerRental) *AppPowerRentalDeleteOne {
	return c.DeleteOneID(apr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppPowerRentalClient) DeleteOneID(id uint32) *AppPowerRentalDeleteOne {
	builder := c.Delete().Where(apppowerrental.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppPowerRentalDeleteOne{builder}
}

// Query returns a query builder for AppPowerRental.
func (c *AppPowerRentalClient) Query() *AppPowerRentalQuery {
	return &AppPowerRentalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppPowerRental},
		inters: c.Interceptors(),
	}
}

// Get returns a AppPowerRental entity by its id.
func (c *AppPowerRentalClient) Get(ctx context.Context, id uint32) (*AppPowerRental, error) {
	return c.Query().Where(apppowerrental.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppPowerRentalClient) GetX(ctx context.Context, id uint32) *AppPowerRental {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppPowerRentalClient) Hooks() []Hook {
	return c.hooks.AppPowerRental
}

// Interceptors returns the client interceptors.
func (c *AppPowerRentalClient) Interceptors() []Interceptor {
	return c.inters.AppPowerRental
}

func (c *AppPowerRentalClient) mutate(ctx context.Context, m *AppPowerRentalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppPowerRentalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppPowerRentalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppPowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppPowerRentalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppPowerRental mutation op: %q", m.Op())
	}
}

// AppSimulatePowerRentalClient is a client for the AppSimulatePowerRental schema.
type AppSimulatePowerRentalClient struct {
	config
}

// NewAppSimulatePowerRentalClient returns a client for the AppSimulatePowerRental from the given config.
func NewAppSimulatePowerRentalClient(c config) *AppSimulatePowerRentalClient {
	return &AppSimulatePowerRentalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appsimulatepowerrental.Hooks(f(g(h())))`.
func (c *AppSimulatePowerRentalClient) Use(hooks ...Hook) {
	c.hooks.AppSimulatePowerRental = append(c.hooks.AppSimulatePowerRental, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appsimulatepowerrental.Intercept(f(g(h())))`.
func (c *AppSimulatePowerRentalClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppSimulatePowerRental = append(c.inters.AppSimulatePowerRental, interceptors...)
}

// Create returns a builder for creating a AppSimulatePowerRental entity.
func (c *AppSimulatePowerRentalClient) Create() *AppSimulatePowerRentalCreate {
	mutation := newAppSimulatePowerRentalMutation(c.config, OpCreate)
	return &AppSimulatePowerRentalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppSimulatePowerRental entities.
func (c *AppSimulatePowerRentalClient) CreateBulk(builders ...*AppSimulatePowerRentalCreate) *AppSimulatePowerRentalCreateBulk {
	return &AppSimulatePowerRentalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppSimulatePowerRentalClient) MapCreateBulk(slice any, setFunc func(*AppSimulatePowerRentalCreate, int)) *AppSimulatePowerRentalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppSimulatePowerRentalCreateBulk{err: fmt.Errorf("calling to AppSimulatePowerRentalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppSimulatePowerRentalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppSimulatePowerRentalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppSimulatePowerRental.
func (c *AppSimulatePowerRentalClient) Update() *AppSimulatePowerRentalUpdate {
	mutation := newAppSimulatePowerRentalMutation(c.config, OpUpdate)
	return &AppSimulatePowerRentalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppSimulatePowerRentalClient) UpdateOne(aspr *AppSimulatePowerRental) *AppSimulatePowerRentalUpdateOne {
	mutation := newAppSimulatePowerRentalMutation(c.config, OpUpdateOne, withAppSimulatePowerRental(aspr))
	return &AppSimulatePowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppSimulatePowerRentalClient) UpdateOneID(id uint32) *AppSimulatePowerRentalUpdateOne {
	mutation := newAppSimulatePowerRentalMutation(c.config, OpUpdateOne, withAppSimulatePowerRentalID(id))
	return &AppSimulatePowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppSimulatePowerRental.
func (c *AppSimulatePowerRentalClient) Delete() *AppSimulatePowerRentalDelete {
	mutation := newAppSimulatePowerRentalMutation(c.config, OpDelete)
	return &AppSimulatePowerRentalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppSimulatePowerRentalClient) DeleteOne(aspr *AppSimulatePowerRental) *AppSimulatePowerRentalDeleteOne {
	return c.DeleteOneID(aspr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppSimulatePowerRentalClient) DeleteOneID(id uint32) *AppSimulatePowerRentalDeleteOne {
	builder := c.Delete().Where(appsimulatepowerrental.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppSimulatePowerRentalDeleteOne{builder}
}

// Query returns a query builder for AppSimulatePowerRental.
func (c *AppSimulatePowerRentalClient) Query() *AppSimulatePowerRentalQuery {
	return &AppSimulatePowerRentalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppSimulatePowerRental},
		inters: c.Interceptors(),
	}
}

// Get returns a AppSimulatePowerRental entity by its id.
func (c *AppSimulatePowerRentalClient) Get(ctx context.Context, id uint32) (*AppSimulatePowerRental, error) {
	return c.Query().Where(appsimulatepowerrental.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppSimulatePowerRentalClient) GetX(ctx context.Context, id uint32) *AppSimulatePowerRental {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppSimulatePowerRentalClient) Hooks() []Hook {
	return c.hooks.AppSimulatePowerRental
}

// Interceptors returns the client interceptors.
func (c *AppSimulatePowerRentalClient) Interceptors() []Interceptor {
	return c.inters.AppSimulatePowerRental
}

func (c *AppSimulatePowerRentalClient) mutate(ctx context.Context, m *AppSimulatePowerRentalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppSimulatePowerRentalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppSimulatePowerRentalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppSimulatePowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppSimulatePowerRentalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppSimulatePowerRental mutation op: %q", m.Op())
	}
}

// AppStockClient is a client for the AppStock schema.
type AppStockClient struct {
	config
}

// NewAppStockClient returns a client for the AppStock from the given config.
func NewAppStockClient(c config) *AppStockClient {
	return &AppStockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appstock.Hooks(f(g(h())))`.
func (c *AppStockClient) Use(hooks ...Hook) {
	c.hooks.AppStock = append(c.hooks.AppStock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appstock.Intercept(f(g(h())))`.
func (c *AppStockClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppStock = append(c.inters.AppStock, interceptors...)
}

// Create returns a builder for creating a AppStock entity.
func (c *AppStockClient) Create() *AppStockCreate {
	mutation := newAppStockMutation(c.config, OpCreate)
	return &AppStockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppStock entities.
func (c *AppStockClient) CreateBulk(builders ...*AppStockCreate) *AppStockCreateBulk {
	return &AppStockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppStockClient) MapCreateBulk(slice any, setFunc func(*AppStockCreate, int)) *AppStockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppStockCreateBulk{err: fmt.Errorf("calling to AppStockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppStockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppStockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppStock.
func (c *AppStockClient) Update() *AppStockUpdate {
	mutation := newAppStockMutation(c.config, OpUpdate)
	return &AppStockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppStockClient) UpdateOne(as *AppStock) *AppStockUpdateOne {
	mutation := newAppStockMutation(c.config, OpUpdateOne, withAppStock(as))
	return &AppStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppStockClient) UpdateOneID(id uint32) *AppStockUpdateOne {
	mutation := newAppStockMutation(c.config, OpUpdateOne, withAppStockID(id))
	return &AppStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppStock.
func (c *AppStockClient) Delete() *AppStockDelete {
	mutation := newAppStockMutation(c.config, OpDelete)
	return &AppStockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppStockClient) DeleteOne(as *AppStock) *AppStockDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppStockClient) DeleteOneID(id uint32) *AppStockDeleteOne {
	builder := c.Delete().Where(appstock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppStockDeleteOne{builder}
}

// Query returns a query builder for AppStock.
func (c *AppStockClient) Query() *AppStockQuery {
	return &AppStockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppStock},
		inters: c.Interceptors(),
	}
}

// Get returns a AppStock entity by its id.
func (c *AppStockClient) Get(ctx context.Context, id uint32) (*AppStock, error) {
	return c.Query().Where(appstock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppStockClient) GetX(ctx context.Context, id uint32) *AppStock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppStockClient) Hooks() []Hook {
	return c.hooks.AppStock
}

// Interceptors returns the client interceptors.
func (c *AppStockClient) Interceptors() []Interceptor {
	return c.inters.AppStock
}

func (c *AppStockClient) mutate(ctx context.Context, m *AppStockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppStockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppStockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppStockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppStock mutation op: %q", m.Op())
	}
}

// AppStockLockClient is a client for the AppStockLock schema.
type AppStockLockClient struct {
	config
}

// NewAppStockLockClient returns a client for the AppStockLock from the given config.
func NewAppStockLockClient(c config) *AppStockLockClient {
	return &AppStockLockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appstocklock.Hooks(f(g(h())))`.
func (c *AppStockLockClient) Use(hooks ...Hook) {
	c.hooks.AppStockLock = append(c.hooks.AppStockLock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appstocklock.Intercept(f(g(h())))`.
func (c *AppStockLockClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppStockLock = append(c.inters.AppStockLock, interceptors...)
}

// Create returns a builder for creating a AppStockLock entity.
func (c *AppStockLockClient) Create() *AppStockLockCreate {
	mutation := newAppStockLockMutation(c.config, OpCreate)
	return &AppStockLockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppStockLock entities.
func (c *AppStockLockClient) CreateBulk(builders ...*AppStockLockCreate) *AppStockLockCreateBulk {
	return &AppStockLockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppStockLockClient) MapCreateBulk(slice any, setFunc func(*AppStockLockCreate, int)) *AppStockLockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppStockLockCreateBulk{err: fmt.Errorf("calling to AppStockLockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppStockLockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppStockLockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppStockLock.
func (c *AppStockLockClient) Update() *AppStockLockUpdate {
	mutation := newAppStockLockMutation(c.config, OpUpdate)
	return &AppStockLockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppStockLockClient) UpdateOne(asl *AppStockLock) *AppStockLockUpdateOne {
	mutation := newAppStockLockMutation(c.config, OpUpdateOne, withAppStockLock(asl))
	return &AppStockLockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppStockLockClient) UpdateOneID(id uint32) *AppStockLockUpdateOne {
	mutation := newAppStockLockMutation(c.config, OpUpdateOne, withAppStockLockID(id))
	return &AppStockLockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppStockLock.
func (c *AppStockLockClient) Delete() *AppStockLockDelete {
	mutation := newAppStockLockMutation(c.config, OpDelete)
	return &AppStockLockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppStockLockClient) DeleteOne(asl *AppStockLock) *AppStockLockDeleteOne {
	return c.DeleteOneID(asl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppStockLockClient) DeleteOneID(id uint32) *AppStockLockDeleteOne {
	builder := c.Delete().Where(appstocklock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppStockLockDeleteOne{builder}
}

// Query returns a query builder for AppStockLock.
func (c *AppStockLockClient) Query() *AppStockLockQuery {
	return &AppStockLockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppStockLock},
		inters: c.Interceptors(),
	}
}

// Get returns a AppStockLock entity by its id.
func (c *AppStockLockClient) Get(ctx context.Context, id uint32) (*AppStockLock, error) {
	return c.Query().Where(appstocklock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppStockLockClient) GetX(ctx context.Context, id uint32) *AppStockLock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppStockLockClient) Hooks() []Hook {
	return c.hooks.AppStockLock
}

// Interceptors returns the client interceptors.
func (c *AppStockLockClient) Interceptors() []Interceptor {
	return c.inters.AppStockLock
}

func (c *AppStockLockClient) mutate(ctx context.Context, m *AppStockLockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppStockLockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppStockLockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppStockLockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppStockLockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppStockLock mutation op: %q", m.Op())
	}
}

// AppSubscriptionClient is a client for the AppSubscription schema.
type AppSubscriptionClient struct {
	config
}

// NewAppSubscriptionClient returns a client for the AppSubscription from the given config.
func NewAppSubscriptionClient(c config) *AppSubscriptionClient {
	return &AppSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appsubscription.Hooks(f(g(h())))`.
func (c *AppSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.AppSubscription = append(c.hooks.AppSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appsubscription.Intercept(f(g(h())))`.
func (c *AppSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppSubscription = append(c.inters.AppSubscription, interceptors...)
}

// Create returns a builder for creating a AppSubscription entity.
func (c *AppSubscriptionClient) Create() *AppSubscriptionCreate {
	mutation := newAppSubscriptionMutation(c.config, OpCreate)
	return &AppSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppSubscription entities.
func (c *AppSubscriptionClient) CreateBulk(builders ...*AppSubscriptionCreate) *AppSubscriptionCreateBulk {
	return &AppSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppSubscriptionClient) MapCreateBulk(slice any, setFunc func(*AppSubscriptionCreate, int)) *AppSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppSubscriptionCreateBulk{err: fmt.Errorf("calling to AppSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppSubscription.
func (c *AppSubscriptionClient) Update() *AppSubscriptionUpdate {
	mutation := newAppSubscriptionMutation(c.config, OpUpdate)
	return &AppSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppSubscriptionClient) UpdateOne(as *AppSubscription) *AppSubscriptionUpdateOne {
	mutation := newAppSubscriptionMutation(c.config, OpUpdateOne, withAppSubscription(as))
	return &AppSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppSubscriptionClient) UpdateOneID(id uint32) *AppSubscriptionUpdateOne {
	mutation := newAppSubscriptionMutation(c.config, OpUpdateOne, withAppSubscriptionID(id))
	return &AppSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppSubscription.
func (c *AppSubscriptionClient) Delete() *AppSubscriptionDelete {
	mutation := newAppSubscriptionMutation(c.config, OpDelete)
	return &AppSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppSubscriptionClient) DeleteOne(as *AppSubscription) *AppSubscriptionDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppSubscriptionClient) DeleteOneID(id uint32) *AppSubscriptionDeleteOne {
	builder := c.Delete().Where(appsubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppSubscriptionDeleteOne{builder}
}

// Query returns a query builder for AppSubscription.
func (c *AppSubscriptionClient) Query() *AppSubscriptionQuery {
	return &AppSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a AppSubscription entity by its id.
func (c *AppSubscriptionClient) Get(ctx context.Context, id uint32) (*AppSubscription, error) {
	return c.Query().Where(appsubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppSubscriptionClient) GetX(ctx context.Context, id uint32) *AppSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppSubscriptionClient) Hooks() []Hook {
	return c.hooks.AppSubscription
}

// Interceptors returns the client interceptors.
func (c *AppSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.AppSubscription
}

func (c *AppSubscriptionClient) mutate(ctx context.Context, m *AppSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppSubscription mutation op: %q", m.Op())
	}
}

// AppSubscriptionOneShotClient is a client for the AppSubscriptionOneShot schema.
type AppSubscriptionOneShotClient struct {
	config
}

// NewAppSubscriptionOneShotClient returns a client for the AppSubscriptionOneShot from the given config.
func NewAppSubscriptionOneShotClient(c config) *AppSubscriptionOneShotClient {
	return &AppSubscriptionOneShotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appsubscriptiononeshot.Hooks(f(g(h())))`.
func (c *AppSubscriptionOneShotClient) Use(hooks ...Hook) {
	c.hooks.AppSubscriptionOneShot = append(c.hooks.AppSubscriptionOneShot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appsubscriptiononeshot.Intercept(f(g(h())))`.
func (c *AppSubscriptionOneShotClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppSubscriptionOneShot = append(c.inters.AppSubscriptionOneShot, interceptors...)
}

// Create returns a builder for creating a AppSubscriptionOneShot entity.
func (c *AppSubscriptionOneShotClient) Create() *AppSubscriptionOneShotCreate {
	mutation := newAppSubscriptionOneShotMutation(c.config, OpCreate)
	return &AppSubscriptionOneShotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppSubscriptionOneShot entities.
func (c *AppSubscriptionOneShotClient) CreateBulk(builders ...*AppSubscriptionOneShotCreate) *AppSubscriptionOneShotCreateBulk {
	return &AppSubscriptionOneShotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppSubscriptionOneShotClient) MapCreateBulk(slice any, setFunc func(*AppSubscriptionOneShotCreate, int)) *AppSubscriptionOneShotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppSubscriptionOneShotCreateBulk{err: fmt.Errorf("calling to AppSubscriptionOneShotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppSubscriptionOneShotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppSubscriptionOneShotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppSubscriptionOneShot.
func (c *AppSubscriptionOneShotClient) Update() *AppSubscriptionOneShotUpdate {
	mutation := newAppSubscriptionOneShotMutation(c.config, OpUpdate)
	return &AppSubscriptionOneShotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppSubscriptionOneShotClient) UpdateOne(asos *AppSubscriptionOneShot) *AppSubscriptionOneShotUpdateOne {
	mutation := newAppSubscriptionOneShotMutation(c.config, OpUpdateOne, withAppSubscriptionOneShot(asos))
	return &AppSubscriptionOneShotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppSubscriptionOneShotClient) UpdateOneID(id uint32) *AppSubscriptionOneShotUpdateOne {
	mutation := newAppSubscriptionOneShotMutation(c.config, OpUpdateOne, withAppSubscriptionOneShotID(id))
	return &AppSubscriptionOneShotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppSubscriptionOneShot.
func (c *AppSubscriptionOneShotClient) Delete() *AppSubscriptionOneShotDelete {
	mutation := newAppSubscriptionOneShotMutation(c.config, OpDelete)
	return &AppSubscriptionOneShotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppSubscriptionOneShotClient) DeleteOne(asos *AppSubscriptionOneShot) *AppSubscriptionOneShotDeleteOne {
	return c.DeleteOneID(asos.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppSubscriptionOneShotClient) DeleteOneID(id uint32) *AppSubscriptionOneShotDeleteOne {
	builder := c.Delete().Where(appsubscriptiononeshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppSubscriptionOneShotDeleteOne{builder}
}

// Query returns a query builder for AppSubscriptionOneShot.
func (c *AppSubscriptionOneShotClient) Query() *AppSubscriptionOneShotQuery {
	return &AppSubscriptionOneShotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppSubscriptionOneShot},
		inters: c.Interceptors(),
	}
}

// Get returns a AppSubscriptionOneShot entity by its id.
func (c *AppSubscriptionOneShotClient) Get(ctx context.Context, id uint32) (*AppSubscriptionOneShot, error) {
	return c.Query().Where(appsubscriptiononeshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppSubscriptionOneShotClient) GetX(ctx context.Context, id uint32) *AppSubscriptionOneShot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppSubscriptionOneShotClient) Hooks() []Hook {
	return c.hooks.AppSubscriptionOneShot
}

// Interceptors returns the client interceptors.
func (c *AppSubscriptionOneShotClient) Interceptors() []Interceptor {
	return c.inters.AppSubscriptionOneShot
}

func (c *AppSubscriptionOneShotClient) mutate(ctx context.Context, m *AppSubscriptionOneShotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppSubscriptionOneShotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppSubscriptionOneShotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppSubscriptionOneShotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppSubscriptionOneShotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppSubscriptionOneShot mutation op: %q", m.Op())
	}
}

// CommentClient is a client for the Comment schema.
type CommentClient struct {
	config
}

// NewCommentClient returns a client for the Comment from the given config.
func NewCommentClient(c config) *CommentClient {
	return &CommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `comment.Hooks(f(g(h())))`.
func (c *CommentClient) Use(hooks ...Hook) {
	c.hooks.Comment = append(c.hooks.Comment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `comment.Intercept(f(g(h())))`.
func (c *CommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Comment = append(c.inters.Comment, interceptors...)
}

// Create returns a builder for creating a Comment entity.
func (c *CommentClient) Create() *CommentCreate {
	mutation := newCommentMutation(c.config, OpCreate)
	return &CommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Comment entities.
func (c *CommentClient) CreateBulk(builders ...*CommentCreate) *CommentCreateBulk {
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommentClient) MapCreateBulk(slice any, setFunc func(*CommentCreate, int)) *CommentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommentCreateBulk{err: fmt.Errorf("calling to CommentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Comment.
func (c *CommentClient) Update() *CommentUpdate {
	mutation := newCommentMutation(c.config, OpUpdate)
	return &CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentClient) UpdateOne(co *Comment) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withComment(co))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentClient) UpdateOneID(id uint32) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withCommentID(id))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Comment.
func (c *CommentClient) Delete() *CommentDelete {
	mutation := newCommentMutation(c.config, OpDelete)
	return &CommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentClient) DeleteOne(co *Comment) *CommentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentClient) DeleteOneID(id uint32) *CommentDeleteOne {
	builder := c.Delete().Where(comment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentDeleteOne{builder}
}

// Query returns a query builder for Comment.
func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComment},
		inters: c.Interceptors(),
	}
}

// Get returns a Comment entity by its id.
func (c *CommentClient) Get(ctx context.Context, id uint32) (*Comment, error) {
	return c.Query().Where(comment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentClient) GetX(ctx context.Context, id uint32) *Comment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CommentClient) Hooks() []Hook {
	return c.hooks.Comment
}

// Interceptors returns the client interceptors.
func (c *CommentClient) Interceptors() []Interceptor {
	return c.inters.Comment
}

func (c *CommentClient) mutate(ctx context.Context, m *CommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Comment mutation op: %q", m.Op())
	}
}

// DelegatedStakingClient is a client for the DelegatedStaking schema.
type DelegatedStakingClient struct {
	config
}

// NewDelegatedStakingClient returns a client for the DelegatedStaking from the given config.
func NewDelegatedStakingClient(c config) *DelegatedStakingClient {
	return &DelegatedStakingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `delegatedstaking.Hooks(f(g(h())))`.
func (c *DelegatedStakingClient) Use(hooks ...Hook) {
	c.hooks.DelegatedStaking = append(c.hooks.DelegatedStaking, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `delegatedstaking.Intercept(f(g(h())))`.
func (c *DelegatedStakingClient) Intercept(interceptors ...Interceptor) {
	c.inters.DelegatedStaking = append(c.inters.DelegatedStaking, interceptors...)
}

// Create returns a builder for creating a DelegatedStaking entity.
func (c *DelegatedStakingClient) Create() *DelegatedStakingCreate {
	mutation := newDelegatedStakingMutation(c.config, OpCreate)
	return &DelegatedStakingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DelegatedStaking entities.
func (c *DelegatedStakingClient) CreateBulk(builders ...*DelegatedStakingCreate) *DelegatedStakingCreateBulk {
	return &DelegatedStakingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DelegatedStakingClient) MapCreateBulk(slice any, setFunc func(*DelegatedStakingCreate, int)) *DelegatedStakingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DelegatedStakingCreateBulk{err: fmt.Errorf("calling to DelegatedStakingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DelegatedStakingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DelegatedStakingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DelegatedStaking.
func (c *DelegatedStakingClient) Update() *DelegatedStakingUpdate {
	mutation := newDelegatedStakingMutation(c.config, OpUpdate)
	return &DelegatedStakingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DelegatedStakingClient) UpdateOne(ds *DelegatedStaking) *DelegatedStakingUpdateOne {
	mutation := newDelegatedStakingMutation(c.config, OpUpdateOne, withDelegatedStaking(ds))
	return &DelegatedStakingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DelegatedStakingClient) UpdateOneID(id uint32) *DelegatedStakingUpdateOne {
	mutation := newDelegatedStakingMutation(c.config, OpUpdateOne, withDelegatedStakingID(id))
	return &DelegatedStakingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DelegatedStaking.
func (c *DelegatedStakingClient) Delete() *DelegatedStakingDelete {
	mutation := newDelegatedStakingMutation(c.config, OpDelete)
	return &DelegatedStakingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DelegatedStakingClient) DeleteOne(ds *DelegatedStaking) *DelegatedStakingDeleteOne {
	return c.DeleteOneID(ds.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DelegatedStakingClient) DeleteOneID(id uint32) *DelegatedStakingDeleteOne {
	builder := c.Delete().Where(delegatedstaking.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DelegatedStakingDeleteOne{builder}
}

// Query returns a query builder for DelegatedStaking.
func (c *DelegatedStakingClient) Query() *DelegatedStakingQuery {
	return &DelegatedStakingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDelegatedStaking},
		inters: c.Interceptors(),
	}
}

// Get returns a DelegatedStaking entity by its id.
func (c *DelegatedStakingClient) Get(ctx context.Context, id uint32) (*DelegatedStaking, error) {
	return c.Query().Where(delegatedstaking.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DelegatedStakingClient) GetX(ctx context.Context, id uint32) *DelegatedStaking {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DelegatedStakingClient) Hooks() []Hook {
	return c.hooks.DelegatedStaking
}

// Interceptors returns the client interceptors.
func (c *DelegatedStakingClient) Interceptors() []Interceptor {
	return c.inters.DelegatedStaking
}

func (c *DelegatedStakingClient) mutate(ctx context.Context, m *DelegatedStakingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DelegatedStakingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DelegatedStakingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DelegatedStakingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DelegatedStakingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DelegatedStaking mutation op: %q", m.Op())
	}
}

// DeviceInfoClient is a client for the DeviceInfo schema.
type DeviceInfoClient struct {
	config
}

// NewDeviceInfoClient returns a client for the DeviceInfo from the given config.
func NewDeviceInfoClient(c config) *DeviceInfoClient {
	return &DeviceInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deviceinfo.Hooks(f(g(h())))`.
func (c *DeviceInfoClient) Use(hooks ...Hook) {
	c.hooks.DeviceInfo = append(c.hooks.DeviceInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deviceinfo.Intercept(f(g(h())))`.
func (c *DeviceInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceInfo = append(c.inters.DeviceInfo, interceptors...)
}

// Create returns a builder for creating a DeviceInfo entity.
func (c *DeviceInfoClient) Create() *DeviceInfoCreate {
	mutation := newDeviceInfoMutation(c.config, OpCreate)
	return &DeviceInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceInfo entities.
func (c *DeviceInfoClient) CreateBulk(builders ...*DeviceInfoCreate) *DeviceInfoCreateBulk {
	return &DeviceInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceInfoClient) MapCreateBulk(slice any, setFunc func(*DeviceInfoCreate, int)) *DeviceInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceInfoCreateBulk{err: fmt.Errorf("calling to DeviceInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceInfo.
func (c *DeviceInfoClient) Update() *DeviceInfoUpdate {
	mutation := newDeviceInfoMutation(c.config, OpUpdate)
	return &DeviceInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceInfoClient) UpdateOne(di *DeviceInfo) *DeviceInfoUpdateOne {
	mutation := newDeviceInfoMutation(c.config, OpUpdateOne, withDeviceInfo(di))
	return &DeviceInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceInfoClient) UpdateOneID(id uint32) *DeviceInfoUpdateOne {
	mutation := newDeviceInfoMutation(c.config, OpUpdateOne, withDeviceInfoID(id))
	return &DeviceInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceInfo.
func (c *DeviceInfoClient) Delete() *DeviceInfoDelete {
	mutation := newDeviceInfoMutation(c.config, OpDelete)
	return &DeviceInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceInfoClient) DeleteOne(di *DeviceInfo) *DeviceInfoDeleteOne {
	return c.DeleteOneID(di.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceInfoClient) DeleteOneID(id uint32) *DeviceInfoDeleteOne {
	builder := c.Delete().Where(deviceinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceInfoDeleteOne{builder}
}

// Query returns a query builder for DeviceInfo.
func (c *DeviceInfoClient) Query() *DeviceInfoQuery {
	return &DeviceInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceInfo entity by its id.
func (c *DeviceInfoClient) Get(ctx context.Context, id uint32) (*DeviceInfo, error) {
	return c.Query().Where(deviceinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceInfoClient) GetX(ctx context.Context, id uint32) *DeviceInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DeviceInfoClient) Hooks() []Hook {
	return c.hooks.DeviceInfo
}

// Interceptors returns the client interceptors.
func (c *DeviceInfoClient) Interceptors() []Interceptor {
	return c.inters.DeviceInfo
}

func (c *DeviceInfoClient) mutate(ctx context.Context, m *DeviceInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DeviceInfo mutation op: %q", m.Op())
	}
}

// DeviceManufacturerClient is a client for the DeviceManufacturer schema.
type DeviceManufacturerClient struct {
	config
}

// NewDeviceManufacturerClient returns a client for the DeviceManufacturer from the given config.
func NewDeviceManufacturerClient(c config) *DeviceManufacturerClient {
	return &DeviceManufacturerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devicemanufacturer.Hooks(f(g(h())))`.
func (c *DeviceManufacturerClient) Use(hooks ...Hook) {
	c.hooks.DeviceManufacturer = append(c.hooks.DeviceManufacturer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devicemanufacturer.Intercept(f(g(h())))`.
func (c *DeviceManufacturerClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceManufacturer = append(c.inters.DeviceManufacturer, interceptors...)
}

// Create returns a builder for creating a DeviceManufacturer entity.
func (c *DeviceManufacturerClient) Create() *DeviceManufacturerCreate {
	mutation := newDeviceManufacturerMutation(c.config, OpCreate)
	return &DeviceManufacturerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceManufacturer entities.
func (c *DeviceManufacturerClient) CreateBulk(builders ...*DeviceManufacturerCreate) *DeviceManufacturerCreateBulk {
	return &DeviceManufacturerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceManufacturerClient) MapCreateBulk(slice any, setFunc func(*DeviceManufacturerCreate, int)) *DeviceManufacturerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceManufacturerCreateBulk{err: fmt.Errorf("calling to DeviceManufacturerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceManufacturerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceManufacturerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceManufacturer.
func (c *DeviceManufacturerClient) Update() *DeviceManufacturerUpdate {
	mutation := newDeviceManufacturerMutation(c.config, OpUpdate)
	return &DeviceManufacturerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceManufacturerClient) UpdateOne(dm *DeviceManufacturer) *DeviceManufacturerUpdateOne {
	mutation := newDeviceManufacturerMutation(c.config, OpUpdateOne, withDeviceManufacturer(dm))
	return &DeviceManufacturerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceManufacturerClient) UpdateOneID(id uint32) *DeviceManufacturerUpdateOne {
	mutation := newDeviceManufacturerMutation(c.config, OpUpdateOne, withDeviceManufacturerID(id))
	return &DeviceManufacturerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceManufacturer.
func (c *DeviceManufacturerClient) Delete() *DeviceManufacturerDelete {
	mutation := newDeviceManufacturerMutation(c.config, OpDelete)
	return &DeviceManufacturerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceManufacturerClient) DeleteOne(dm *DeviceManufacturer) *DeviceManufacturerDeleteOne {
	return c.DeleteOneID(dm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceManufacturerClient) DeleteOneID(id uint32) *DeviceManufacturerDeleteOne {
	builder := c.Delete().Where(devicemanufacturer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceManufacturerDeleteOne{builder}
}

// Query returns a query builder for DeviceManufacturer.
func (c *DeviceManufacturerClient) Query() *DeviceManufacturerQuery {
	return &DeviceManufacturerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceManufacturer},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceManufacturer entity by its id.
func (c *DeviceManufacturerClient) Get(ctx context.Context, id uint32) (*DeviceManufacturer, error) {
	return c.Query().Where(devicemanufacturer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceManufacturerClient) GetX(ctx context.Context, id uint32) *DeviceManufacturer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DeviceManufacturerClient) Hooks() []Hook {
	return c.hooks.DeviceManufacturer
}

// Interceptors returns the client interceptors.
func (c *DeviceManufacturerClient) Interceptors() []Interceptor {
	return c.inters.DeviceManufacturer
}

func (c *DeviceManufacturerClient) mutate(ctx context.Context, m *DeviceManufacturerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceManufacturerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceManufacturerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceManufacturerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceManufacturerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DeviceManufacturer mutation op: %q", m.Op())
	}
}

// DevicePosterClient is a client for the DevicePoster schema.
type DevicePosterClient struct {
	config
}

// NewDevicePosterClient returns a client for the DevicePoster from the given config.
func NewDevicePosterClient(c config) *DevicePosterClient {
	return &DevicePosterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deviceposter.Hooks(f(g(h())))`.
func (c *DevicePosterClient) Use(hooks ...Hook) {
	c.hooks.DevicePoster = append(c.hooks.DevicePoster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deviceposter.Intercept(f(g(h())))`.
func (c *DevicePosterClient) Intercept(interceptors ...Interceptor) {
	c.inters.DevicePoster = append(c.inters.DevicePoster, interceptors...)
}

// Create returns a builder for creating a DevicePoster entity.
func (c *DevicePosterClient) Create() *DevicePosterCreate {
	mutation := newDevicePosterMutation(c.config, OpCreate)
	return &DevicePosterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DevicePoster entities.
func (c *DevicePosterClient) CreateBulk(builders ...*DevicePosterCreate) *DevicePosterCreateBulk {
	return &DevicePosterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DevicePosterClient) MapCreateBulk(slice any, setFunc func(*DevicePosterCreate, int)) *DevicePosterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DevicePosterCreateBulk{err: fmt.Errorf("calling to DevicePosterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DevicePosterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DevicePosterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DevicePoster.
func (c *DevicePosterClient) Update() *DevicePosterUpdate {
	mutation := newDevicePosterMutation(c.config, OpUpdate)
	return &DevicePosterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DevicePosterClient) UpdateOne(dp *DevicePoster) *DevicePosterUpdateOne {
	mutation := newDevicePosterMutation(c.config, OpUpdateOne, withDevicePoster(dp))
	return &DevicePosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DevicePosterClient) UpdateOneID(id uint32) *DevicePosterUpdateOne {
	mutation := newDevicePosterMutation(c.config, OpUpdateOne, withDevicePosterID(id))
	return &DevicePosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DevicePoster.
func (c *DevicePosterClient) Delete() *DevicePosterDelete {
	mutation := newDevicePosterMutation(c.config, OpDelete)
	return &DevicePosterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DevicePosterClient) DeleteOne(dp *DevicePoster) *DevicePosterDeleteOne {
	return c.DeleteOneID(dp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DevicePosterClient) DeleteOneID(id uint32) *DevicePosterDeleteOne {
	builder := c.Delete().Where(deviceposter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DevicePosterDeleteOne{builder}
}

// Query returns a query builder for DevicePoster.
func (c *DevicePosterClient) Query() *DevicePosterQuery {
	return &DevicePosterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDevicePoster},
		inters: c.Interceptors(),
	}
}

// Get returns a DevicePoster entity by its id.
func (c *DevicePosterClient) Get(ctx context.Context, id uint32) (*DevicePoster, error) {
	return c.Query().Where(deviceposter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DevicePosterClient) GetX(ctx context.Context, id uint32) *DevicePoster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DevicePosterClient) Hooks() []Hook {
	return c.hooks.DevicePoster
}

// Interceptors returns the client interceptors.
func (c *DevicePosterClient) Interceptors() []Interceptor {
	return c.inters.DevicePoster
}

func (c *DevicePosterClient) mutate(ctx context.Context, m *DevicePosterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DevicePosterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DevicePosterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DevicePosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DevicePosterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DevicePoster mutation op: %q", m.Op())
	}
}

// ExtraInfoClient is a client for the ExtraInfo schema.
type ExtraInfoClient struct {
	config
}

// NewExtraInfoClient returns a client for the ExtraInfo from the given config.
func NewExtraInfoClient(c config) *ExtraInfoClient {
	return &ExtraInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `extrainfo.Hooks(f(g(h())))`.
func (c *ExtraInfoClient) Use(hooks ...Hook) {
	c.hooks.ExtraInfo = append(c.hooks.ExtraInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `extrainfo.Intercept(f(g(h())))`.
func (c *ExtraInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExtraInfo = append(c.inters.ExtraInfo, interceptors...)
}

// Create returns a builder for creating a ExtraInfo entity.
func (c *ExtraInfoClient) Create() *ExtraInfoCreate {
	mutation := newExtraInfoMutation(c.config, OpCreate)
	return &ExtraInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExtraInfo entities.
func (c *ExtraInfoClient) CreateBulk(builders ...*ExtraInfoCreate) *ExtraInfoCreateBulk {
	return &ExtraInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExtraInfoClient) MapCreateBulk(slice any, setFunc func(*ExtraInfoCreate, int)) *ExtraInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExtraInfoCreateBulk{err: fmt.Errorf("calling to ExtraInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExtraInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExtraInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExtraInfo.
func (c *ExtraInfoClient) Update() *ExtraInfoUpdate {
	mutation := newExtraInfoMutation(c.config, OpUpdate)
	return &ExtraInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExtraInfoClient) UpdateOne(ei *ExtraInfo) *ExtraInfoUpdateOne {
	mutation := newExtraInfoMutation(c.config, OpUpdateOne, withExtraInfo(ei))
	return &ExtraInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExtraInfoClient) UpdateOneID(id uint32) *ExtraInfoUpdateOne {
	mutation := newExtraInfoMutation(c.config, OpUpdateOne, withExtraInfoID(id))
	return &ExtraInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExtraInfo.
func (c *ExtraInfoClient) Delete() *ExtraInfoDelete {
	mutation := newExtraInfoMutation(c.config, OpDelete)
	return &ExtraInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExtraInfoClient) DeleteOne(ei *ExtraInfo) *ExtraInfoDeleteOne {
	return c.DeleteOneID(ei.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExtraInfoClient) DeleteOneID(id uint32) *ExtraInfoDeleteOne {
	builder := c.Delete().Where(extrainfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExtraInfoDeleteOne{builder}
}

// Query returns a query builder for ExtraInfo.
func (c *ExtraInfoClient) Query() *ExtraInfoQuery {
	return &ExtraInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExtraInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a ExtraInfo entity by its id.
func (c *ExtraInfoClient) Get(ctx context.Context, id uint32) (*ExtraInfo, error) {
	return c.Query().Where(extrainfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExtraInfoClient) GetX(ctx context.Context, id uint32) *ExtraInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExtraInfoClient) Hooks() []Hook {
	return c.hooks.ExtraInfo
}

// Interceptors returns the client interceptors.
func (c *ExtraInfoClient) Interceptors() []Interceptor {
	return c.inters.ExtraInfo
}

func (c *ExtraInfoClient) mutate(ctx context.Context, m *ExtraInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExtraInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExtraInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExtraInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExtraInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ExtraInfo mutation op: %q", m.Op())
	}
}

// FbmCrowdFundingClient is a client for the FbmCrowdFunding schema.
type FbmCrowdFundingClient struct {
	config
}

// NewFbmCrowdFundingClient returns a client for the FbmCrowdFunding from the given config.
func NewFbmCrowdFundingClient(c config) *FbmCrowdFundingClient {
	return &FbmCrowdFundingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fbmcrowdfunding.Hooks(f(g(h())))`.
func (c *FbmCrowdFundingClient) Use(hooks ...Hook) {
	c.hooks.FbmCrowdFunding = append(c.hooks.FbmCrowdFunding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fbmcrowdfunding.Intercept(f(g(h())))`.
func (c *FbmCrowdFundingClient) Intercept(interceptors ...Interceptor) {
	c.inters.FbmCrowdFunding = append(c.inters.FbmCrowdFunding, interceptors...)
}

// Create returns a builder for creating a FbmCrowdFunding entity.
func (c *FbmCrowdFundingClient) Create() *FbmCrowdFundingCreate {
	mutation := newFbmCrowdFundingMutation(c.config, OpCreate)
	return &FbmCrowdFundingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FbmCrowdFunding entities.
func (c *FbmCrowdFundingClient) CreateBulk(builders ...*FbmCrowdFundingCreate) *FbmCrowdFundingCreateBulk {
	return &FbmCrowdFundingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FbmCrowdFundingClient) MapCreateBulk(slice any, setFunc func(*FbmCrowdFundingCreate, int)) *FbmCrowdFundingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FbmCrowdFundingCreateBulk{err: fmt.Errorf("calling to FbmCrowdFundingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FbmCrowdFundingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FbmCrowdFundingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FbmCrowdFunding.
func (c *FbmCrowdFundingClient) Update() *FbmCrowdFundingUpdate {
	mutation := newFbmCrowdFundingMutation(c.config, OpUpdate)
	return &FbmCrowdFundingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FbmCrowdFundingClient) UpdateOne(fcf *FbmCrowdFunding) *FbmCrowdFundingUpdateOne {
	mutation := newFbmCrowdFundingMutation(c.config, OpUpdateOne, withFbmCrowdFunding(fcf))
	return &FbmCrowdFundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FbmCrowdFundingClient) UpdateOneID(id uint32) *FbmCrowdFundingUpdateOne {
	mutation := newFbmCrowdFundingMutation(c.config, OpUpdateOne, withFbmCrowdFundingID(id))
	return &FbmCrowdFundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FbmCrowdFunding.
func (c *FbmCrowdFundingClient) Delete() *FbmCrowdFundingDelete {
	mutation := newFbmCrowdFundingMutation(c.config, OpDelete)
	return &FbmCrowdFundingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FbmCrowdFundingClient) DeleteOne(fcf *FbmCrowdFunding) *FbmCrowdFundingDeleteOne {
	return c.DeleteOneID(fcf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FbmCrowdFundingClient) DeleteOneID(id uint32) *FbmCrowdFundingDeleteOne {
	builder := c.Delete().Where(fbmcrowdfunding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FbmCrowdFundingDeleteOne{builder}
}

// Query returns a query builder for FbmCrowdFunding.
func (c *FbmCrowdFundingClient) Query() *FbmCrowdFundingQuery {
	return &FbmCrowdFundingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFbmCrowdFunding},
		inters: c.Interceptors(),
	}
}

// Get returns a FbmCrowdFunding entity by its id.
func (c *FbmCrowdFundingClient) Get(ctx context.Context, id uint32) (*FbmCrowdFunding, error) {
	return c.Query().Where(fbmcrowdfunding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FbmCrowdFundingClient) GetX(ctx context.Context, id uint32) *FbmCrowdFunding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FbmCrowdFundingClient) Hooks() []Hook {
	return c.hooks.FbmCrowdFunding
}

// Interceptors returns the client interceptors.
func (c *FbmCrowdFundingClient) Interceptors() []Interceptor {
	return c.inters.FbmCrowdFunding
}

func (c *FbmCrowdFundingClient) mutate(ctx context.Context, m *FbmCrowdFundingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FbmCrowdFundingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FbmCrowdFundingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FbmCrowdFundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FbmCrowdFundingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown FbmCrowdFunding mutation op: %q", m.Op())
	}
}

// FeeClient is a client for the Fee schema.
type FeeClient struct {
	config
}

// NewFeeClient returns a client for the Fee from the given config.
func NewFeeClient(c config) *FeeClient {
	return &FeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fee.Hooks(f(g(h())))`.
func (c *FeeClient) Use(hooks ...Hook) {
	c.hooks.Fee = append(c.hooks.Fee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fee.Intercept(f(g(h())))`.
func (c *FeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Fee = append(c.inters.Fee, interceptors...)
}

// Create returns a builder for creating a Fee entity.
func (c *FeeClient) Create() *FeeCreate {
	mutation := newFeeMutation(c.config, OpCreate)
	return &FeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Fee entities.
func (c *FeeClient) CreateBulk(builders ...*FeeCreate) *FeeCreateBulk {
	return &FeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeeClient) MapCreateBulk(slice any, setFunc func(*FeeCreate, int)) *FeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeeCreateBulk{err: fmt.Errorf("calling to FeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Fee.
func (c *FeeClient) Update() *FeeUpdate {
	mutation := newFeeMutation(c.config, OpUpdate)
	return &FeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeeClient) UpdateOne(f *Fee) *FeeUpdateOne {
	mutation := newFeeMutation(c.config, OpUpdateOne, withFee(f))
	return &FeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeeClient) UpdateOneID(id uint32) *FeeUpdateOne {
	mutation := newFeeMutation(c.config, OpUpdateOne, withFeeID(id))
	return &FeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fee.
func (c *FeeClient) Delete() *FeeDelete {
	mutation := newFeeMutation(c.config, OpDelete)
	return &FeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeeClient) DeleteOne(f *Fee) *FeeDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeeClient) DeleteOneID(id uint32) *FeeDeleteOne {
	builder := c.Delete().Where(fee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeeDeleteOne{builder}
}

// Query returns a query builder for Fee.
func (c *FeeClient) Query() *FeeQuery {
	return &FeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFee},
		inters: c.Interceptors(),
	}
}

// Get returns a Fee entity by its id.
func (c *FeeClient) Get(ctx context.Context, id uint32) (*Fee, error) {
	return c.Query().Where(fee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeeClient) GetX(ctx context.Context, id uint32) *Fee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FeeClient) Hooks() []Hook {
	return c.hooks.Fee
}

// Interceptors returns the client interceptors.
func (c *FeeClient) Interceptors() []Interceptor {
	return c.inters.Fee
}

func (c *FeeClient) mutate(ctx context.Context, m *FeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Fee mutation op: %q", m.Op())
	}
}

// GoodClient is a client for the Good schema.
type GoodClient struct {
	config
}

// NewGoodClient returns a client for the Good from the given config.
func NewGoodClient(c config) *GoodClient {
	return &GoodClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `good.Hooks(f(g(h())))`.
func (c *GoodClient) Use(hooks ...Hook) {
	c.hooks.Good = append(c.hooks.Good, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `good.Intercept(f(g(h())))`.
func (c *GoodClient) Intercept(interceptors ...Interceptor) {
	c.inters.Good = append(c.inters.Good, interceptors...)
}

// Create returns a builder for creating a Good entity.
func (c *GoodClient) Create() *GoodCreate {
	mutation := newGoodMutation(c.config, OpCreate)
	return &GoodCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Good entities.
func (c *GoodClient) CreateBulk(builders ...*GoodCreate) *GoodCreateBulk {
	return &GoodCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodClient) MapCreateBulk(slice any, setFunc func(*GoodCreate, int)) *GoodCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodCreateBulk{err: fmt.Errorf("calling to GoodClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Good.
func (c *GoodClient) Update() *GoodUpdate {
	mutation := newGoodMutation(c.config, OpUpdate)
	return &GoodUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodClient) UpdateOne(_go *Good) *GoodUpdateOne {
	mutation := newGoodMutation(c.config, OpUpdateOne, withGood(_go))
	return &GoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodClient) UpdateOneID(id uint32) *GoodUpdateOne {
	mutation := newGoodMutation(c.config, OpUpdateOne, withGoodID(id))
	return &GoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Good.
func (c *GoodClient) Delete() *GoodDelete {
	mutation := newGoodMutation(c.config, OpDelete)
	return &GoodDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodClient) DeleteOne(_go *Good) *GoodDeleteOne {
	return c.DeleteOneID(_go.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodClient) DeleteOneID(id uint32) *GoodDeleteOne {
	builder := c.Delete().Where(good.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodDeleteOne{builder}
}

// Query returns a query builder for Good.
func (c *GoodClient) Query() *GoodQuery {
	return &GoodQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGood},
		inters: c.Interceptors(),
	}
}

// Get returns a Good entity by its id.
func (c *GoodClient) Get(ctx context.Context, id uint32) (*Good, error) {
	return c.Query().Where(good.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodClient) GetX(ctx context.Context, id uint32) *Good {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodClient) Hooks() []Hook {
	return c.hooks.Good
}

// Interceptors returns the client interceptors.
func (c *GoodClient) Interceptors() []Interceptor {
	return c.inters.Good
}

func (c *GoodClient) mutate(ctx context.Context, m *GoodMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Good mutation op: %q", m.Op())
	}
}

// GoodBaseClient is a client for the GoodBase schema.
type GoodBaseClient struct {
	config
}

// NewGoodBaseClient returns a client for the GoodBase from the given config.
func NewGoodBaseClient(c config) *GoodBaseClient {
	return &GoodBaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goodbase.Hooks(f(g(h())))`.
func (c *GoodBaseClient) Use(hooks ...Hook) {
	c.hooks.GoodBase = append(c.hooks.GoodBase, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goodbase.Intercept(f(g(h())))`.
func (c *GoodBaseClient) Intercept(interceptors ...Interceptor) {
	c.inters.GoodBase = append(c.inters.GoodBase, interceptors...)
}

// Create returns a builder for creating a GoodBase entity.
func (c *GoodBaseClient) Create() *GoodBaseCreate {
	mutation := newGoodBaseMutation(c.config, OpCreate)
	return &GoodBaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoodBase entities.
func (c *GoodBaseClient) CreateBulk(builders ...*GoodBaseCreate) *GoodBaseCreateBulk {
	return &GoodBaseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodBaseClient) MapCreateBulk(slice any, setFunc func(*GoodBaseCreate, int)) *GoodBaseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodBaseCreateBulk{err: fmt.Errorf("calling to GoodBaseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodBaseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodBaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoodBase.
func (c *GoodBaseClient) Update() *GoodBaseUpdate {
	mutation := newGoodBaseMutation(c.config, OpUpdate)
	return &GoodBaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodBaseClient) UpdateOne(gb *GoodBase) *GoodBaseUpdateOne {
	mutation := newGoodBaseMutation(c.config, OpUpdateOne, withGoodBase(gb))
	return &GoodBaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodBaseClient) UpdateOneID(id uint32) *GoodBaseUpdateOne {
	mutation := newGoodBaseMutation(c.config, OpUpdateOne, withGoodBaseID(id))
	return &GoodBaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoodBase.
func (c *GoodBaseClient) Delete() *GoodBaseDelete {
	mutation := newGoodBaseMutation(c.config, OpDelete)
	return &GoodBaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodBaseClient) DeleteOne(gb *GoodBase) *GoodBaseDeleteOne {
	return c.DeleteOneID(gb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodBaseClient) DeleteOneID(id uint32) *GoodBaseDeleteOne {
	builder := c.Delete().Where(goodbase.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodBaseDeleteOne{builder}
}

// Query returns a query builder for GoodBase.
func (c *GoodBaseClient) Query() *GoodBaseQuery {
	return &GoodBaseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoodBase},
		inters: c.Interceptors(),
	}
}

// Get returns a GoodBase entity by its id.
func (c *GoodBaseClient) Get(ctx context.Context, id uint32) (*GoodBase, error) {
	return c.Query().Where(goodbase.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodBaseClient) GetX(ctx context.Context, id uint32) *GoodBase {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodBaseClient) Hooks() []Hook {
	return c.hooks.GoodBase
}

// Interceptors returns the client interceptors.
func (c *GoodBaseClient) Interceptors() []Interceptor {
	return c.inters.GoodBase
}

func (c *GoodBaseClient) mutate(ctx context.Context, m *GoodBaseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodBaseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodBaseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodBaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodBaseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GoodBase mutation op: %q", m.Op())
	}
}

// GoodCoinClient is a client for the GoodCoin schema.
type GoodCoinClient struct {
	config
}

// NewGoodCoinClient returns a client for the GoodCoin from the given config.
func NewGoodCoinClient(c config) *GoodCoinClient {
	return &GoodCoinClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goodcoin.Hooks(f(g(h())))`.
func (c *GoodCoinClient) Use(hooks ...Hook) {
	c.hooks.GoodCoin = append(c.hooks.GoodCoin, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goodcoin.Intercept(f(g(h())))`.
func (c *GoodCoinClient) Intercept(interceptors ...Interceptor) {
	c.inters.GoodCoin = append(c.inters.GoodCoin, interceptors...)
}

// Create returns a builder for creating a GoodCoin entity.
func (c *GoodCoinClient) Create() *GoodCoinCreate {
	mutation := newGoodCoinMutation(c.config, OpCreate)
	return &GoodCoinCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoodCoin entities.
func (c *GoodCoinClient) CreateBulk(builders ...*GoodCoinCreate) *GoodCoinCreateBulk {
	return &GoodCoinCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodCoinClient) MapCreateBulk(slice any, setFunc func(*GoodCoinCreate, int)) *GoodCoinCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodCoinCreateBulk{err: fmt.Errorf("calling to GoodCoinClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodCoinCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodCoinCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoodCoin.
func (c *GoodCoinClient) Update() *GoodCoinUpdate {
	mutation := newGoodCoinMutation(c.config, OpUpdate)
	return &GoodCoinUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodCoinClient) UpdateOne(gc *GoodCoin) *GoodCoinUpdateOne {
	mutation := newGoodCoinMutation(c.config, OpUpdateOne, withGoodCoin(gc))
	return &GoodCoinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodCoinClient) UpdateOneID(id uint32) *GoodCoinUpdateOne {
	mutation := newGoodCoinMutation(c.config, OpUpdateOne, withGoodCoinID(id))
	return &GoodCoinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoodCoin.
func (c *GoodCoinClient) Delete() *GoodCoinDelete {
	mutation := newGoodCoinMutation(c.config, OpDelete)
	return &GoodCoinDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodCoinClient) DeleteOne(gc *GoodCoin) *GoodCoinDeleteOne {
	return c.DeleteOneID(gc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodCoinClient) DeleteOneID(id uint32) *GoodCoinDeleteOne {
	builder := c.Delete().Where(goodcoin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodCoinDeleteOne{builder}
}

// Query returns a query builder for GoodCoin.
func (c *GoodCoinClient) Query() *GoodCoinQuery {
	return &GoodCoinQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoodCoin},
		inters: c.Interceptors(),
	}
}

// Get returns a GoodCoin entity by its id.
func (c *GoodCoinClient) Get(ctx context.Context, id uint32) (*GoodCoin, error) {
	return c.Query().Where(goodcoin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodCoinClient) GetX(ctx context.Context, id uint32) *GoodCoin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodCoinClient) Hooks() []Hook {
	return c.hooks.GoodCoin
}

// Interceptors returns the client interceptors.
func (c *GoodCoinClient) Interceptors() []Interceptor {
	return c.inters.GoodCoin
}

func (c *GoodCoinClient) mutate(ctx context.Context, m *GoodCoinMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodCoinCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodCoinUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodCoinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodCoinDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GoodCoin mutation op: %q", m.Op())
	}
}

// GoodCoinRewardClient is a client for the GoodCoinReward schema.
type GoodCoinRewardClient struct {
	config
}

// NewGoodCoinRewardClient returns a client for the GoodCoinReward from the given config.
func NewGoodCoinRewardClient(c config) *GoodCoinRewardClient {
	return &GoodCoinRewardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goodcoinreward.Hooks(f(g(h())))`.
func (c *GoodCoinRewardClient) Use(hooks ...Hook) {
	c.hooks.GoodCoinReward = append(c.hooks.GoodCoinReward, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goodcoinreward.Intercept(f(g(h())))`.
func (c *GoodCoinRewardClient) Intercept(interceptors ...Interceptor) {
	c.inters.GoodCoinReward = append(c.inters.GoodCoinReward, interceptors...)
}

// Create returns a builder for creating a GoodCoinReward entity.
func (c *GoodCoinRewardClient) Create() *GoodCoinRewardCreate {
	mutation := newGoodCoinRewardMutation(c.config, OpCreate)
	return &GoodCoinRewardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoodCoinReward entities.
func (c *GoodCoinRewardClient) CreateBulk(builders ...*GoodCoinRewardCreate) *GoodCoinRewardCreateBulk {
	return &GoodCoinRewardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodCoinRewardClient) MapCreateBulk(slice any, setFunc func(*GoodCoinRewardCreate, int)) *GoodCoinRewardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodCoinRewardCreateBulk{err: fmt.Errorf("calling to GoodCoinRewardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodCoinRewardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodCoinRewardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoodCoinReward.
func (c *GoodCoinRewardClient) Update() *GoodCoinRewardUpdate {
	mutation := newGoodCoinRewardMutation(c.config, OpUpdate)
	return &GoodCoinRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodCoinRewardClient) UpdateOne(gcr *GoodCoinReward) *GoodCoinRewardUpdateOne {
	mutation := newGoodCoinRewardMutation(c.config, OpUpdateOne, withGoodCoinReward(gcr))
	return &GoodCoinRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodCoinRewardClient) UpdateOneID(id uint32) *GoodCoinRewardUpdateOne {
	mutation := newGoodCoinRewardMutation(c.config, OpUpdateOne, withGoodCoinRewardID(id))
	return &GoodCoinRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoodCoinReward.
func (c *GoodCoinRewardClient) Delete() *GoodCoinRewardDelete {
	mutation := newGoodCoinRewardMutation(c.config, OpDelete)
	return &GoodCoinRewardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodCoinRewardClient) DeleteOne(gcr *GoodCoinReward) *GoodCoinRewardDeleteOne {
	return c.DeleteOneID(gcr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodCoinRewardClient) DeleteOneID(id uint32) *GoodCoinRewardDeleteOne {
	builder := c.Delete().Where(goodcoinreward.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodCoinRewardDeleteOne{builder}
}

// Query returns a query builder for GoodCoinReward.
func (c *GoodCoinRewardClient) Query() *GoodCoinRewardQuery {
	return &GoodCoinRewardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoodCoinReward},
		inters: c.Interceptors(),
	}
}

// Get returns a GoodCoinReward entity by its id.
func (c *GoodCoinRewardClient) Get(ctx context.Context, id uint32) (*GoodCoinReward, error) {
	return c.Query().Where(goodcoinreward.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodCoinRewardClient) GetX(ctx context.Context, id uint32) *GoodCoinReward {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodCoinRewardClient) Hooks() []Hook {
	return c.hooks.GoodCoinReward
}

// Interceptors returns the client interceptors.
func (c *GoodCoinRewardClient) Interceptors() []Interceptor {
	return c.inters.GoodCoinReward
}

func (c *GoodCoinRewardClient) mutate(ctx context.Context, m *GoodCoinRewardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodCoinRewardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodCoinRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodCoinRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodCoinRewardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GoodCoinReward mutation op: %q", m.Op())
	}
}

// GoodMalfunctionClient is a client for the GoodMalfunction schema.
type GoodMalfunctionClient struct {
	config
}

// NewGoodMalfunctionClient returns a client for the GoodMalfunction from the given config.
func NewGoodMalfunctionClient(c config) *GoodMalfunctionClient {
	return &GoodMalfunctionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goodmalfunction.Hooks(f(g(h())))`.
func (c *GoodMalfunctionClient) Use(hooks ...Hook) {
	c.hooks.GoodMalfunction = append(c.hooks.GoodMalfunction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goodmalfunction.Intercept(f(g(h())))`.
func (c *GoodMalfunctionClient) Intercept(interceptors ...Interceptor) {
	c.inters.GoodMalfunction = append(c.inters.GoodMalfunction, interceptors...)
}

// Create returns a builder for creating a GoodMalfunction entity.
func (c *GoodMalfunctionClient) Create() *GoodMalfunctionCreate {
	mutation := newGoodMalfunctionMutation(c.config, OpCreate)
	return &GoodMalfunctionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoodMalfunction entities.
func (c *GoodMalfunctionClient) CreateBulk(builders ...*GoodMalfunctionCreate) *GoodMalfunctionCreateBulk {
	return &GoodMalfunctionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodMalfunctionClient) MapCreateBulk(slice any, setFunc func(*GoodMalfunctionCreate, int)) *GoodMalfunctionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodMalfunctionCreateBulk{err: fmt.Errorf("calling to GoodMalfunctionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodMalfunctionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodMalfunctionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoodMalfunction.
func (c *GoodMalfunctionClient) Update() *GoodMalfunctionUpdate {
	mutation := newGoodMalfunctionMutation(c.config, OpUpdate)
	return &GoodMalfunctionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodMalfunctionClient) UpdateOne(gm *GoodMalfunction) *GoodMalfunctionUpdateOne {
	mutation := newGoodMalfunctionMutation(c.config, OpUpdateOne, withGoodMalfunction(gm))
	return &GoodMalfunctionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodMalfunctionClient) UpdateOneID(id uint32) *GoodMalfunctionUpdateOne {
	mutation := newGoodMalfunctionMutation(c.config, OpUpdateOne, withGoodMalfunctionID(id))
	return &GoodMalfunctionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoodMalfunction.
func (c *GoodMalfunctionClient) Delete() *GoodMalfunctionDelete {
	mutation := newGoodMalfunctionMutation(c.config, OpDelete)
	return &GoodMalfunctionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodMalfunctionClient) DeleteOne(gm *GoodMalfunction) *GoodMalfunctionDeleteOne {
	return c.DeleteOneID(gm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodMalfunctionClient) DeleteOneID(id uint32) *GoodMalfunctionDeleteOne {
	builder := c.Delete().Where(goodmalfunction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodMalfunctionDeleteOne{builder}
}

// Query returns a query builder for GoodMalfunction.
func (c *GoodMalfunctionClient) Query() *GoodMalfunctionQuery {
	return &GoodMalfunctionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoodMalfunction},
		inters: c.Interceptors(),
	}
}

// Get returns a GoodMalfunction entity by its id.
func (c *GoodMalfunctionClient) Get(ctx context.Context, id uint32) (*GoodMalfunction, error) {
	return c.Query().Where(goodmalfunction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodMalfunctionClient) GetX(ctx context.Context, id uint32) *GoodMalfunction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodMalfunctionClient) Hooks() []Hook {
	return c.hooks.GoodMalfunction
}

// Interceptors returns the client interceptors.
func (c *GoodMalfunctionClient) Interceptors() []Interceptor {
	return c.inters.GoodMalfunction
}

func (c *GoodMalfunctionClient) mutate(ctx context.Context, m *GoodMalfunctionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodMalfunctionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodMalfunctionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodMalfunctionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodMalfunctionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GoodMalfunction mutation op: %q", m.Op())
	}
}

// GoodRewardClient is a client for the GoodReward schema.
type GoodRewardClient struct {
	config
}

// NewGoodRewardClient returns a client for the GoodReward from the given config.
func NewGoodRewardClient(c config) *GoodRewardClient {
	return &GoodRewardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goodreward.Hooks(f(g(h())))`.
func (c *GoodRewardClient) Use(hooks ...Hook) {
	c.hooks.GoodReward = append(c.hooks.GoodReward, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goodreward.Intercept(f(g(h())))`.
func (c *GoodRewardClient) Intercept(interceptors ...Interceptor) {
	c.inters.GoodReward = append(c.inters.GoodReward, interceptors...)
}

// Create returns a builder for creating a GoodReward entity.
func (c *GoodRewardClient) Create() *GoodRewardCreate {
	mutation := newGoodRewardMutation(c.config, OpCreate)
	return &GoodRewardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoodReward entities.
func (c *GoodRewardClient) CreateBulk(builders ...*GoodRewardCreate) *GoodRewardCreateBulk {
	return &GoodRewardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodRewardClient) MapCreateBulk(slice any, setFunc func(*GoodRewardCreate, int)) *GoodRewardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodRewardCreateBulk{err: fmt.Errorf("calling to GoodRewardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodRewardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodRewardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoodReward.
func (c *GoodRewardClient) Update() *GoodRewardUpdate {
	mutation := newGoodRewardMutation(c.config, OpUpdate)
	return &GoodRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodRewardClient) UpdateOne(gr *GoodReward) *GoodRewardUpdateOne {
	mutation := newGoodRewardMutation(c.config, OpUpdateOne, withGoodReward(gr))
	return &GoodRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodRewardClient) UpdateOneID(id uint32) *GoodRewardUpdateOne {
	mutation := newGoodRewardMutation(c.config, OpUpdateOne, withGoodRewardID(id))
	return &GoodRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoodReward.
func (c *GoodRewardClient) Delete() *GoodRewardDelete {
	mutation := newGoodRewardMutation(c.config, OpDelete)
	return &GoodRewardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodRewardClient) DeleteOne(gr *GoodReward) *GoodRewardDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodRewardClient) DeleteOneID(id uint32) *GoodRewardDeleteOne {
	builder := c.Delete().Where(goodreward.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodRewardDeleteOne{builder}
}

// Query returns a query builder for GoodReward.
func (c *GoodRewardClient) Query() *GoodRewardQuery {
	return &GoodRewardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoodReward},
		inters: c.Interceptors(),
	}
}

// Get returns a GoodReward entity by its id.
func (c *GoodRewardClient) Get(ctx context.Context, id uint32) (*GoodReward, error) {
	return c.Query().Where(goodreward.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodRewardClient) GetX(ctx context.Context, id uint32) *GoodReward {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodRewardClient) Hooks() []Hook {
	return c.hooks.GoodReward
}

// Interceptors returns the client interceptors.
func (c *GoodRewardClient) Interceptors() []Interceptor {
	return c.inters.GoodReward
}

func (c *GoodRewardClient) mutate(ctx context.Context, m *GoodRewardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodRewardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodRewardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GoodReward mutation op: %q", m.Op())
	}
}

// GoodRewardHistoryClient is a client for the GoodRewardHistory schema.
type GoodRewardHistoryClient struct {
	config
}

// NewGoodRewardHistoryClient returns a client for the GoodRewardHistory from the given config.
func NewGoodRewardHistoryClient(c config) *GoodRewardHistoryClient {
	return &GoodRewardHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goodrewardhistory.Hooks(f(g(h())))`.
func (c *GoodRewardHistoryClient) Use(hooks ...Hook) {
	c.hooks.GoodRewardHistory = append(c.hooks.GoodRewardHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goodrewardhistory.Intercept(f(g(h())))`.
func (c *GoodRewardHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.GoodRewardHistory = append(c.inters.GoodRewardHistory, interceptors...)
}

// Create returns a builder for creating a GoodRewardHistory entity.
func (c *GoodRewardHistoryClient) Create() *GoodRewardHistoryCreate {
	mutation := newGoodRewardHistoryMutation(c.config, OpCreate)
	return &GoodRewardHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoodRewardHistory entities.
func (c *GoodRewardHistoryClient) CreateBulk(builders ...*GoodRewardHistoryCreate) *GoodRewardHistoryCreateBulk {
	return &GoodRewardHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoodRewardHistoryClient) MapCreateBulk(slice any, setFunc func(*GoodRewardHistoryCreate, int)) *GoodRewardHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoodRewardHistoryCreateBulk{err: fmt.Errorf("calling to GoodRewardHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoodRewardHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoodRewardHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoodRewardHistory.
func (c *GoodRewardHistoryClient) Update() *GoodRewardHistoryUpdate {
	mutation := newGoodRewardHistoryMutation(c.config, OpUpdate)
	return &GoodRewardHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoodRewardHistoryClient) UpdateOne(grh *GoodRewardHistory) *GoodRewardHistoryUpdateOne {
	mutation := newGoodRewardHistoryMutation(c.config, OpUpdateOne, withGoodRewardHistory(grh))
	return &GoodRewardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoodRewardHistoryClient) UpdateOneID(id uint32) *GoodRewardHistoryUpdateOne {
	mutation := newGoodRewardHistoryMutation(c.config, OpUpdateOne, withGoodRewardHistoryID(id))
	return &GoodRewardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoodRewardHistory.
func (c *GoodRewardHistoryClient) Delete() *GoodRewardHistoryDelete {
	mutation := newGoodRewardHistoryMutation(c.config, OpDelete)
	return &GoodRewardHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoodRewardHistoryClient) DeleteOne(grh *GoodRewardHistory) *GoodRewardHistoryDeleteOne {
	return c.DeleteOneID(grh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoodRewardHistoryClient) DeleteOneID(id uint32) *GoodRewardHistoryDeleteOne {
	builder := c.Delete().Where(goodrewardhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoodRewardHistoryDeleteOne{builder}
}

// Query returns a query builder for GoodRewardHistory.
func (c *GoodRewardHistoryClient) Query() *GoodRewardHistoryQuery {
	return &GoodRewardHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoodRewardHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a GoodRewardHistory entity by its id.
func (c *GoodRewardHistoryClient) Get(ctx context.Context, id uint32) (*GoodRewardHistory, error) {
	return c.Query().Where(goodrewardhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoodRewardHistoryClient) GetX(ctx context.Context, id uint32) *GoodRewardHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoodRewardHistoryClient) Hooks() []Hook {
	return c.hooks.GoodRewardHistory
}

// Interceptors returns the client interceptors.
func (c *GoodRewardHistoryClient) Interceptors() []Interceptor {
	return c.inters.GoodRewardHistory
}

func (c *GoodRewardHistoryClient) mutate(ctx context.Context, m *GoodRewardHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoodRewardHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoodRewardHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoodRewardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoodRewardHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GoodRewardHistory mutation op: %q", m.Op())
	}
}

// LikeClient is a client for the Like schema.
type LikeClient struct {
	config
}

// NewLikeClient returns a client for the Like from the given config.
func NewLikeClient(c config) *LikeClient {
	return &LikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `like.Hooks(f(g(h())))`.
func (c *LikeClient) Use(hooks ...Hook) {
	c.hooks.Like = append(c.hooks.Like, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `like.Intercept(f(g(h())))`.
func (c *LikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Like = append(c.inters.Like, interceptors...)
}

// Create returns a builder for creating a Like entity.
func (c *LikeClient) Create() *LikeCreate {
	mutation := newLikeMutation(c.config, OpCreate)
	return &LikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Like entities.
func (c *LikeClient) CreateBulk(builders ...*LikeCreate) *LikeCreateBulk {
	return &LikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LikeClient) MapCreateBulk(slice any, setFunc func(*LikeCreate, int)) *LikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LikeCreateBulk{err: fmt.Errorf("calling to LikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Like.
func (c *LikeClient) Update() *LikeUpdate {
	mutation := newLikeMutation(c.config, OpUpdate)
	return &LikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LikeClient) UpdateOne(l *Like) *LikeUpdateOne {
	mutation := newLikeMutation(c.config, OpUpdateOne, withLike(l))
	return &LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LikeClient) UpdateOneID(id uint32) *LikeUpdateOne {
	mutation := newLikeMutation(c.config, OpUpdateOne, withLikeID(id))
	return &LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Like.
func (c *LikeClient) Delete() *LikeDelete {
	mutation := newLikeMutation(c.config, OpDelete)
	return &LikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LikeClient) DeleteOne(l *Like) *LikeDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LikeClient) DeleteOneID(id uint32) *LikeDeleteOne {
	builder := c.Delete().Where(like.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LikeDeleteOne{builder}
}

// Query returns a query builder for Like.
func (c *LikeClient) Query() *LikeQuery {
	return &LikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLike},
		inters: c.Interceptors(),
	}
}

// Get returns a Like entity by its id.
func (c *LikeClient) Get(ctx context.Context, id uint32) (*Like, error) {
	return c.Query().Where(like.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LikeClient) GetX(ctx context.Context, id uint32) *Like {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LikeClient) Hooks() []Hook {
	return c.hooks.Like
}

// Interceptors returns the client interceptors.
func (c *LikeClient) Interceptors() []Interceptor {
	return c.inters.Like
}

func (c *LikeClient) mutate(ctx context.Context, m *LikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Like mutation op: %q", m.Op())
	}
}

// MiningGoodStockClient is a client for the MiningGoodStock schema.
type MiningGoodStockClient struct {
	config
}

// NewMiningGoodStockClient returns a client for the MiningGoodStock from the given config.
func NewMiningGoodStockClient(c config) *MiningGoodStockClient {
	return &MiningGoodStockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mininggoodstock.Hooks(f(g(h())))`.
func (c *MiningGoodStockClient) Use(hooks ...Hook) {
	c.hooks.MiningGoodStock = append(c.hooks.MiningGoodStock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mininggoodstock.Intercept(f(g(h())))`.
func (c *MiningGoodStockClient) Intercept(interceptors ...Interceptor) {
	c.inters.MiningGoodStock = append(c.inters.MiningGoodStock, interceptors...)
}

// Create returns a builder for creating a MiningGoodStock entity.
func (c *MiningGoodStockClient) Create() *MiningGoodStockCreate {
	mutation := newMiningGoodStockMutation(c.config, OpCreate)
	return &MiningGoodStockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MiningGoodStock entities.
func (c *MiningGoodStockClient) CreateBulk(builders ...*MiningGoodStockCreate) *MiningGoodStockCreateBulk {
	return &MiningGoodStockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MiningGoodStockClient) MapCreateBulk(slice any, setFunc func(*MiningGoodStockCreate, int)) *MiningGoodStockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MiningGoodStockCreateBulk{err: fmt.Errorf("calling to MiningGoodStockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MiningGoodStockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MiningGoodStockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MiningGoodStock.
func (c *MiningGoodStockClient) Update() *MiningGoodStockUpdate {
	mutation := newMiningGoodStockMutation(c.config, OpUpdate)
	return &MiningGoodStockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MiningGoodStockClient) UpdateOne(mgs *MiningGoodStock) *MiningGoodStockUpdateOne {
	mutation := newMiningGoodStockMutation(c.config, OpUpdateOne, withMiningGoodStock(mgs))
	return &MiningGoodStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MiningGoodStockClient) UpdateOneID(id uint32) *MiningGoodStockUpdateOne {
	mutation := newMiningGoodStockMutation(c.config, OpUpdateOne, withMiningGoodStockID(id))
	return &MiningGoodStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MiningGoodStock.
func (c *MiningGoodStockClient) Delete() *MiningGoodStockDelete {
	mutation := newMiningGoodStockMutation(c.config, OpDelete)
	return &MiningGoodStockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MiningGoodStockClient) DeleteOne(mgs *MiningGoodStock) *MiningGoodStockDeleteOne {
	return c.DeleteOneID(mgs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MiningGoodStockClient) DeleteOneID(id uint32) *MiningGoodStockDeleteOne {
	builder := c.Delete().Where(mininggoodstock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MiningGoodStockDeleteOne{builder}
}

// Query returns a query builder for MiningGoodStock.
func (c *MiningGoodStockClient) Query() *MiningGoodStockQuery {
	return &MiningGoodStockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMiningGoodStock},
		inters: c.Interceptors(),
	}
}

// Get returns a MiningGoodStock entity by its id.
func (c *MiningGoodStockClient) Get(ctx context.Context, id uint32) (*MiningGoodStock, error) {
	return c.Query().Where(mininggoodstock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MiningGoodStockClient) GetX(ctx context.Context, id uint32) *MiningGoodStock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MiningGoodStockClient) Hooks() []Hook {
	return c.hooks.MiningGoodStock
}

// Interceptors returns the client interceptors.
func (c *MiningGoodStockClient) Interceptors() []Interceptor {
	return c.inters.MiningGoodStock
}

func (c *MiningGoodStockClient) mutate(ctx context.Context, m *MiningGoodStockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MiningGoodStockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MiningGoodStockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MiningGoodStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MiningGoodStockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown MiningGoodStock mutation op: %q", m.Op())
	}
}

// PowerRentalClient is a client for the PowerRental schema.
type PowerRentalClient struct {
	config
}

// NewPowerRentalClient returns a client for the PowerRental from the given config.
func NewPowerRentalClient(c config) *PowerRentalClient {
	return &PowerRentalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `powerrental.Hooks(f(g(h())))`.
func (c *PowerRentalClient) Use(hooks ...Hook) {
	c.hooks.PowerRental = append(c.hooks.PowerRental, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `powerrental.Intercept(f(g(h())))`.
func (c *PowerRentalClient) Intercept(interceptors ...Interceptor) {
	c.inters.PowerRental = append(c.inters.PowerRental, interceptors...)
}

// Create returns a builder for creating a PowerRental entity.
func (c *PowerRentalClient) Create() *PowerRentalCreate {
	mutation := newPowerRentalMutation(c.config, OpCreate)
	return &PowerRentalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PowerRental entities.
func (c *PowerRentalClient) CreateBulk(builders ...*PowerRentalCreate) *PowerRentalCreateBulk {
	return &PowerRentalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PowerRentalClient) MapCreateBulk(slice any, setFunc func(*PowerRentalCreate, int)) *PowerRentalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PowerRentalCreateBulk{err: fmt.Errorf("calling to PowerRentalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PowerRentalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PowerRentalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PowerRental.
func (c *PowerRentalClient) Update() *PowerRentalUpdate {
	mutation := newPowerRentalMutation(c.config, OpUpdate)
	return &PowerRentalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PowerRentalClient) UpdateOne(pr *PowerRental) *PowerRentalUpdateOne {
	mutation := newPowerRentalMutation(c.config, OpUpdateOne, withPowerRental(pr))
	return &PowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PowerRentalClient) UpdateOneID(id uint32) *PowerRentalUpdateOne {
	mutation := newPowerRentalMutation(c.config, OpUpdateOne, withPowerRentalID(id))
	return &PowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PowerRental.
func (c *PowerRentalClient) Delete() *PowerRentalDelete {
	mutation := newPowerRentalMutation(c.config, OpDelete)
	return &PowerRentalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PowerRentalClient) DeleteOne(pr *PowerRental) *PowerRentalDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PowerRentalClient) DeleteOneID(id uint32) *PowerRentalDeleteOne {
	builder := c.Delete().Where(powerrental.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PowerRentalDeleteOne{builder}
}

// Query returns a query builder for PowerRental.
func (c *PowerRentalClient) Query() *PowerRentalQuery {
	return &PowerRentalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePowerRental},
		inters: c.Interceptors(),
	}
}

// Get returns a PowerRental entity by its id.
func (c *PowerRentalClient) Get(ctx context.Context, id uint32) (*PowerRental, error) {
	return c.Query().Where(powerrental.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PowerRentalClient) GetX(ctx context.Context, id uint32) *PowerRental {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PowerRentalClient) Hooks() []Hook {
	return c.hooks.PowerRental
}

// Interceptors returns the client interceptors.
func (c *PowerRentalClient) Interceptors() []Interceptor {
	return c.inters.PowerRental
}

func (c *PowerRentalClient) mutate(ctx context.Context, m *PowerRentalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PowerRentalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PowerRentalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PowerRentalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PowerRentalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown PowerRental mutation op: %q", m.Op())
	}
}

// RecommendClient is a client for the Recommend schema.
type RecommendClient struct {
	config
}

// NewRecommendClient returns a client for the Recommend from the given config.
func NewRecommendClient(c config) *RecommendClient {
	return &RecommendClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `recommend.Hooks(f(g(h())))`.
func (c *RecommendClient) Use(hooks ...Hook) {
	c.hooks.Recommend = append(c.hooks.Recommend, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `recommend.Intercept(f(g(h())))`.
func (c *RecommendClient) Intercept(interceptors ...Interceptor) {
	c.inters.Recommend = append(c.inters.Recommend, interceptors...)
}

// Create returns a builder for creating a Recommend entity.
func (c *RecommendClient) Create() *RecommendCreate {
	mutation := newRecommendMutation(c.config, OpCreate)
	return &RecommendCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Recommend entities.
func (c *RecommendClient) CreateBulk(builders ...*RecommendCreate) *RecommendCreateBulk {
	return &RecommendCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RecommendClient) MapCreateBulk(slice any, setFunc func(*RecommendCreate, int)) *RecommendCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RecommendCreateBulk{err: fmt.Errorf("calling to RecommendClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RecommendCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RecommendCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Recommend.
func (c *RecommendClient) Update() *RecommendUpdate {
	mutation := newRecommendMutation(c.config, OpUpdate)
	return &RecommendUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RecommendClient) UpdateOne(r *Recommend) *RecommendUpdateOne {
	mutation := newRecommendMutation(c.config, OpUpdateOne, withRecommend(r))
	return &RecommendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RecommendClient) UpdateOneID(id uint32) *RecommendUpdateOne {
	mutation := newRecommendMutation(c.config, OpUpdateOne, withRecommendID(id))
	return &RecommendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Recommend.
func (c *RecommendClient) Delete() *RecommendDelete {
	mutation := newRecommendMutation(c.config, OpDelete)
	return &RecommendDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RecommendClient) DeleteOne(r *Recommend) *RecommendDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RecommendClient) DeleteOneID(id uint32) *RecommendDeleteOne {
	builder := c.Delete().Where(recommend.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RecommendDeleteOne{builder}
}

// Query returns a query builder for Recommend.
func (c *RecommendClient) Query() *RecommendQuery {
	return &RecommendQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRecommend},
		inters: c.Interceptors(),
	}
}

// Get returns a Recommend entity by its id.
func (c *RecommendClient) Get(ctx context.Context, id uint32) (*Recommend, error) {
	return c.Query().Where(recommend.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RecommendClient) GetX(ctx context.Context, id uint32) *Recommend {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RecommendClient) Hooks() []Hook {
	return c.hooks.Recommend
}

// Interceptors returns the client interceptors.
func (c *RecommendClient) Interceptors() []Interceptor {
	return c.inters.Recommend
}

func (c *RecommendClient) mutate(ctx context.Context, m *RecommendMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RecommendCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RecommendUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RecommendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RecommendDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Recommend mutation op: %q", m.Op())
	}
}

// RequiredAppGoodClient is a client for the RequiredAppGood schema.
type RequiredAppGoodClient struct {
	config
}

// NewRequiredAppGoodClient returns a client for the RequiredAppGood from the given config.
func NewRequiredAppGoodClient(c config) *RequiredAppGoodClient {
	return &RequiredAppGoodClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `requiredappgood.Hooks(f(g(h())))`.
func (c *RequiredAppGoodClient) Use(hooks ...Hook) {
	c.hooks.RequiredAppGood = append(c.hooks.RequiredAppGood, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `requiredappgood.Intercept(f(g(h())))`.
func (c *RequiredAppGoodClient) Intercept(interceptors ...Interceptor) {
	c.inters.RequiredAppGood = append(c.inters.RequiredAppGood, interceptors...)
}

// Create returns a builder for creating a RequiredAppGood entity.
func (c *RequiredAppGoodClient) Create() *RequiredAppGoodCreate {
	mutation := newRequiredAppGoodMutation(c.config, OpCreate)
	return &RequiredAppGoodCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RequiredAppGood entities.
func (c *RequiredAppGoodClient) CreateBulk(builders ...*RequiredAppGoodCreate) *RequiredAppGoodCreateBulk {
	return &RequiredAppGoodCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RequiredAppGoodClient) MapCreateBulk(slice any, setFunc func(*RequiredAppGoodCreate, int)) *RequiredAppGoodCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RequiredAppGoodCreateBulk{err: fmt.Errorf("calling to RequiredAppGoodClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RequiredAppGoodCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RequiredAppGoodCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RequiredAppGood.
func (c *RequiredAppGoodClient) Update() *RequiredAppGoodUpdate {
	mutation := newRequiredAppGoodMutation(c.config, OpUpdate)
	return &RequiredAppGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RequiredAppGoodClient) UpdateOne(rag *RequiredAppGood) *RequiredAppGoodUpdateOne {
	mutation := newRequiredAppGoodMutation(c.config, OpUpdateOne, withRequiredAppGood(rag))
	return &RequiredAppGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RequiredAppGoodClient) UpdateOneID(id uint32) *RequiredAppGoodUpdateOne {
	mutation := newRequiredAppGoodMutation(c.config, OpUpdateOne, withRequiredAppGoodID(id))
	return &RequiredAppGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RequiredAppGood.
func (c *RequiredAppGoodClient) Delete() *RequiredAppGoodDelete {
	mutation := newRequiredAppGoodMutation(c.config, OpDelete)
	return &RequiredAppGoodDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RequiredAppGoodClient) DeleteOne(rag *RequiredAppGood) *RequiredAppGoodDeleteOne {
	return c.DeleteOneID(rag.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RequiredAppGoodClient) DeleteOneID(id uint32) *RequiredAppGoodDeleteOne {
	builder := c.Delete().Where(requiredappgood.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RequiredAppGoodDeleteOne{builder}
}

// Query returns a query builder for RequiredAppGood.
func (c *RequiredAppGoodClient) Query() *RequiredAppGoodQuery {
	return &RequiredAppGoodQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRequiredAppGood},
		inters: c.Interceptors(),
	}
}

// Get returns a RequiredAppGood entity by its id.
func (c *RequiredAppGoodClient) Get(ctx context.Context, id uint32) (*RequiredAppGood, error) {
	return c.Query().Where(requiredappgood.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RequiredAppGoodClient) GetX(ctx context.Context, id uint32) *RequiredAppGood {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RequiredAppGoodClient) Hooks() []Hook {
	return c.hooks.RequiredAppGood
}

// Interceptors returns the client interceptors.
func (c *RequiredAppGoodClient) Interceptors() []Interceptor {
	return c.inters.RequiredAppGood
}

func (c *RequiredAppGoodClient) mutate(ctx context.Context, m *RequiredAppGoodMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RequiredAppGoodCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RequiredAppGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RequiredAppGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RequiredAppGoodDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown RequiredAppGood mutation op: %q", m.Op())
	}
}

// RequiredGoodClient is a client for the RequiredGood schema.
type RequiredGoodClient struct {
	config
}

// NewRequiredGoodClient returns a client for the RequiredGood from the given config.
func NewRequiredGoodClient(c config) *RequiredGoodClient {
	return &RequiredGoodClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `requiredgood.Hooks(f(g(h())))`.
func (c *RequiredGoodClient) Use(hooks ...Hook) {
	c.hooks.RequiredGood = append(c.hooks.RequiredGood, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `requiredgood.Intercept(f(g(h())))`.
func (c *RequiredGoodClient) Intercept(interceptors ...Interceptor) {
	c.inters.RequiredGood = append(c.inters.RequiredGood, interceptors...)
}

// Create returns a builder for creating a RequiredGood entity.
func (c *RequiredGoodClient) Create() *RequiredGoodCreate {
	mutation := newRequiredGoodMutation(c.config, OpCreate)
	return &RequiredGoodCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RequiredGood entities.
func (c *RequiredGoodClient) CreateBulk(builders ...*RequiredGoodCreate) *RequiredGoodCreateBulk {
	return &RequiredGoodCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RequiredGoodClient) MapCreateBulk(slice any, setFunc func(*RequiredGoodCreate, int)) *RequiredGoodCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RequiredGoodCreateBulk{err: fmt.Errorf("calling to RequiredGoodClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RequiredGoodCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RequiredGoodCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RequiredGood.
func (c *RequiredGoodClient) Update() *RequiredGoodUpdate {
	mutation := newRequiredGoodMutation(c.config, OpUpdate)
	return &RequiredGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RequiredGoodClient) UpdateOne(rg *RequiredGood) *RequiredGoodUpdateOne {
	mutation := newRequiredGoodMutation(c.config, OpUpdateOne, withRequiredGood(rg))
	return &RequiredGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RequiredGoodClient) UpdateOneID(id uint32) *RequiredGoodUpdateOne {
	mutation := newRequiredGoodMutation(c.config, OpUpdateOne, withRequiredGoodID(id))
	return &RequiredGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RequiredGood.
func (c *RequiredGoodClient) Delete() *RequiredGoodDelete {
	mutation := newRequiredGoodMutation(c.config, OpDelete)
	return &RequiredGoodDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RequiredGoodClient) DeleteOne(rg *RequiredGood) *RequiredGoodDeleteOne {
	return c.DeleteOneID(rg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RequiredGoodClient) DeleteOneID(id uint32) *RequiredGoodDeleteOne {
	builder := c.Delete().Where(requiredgood.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RequiredGoodDeleteOne{builder}
}

// Query returns a query builder for RequiredGood.
func (c *RequiredGoodClient) Query() *RequiredGoodQuery {
	return &RequiredGoodQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRequiredGood},
		inters: c.Interceptors(),
	}
}

// Get returns a RequiredGood entity by its id.
func (c *RequiredGoodClient) Get(ctx context.Context, id uint32) (*RequiredGood, error) {
	return c.Query().Where(requiredgood.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RequiredGoodClient) GetX(ctx context.Context, id uint32) *RequiredGood {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RequiredGoodClient) Hooks() []Hook {
	return c.hooks.RequiredGood
}

// Interceptors returns the client interceptors.
func (c *RequiredGoodClient) Interceptors() []Interceptor {
	return c.inters.RequiredGood
}

func (c *RequiredGoodClient) mutate(ctx context.Context, m *RequiredGoodMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RequiredGoodCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RequiredGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RequiredGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RequiredGoodDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown RequiredGood mutation op: %q", m.Op())
	}
}

// ScoreClient is a client for the Score schema.
type ScoreClient struct {
	config
}

// NewScoreClient returns a client for the Score from the given config.
func NewScoreClient(c config) *ScoreClient {
	return &ScoreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `score.Hooks(f(g(h())))`.
func (c *ScoreClient) Use(hooks ...Hook) {
	c.hooks.Score = append(c.hooks.Score, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `score.Intercept(f(g(h())))`.
func (c *ScoreClient) Intercept(interceptors ...Interceptor) {
	c.inters.Score = append(c.inters.Score, interceptors...)
}

// Create returns a builder for creating a Score entity.
func (c *ScoreClient) Create() *ScoreCreate {
	mutation := newScoreMutation(c.config, OpCreate)
	return &ScoreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Score entities.
func (c *ScoreClient) CreateBulk(builders ...*ScoreCreate) *ScoreCreateBulk {
	return &ScoreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScoreClient) MapCreateBulk(slice any, setFunc func(*ScoreCreate, int)) *ScoreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScoreCreateBulk{err: fmt.Errorf("calling to ScoreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScoreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScoreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Score.
func (c *ScoreClient) Update() *ScoreUpdate {
	mutation := newScoreMutation(c.config, OpUpdate)
	return &ScoreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScoreClient) UpdateOne(s *Score) *ScoreUpdateOne {
	mutation := newScoreMutation(c.config, OpUpdateOne, withScore(s))
	return &ScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScoreClient) UpdateOneID(id uint32) *ScoreUpdateOne {
	mutation := newScoreMutation(c.config, OpUpdateOne, withScoreID(id))
	return &ScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Score.
func (c *ScoreClient) Delete() *ScoreDelete {
	mutation := newScoreMutation(c.config, OpDelete)
	return &ScoreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScoreClient) DeleteOne(s *Score) *ScoreDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScoreClient) DeleteOneID(id uint32) *ScoreDeleteOne {
	builder := c.Delete().Where(score.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScoreDeleteOne{builder}
}

// Query returns a query builder for Score.
func (c *ScoreClient) Query() *ScoreQuery {
	return &ScoreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScore},
		inters: c.Interceptors(),
	}
}

// Get returns a Score entity by its id.
func (c *ScoreClient) Get(ctx context.Context, id uint32) (*Score, error) {
	return c.Query().Where(score.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScoreClient) GetX(ctx context.Context, id uint32) *Score {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ScoreClient) Hooks() []Hook {
	return c.hooks.Score
}

// Interceptors returns the client interceptors.
func (c *ScoreClient) Interceptors() []Interceptor {
	return c.inters.Score
}

func (c *ScoreClient) mutate(ctx context.Context, m *ScoreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScoreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScoreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScoreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Score mutation op: %q", m.Op())
	}
}

// StockClient is a client for the Stock schema.
type StockClient struct {
	config
}

// NewStockClient returns a client for the Stock from the given config.
func NewStockClient(c config) *StockClient {
	return &StockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `stock.Hooks(f(g(h())))`.
func (c *StockClient) Use(hooks ...Hook) {
	c.hooks.Stock = append(c.hooks.Stock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `stock.Intercept(f(g(h())))`.
func (c *StockClient) Intercept(interceptors ...Interceptor) {
	c.inters.Stock = append(c.inters.Stock, interceptors...)
}

// Create returns a builder for creating a Stock entity.
func (c *StockClient) Create() *StockCreate {
	mutation := newStockMutation(c.config, OpCreate)
	return &StockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Stock entities.
func (c *StockClient) CreateBulk(builders ...*StockCreate) *StockCreateBulk {
	return &StockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StockClient) MapCreateBulk(slice any, setFunc func(*StockCreate, int)) *StockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StockCreateBulk{err: fmt.Errorf("calling to StockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Stock.
func (c *StockClient) Update() *StockUpdate {
	mutation := newStockMutation(c.config, OpUpdate)
	return &StockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StockClient) UpdateOne(s *Stock) *StockUpdateOne {
	mutation := newStockMutation(c.config, OpUpdateOne, withStock(s))
	return &StockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StockClient) UpdateOneID(id uint32) *StockUpdateOne {
	mutation := newStockMutation(c.config, OpUpdateOne, withStockID(id))
	return &StockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Stock.
func (c *StockClient) Delete() *StockDelete {
	mutation := newStockMutation(c.config, OpDelete)
	return &StockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StockClient) DeleteOne(s *Stock) *StockDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StockClient) DeleteOneID(id uint32) *StockDeleteOne {
	builder := c.Delete().Where(stock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StockDeleteOne{builder}
}

// Query returns a query builder for Stock.
func (c *StockClient) Query() *StockQuery {
	return &StockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStock},
		inters: c.Interceptors(),
	}
}

// Get returns a Stock entity by its id.
func (c *StockClient) Get(ctx context.Context, id uint32) (*Stock, error) {
	return c.Query().Where(stock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StockClient) GetX(ctx context.Context, id uint32) *Stock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StockClient) Hooks() []Hook {
	return c.hooks.Stock
}

// Interceptors returns the client interceptors.
func (c *StockClient) Interceptors() []Interceptor {
	return c.inters.Stock
}

func (c *StockClient) mutate(ctx context.Context, m *StockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Stock mutation op: %q", m.Op())
	}
}

// SubscriptionClient is a client for the Subscription schema.
type SubscriptionClient struct {
	config
}

// NewSubscriptionClient returns a client for the Subscription from the given config.
func NewSubscriptionClient(c config) *SubscriptionClient {
	return &SubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscription.Hooks(f(g(h())))`.
func (c *SubscriptionClient) Use(hooks ...Hook) {
	c.hooks.Subscription = append(c.hooks.Subscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscription.Intercept(f(g(h())))`.
func (c *SubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscription = append(c.inters.Subscription, interceptors...)
}

// Create returns a builder for creating a Subscription entity.
func (c *SubscriptionClient) Create() *SubscriptionCreate {
	mutation := newSubscriptionMutation(c.config, OpCreate)
	return &SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscription entities.
func (c *SubscriptionClient) CreateBulk(builders ...*SubscriptionCreate) *SubscriptionCreateBulk {
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionClient) MapCreateBulk(slice any, setFunc func(*SubscriptionCreate, int)) *SubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionCreateBulk{err: fmt.Errorf("calling to SubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscription.
func (c *SubscriptionClient) Update() *SubscriptionUpdate {
	mutation := newSubscriptionMutation(c.config, OpUpdate)
	return &SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionClient) UpdateOne(s *Subscription) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscription(s))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionClient) UpdateOneID(id uint32) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscriptionID(id))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscription.
func (c *SubscriptionClient) Delete() *SubscriptionDelete {
	mutation := newSubscriptionMutation(c.config, OpDelete)
	return &SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionClient) DeleteOne(s *Subscription) *SubscriptionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionClient) DeleteOneID(id uint32) *SubscriptionDeleteOne {
	builder := c.Delete().Where(subscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionDeleteOne{builder}
}

// Query returns a query builder for Subscription.
func (c *SubscriptionClient) Query() *SubscriptionQuery {
	return &SubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscription entity by its id.
func (c *SubscriptionClient) Get(ctx context.Context, id uint32) (*Subscription, error) {
	return c.Query().Where(subscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionClient) GetX(ctx context.Context, id uint32) *Subscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SubscriptionClient) Hooks() []Hook {
	return c.hooks.Subscription
}

// Interceptors returns the client interceptors.
func (c *SubscriptionClient) Interceptors() []Interceptor {
	return c.inters.Subscription
}

func (c *SubscriptionClient) mutate(ctx context.Context, m *SubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Subscription mutation op: %q", m.Op())
	}
}

// SubscriptionOneShotClient is a client for the SubscriptionOneShot schema.
type SubscriptionOneShotClient struct {
	config
}

// NewSubscriptionOneShotClient returns a client for the SubscriptionOneShot from the given config.
func NewSubscriptionOneShotClient(c config) *SubscriptionOneShotClient {
	return &SubscriptionOneShotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscriptiononeshot.Hooks(f(g(h())))`.
func (c *SubscriptionOneShotClient) Use(hooks ...Hook) {
	c.hooks.SubscriptionOneShot = append(c.hooks.SubscriptionOneShot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscriptiononeshot.Intercept(f(g(h())))`.
func (c *SubscriptionOneShotClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubscriptionOneShot = append(c.inters.SubscriptionOneShot, interceptors...)
}

// Create returns a builder for creating a SubscriptionOneShot entity.
func (c *SubscriptionOneShotClient) Create() *SubscriptionOneShotCreate {
	mutation := newSubscriptionOneShotMutation(c.config, OpCreate)
	return &SubscriptionOneShotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubscriptionOneShot entities.
func (c *SubscriptionOneShotClient) CreateBulk(builders ...*SubscriptionOneShotCreate) *SubscriptionOneShotCreateBulk {
	return &SubscriptionOneShotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionOneShotClient) MapCreateBulk(slice any, setFunc func(*SubscriptionOneShotCreate, int)) *SubscriptionOneShotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionOneShotCreateBulk{err: fmt.Errorf("calling to SubscriptionOneShotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionOneShotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionOneShotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubscriptionOneShot.
func (c *SubscriptionOneShotClient) Update() *SubscriptionOneShotUpdate {
	mutation := newSubscriptionOneShotMutation(c.config, OpUpdate)
	return &SubscriptionOneShotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionOneShotClient) UpdateOne(sos *SubscriptionOneShot) *SubscriptionOneShotUpdateOne {
	mutation := newSubscriptionOneShotMutation(c.config, OpUpdateOne, withSubscriptionOneShot(sos))
	return &SubscriptionOneShotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionOneShotClient) UpdateOneID(id uint32) *SubscriptionOneShotUpdateOne {
	mutation := newSubscriptionOneShotMutation(c.config, OpUpdateOne, withSubscriptionOneShotID(id))
	return &SubscriptionOneShotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubscriptionOneShot.
func (c *SubscriptionOneShotClient) Delete() *SubscriptionOneShotDelete {
	mutation := newSubscriptionOneShotMutation(c.config, OpDelete)
	return &SubscriptionOneShotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionOneShotClient) DeleteOne(sos *SubscriptionOneShot) *SubscriptionOneShotDeleteOne {
	return c.DeleteOneID(sos.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionOneShotClient) DeleteOneID(id uint32) *SubscriptionOneShotDeleteOne {
	builder := c.Delete().Where(subscriptiononeshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionOneShotDeleteOne{builder}
}

// Query returns a query builder for SubscriptionOneShot.
func (c *SubscriptionOneShotClient) Query() *SubscriptionOneShotQuery {
	return &SubscriptionOneShotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscriptionOneShot},
		inters: c.Interceptors(),
	}
}

// Get returns a SubscriptionOneShot entity by its id.
func (c *SubscriptionOneShotClient) Get(ctx context.Context, id uint32) (*SubscriptionOneShot, error) {
	return c.Query().Where(subscriptiononeshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionOneShotClient) GetX(ctx context.Context, id uint32) *SubscriptionOneShot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SubscriptionOneShotClient) Hooks() []Hook {
	return c.hooks.SubscriptionOneShot
}

// Interceptors returns the client interceptors.
func (c *SubscriptionOneShotClient) Interceptors() []Interceptor {
	return c.inters.SubscriptionOneShot
}

func (c *SubscriptionOneShotClient) mutate(ctx context.Context, m *SubscriptionOneShotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionOneShotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionOneShotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionOneShotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionOneShotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown SubscriptionOneShot mutation op: %q", m.Op())
	}
}

// TopMostClient is a client for the TopMost schema.
type TopMostClient struct {
	config
}

// NewTopMostClient returns a client for the TopMost from the given config.
func NewTopMostClient(c config) *TopMostClient {
	return &TopMostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topmost.Hooks(f(g(h())))`.
func (c *TopMostClient) Use(hooks ...Hook) {
	c.hooks.TopMost = append(c.hooks.TopMost, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topmost.Intercept(f(g(h())))`.
func (c *TopMostClient) Intercept(interceptors ...Interceptor) {
	c.inters.TopMost = append(c.inters.TopMost, interceptors...)
}

// Create returns a builder for creating a TopMost entity.
func (c *TopMostClient) Create() *TopMostCreate {
	mutation := newTopMostMutation(c.config, OpCreate)
	return &TopMostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TopMost entities.
func (c *TopMostClient) CreateBulk(builders ...*TopMostCreate) *TopMostCreateBulk {
	return &TopMostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TopMostClient) MapCreateBulk(slice any, setFunc func(*TopMostCreate, int)) *TopMostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TopMostCreateBulk{err: fmt.Errorf("calling to TopMostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TopMostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TopMostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TopMost.
func (c *TopMostClient) Update() *TopMostUpdate {
	mutation := newTopMostMutation(c.config, OpUpdate)
	return &TopMostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopMostClient) UpdateOne(tm *TopMost) *TopMostUpdateOne {
	mutation := newTopMostMutation(c.config, OpUpdateOne, withTopMost(tm))
	return &TopMostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopMostClient) UpdateOneID(id uint32) *TopMostUpdateOne {
	mutation := newTopMostMutation(c.config, OpUpdateOne, withTopMostID(id))
	return &TopMostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TopMost.
func (c *TopMostClient) Delete() *TopMostDelete {
	mutation := newTopMostMutation(c.config, OpDelete)
	return &TopMostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopMostClient) DeleteOne(tm *TopMost) *TopMostDeleteOne {
	return c.DeleteOneID(tm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopMostClient) DeleteOneID(id uint32) *TopMostDeleteOne {
	builder := c.Delete().Where(topmost.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopMostDeleteOne{builder}
}

// Query returns a query builder for TopMost.
func (c *TopMostClient) Query() *TopMostQuery {
	return &TopMostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopMost},
		inters: c.Interceptors(),
	}
}

// Get returns a TopMost entity by its id.
func (c *TopMostClient) Get(ctx context.Context, id uint32) (*TopMost, error) {
	return c.Query().Where(topmost.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopMostClient) GetX(ctx context.Context, id uint32) *TopMost {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TopMostClient) Hooks() []Hook {
	return c.hooks.TopMost
}

// Interceptors returns the client interceptors.
func (c *TopMostClient) Interceptors() []Interceptor {
	return c.inters.TopMost
}

func (c *TopMostClient) mutate(ctx context.Context, m *TopMostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopMostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopMostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopMostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopMostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TopMost mutation op: %q", m.Op())
	}
}

// TopMostConstraintClient is a client for the TopMostConstraint schema.
type TopMostConstraintClient struct {
	config
}

// NewTopMostConstraintClient returns a client for the TopMostConstraint from the given config.
func NewTopMostConstraintClient(c config) *TopMostConstraintClient {
	return &TopMostConstraintClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topmostconstraint.Hooks(f(g(h())))`.
func (c *TopMostConstraintClient) Use(hooks ...Hook) {
	c.hooks.TopMostConstraint = append(c.hooks.TopMostConstraint, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topmostconstraint.Intercept(f(g(h())))`.
func (c *TopMostConstraintClient) Intercept(interceptors ...Interceptor) {
	c.inters.TopMostConstraint = append(c.inters.TopMostConstraint, interceptors...)
}

// Create returns a builder for creating a TopMostConstraint entity.
func (c *TopMostConstraintClient) Create() *TopMostConstraintCreate {
	mutation := newTopMostConstraintMutation(c.config, OpCreate)
	return &TopMostConstraintCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TopMostConstraint entities.
func (c *TopMostConstraintClient) CreateBulk(builders ...*TopMostConstraintCreate) *TopMostConstraintCreateBulk {
	return &TopMostConstraintCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TopMostConstraintClient) MapCreateBulk(slice any, setFunc func(*TopMostConstraintCreate, int)) *TopMostConstraintCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TopMostConstraintCreateBulk{err: fmt.Errorf("calling to TopMostConstraintClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TopMostConstraintCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TopMostConstraintCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TopMostConstraint.
func (c *TopMostConstraintClient) Update() *TopMostConstraintUpdate {
	mutation := newTopMostConstraintMutation(c.config, OpUpdate)
	return &TopMostConstraintUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopMostConstraintClient) UpdateOne(tmc *TopMostConstraint) *TopMostConstraintUpdateOne {
	mutation := newTopMostConstraintMutation(c.config, OpUpdateOne, withTopMostConstraint(tmc))
	return &TopMostConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopMostConstraintClient) UpdateOneID(id uint32) *TopMostConstraintUpdateOne {
	mutation := newTopMostConstraintMutation(c.config, OpUpdateOne, withTopMostConstraintID(id))
	return &TopMostConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TopMostConstraint.
func (c *TopMostConstraintClient) Delete() *TopMostConstraintDelete {
	mutation := newTopMostConstraintMutation(c.config, OpDelete)
	return &TopMostConstraintDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopMostConstraintClient) DeleteOne(tmc *TopMostConstraint) *TopMostConstraintDeleteOne {
	return c.DeleteOneID(tmc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopMostConstraintClient) DeleteOneID(id uint32) *TopMostConstraintDeleteOne {
	builder := c.Delete().Where(topmostconstraint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopMostConstraintDeleteOne{builder}
}

// Query returns a query builder for TopMostConstraint.
func (c *TopMostConstraintClient) Query() *TopMostConstraintQuery {
	return &TopMostConstraintQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopMostConstraint},
		inters: c.Interceptors(),
	}
}

// Get returns a TopMostConstraint entity by its id.
func (c *TopMostConstraintClient) Get(ctx context.Context, id uint32) (*TopMostConstraint, error) {
	return c.Query().Where(topmostconstraint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopMostConstraintClient) GetX(ctx context.Context, id uint32) *TopMostConstraint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TopMostConstraintClient) Hooks() []Hook {
	return c.hooks.TopMostConstraint
}

// Interceptors returns the client interceptors.
func (c *TopMostConstraintClient) Interceptors() []Interceptor {
	return c.inters.TopMostConstraint
}

func (c *TopMostConstraintClient) mutate(ctx context.Context, m *TopMostConstraintMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopMostConstraintCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopMostConstraintUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopMostConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopMostConstraintDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TopMostConstraint mutation op: %q", m.Op())
	}
}

// TopMostGoodClient is a client for the TopMostGood schema.
type TopMostGoodClient struct {
	config
}

// NewTopMostGoodClient returns a client for the TopMostGood from the given config.
func NewTopMostGoodClient(c config) *TopMostGoodClient {
	return &TopMostGoodClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topmostgood.Hooks(f(g(h())))`.
func (c *TopMostGoodClient) Use(hooks ...Hook) {
	c.hooks.TopMostGood = append(c.hooks.TopMostGood, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topmostgood.Intercept(f(g(h())))`.
func (c *TopMostGoodClient) Intercept(interceptors ...Interceptor) {
	c.inters.TopMostGood = append(c.inters.TopMostGood, interceptors...)
}

// Create returns a builder for creating a TopMostGood entity.
func (c *TopMostGoodClient) Create() *TopMostGoodCreate {
	mutation := newTopMostGoodMutation(c.config, OpCreate)
	return &TopMostGoodCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TopMostGood entities.
func (c *TopMostGoodClient) CreateBulk(builders ...*TopMostGoodCreate) *TopMostGoodCreateBulk {
	return &TopMostGoodCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TopMostGoodClient) MapCreateBulk(slice any, setFunc func(*TopMostGoodCreate, int)) *TopMostGoodCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TopMostGoodCreateBulk{err: fmt.Errorf("calling to TopMostGoodClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TopMostGoodCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TopMostGoodCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TopMostGood.
func (c *TopMostGoodClient) Update() *TopMostGoodUpdate {
	mutation := newTopMostGoodMutation(c.config, OpUpdate)
	return &TopMostGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopMostGoodClient) UpdateOne(tmg *TopMostGood) *TopMostGoodUpdateOne {
	mutation := newTopMostGoodMutation(c.config, OpUpdateOne, withTopMostGood(tmg))
	return &TopMostGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopMostGoodClient) UpdateOneID(id uint32) *TopMostGoodUpdateOne {
	mutation := newTopMostGoodMutation(c.config, OpUpdateOne, withTopMostGoodID(id))
	return &TopMostGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TopMostGood.
func (c *TopMostGoodClient) Delete() *TopMostGoodDelete {
	mutation := newTopMostGoodMutation(c.config, OpDelete)
	return &TopMostGoodDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopMostGoodClient) DeleteOne(tmg *TopMostGood) *TopMostGoodDeleteOne {
	return c.DeleteOneID(tmg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopMostGoodClient) DeleteOneID(id uint32) *TopMostGoodDeleteOne {
	builder := c.Delete().Where(topmostgood.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopMostGoodDeleteOne{builder}
}

// Query returns a query builder for TopMostGood.
func (c *TopMostGoodClient) Query() *TopMostGoodQuery {
	return &TopMostGoodQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopMostGood},
		inters: c.Interceptors(),
	}
}

// Get returns a TopMostGood entity by its id.
func (c *TopMostGoodClient) Get(ctx context.Context, id uint32) (*TopMostGood, error) {
	return c.Query().Where(topmostgood.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopMostGoodClient) GetX(ctx context.Context, id uint32) *TopMostGood {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TopMostGoodClient) Hooks() []Hook {
	return c.hooks.TopMostGood
}

// Interceptors returns the client interceptors.
func (c *TopMostGoodClient) Interceptors() []Interceptor {
	return c.inters.TopMostGood
}

func (c *TopMostGoodClient) mutate(ctx context.Context, m *TopMostGoodMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopMostGoodCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopMostGoodUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopMostGoodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopMostGoodDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TopMostGood mutation op: %q", m.Op())
	}
}

// TopMostGoodConstraintClient is a client for the TopMostGoodConstraint schema.
type TopMostGoodConstraintClient struct {
	config
}

// NewTopMostGoodConstraintClient returns a client for the TopMostGoodConstraint from the given config.
func NewTopMostGoodConstraintClient(c config) *TopMostGoodConstraintClient {
	return &TopMostGoodConstraintClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topmostgoodconstraint.Hooks(f(g(h())))`.
func (c *TopMostGoodConstraintClient) Use(hooks ...Hook) {
	c.hooks.TopMostGoodConstraint = append(c.hooks.TopMostGoodConstraint, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topmostgoodconstraint.Intercept(f(g(h())))`.
func (c *TopMostGoodConstraintClient) Intercept(interceptors ...Interceptor) {
	c.inters.TopMostGoodConstraint = append(c.inters.TopMostGoodConstraint, interceptors...)
}

// Create returns a builder for creating a TopMostGoodConstraint entity.
func (c *TopMostGoodConstraintClient) Create() *TopMostGoodConstraintCreate {
	mutation := newTopMostGoodConstraintMutation(c.config, OpCreate)
	return &TopMostGoodConstraintCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TopMostGoodConstraint entities.
func (c *TopMostGoodConstraintClient) CreateBulk(builders ...*TopMostGoodConstraintCreate) *TopMostGoodConstraintCreateBulk {
	return &TopMostGoodConstraintCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TopMostGoodConstraintClient) MapCreateBulk(slice any, setFunc func(*TopMostGoodConstraintCreate, int)) *TopMostGoodConstraintCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TopMostGoodConstraintCreateBulk{err: fmt.Errorf("calling to TopMostGoodConstraintClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TopMostGoodConstraintCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TopMostGoodConstraintCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TopMostGoodConstraint.
func (c *TopMostGoodConstraintClient) Update() *TopMostGoodConstraintUpdate {
	mutation := newTopMostGoodConstraintMutation(c.config, OpUpdate)
	return &TopMostGoodConstraintUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopMostGoodConstraintClient) UpdateOne(tmgc *TopMostGoodConstraint) *TopMostGoodConstraintUpdateOne {
	mutation := newTopMostGoodConstraintMutation(c.config, OpUpdateOne, withTopMostGoodConstraint(tmgc))
	return &TopMostGoodConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopMostGoodConstraintClient) UpdateOneID(id uint32) *TopMostGoodConstraintUpdateOne {
	mutation := newTopMostGoodConstraintMutation(c.config, OpUpdateOne, withTopMostGoodConstraintID(id))
	return &TopMostGoodConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TopMostGoodConstraint.
func (c *TopMostGoodConstraintClient) Delete() *TopMostGoodConstraintDelete {
	mutation := newTopMostGoodConstraintMutation(c.config, OpDelete)
	return &TopMostGoodConstraintDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopMostGoodConstraintClient) DeleteOne(tmgc *TopMostGoodConstraint) *TopMostGoodConstraintDeleteOne {
	return c.DeleteOneID(tmgc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopMostGoodConstraintClient) DeleteOneID(id uint32) *TopMostGoodConstraintDeleteOne {
	builder := c.Delete().Where(topmostgoodconstraint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopMostGoodConstraintDeleteOne{builder}
}

// Query returns a query builder for TopMostGoodConstraint.
func (c *TopMostGoodConstraintClient) Query() *TopMostGoodConstraintQuery {
	return &TopMostGoodConstraintQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopMostGoodConstraint},
		inters: c.Interceptors(),
	}
}

// Get returns a TopMostGoodConstraint entity by its id.
func (c *TopMostGoodConstraintClient) Get(ctx context.Context, id uint32) (*TopMostGoodConstraint, error) {
	return c.Query().Where(topmostgoodconstraint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopMostGoodConstraintClient) GetX(ctx context.Context, id uint32) *TopMostGoodConstraint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TopMostGoodConstraintClient) Hooks() []Hook {
	return c.hooks.TopMostGoodConstraint
}

// Interceptors returns the client interceptors.
func (c *TopMostGoodConstraintClient) Interceptors() []Interceptor {
	return c.inters.TopMostGoodConstraint
}

func (c *TopMostGoodConstraintClient) mutate(ctx context.Context, m *TopMostGoodConstraintMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopMostGoodConstraintCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopMostGoodConstraintUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopMostGoodConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopMostGoodConstraintDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TopMostGoodConstraint mutation op: %q", m.Op())
	}
}

// TopMostGoodPosterClient is a client for the TopMostGoodPoster schema.
type TopMostGoodPosterClient struct {
	config
}

// NewTopMostGoodPosterClient returns a client for the TopMostGoodPoster from the given config.
func NewTopMostGoodPosterClient(c config) *TopMostGoodPosterClient {
	return &TopMostGoodPosterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topmostgoodposter.Hooks(f(g(h())))`.
func (c *TopMostGoodPosterClient) Use(hooks ...Hook) {
	c.hooks.TopMostGoodPoster = append(c.hooks.TopMostGoodPoster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topmostgoodposter.Intercept(f(g(h())))`.
func (c *TopMostGoodPosterClient) Intercept(interceptors ...Interceptor) {
	c.inters.TopMostGoodPoster = append(c.inters.TopMostGoodPoster, interceptors...)
}

// Create returns a builder for creating a TopMostGoodPoster entity.
func (c *TopMostGoodPosterClient) Create() *TopMostGoodPosterCreate {
	mutation := newTopMostGoodPosterMutation(c.config, OpCreate)
	return &TopMostGoodPosterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TopMostGoodPoster entities.
func (c *TopMostGoodPosterClient) CreateBulk(builders ...*TopMostGoodPosterCreate) *TopMostGoodPosterCreateBulk {
	return &TopMostGoodPosterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TopMostGoodPosterClient) MapCreateBulk(slice any, setFunc func(*TopMostGoodPosterCreate, int)) *TopMostGoodPosterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TopMostGoodPosterCreateBulk{err: fmt.Errorf("calling to TopMostGoodPosterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TopMostGoodPosterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TopMostGoodPosterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TopMostGoodPoster.
func (c *TopMostGoodPosterClient) Update() *TopMostGoodPosterUpdate {
	mutation := newTopMostGoodPosterMutation(c.config, OpUpdate)
	return &TopMostGoodPosterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopMostGoodPosterClient) UpdateOne(tmgp *TopMostGoodPoster) *TopMostGoodPosterUpdateOne {
	mutation := newTopMostGoodPosterMutation(c.config, OpUpdateOne, withTopMostGoodPoster(tmgp))
	return &TopMostGoodPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopMostGoodPosterClient) UpdateOneID(id uint32) *TopMostGoodPosterUpdateOne {
	mutation := newTopMostGoodPosterMutation(c.config, OpUpdateOne, withTopMostGoodPosterID(id))
	return &TopMostGoodPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TopMostGoodPoster.
func (c *TopMostGoodPosterClient) Delete() *TopMostGoodPosterDelete {
	mutation := newTopMostGoodPosterMutation(c.config, OpDelete)
	return &TopMostGoodPosterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopMostGoodPosterClient) DeleteOne(tmgp *TopMostGoodPoster) *TopMostGoodPosterDeleteOne {
	return c.DeleteOneID(tmgp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopMostGoodPosterClient) DeleteOneID(id uint32) *TopMostGoodPosterDeleteOne {
	builder := c.Delete().Where(topmostgoodposter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopMostGoodPosterDeleteOne{builder}
}

// Query returns a query builder for TopMostGoodPoster.
func (c *TopMostGoodPosterClient) Query() *TopMostGoodPosterQuery {
	return &TopMostGoodPosterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopMostGoodPoster},
		inters: c.Interceptors(),
	}
}

// Get returns a TopMostGoodPoster entity by its id.
func (c *TopMostGoodPosterClient) Get(ctx context.Context, id uint32) (*TopMostGoodPoster, error) {
	return c.Query().Where(topmostgoodposter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopMostGoodPosterClient) GetX(ctx context.Context, id uint32) *TopMostGoodPoster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TopMostGoodPosterClient) Hooks() []Hook {
	return c.hooks.TopMostGoodPoster
}

// Interceptors returns the client interceptors.
func (c *TopMostGoodPosterClient) Interceptors() []Interceptor {
	return c.inters.TopMostGoodPoster
}

func (c *TopMostGoodPosterClient) mutate(ctx context.Context, m *TopMostGoodPosterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopMostGoodPosterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopMostGoodPosterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopMostGoodPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopMostGoodPosterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TopMostGoodPoster mutation op: %q", m.Op())
	}
}

// TopMostPosterClient is a client for the TopMostPoster schema.
type TopMostPosterClient struct {
	config
}

// NewTopMostPosterClient returns a client for the TopMostPoster from the given config.
func NewTopMostPosterClient(c config) *TopMostPosterClient {
	return &TopMostPosterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topmostposter.Hooks(f(g(h())))`.
func (c *TopMostPosterClient) Use(hooks ...Hook) {
	c.hooks.TopMostPoster = append(c.hooks.TopMostPoster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topmostposter.Intercept(f(g(h())))`.
func (c *TopMostPosterClient) Intercept(interceptors ...Interceptor) {
	c.inters.TopMostPoster = append(c.inters.TopMostPoster, interceptors...)
}

// Create returns a builder for creating a TopMostPoster entity.
func (c *TopMostPosterClient) Create() *TopMostPosterCreate {
	mutation := newTopMostPosterMutation(c.config, OpCreate)
	return &TopMostPosterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TopMostPoster entities.
func (c *TopMostPosterClient) CreateBulk(builders ...*TopMostPosterCreate) *TopMostPosterCreateBulk {
	return &TopMostPosterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TopMostPosterClient) MapCreateBulk(slice any, setFunc func(*TopMostPosterCreate, int)) *TopMostPosterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TopMostPosterCreateBulk{err: fmt.Errorf("calling to TopMostPosterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TopMostPosterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TopMostPosterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TopMostPoster.
func (c *TopMostPosterClient) Update() *TopMostPosterUpdate {
	mutation := newTopMostPosterMutation(c.config, OpUpdate)
	return &TopMostPosterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopMostPosterClient) UpdateOne(tmp *TopMostPoster) *TopMostPosterUpdateOne {
	mutation := newTopMostPosterMutation(c.config, OpUpdateOne, withTopMostPoster(tmp))
	return &TopMostPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopMostPosterClient) UpdateOneID(id uint32) *TopMostPosterUpdateOne {
	mutation := newTopMostPosterMutation(c.config, OpUpdateOne, withTopMostPosterID(id))
	return &TopMostPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TopMostPoster.
func (c *TopMostPosterClient) Delete() *TopMostPosterDelete {
	mutation := newTopMostPosterMutation(c.config, OpDelete)
	return &TopMostPosterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopMostPosterClient) DeleteOne(tmp *TopMostPoster) *TopMostPosterDeleteOne {
	return c.DeleteOneID(tmp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopMostPosterClient) DeleteOneID(id uint32) *TopMostPosterDeleteOne {
	builder := c.Delete().Where(topmostposter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopMostPosterDeleteOne{builder}
}

// Query returns a query builder for TopMostPoster.
func (c *TopMostPosterClient) Query() *TopMostPosterQuery {
	return &TopMostPosterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopMostPoster},
		inters: c.Interceptors(),
	}
}

// Get returns a TopMostPoster entity by its id.
func (c *TopMostPosterClient) Get(ctx context.Context, id uint32) (*TopMostPoster, error) {
	return c.Query().Where(topmostposter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopMostPosterClient) GetX(ctx context.Context, id uint32) *TopMostPoster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TopMostPosterClient) Hooks() []Hook {
	return c.hooks.TopMostPoster
}

// Interceptors returns the client interceptors.
func (c *TopMostPosterClient) Interceptors() []Interceptor {
	return c.inters.TopMostPoster
}

func (c *TopMostPosterClient) mutate(ctx context.Context, m *TopMostPosterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopMostPosterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopMostPosterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopMostPosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopMostPosterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TopMostPoster mutation op: %q", m.Op())
	}
}

// VendorBrandClient is a client for the VendorBrand schema.
type VendorBrandClient struct {
	config
}

// NewVendorBrandClient returns a client for the VendorBrand from the given config.
func NewVendorBrandClient(c config) *VendorBrandClient {
	return &VendorBrandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vendorbrand.Hooks(f(g(h())))`.
func (c *VendorBrandClient) Use(hooks ...Hook) {
	c.hooks.VendorBrand = append(c.hooks.VendorBrand, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vendorbrand.Intercept(f(g(h())))`.
func (c *VendorBrandClient) Intercept(interceptors ...Interceptor) {
	c.inters.VendorBrand = append(c.inters.VendorBrand, interceptors...)
}

// Create returns a builder for creating a VendorBrand entity.
func (c *VendorBrandClient) Create() *VendorBrandCreate {
	mutation := newVendorBrandMutation(c.config, OpCreate)
	return &VendorBrandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VendorBrand entities.
func (c *VendorBrandClient) CreateBulk(builders ...*VendorBrandCreate) *VendorBrandCreateBulk {
	return &VendorBrandCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VendorBrandClient) MapCreateBulk(slice any, setFunc func(*VendorBrandCreate, int)) *VendorBrandCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VendorBrandCreateBulk{err: fmt.Errorf("calling to VendorBrandClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VendorBrandCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VendorBrandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VendorBrand.
func (c *VendorBrandClient) Update() *VendorBrandUpdate {
	mutation := newVendorBrandMutation(c.config, OpUpdate)
	return &VendorBrandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VendorBrandClient) UpdateOne(vb *VendorBrand) *VendorBrandUpdateOne {
	mutation := newVendorBrandMutation(c.config, OpUpdateOne, withVendorBrand(vb))
	return &VendorBrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VendorBrandClient) UpdateOneID(id uint32) *VendorBrandUpdateOne {
	mutation := newVendorBrandMutation(c.config, OpUpdateOne, withVendorBrandID(id))
	return &VendorBrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VendorBrand.
func (c *VendorBrandClient) Delete() *VendorBrandDelete {
	mutation := newVendorBrandMutation(c.config, OpDelete)
	return &VendorBrandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VendorBrandClient) DeleteOne(vb *VendorBrand) *VendorBrandDeleteOne {
	return c.DeleteOneID(vb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VendorBrandClient) DeleteOneID(id uint32) *VendorBrandDeleteOne {
	builder := c.Delete().Where(vendorbrand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VendorBrandDeleteOne{builder}
}

// Query returns a query builder for VendorBrand.
func (c *VendorBrandClient) Query() *VendorBrandQuery {
	return &VendorBrandQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVendorBrand},
		inters: c.Interceptors(),
	}
}

// Get returns a VendorBrand entity by its id.
func (c *VendorBrandClient) Get(ctx context.Context, id uint32) (*VendorBrand, error) {
	return c.Query().Where(vendorbrand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VendorBrandClient) GetX(ctx context.Context, id uint32) *VendorBrand {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VendorBrandClient) Hooks() []Hook {
	return c.hooks.VendorBrand
}

// Interceptors returns the client interceptors.
func (c *VendorBrandClient) Interceptors() []Interceptor {
	return c.inters.VendorBrand
}

func (c *VendorBrandClient) mutate(ctx context.Context, m *VendorBrandMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VendorBrandCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VendorBrandUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VendorBrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VendorBrandDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown VendorBrand mutation op: %q", m.Op())
	}
}

// VendorLocationClient is a client for the VendorLocation schema.
type VendorLocationClient struct {
	config
}

// NewVendorLocationClient returns a client for the VendorLocation from the given config.
func NewVendorLocationClient(c config) *VendorLocationClient {
	return &VendorLocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vendorlocation.Hooks(f(g(h())))`.
func (c *VendorLocationClient) Use(hooks ...Hook) {
	c.hooks.VendorLocation = append(c.hooks.VendorLocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vendorlocation.Intercept(f(g(h())))`.
func (c *VendorLocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.VendorLocation = append(c.inters.VendorLocation, interceptors...)
}

// Create returns a builder for creating a VendorLocation entity.
func (c *VendorLocationClient) Create() *VendorLocationCreate {
	mutation := newVendorLocationMutation(c.config, OpCreate)
	return &VendorLocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VendorLocation entities.
func (c *VendorLocationClient) CreateBulk(builders ...*VendorLocationCreate) *VendorLocationCreateBulk {
	return &VendorLocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VendorLocationClient) MapCreateBulk(slice any, setFunc func(*VendorLocationCreate, int)) *VendorLocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VendorLocationCreateBulk{err: fmt.Errorf("calling to VendorLocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VendorLocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VendorLocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VendorLocation.
func (c *VendorLocationClient) Update() *VendorLocationUpdate {
	mutation := newVendorLocationMutation(c.config, OpUpdate)
	return &VendorLocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VendorLocationClient) UpdateOne(vl *VendorLocation) *VendorLocationUpdateOne {
	mutation := newVendorLocationMutation(c.config, OpUpdateOne, withVendorLocation(vl))
	return &VendorLocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VendorLocationClient) UpdateOneID(id uint32) *VendorLocationUpdateOne {
	mutation := newVendorLocationMutation(c.config, OpUpdateOne, withVendorLocationID(id))
	return &VendorLocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VendorLocation.
func (c *VendorLocationClient) Delete() *VendorLocationDelete {
	mutation := newVendorLocationMutation(c.config, OpDelete)
	return &VendorLocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VendorLocationClient) DeleteOne(vl *VendorLocation) *VendorLocationDeleteOne {
	return c.DeleteOneID(vl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VendorLocationClient) DeleteOneID(id uint32) *VendorLocationDeleteOne {
	builder := c.Delete().Where(vendorlocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VendorLocationDeleteOne{builder}
}

// Query returns a query builder for VendorLocation.
func (c *VendorLocationClient) Query() *VendorLocationQuery {
	return &VendorLocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVendorLocation},
		inters: c.Interceptors(),
	}
}

// Get returns a VendorLocation entity by its id.
func (c *VendorLocationClient) Get(ctx context.Context, id uint32) (*VendorLocation, error) {
	return c.Query().Where(vendorlocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VendorLocationClient) GetX(ctx context.Context, id uint32) *VendorLocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VendorLocationClient) Hooks() []Hook {
	return c.hooks.VendorLocation
}

// Interceptors returns the client interceptors.
func (c *VendorLocationClient) Interceptors() []Interceptor {
	return c.inters.VendorLocation
}

func (c *VendorLocationClient) mutate(ctx context.Context, m *VendorLocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VendorLocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VendorLocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VendorLocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VendorLocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown VendorLocation mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AppDefaultGood, AppDelegatedStaking, AppFee, AppGood, AppGoodBase,
		AppGoodDescription, AppGoodDisplayColor, AppGoodDisplayName, AppGoodLabel,
		AppGoodPoster, AppLegacyPowerRental, AppMiningGoodStock, AppPowerRental,
		AppSimulatePowerRental, AppStock, AppStockLock, AppSubscription,
		AppSubscriptionOneShot, Comment, DelegatedStaking, DeviceInfo,
		DeviceManufacturer, DevicePoster, ExtraInfo, FbmCrowdFunding, Fee, Good,
		GoodBase, GoodCoin, GoodCoinReward, GoodMalfunction, GoodReward,
		GoodRewardHistory, Like, MiningGoodStock, PowerRental, Recommend,
		RequiredAppGood, RequiredGood, Score, Stock, Subscription, SubscriptionOneShot,
		TopMost, TopMostConstraint, TopMostGood, TopMostGoodConstraint,
		TopMostGoodPoster, TopMostPoster, VendorBrand, VendorLocation []ent.Hook
	}
	inters struct {
		AppDefaultGood, AppDelegatedStaking, AppFee, AppGood, AppGoodBase,
		AppGoodDescription, AppGoodDisplayColor, AppGoodDisplayName, AppGoodLabel,
		AppGoodPoster, AppLegacyPowerRental, AppMiningGoodStock, AppPowerRental,
		AppSimulatePowerRental, AppStock, AppStockLock, AppSubscription,
		AppSubscriptionOneShot, Comment, DelegatedStaking, DeviceInfo,
		DeviceManufacturer, DevicePoster, ExtraInfo, FbmCrowdFunding, Fee, Good,
		GoodBase, GoodCoin, GoodCoinReward, GoodMalfunction, GoodReward,
		GoodRewardHistory, Like, MiningGoodStock, PowerRental, Recommend,
		RequiredAppGood, RequiredGood, Score, Stock, Subscription, SubscriptionOneShot,
		TopMost, TopMostConstraint, TopMostGood, TopMostGoodConstraint,
		TopMostGoodPoster, TopMostPoster, VendorBrand, VendorLocation []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
