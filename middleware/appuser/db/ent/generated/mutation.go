// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/app"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appcontrol"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appoauththirdparty"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/approle"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/approleuser"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appsubscribe"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appuser"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appusercontrol"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appuserextra"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appusersecret"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appuserthirdparty"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/auth"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/authhistory"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/banapp"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/banappuser"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/kyc"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/loginhistory"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/oauththirdparty"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/predicate"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/recoverycode"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/subscriber"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp                = "App"
	TypeAppControl         = "AppControl"
	TypeAppOAuthThirdParty = "AppOAuthThirdParty"
	TypeAppRole            = "AppRole"
	TypeAppRoleUser        = "AppRoleUser"
	TypeAppSubscribe       = "AppSubscribe"
	TypeAppUser            = "AppUser"
	TypeAppUserControl     = "AppUserControl"
	TypeAppUserExtra       = "AppUserExtra"
	TypeAppUserSecret      = "AppUserSecret"
	TypeAppUserThirdParty  = "AppUserThirdParty"
	TypeAuth               = "Auth"
	TypeAuthHistory        = "AuthHistory"
	TypeBanApp             = "BanApp"
	TypeBanAppUser         = "BanAppUser"
	TypeKyc                = "Kyc"
	TypeLoginHistory       = "LoginHistory"
	TypeOAuthThirdParty    = "OAuthThirdParty"
	TypeRecoveryCode       = "RecoveryCode"
	TypeSubscriber         = "Subscriber"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	created_by    *uuid.UUID
	name          *string
	logo          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*App, error)
	predicates    []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id uint32) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AppMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[app.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AppMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[app.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, app.FieldCreatedBy)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppMutation) ClearName() {
	m.name = nil
	m.clearedFields[app.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppMutation) NameCleared() bool {
	_, ok := m.clearedFields[app.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, app.FieldName)
}

// SetLogo sets the "logo" field.
func (m *AppMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *AppMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *AppMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[app.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *AppMutation) LogoCleared() bool {
	_, ok := m.clearedFields[app.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *AppMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, app.FieldLogo)
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[app.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[app.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, app.FieldDescription)
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, app.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, app.FieldEntID)
	}
	if m.created_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, app.FieldLogo)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldDeletedAt:
		return m.DeletedAt()
	case app.FieldEntID:
		return m.EntID()
	case app.FieldCreatedBy:
		return m.CreatedBy()
	case app.FieldName:
		return m.Name()
	case app.FieldLogo:
		return m.Logo()
	case app.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case app.FieldEntID:
		return m.OldEntID(ctx)
	case app.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldLogo:
		return m.OldLogo(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case app.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case app.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, app.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.AddedCreatedAt()
	case app.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case app.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case app.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldCreatedBy) {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.FieldCleared(app.FieldName) {
		fields = append(fields, app.FieldName)
	}
	if m.FieldCleared(app.FieldLogo) {
		fields = append(fields, app.FieldLogo)
	}
	if m.FieldCleared(app.FieldDescription) {
		fields = append(fields, app.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case app.FieldName:
		m.ClearName()
		return nil
	case app.FieldLogo:
		m.ClearLogo()
		return nil
	case app.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case app.FieldEntID:
		m.ResetEntID()
		return nil
	case app.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldLogo:
		m.ResetLogo()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown App edge %s", name)
}

// AppControlMutation represents an operation that mutates the AppControl nodes in the graph.
type AppControlMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uint32
	created_at                     *uint32
	addcreated_at                  *int32
	updated_at                     *uint32
	addupdated_at                  *int32
	deleted_at                     *uint32
	adddeleted_at                  *int32
	ent_id                         *uuid.UUID
	app_id                         *uuid.UUID
	signup_methods                 *[]string
	appendsignup_methods           []string
	extern_signin_methods          *[]string
	appendextern_signin_methods    []string
	recaptcha_method               *string
	kyc_enable                     *bool
	signin_verify_enable           *bool
	invitation_code_must           *bool
	create_invitation_code_when    *string
	max_typed_coupons_per_order    *uint32
	addmax_typed_coupons_per_order *int32
	maintaining                    *bool
	coupon_withdraw_enable         *bool
	commit_button_targets          *[]string
	appendcommit_button_targets    []string
	reset_user_method              *string
	clearedFields                  map[string]struct{}
	done                           bool
	oldValue                       func(context.Context) (*AppControl, error)
	predicates                     []predicate.AppControl
}

var _ ent.Mutation = (*AppControlMutation)(nil)

// appcontrolOption allows management of the mutation configuration using functional options.
type appcontrolOption func(*AppControlMutation)

// newAppControlMutation creates new mutation for the AppControl entity.
func newAppControlMutation(c config, op Op, opts ...appcontrolOption) *AppControlMutation {
	m := &AppControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAppControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppControlID sets the ID field of the mutation.
func withAppControlID(id uint32) appcontrolOption {
	return func(m *AppControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AppControl
		)
		m.oldValue = func(ctx context.Context) (*AppControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppControl sets the old AppControl of the mutation.
func withAppControl(node *AppControl) appcontrolOption {
	return func(m *AppControlMutation) {
		m.oldValue = func(context.Context) (*AppControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppControl entities.
func (m *AppControlMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppControlMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppControlMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppControlMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppControlMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppControlMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppControlMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppControlMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppControlMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppControlMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppControlMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppControlMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppControlMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppControlMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppControlMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppControlMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppControlMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppControlMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppControlMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppControlMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppControlMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppControlMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppControlMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appcontrol.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppControlMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppControlMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appcontrol.FieldAppID)
}

// SetSignupMethods sets the "signup_methods" field.
func (m *AppControlMutation) SetSignupMethods(s []string) {
	m.signup_methods = &s
	m.appendsignup_methods = nil
}

// SignupMethods returns the value of the "signup_methods" field in the mutation.
func (m *AppControlMutation) SignupMethods() (r []string, exists bool) {
	v := m.signup_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldSignupMethods returns the old "signup_methods" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldSignupMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignupMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignupMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignupMethods: %w", err)
	}
	return oldValue.SignupMethods, nil
}

// AppendSignupMethods adds s to the "signup_methods" field.
func (m *AppControlMutation) AppendSignupMethods(s []string) {
	m.appendsignup_methods = append(m.appendsignup_methods, s...)
}

// AppendedSignupMethods returns the list of values that were appended to the "signup_methods" field in this mutation.
func (m *AppControlMutation) AppendedSignupMethods() ([]string, bool) {
	if len(m.appendsignup_methods) == 0 {
		return nil, false
	}
	return m.appendsignup_methods, true
}

// ClearSignupMethods clears the value of the "signup_methods" field.
func (m *AppControlMutation) ClearSignupMethods() {
	m.signup_methods = nil
	m.appendsignup_methods = nil
	m.clearedFields[appcontrol.FieldSignupMethods] = struct{}{}
}

// SignupMethodsCleared returns if the "signup_methods" field was cleared in this mutation.
func (m *AppControlMutation) SignupMethodsCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldSignupMethods]
	return ok
}

// ResetSignupMethods resets all changes to the "signup_methods" field.
func (m *AppControlMutation) ResetSignupMethods() {
	m.signup_methods = nil
	m.appendsignup_methods = nil
	delete(m.clearedFields, appcontrol.FieldSignupMethods)
}

// SetExternSigninMethods sets the "extern_signin_methods" field.
func (m *AppControlMutation) SetExternSigninMethods(s []string) {
	m.extern_signin_methods = &s
	m.appendextern_signin_methods = nil
}

// ExternSigninMethods returns the value of the "extern_signin_methods" field in the mutation.
func (m *AppControlMutation) ExternSigninMethods() (r []string, exists bool) {
	v := m.extern_signin_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldExternSigninMethods returns the old "extern_signin_methods" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldExternSigninMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternSigninMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternSigninMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternSigninMethods: %w", err)
	}
	return oldValue.ExternSigninMethods, nil
}

// AppendExternSigninMethods adds s to the "extern_signin_methods" field.
func (m *AppControlMutation) AppendExternSigninMethods(s []string) {
	m.appendextern_signin_methods = append(m.appendextern_signin_methods, s...)
}

// AppendedExternSigninMethods returns the list of values that were appended to the "extern_signin_methods" field in this mutation.
func (m *AppControlMutation) AppendedExternSigninMethods() ([]string, bool) {
	if len(m.appendextern_signin_methods) == 0 {
		return nil, false
	}
	return m.appendextern_signin_methods, true
}

// ClearExternSigninMethods clears the value of the "extern_signin_methods" field.
func (m *AppControlMutation) ClearExternSigninMethods() {
	m.extern_signin_methods = nil
	m.appendextern_signin_methods = nil
	m.clearedFields[appcontrol.FieldExternSigninMethods] = struct{}{}
}

// ExternSigninMethodsCleared returns if the "extern_signin_methods" field was cleared in this mutation.
func (m *AppControlMutation) ExternSigninMethodsCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldExternSigninMethods]
	return ok
}

// ResetExternSigninMethods resets all changes to the "extern_signin_methods" field.
func (m *AppControlMutation) ResetExternSigninMethods() {
	m.extern_signin_methods = nil
	m.appendextern_signin_methods = nil
	delete(m.clearedFields, appcontrol.FieldExternSigninMethods)
}

// SetRecaptchaMethod sets the "recaptcha_method" field.
func (m *AppControlMutation) SetRecaptchaMethod(s string) {
	m.recaptcha_method = &s
}

// RecaptchaMethod returns the value of the "recaptcha_method" field in the mutation.
func (m *AppControlMutation) RecaptchaMethod() (r string, exists bool) {
	v := m.recaptcha_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRecaptchaMethod returns the old "recaptcha_method" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldRecaptchaMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecaptchaMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecaptchaMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecaptchaMethod: %w", err)
	}
	return oldValue.RecaptchaMethod, nil
}

// ClearRecaptchaMethod clears the value of the "recaptcha_method" field.
func (m *AppControlMutation) ClearRecaptchaMethod() {
	m.recaptcha_method = nil
	m.clearedFields[appcontrol.FieldRecaptchaMethod] = struct{}{}
}

// RecaptchaMethodCleared returns if the "recaptcha_method" field was cleared in this mutation.
func (m *AppControlMutation) RecaptchaMethodCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldRecaptchaMethod]
	return ok
}

// ResetRecaptchaMethod resets all changes to the "recaptcha_method" field.
func (m *AppControlMutation) ResetRecaptchaMethod() {
	m.recaptcha_method = nil
	delete(m.clearedFields, appcontrol.FieldRecaptchaMethod)
}

// SetKycEnable sets the "kyc_enable" field.
func (m *AppControlMutation) SetKycEnable(b bool) {
	m.kyc_enable = &b
}

// KycEnable returns the value of the "kyc_enable" field in the mutation.
func (m *AppControlMutation) KycEnable() (r bool, exists bool) {
	v := m.kyc_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldKycEnable returns the old "kyc_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldKycEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKycEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKycEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKycEnable: %w", err)
	}
	return oldValue.KycEnable, nil
}

// ClearKycEnable clears the value of the "kyc_enable" field.
func (m *AppControlMutation) ClearKycEnable() {
	m.kyc_enable = nil
	m.clearedFields[appcontrol.FieldKycEnable] = struct{}{}
}

// KycEnableCleared returns if the "kyc_enable" field was cleared in this mutation.
func (m *AppControlMutation) KycEnableCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldKycEnable]
	return ok
}

// ResetKycEnable resets all changes to the "kyc_enable" field.
func (m *AppControlMutation) ResetKycEnable() {
	m.kyc_enable = nil
	delete(m.clearedFields, appcontrol.FieldKycEnable)
}

// SetSigninVerifyEnable sets the "signin_verify_enable" field.
func (m *AppControlMutation) SetSigninVerifyEnable(b bool) {
	m.signin_verify_enable = &b
}

// SigninVerifyEnable returns the value of the "signin_verify_enable" field in the mutation.
func (m *AppControlMutation) SigninVerifyEnable() (r bool, exists bool) {
	v := m.signin_verify_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyEnable returns the old "signin_verify_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldSigninVerifyEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyEnable: %w", err)
	}
	return oldValue.SigninVerifyEnable, nil
}

// ClearSigninVerifyEnable clears the value of the "signin_verify_enable" field.
func (m *AppControlMutation) ClearSigninVerifyEnable() {
	m.signin_verify_enable = nil
	m.clearedFields[appcontrol.FieldSigninVerifyEnable] = struct{}{}
}

// SigninVerifyEnableCleared returns if the "signin_verify_enable" field was cleared in this mutation.
func (m *AppControlMutation) SigninVerifyEnableCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldSigninVerifyEnable]
	return ok
}

// ResetSigninVerifyEnable resets all changes to the "signin_verify_enable" field.
func (m *AppControlMutation) ResetSigninVerifyEnable() {
	m.signin_verify_enable = nil
	delete(m.clearedFields, appcontrol.FieldSigninVerifyEnable)
}

// SetInvitationCodeMust sets the "invitation_code_must" field.
func (m *AppControlMutation) SetInvitationCodeMust(b bool) {
	m.invitation_code_must = &b
}

// InvitationCodeMust returns the value of the "invitation_code_must" field in the mutation.
func (m *AppControlMutation) InvitationCodeMust() (r bool, exists bool) {
	v := m.invitation_code_must
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationCodeMust returns the old "invitation_code_must" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldInvitationCodeMust(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationCodeMust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationCodeMust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationCodeMust: %w", err)
	}
	return oldValue.InvitationCodeMust, nil
}

// ClearInvitationCodeMust clears the value of the "invitation_code_must" field.
func (m *AppControlMutation) ClearInvitationCodeMust() {
	m.invitation_code_must = nil
	m.clearedFields[appcontrol.FieldInvitationCodeMust] = struct{}{}
}

// InvitationCodeMustCleared returns if the "invitation_code_must" field was cleared in this mutation.
func (m *AppControlMutation) InvitationCodeMustCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldInvitationCodeMust]
	return ok
}

// ResetInvitationCodeMust resets all changes to the "invitation_code_must" field.
func (m *AppControlMutation) ResetInvitationCodeMust() {
	m.invitation_code_must = nil
	delete(m.clearedFields, appcontrol.FieldInvitationCodeMust)
}

// SetCreateInvitationCodeWhen sets the "create_invitation_code_when" field.
func (m *AppControlMutation) SetCreateInvitationCodeWhen(s string) {
	m.create_invitation_code_when = &s
}

// CreateInvitationCodeWhen returns the value of the "create_invitation_code_when" field in the mutation.
func (m *AppControlMutation) CreateInvitationCodeWhen() (r string, exists bool) {
	v := m.create_invitation_code_when
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateInvitationCodeWhen returns the old "create_invitation_code_when" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldCreateInvitationCodeWhen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateInvitationCodeWhen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateInvitationCodeWhen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateInvitationCodeWhen: %w", err)
	}
	return oldValue.CreateInvitationCodeWhen, nil
}

// ClearCreateInvitationCodeWhen clears the value of the "create_invitation_code_when" field.
func (m *AppControlMutation) ClearCreateInvitationCodeWhen() {
	m.create_invitation_code_when = nil
	m.clearedFields[appcontrol.FieldCreateInvitationCodeWhen] = struct{}{}
}

// CreateInvitationCodeWhenCleared returns if the "create_invitation_code_when" field was cleared in this mutation.
func (m *AppControlMutation) CreateInvitationCodeWhenCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldCreateInvitationCodeWhen]
	return ok
}

// ResetCreateInvitationCodeWhen resets all changes to the "create_invitation_code_when" field.
func (m *AppControlMutation) ResetCreateInvitationCodeWhen() {
	m.create_invitation_code_when = nil
	delete(m.clearedFields, appcontrol.FieldCreateInvitationCodeWhen)
}

// SetMaxTypedCouponsPerOrder sets the "max_typed_coupons_per_order" field.
func (m *AppControlMutation) SetMaxTypedCouponsPerOrder(u uint32) {
	m.max_typed_coupons_per_order = &u
	m.addmax_typed_coupons_per_order = nil
}

// MaxTypedCouponsPerOrder returns the value of the "max_typed_coupons_per_order" field in the mutation.
func (m *AppControlMutation) MaxTypedCouponsPerOrder() (r uint32, exists bool) {
	v := m.max_typed_coupons_per_order
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTypedCouponsPerOrder returns the old "max_typed_coupons_per_order" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldMaxTypedCouponsPerOrder(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTypedCouponsPerOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTypedCouponsPerOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTypedCouponsPerOrder: %w", err)
	}
	return oldValue.MaxTypedCouponsPerOrder, nil
}

// AddMaxTypedCouponsPerOrder adds u to the "max_typed_coupons_per_order" field.
func (m *AppControlMutation) AddMaxTypedCouponsPerOrder(u int32) {
	if m.addmax_typed_coupons_per_order != nil {
		*m.addmax_typed_coupons_per_order += u
	} else {
		m.addmax_typed_coupons_per_order = &u
	}
}

// AddedMaxTypedCouponsPerOrder returns the value that was added to the "max_typed_coupons_per_order" field in this mutation.
func (m *AppControlMutation) AddedMaxTypedCouponsPerOrder() (r int32, exists bool) {
	v := m.addmax_typed_coupons_per_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTypedCouponsPerOrder clears the value of the "max_typed_coupons_per_order" field.
func (m *AppControlMutation) ClearMaxTypedCouponsPerOrder() {
	m.max_typed_coupons_per_order = nil
	m.addmax_typed_coupons_per_order = nil
	m.clearedFields[appcontrol.FieldMaxTypedCouponsPerOrder] = struct{}{}
}

// MaxTypedCouponsPerOrderCleared returns if the "max_typed_coupons_per_order" field was cleared in this mutation.
func (m *AppControlMutation) MaxTypedCouponsPerOrderCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldMaxTypedCouponsPerOrder]
	return ok
}

// ResetMaxTypedCouponsPerOrder resets all changes to the "max_typed_coupons_per_order" field.
func (m *AppControlMutation) ResetMaxTypedCouponsPerOrder() {
	m.max_typed_coupons_per_order = nil
	m.addmax_typed_coupons_per_order = nil
	delete(m.clearedFields, appcontrol.FieldMaxTypedCouponsPerOrder)
}

// SetMaintaining sets the "maintaining" field.
func (m *AppControlMutation) SetMaintaining(b bool) {
	m.maintaining = &b
}

// Maintaining returns the value of the "maintaining" field in the mutation.
func (m *AppControlMutation) Maintaining() (r bool, exists bool) {
	v := m.maintaining
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintaining returns the old "maintaining" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldMaintaining(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintaining is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintaining requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintaining: %w", err)
	}
	return oldValue.Maintaining, nil
}

// ClearMaintaining clears the value of the "maintaining" field.
func (m *AppControlMutation) ClearMaintaining() {
	m.maintaining = nil
	m.clearedFields[appcontrol.FieldMaintaining] = struct{}{}
}

// MaintainingCleared returns if the "maintaining" field was cleared in this mutation.
func (m *AppControlMutation) MaintainingCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldMaintaining]
	return ok
}

// ResetMaintaining resets all changes to the "maintaining" field.
func (m *AppControlMutation) ResetMaintaining() {
	m.maintaining = nil
	delete(m.clearedFields, appcontrol.FieldMaintaining)
}

// SetCouponWithdrawEnable sets the "coupon_withdraw_enable" field.
func (m *AppControlMutation) SetCouponWithdrawEnable(b bool) {
	m.coupon_withdraw_enable = &b
}

// CouponWithdrawEnable returns the value of the "coupon_withdraw_enable" field in the mutation.
func (m *AppControlMutation) CouponWithdrawEnable() (r bool, exists bool) {
	v := m.coupon_withdraw_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponWithdrawEnable returns the old "coupon_withdraw_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldCouponWithdrawEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponWithdrawEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponWithdrawEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponWithdrawEnable: %w", err)
	}
	return oldValue.CouponWithdrawEnable, nil
}

// ClearCouponWithdrawEnable clears the value of the "coupon_withdraw_enable" field.
func (m *AppControlMutation) ClearCouponWithdrawEnable() {
	m.coupon_withdraw_enable = nil
	m.clearedFields[appcontrol.FieldCouponWithdrawEnable] = struct{}{}
}

// CouponWithdrawEnableCleared returns if the "coupon_withdraw_enable" field was cleared in this mutation.
func (m *AppControlMutation) CouponWithdrawEnableCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldCouponWithdrawEnable]
	return ok
}

// ResetCouponWithdrawEnable resets all changes to the "coupon_withdraw_enable" field.
func (m *AppControlMutation) ResetCouponWithdrawEnable() {
	m.coupon_withdraw_enable = nil
	delete(m.clearedFields, appcontrol.FieldCouponWithdrawEnable)
}

// SetCommitButtonTargets sets the "commit_button_targets" field.
func (m *AppControlMutation) SetCommitButtonTargets(s []string) {
	m.commit_button_targets = &s
	m.appendcommit_button_targets = nil
}

// CommitButtonTargets returns the value of the "commit_button_targets" field in the mutation.
func (m *AppControlMutation) CommitButtonTargets() (r []string, exists bool) {
	v := m.commit_button_targets
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitButtonTargets returns the old "commit_button_targets" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldCommitButtonTargets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitButtonTargets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitButtonTargets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitButtonTargets: %w", err)
	}
	return oldValue.CommitButtonTargets, nil
}

// AppendCommitButtonTargets adds s to the "commit_button_targets" field.
func (m *AppControlMutation) AppendCommitButtonTargets(s []string) {
	m.appendcommit_button_targets = append(m.appendcommit_button_targets, s...)
}

// AppendedCommitButtonTargets returns the list of values that were appended to the "commit_button_targets" field in this mutation.
func (m *AppControlMutation) AppendedCommitButtonTargets() ([]string, bool) {
	if len(m.appendcommit_button_targets) == 0 {
		return nil, false
	}
	return m.appendcommit_button_targets, true
}

// ClearCommitButtonTargets clears the value of the "commit_button_targets" field.
func (m *AppControlMutation) ClearCommitButtonTargets() {
	m.commit_button_targets = nil
	m.appendcommit_button_targets = nil
	m.clearedFields[appcontrol.FieldCommitButtonTargets] = struct{}{}
}

// CommitButtonTargetsCleared returns if the "commit_button_targets" field was cleared in this mutation.
func (m *AppControlMutation) CommitButtonTargetsCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldCommitButtonTargets]
	return ok
}

// ResetCommitButtonTargets resets all changes to the "commit_button_targets" field.
func (m *AppControlMutation) ResetCommitButtonTargets() {
	m.commit_button_targets = nil
	m.appendcommit_button_targets = nil
	delete(m.clearedFields, appcontrol.FieldCommitButtonTargets)
}

// SetResetUserMethod sets the "reset_user_method" field.
func (m *AppControlMutation) SetResetUserMethod(s string) {
	m.reset_user_method = &s
}

// ResetUserMethod returns the value of the "reset_user_method" field in the mutation.
func (m *AppControlMutation) ResetUserMethod() (r string, exists bool) {
	v := m.reset_user_method
	if v == nil {
		return
	}
	return *v, true
}

// OldResetUserMethod returns the old "reset_user_method" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldResetUserMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetUserMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetUserMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetUserMethod: %w", err)
	}
	return oldValue.ResetUserMethod, nil
}

// ClearResetUserMethod clears the value of the "reset_user_method" field.
func (m *AppControlMutation) ClearResetUserMethod() {
	m.reset_user_method = nil
	m.clearedFields[appcontrol.FieldResetUserMethod] = struct{}{}
}

// ResetUserMethodCleared returns if the "reset_user_method" field was cleared in this mutation.
func (m *AppControlMutation) ResetUserMethodCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldResetUserMethod]
	return ok
}

// ResetResetUserMethod resets all changes to the "reset_user_method" field.
func (m *AppControlMutation) ResetResetUserMethod() {
	m.reset_user_method = nil
	delete(m.clearedFields, appcontrol.FieldResetUserMethod)
}

// Where appends a list predicates to the AppControlMutation builder.
func (m *AppControlMutation) Where(ps ...predicate.AppControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppControl).
func (m *AppControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppControlMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, appcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appcontrol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appcontrol.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appcontrol.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appcontrol.FieldAppID)
	}
	if m.signup_methods != nil {
		fields = append(fields, appcontrol.FieldSignupMethods)
	}
	if m.extern_signin_methods != nil {
		fields = append(fields, appcontrol.FieldExternSigninMethods)
	}
	if m.recaptcha_method != nil {
		fields = append(fields, appcontrol.FieldRecaptchaMethod)
	}
	if m.kyc_enable != nil {
		fields = append(fields, appcontrol.FieldKycEnable)
	}
	if m.signin_verify_enable != nil {
		fields = append(fields, appcontrol.FieldSigninVerifyEnable)
	}
	if m.invitation_code_must != nil {
		fields = append(fields, appcontrol.FieldInvitationCodeMust)
	}
	if m.create_invitation_code_when != nil {
		fields = append(fields, appcontrol.FieldCreateInvitationCodeWhen)
	}
	if m.max_typed_coupons_per_order != nil {
		fields = append(fields, appcontrol.FieldMaxTypedCouponsPerOrder)
	}
	if m.maintaining != nil {
		fields = append(fields, appcontrol.FieldMaintaining)
	}
	if m.coupon_withdraw_enable != nil {
		fields = append(fields, appcontrol.FieldCouponWithdrawEnable)
	}
	if m.commit_button_targets != nil {
		fields = append(fields, appcontrol.FieldCommitButtonTargets)
	}
	if m.reset_user_method != nil {
		fields = append(fields, appcontrol.FieldResetUserMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case appcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcontrol.FieldDeletedAt:
		return m.DeletedAt()
	case appcontrol.FieldEntID:
		return m.EntID()
	case appcontrol.FieldAppID:
		return m.AppID()
	case appcontrol.FieldSignupMethods:
		return m.SignupMethods()
	case appcontrol.FieldExternSigninMethods:
		return m.ExternSigninMethods()
	case appcontrol.FieldRecaptchaMethod:
		return m.RecaptchaMethod()
	case appcontrol.FieldKycEnable:
		return m.KycEnable()
	case appcontrol.FieldSigninVerifyEnable:
		return m.SigninVerifyEnable()
	case appcontrol.FieldInvitationCodeMust:
		return m.InvitationCodeMust()
	case appcontrol.FieldCreateInvitationCodeWhen:
		return m.CreateInvitationCodeWhen()
	case appcontrol.FieldMaxTypedCouponsPerOrder:
		return m.MaxTypedCouponsPerOrder()
	case appcontrol.FieldMaintaining:
		return m.Maintaining()
	case appcontrol.FieldCouponWithdrawEnable:
		return m.CouponWithdrawEnable()
	case appcontrol.FieldCommitButtonTargets:
		return m.CommitButtonTargets()
	case appcontrol.FieldResetUserMethod:
		return m.ResetUserMethod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcontrol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appcontrol.FieldEntID:
		return m.OldEntID(ctx)
	case appcontrol.FieldAppID:
		return m.OldAppID(ctx)
	case appcontrol.FieldSignupMethods:
		return m.OldSignupMethods(ctx)
	case appcontrol.FieldExternSigninMethods:
		return m.OldExternSigninMethods(ctx)
	case appcontrol.FieldRecaptchaMethod:
		return m.OldRecaptchaMethod(ctx)
	case appcontrol.FieldKycEnable:
		return m.OldKycEnable(ctx)
	case appcontrol.FieldSigninVerifyEnable:
		return m.OldSigninVerifyEnable(ctx)
	case appcontrol.FieldInvitationCodeMust:
		return m.OldInvitationCodeMust(ctx)
	case appcontrol.FieldCreateInvitationCodeWhen:
		return m.OldCreateInvitationCodeWhen(ctx)
	case appcontrol.FieldMaxTypedCouponsPerOrder:
		return m.OldMaxTypedCouponsPerOrder(ctx)
	case appcontrol.FieldMaintaining:
		return m.OldMaintaining(ctx)
	case appcontrol.FieldCouponWithdrawEnable:
		return m.OldCouponWithdrawEnable(ctx)
	case appcontrol.FieldCommitButtonTargets:
		return m.OldCommitButtonTargets(ctx)
	case appcontrol.FieldResetUserMethod:
		return m.OldResetUserMethod(ctx)
	}
	return nil, fmt.Errorf("unknown AppControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appcontrol.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcontrol.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appcontrol.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appcontrol.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appcontrol.FieldSignupMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignupMethods(v)
		return nil
	case appcontrol.FieldExternSigninMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternSigninMethods(v)
		return nil
	case appcontrol.FieldRecaptchaMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecaptchaMethod(v)
		return nil
	case appcontrol.FieldKycEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKycEnable(v)
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyEnable(v)
		return nil
	case appcontrol.FieldInvitationCodeMust:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationCodeMust(v)
		return nil
	case appcontrol.FieldCreateInvitationCodeWhen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateInvitationCodeWhen(v)
		return nil
	case appcontrol.FieldMaxTypedCouponsPerOrder:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTypedCouponsPerOrder(v)
		return nil
	case appcontrol.FieldMaintaining:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintaining(v)
		return nil
	case appcontrol.FieldCouponWithdrawEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponWithdrawEnable(v)
		return nil
	case appcontrol.FieldCommitButtonTargets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitButtonTargets(v)
		return nil
	case appcontrol.FieldResetUserMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetUserMethod(v)
		return nil
	}
	return fmt.Errorf("unknown AppControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppControlMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appcontrol.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appcontrol.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appcontrol.FieldDeletedAt)
	}
	if m.addmax_typed_coupons_per_order != nil {
		fields = append(fields, appcontrol.FieldMaxTypedCouponsPerOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appcontrol.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appcontrol.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appcontrol.FieldMaxTypedCouponsPerOrder:
		return m.AddedMaxTypedCouponsPerOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appcontrol.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appcontrol.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appcontrol.FieldMaxTypedCouponsPerOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTypedCouponsPerOrder(v)
		return nil
	}
	return fmt.Errorf("unknown AppControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appcontrol.FieldAppID) {
		fields = append(fields, appcontrol.FieldAppID)
	}
	if m.FieldCleared(appcontrol.FieldSignupMethods) {
		fields = append(fields, appcontrol.FieldSignupMethods)
	}
	if m.FieldCleared(appcontrol.FieldExternSigninMethods) {
		fields = append(fields, appcontrol.FieldExternSigninMethods)
	}
	if m.FieldCleared(appcontrol.FieldRecaptchaMethod) {
		fields = append(fields, appcontrol.FieldRecaptchaMethod)
	}
	if m.FieldCleared(appcontrol.FieldKycEnable) {
		fields = append(fields, appcontrol.FieldKycEnable)
	}
	if m.FieldCleared(appcontrol.FieldSigninVerifyEnable) {
		fields = append(fields, appcontrol.FieldSigninVerifyEnable)
	}
	if m.FieldCleared(appcontrol.FieldInvitationCodeMust) {
		fields = append(fields, appcontrol.FieldInvitationCodeMust)
	}
	if m.FieldCleared(appcontrol.FieldCreateInvitationCodeWhen) {
		fields = append(fields, appcontrol.FieldCreateInvitationCodeWhen)
	}
	if m.FieldCleared(appcontrol.FieldMaxTypedCouponsPerOrder) {
		fields = append(fields, appcontrol.FieldMaxTypedCouponsPerOrder)
	}
	if m.FieldCleared(appcontrol.FieldMaintaining) {
		fields = append(fields, appcontrol.FieldMaintaining)
	}
	if m.FieldCleared(appcontrol.FieldCouponWithdrawEnable) {
		fields = append(fields, appcontrol.FieldCouponWithdrawEnable)
	}
	if m.FieldCleared(appcontrol.FieldCommitButtonTargets) {
		fields = append(fields, appcontrol.FieldCommitButtonTargets)
	}
	if m.FieldCleared(appcontrol.FieldResetUserMethod) {
		fields = append(fields, appcontrol.FieldResetUserMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppControlMutation) ClearField(name string) error {
	switch name {
	case appcontrol.FieldAppID:
		m.ClearAppID()
		return nil
	case appcontrol.FieldSignupMethods:
		m.ClearSignupMethods()
		return nil
	case appcontrol.FieldExternSigninMethods:
		m.ClearExternSigninMethods()
		return nil
	case appcontrol.FieldRecaptchaMethod:
		m.ClearRecaptchaMethod()
		return nil
	case appcontrol.FieldKycEnable:
		m.ClearKycEnable()
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		m.ClearSigninVerifyEnable()
		return nil
	case appcontrol.FieldInvitationCodeMust:
		m.ClearInvitationCodeMust()
		return nil
	case appcontrol.FieldCreateInvitationCodeWhen:
		m.ClearCreateInvitationCodeWhen()
		return nil
	case appcontrol.FieldMaxTypedCouponsPerOrder:
		m.ClearMaxTypedCouponsPerOrder()
		return nil
	case appcontrol.FieldMaintaining:
		m.ClearMaintaining()
		return nil
	case appcontrol.FieldCouponWithdrawEnable:
		m.ClearCouponWithdrawEnable()
		return nil
	case appcontrol.FieldCommitButtonTargets:
		m.ClearCommitButtonTargets()
		return nil
	case appcontrol.FieldResetUserMethod:
		m.ClearResetUserMethod()
		return nil
	}
	return fmt.Errorf("unknown AppControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppControlMutation) ResetField(name string) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcontrol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appcontrol.FieldEntID:
		m.ResetEntID()
		return nil
	case appcontrol.FieldAppID:
		m.ResetAppID()
		return nil
	case appcontrol.FieldSignupMethods:
		m.ResetSignupMethods()
		return nil
	case appcontrol.FieldExternSigninMethods:
		m.ResetExternSigninMethods()
		return nil
	case appcontrol.FieldRecaptchaMethod:
		m.ResetRecaptchaMethod()
		return nil
	case appcontrol.FieldKycEnable:
		m.ResetKycEnable()
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		m.ResetSigninVerifyEnable()
		return nil
	case appcontrol.FieldInvitationCodeMust:
		m.ResetInvitationCodeMust()
		return nil
	case appcontrol.FieldCreateInvitationCodeWhen:
		m.ResetCreateInvitationCodeWhen()
		return nil
	case appcontrol.FieldMaxTypedCouponsPerOrder:
		m.ResetMaxTypedCouponsPerOrder()
		return nil
	case appcontrol.FieldMaintaining:
		m.ResetMaintaining()
		return nil
	case appcontrol.FieldCouponWithdrawEnable:
		m.ResetCouponWithdrawEnable()
		return nil
	case appcontrol.FieldCommitButtonTargets:
		m.ResetCommitButtonTargets()
		return nil
	case appcontrol.FieldResetUserMethod:
		m.ResetResetUserMethod()
		return nil
	}
	return fmt.Errorf("unknown AppControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppControl edge %s", name)
}

// AppOAuthThirdPartyMutation represents an operation that mutates the AppOAuthThirdParty nodes in the graph.
type AppOAuthThirdPartyMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	ent_id         *uuid.UUID
	app_id         *uuid.UUID
	third_party_id *uuid.UUID
	client_id      *string
	client_secret  *string
	callback_url   *string
	salt           *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AppOAuthThirdParty, error)
	predicates     []predicate.AppOAuthThirdParty
}

var _ ent.Mutation = (*AppOAuthThirdPartyMutation)(nil)

// appoauththirdpartyOption allows management of the mutation configuration using functional options.
type appoauththirdpartyOption func(*AppOAuthThirdPartyMutation)

// newAppOAuthThirdPartyMutation creates new mutation for the AppOAuthThirdParty entity.
func newAppOAuthThirdPartyMutation(c config, op Op, opts ...appoauththirdpartyOption) *AppOAuthThirdPartyMutation {
	m := &AppOAuthThirdPartyMutation{
		config:        c,
		op:            op,
		typ:           TypeAppOAuthThirdParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppOAuthThirdPartyID sets the ID field of the mutation.
func withAppOAuthThirdPartyID(id uint32) appoauththirdpartyOption {
	return func(m *AppOAuthThirdPartyMutation) {
		var (
			err   error
			once  sync.Once
			value *AppOAuthThirdParty
		)
		m.oldValue = func(ctx context.Context) (*AppOAuthThirdParty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppOAuthThirdParty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppOAuthThirdParty sets the old AppOAuthThirdParty of the mutation.
func withAppOAuthThirdParty(node *AppOAuthThirdParty) appoauththirdpartyOption {
	return func(m *AppOAuthThirdPartyMutation) {
		m.oldValue = func(context.Context) (*AppOAuthThirdParty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppOAuthThirdPartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppOAuthThirdPartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppOAuthThirdParty entities.
func (m *AppOAuthThirdPartyMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppOAuthThirdPartyMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppOAuthThirdPartyMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppOAuthThirdParty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppOAuthThirdPartyMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppOAuthThirdPartyMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppOAuthThirdPartyMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppOAuthThirdPartyMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppOAuthThirdPartyMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppOAuthThirdPartyMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppOAuthThirdPartyMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppOAuthThirdPartyMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppOAuthThirdPartyMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppOAuthThirdPartyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppOAuthThirdPartyMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppOAuthThirdPartyMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppOAuthThirdPartyMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppOAuthThirdPartyMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppOAuthThirdPartyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppOAuthThirdPartyMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppOAuthThirdPartyMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppOAuthThirdPartyMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppOAuthThirdPartyMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppOAuthThirdPartyMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppOAuthThirdPartyMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appoauththirdparty.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appoauththirdparty.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppOAuthThirdPartyMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appoauththirdparty.FieldAppID)
}

// SetThirdPartyID sets the "third_party_id" field.
func (m *AppOAuthThirdPartyMutation) SetThirdPartyID(u uuid.UUID) {
	m.third_party_id = &u
}

// ThirdPartyID returns the value of the "third_party_id" field in the mutation.
func (m *AppOAuthThirdPartyMutation) ThirdPartyID() (r uuid.UUID, exists bool) {
	v := m.third_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyID returns the old "third_party_id" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldThirdPartyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyID: %w", err)
	}
	return oldValue.ThirdPartyID, nil
}

// ClearThirdPartyID clears the value of the "third_party_id" field.
func (m *AppOAuthThirdPartyMutation) ClearThirdPartyID() {
	m.third_party_id = nil
	m.clearedFields[appoauththirdparty.FieldThirdPartyID] = struct{}{}
}

// ThirdPartyIDCleared returns if the "third_party_id" field was cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) ThirdPartyIDCleared() bool {
	_, ok := m.clearedFields[appoauththirdparty.FieldThirdPartyID]
	return ok
}

// ResetThirdPartyID resets all changes to the "third_party_id" field.
func (m *AppOAuthThirdPartyMutation) ResetThirdPartyID() {
	m.third_party_id = nil
	delete(m.clearedFields, appoauththirdparty.FieldThirdPartyID)
}

// SetClientID sets the "client_id" field.
func (m *AppOAuthThirdPartyMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AppOAuthThirdPartyMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *AppOAuthThirdPartyMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[appoauththirdparty.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[appoauththirdparty.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AppOAuthThirdPartyMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, appoauththirdparty.FieldClientID)
}

// SetClientSecret sets the "client_secret" field.
func (m *AppOAuthThirdPartyMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *AppOAuthThirdPartyMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ClearClientSecret clears the value of the "client_secret" field.
func (m *AppOAuthThirdPartyMutation) ClearClientSecret() {
	m.client_secret = nil
	m.clearedFields[appoauththirdparty.FieldClientSecret] = struct{}{}
}

// ClientSecretCleared returns if the "client_secret" field was cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) ClientSecretCleared() bool {
	_, ok := m.clearedFields[appoauththirdparty.FieldClientSecret]
	return ok
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *AppOAuthThirdPartyMutation) ResetClientSecret() {
	m.client_secret = nil
	delete(m.clearedFields, appoauththirdparty.FieldClientSecret)
}

// SetCallbackURL sets the "callback_url" field.
func (m *AppOAuthThirdPartyMutation) SetCallbackURL(s string) {
	m.callback_url = &s
}

// CallbackURL returns the value of the "callback_url" field in the mutation.
func (m *AppOAuthThirdPartyMutation) CallbackURL() (r string, exists bool) {
	v := m.callback_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCallbackURL returns the old "callback_url" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldCallbackURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallbackURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallbackURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallbackURL: %w", err)
	}
	return oldValue.CallbackURL, nil
}

// ClearCallbackURL clears the value of the "callback_url" field.
func (m *AppOAuthThirdPartyMutation) ClearCallbackURL() {
	m.callback_url = nil
	m.clearedFields[appoauththirdparty.FieldCallbackURL] = struct{}{}
}

// CallbackURLCleared returns if the "callback_url" field was cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) CallbackURLCleared() bool {
	_, ok := m.clearedFields[appoauththirdparty.FieldCallbackURL]
	return ok
}

// ResetCallbackURL resets all changes to the "callback_url" field.
func (m *AppOAuthThirdPartyMutation) ResetCallbackURL() {
	m.callback_url = nil
	delete(m.clearedFields, appoauththirdparty.FieldCallbackURL)
}

// SetSalt sets the "salt" field.
func (m *AppOAuthThirdPartyMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *AppOAuthThirdPartyMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the AppOAuthThirdParty entity.
// If the AppOAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOAuthThirdPartyMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ClearSalt clears the value of the "salt" field.
func (m *AppOAuthThirdPartyMutation) ClearSalt() {
	m.salt = nil
	m.clearedFields[appoauththirdparty.FieldSalt] = struct{}{}
}

// SaltCleared returns if the "salt" field was cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) SaltCleared() bool {
	_, ok := m.clearedFields[appoauththirdparty.FieldSalt]
	return ok
}

// ResetSalt resets all changes to the "salt" field.
func (m *AppOAuthThirdPartyMutation) ResetSalt() {
	m.salt = nil
	delete(m.clearedFields, appoauththirdparty.FieldSalt)
}

// Where appends a list predicates to the AppOAuthThirdPartyMutation builder.
func (m *AppOAuthThirdPartyMutation) Where(ps ...predicate.AppOAuthThirdParty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppOAuthThirdPartyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppOAuthThirdPartyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppOAuthThirdParty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppOAuthThirdPartyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppOAuthThirdPartyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppOAuthThirdParty).
func (m *AppOAuthThirdPartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppOAuthThirdPartyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, appoauththirdparty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appoauththirdparty.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appoauththirdparty.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appoauththirdparty.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appoauththirdparty.FieldAppID)
	}
	if m.third_party_id != nil {
		fields = append(fields, appoauththirdparty.FieldThirdPartyID)
	}
	if m.client_id != nil {
		fields = append(fields, appoauththirdparty.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, appoauththirdparty.FieldClientSecret)
	}
	if m.callback_url != nil {
		fields = append(fields, appoauththirdparty.FieldCallbackURL)
	}
	if m.salt != nil {
		fields = append(fields, appoauththirdparty.FieldSalt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppOAuthThirdPartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appoauththirdparty.FieldCreatedAt:
		return m.CreatedAt()
	case appoauththirdparty.FieldUpdatedAt:
		return m.UpdatedAt()
	case appoauththirdparty.FieldDeletedAt:
		return m.DeletedAt()
	case appoauththirdparty.FieldEntID:
		return m.EntID()
	case appoauththirdparty.FieldAppID:
		return m.AppID()
	case appoauththirdparty.FieldThirdPartyID:
		return m.ThirdPartyID()
	case appoauththirdparty.FieldClientID:
		return m.ClientID()
	case appoauththirdparty.FieldClientSecret:
		return m.ClientSecret()
	case appoauththirdparty.FieldCallbackURL:
		return m.CallbackURL()
	case appoauththirdparty.FieldSalt:
		return m.Salt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppOAuthThirdPartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appoauththirdparty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appoauththirdparty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appoauththirdparty.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appoauththirdparty.FieldEntID:
		return m.OldEntID(ctx)
	case appoauththirdparty.FieldAppID:
		return m.OldAppID(ctx)
	case appoauththirdparty.FieldThirdPartyID:
		return m.OldThirdPartyID(ctx)
	case appoauththirdparty.FieldClientID:
		return m.OldClientID(ctx)
	case appoauththirdparty.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case appoauththirdparty.FieldCallbackURL:
		return m.OldCallbackURL(ctx)
	case appoauththirdparty.FieldSalt:
		return m.OldSalt(ctx)
	}
	return nil, fmt.Errorf("unknown AppOAuthThirdParty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppOAuthThirdPartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appoauththirdparty.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appoauththirdparty.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appoauththirdparty.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appoauththirdparty.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appoauththirdparty.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appoauththirdparty.FieldThirdPartyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyID(v)
		return nil
	case appoauththirdparty.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case appoauththirdparty.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case appoauththirdparty.FieldCallbackURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallbackURL(v)
		return nil
	case appoauththirdparty.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	}
	return fmt.Errorf("unknown AppOAuthThirdParty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppOAuthThirdPartyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appoauththirdparty.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appoauththirdparty.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appoauththirdparty.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppOAuthThirdPartyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appoauththirdparty.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appoauththirdparty.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appoauththirdparty.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppOAuthThirdPartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appoauththirdparty.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appoauththirdparty.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appoauththirdparty.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppOAuthThirdParty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppOAuthThirdPartyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appoauththirdparty.FieldAppID) {
		fields = append(fields, appoauththirdparty.FieldAppID)
	}
	if m.FieldCleared(appoauththirdparty.FieldThirdPartyID) {
		fields = append(fields, appoauththirdparty.FieldThirdPartyID)
	}
	if m.FieldCleared(appoauththirdparty.FieldClientID) {
		fields = append(fields, appoauththirdparty.FieldClientID)
	}
	if m.FieldCleared(appoauththirdparty.FieldClientSecret) {
		fields = append(fields, appoauththirdparty.FieldClientSecret)
	}
	if m.FieldCleared(appoauththirdparty.FieldCallbackURL) {
		fields = append(fields, appoauththirdparty.FieldCallbackURL)
	}
	if m.FieldCleared(appoauththirdparty.FieldSalt) {
		fields = append(fields, appoauththirdparty.FieldSalt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppOAuthThirdPartyMutation) ClearField(name string) error {
	switch name {
	case appoauththirdparty.FieldAppID:
		m.ClearAppID()
		return nil
	case appoauththirdparty.FieldThirdPartyID:
		m.ClearThirdPartyID()
		return nil
	case appoauththirdparty.FieldClientID:
		m.ClearClientID()
		return nil
	case appoauththirdparty.FieldClientSecret:
		m.ClearClientSecret()
		return nil
	case appoauththirdparty.FieldCallbackURL:
		m.ClearCallbackURL()
		return nil
	case appoauththirdparty.FieldSalt:
		m.ClearSalt()
		return nil
	}
	return fmt.Errorf("unknown AppOAuthThirdParty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppOAuthThirdPartyMutation) ResetField(name string) error {
	switch name {
	case appoauththirdparty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appoauththirdparty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appoauththirdparty.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appoauththirdparty.FieldEntID:
		m.ResetEntID()
		return nil
	case appoauththirdparty.FieldAppID:
		m.ResetAppID()
		return nil
	case appoauththirdparty.FieldThirdPartyID:
		m.ResetThirdPartyID()
		return nil
	case appoauththirdparty.FieldClientID:
		m.ResetClientID()
		return nil
	case appoauththirdparty.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case appoauththirdparty.FieldCallbackURL:
		m.ResetCallbackURL()
		return nil
	case appoauththirdparty.FieldSalt:
		m.ResetSalt()
		return nil
	}
	return fmt.Errorf("unknown AppOAuthThirdParty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppOAuthThirdPartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppOAuthThirdPartyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppOAuthThirdPartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppOAuthThirdPartyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppOAuthThirdPartyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppOAuthThirdPartyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppOAuthThirdParty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppOAuthThirdPartyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppOAuthThirdParty edge %s", name)
}

// AppRoleMutation represents an operation that mutates the AppRole nodes in the graph.
type AppRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	created_by    *uuid.UUID
	role          *string
	description   *string
	app_id        *uuid.UUID
	_default      *bool
	genesis       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppRole, error)
	predicates    []predicate.AppRole
}

var _ ent.Mutation = (*AppRoleMutation)(nil)

// approleOption allows management of the mutation configuration using functional options.
type approleOption func(*AppRoleMutation)

// newAppRoleMutation creates new mutation for the AppRole entity.
func newAppRoleMutation(c config, op Op, opts ...approleOption) *AppRoleMutation {
	m := &AppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleID sets the ID field of the mutation.
func withAppRoleID(id uint32) approleOption {
	return func(m *AppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRole
		)
		m.oldValue = func(ctx context.Context) (*AppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRole sets the old AppRole of the mutation.
func withAppRole(node *AppRole) approleOption {
	return func(m *AppRoleMutation) {
		m.oldValue = func(context.Context) (*AppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRole entities.
func (m *AppRoleMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppRoleMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppRoleMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppRoleMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppRoleMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppRoleMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppRoleMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppRoleMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppRoleMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppRoleMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppRoleMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppRoleMutation) ResetEntID() {
	m.ent_id = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AppRoleMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppRoleMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AppRoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[approle.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AppRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[approle.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, approle.FieldCreatedBy)
}

// SetRole sets the "role" field.
func (m *AppRoleMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *AppRoleMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *AppRoleMutation) ClearRole() {
	m.role = nil
	m.clearedFields[approle.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *AppRoleMutation) RoleCleared() bool {
	_, ok := m.clearedFields[approle.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *AppRoleMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, approle.FieldRole)
}

// SetDescription sets the "description" field.
func (m *AppRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppRoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[approle.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppRoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[approle.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppRoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, approle.FieldDescription)
}

// SetAppID sets the "app_id" field.
func (m *AppRoleMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppRoleMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[approle.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppRoleMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[approle.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, approle.FieldAppID)
}

// SetDefault sets the "default" field.
func (m *AppRoleMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *AppRoleMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ClearDefault clears the value of the "default" field.
func (m *AppRoleMutation) ClearDefault() {
	m._default = nil
	m.clearedFields[approle.FieldDefault] = struct{}{}
}

// DefaultCleared returns if the "default" field was cleared in this mutation.
func (m *AppRoleMutation) DefaultCleared() bool {
	_, ok := m.clearedFields[approle.FieldDefault]
	return ok
}

// ResetDefault resets all changes to the "default" field.
func (m *AppRoleMutation) ResetDefault() {
	m._default = nil
	delete(m.clearedFields, approle.FieldDefault)
}

// SetGenesis sets the "genesis" field.
func (m *AppRoleMutation) SetGenesis(b bool) {
	m.genesis = &b
}

// Genesis returns the value of the "genesis" field in the mutation.
func (m *AppRoleMutation) Genesis() (r bool, exists bool) {
	v := m.genesis
	if v == nil {
		return
	}
	return *v, true
}

// OldGenesis returns the old "genesis" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldGenesis(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenesis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenesis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenesis: %w", err)
	}
	return oldValue.Genesis, nil
}

// ClearGenesis clears the value of the "genesis" field.
func (m *AppRoleMutation) ClearGenesis() {
	m.genesis = nil
	m.clearedFields[approle.FieldGenesis] = struct{}{}
}

// GenesisCleared returns if the "genesis" field was cleared in this mutation.
func (m *AppRoleMutation) GenesisCleared() bool {
	_, ok := m.clearedFields[approle.FieldGenesis]
	return ok
}

// ResetGenesis resets all changes to the "genesis" field.
func (m *AppRoleMutation) ResetGenesis() {
	m.genesis = nil
	delete(m.clearedFields, approle.FieldGenesis)
}

// Where appends a list predicates to the AppRoleMutation builder.
func (m *AppRoleMutation) Where(ps ...predicate.AppRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRole).
func (m *AppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, approle.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, approle.FieldEntID)
	}
	if m.created_by != nil {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.role != nil {
		fields = append(fields, approle.FieldRole)
	}
	if m.description != nil {
		fields = append(fields, approle.FieldDescription)
	}
	if m.app_id != nil {
		fields = append(fields, approle.FieldAppID)
	}
	if m._default != nil {
		fields = append(fields, approle.FieldDefault)
	}
	if m.genesis != nil {
		fields = append(fields, approle.FieldGenesis)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedAt:
		return m.CreatedAt()
	case approle.FieldUpdatedAt:
		return m.UpdatedAt()
	case approle.FieldDeletedAt:
		return m.DeletedAt()
	case approle.FieldEntID:
		return m.EntID()
	case approle.FieldCreatedBy:
		return m.CreatedBy()
	case approle.FieldRole:
		return m.Role()
	case approle.FieldDescription:
		return m.Description()
	case approle.FieldAppID:
		return m.AppID()
	case approle.FieldDefault:
		return m.Default()
	case approle.FieldGenesis:
		return m.Genesis()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approle.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case approle.FieldEntID:
		return m.OldEntID(ctx)
	case approle.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case approle.FieldRole:
		return m.OldRole(ctx)
	case approle.FieldDescription:
		return m.OldDescription(ctx)
	case approle.FieldAppID:
		return m.OldAppID(ctx)
	case approle.FieldDefault:
		return m.OldDefault(ctx)
	case approle.FieldGenesis:
		return m.OldGenesis(ctx)
	}
	return nil, fmt.Errorf("unknown AppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approle.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case approle.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case approle.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case approle.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case approle.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case approle.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approle.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case approle.FieldGenesis:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenesis(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, approle.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedAt:
		return m.AddedCreatedAt()
	case approle.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case approle.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case approle.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approle.FieldCreatedBy) {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.FieldCleared(approle.FieldRole) {
		fields = append(fields, approle.FieldRole)
	}
	if m.FieldCleared(approle.FieldDescription) {
		fields = append(fields, approle.FieldDescription)
	}
	if m.FieldCleared(approle.FieldAppID) {
		fields = append(fields, approle.FieldAppID)
	}
	if m.FieldCleared(approle.FieldDefault) {
		fields = append(fields, approle.FieldDefault)
	}
	if m.FieldCleared(approle.FieldGenesis) {
		fields = append(fields, approle.FieldGenesis)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleMutation) ClearField(name string) error {
	switch name {
	case approle.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case approle.FieldRole:
		m.ClearRole()
		return nil
	case approle.FieldDescription:
		m.ClearDescription()
		return nil
	case approle.FieldAppID:
		m.ClearAppID()
		return nil
	case approle.FieldDefault:
		m.ClearDefault()
		return nil
	case approle.FieldGenesis:
		m.ClearGenesis()
		return nil
	}
	return fmt.Errorf("unknown AppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleMutation) ResetField(name string) error {
	switch name {
	case approle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approle.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case approle.FieldEntID:
		m.ResetEntID()
		return nil
	case approle.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case approle.FieldRole:
		m.ResetRole()
		return nil
	case approle.FieldDescription:
		m.ResetDescription()
		return nil
	case approle.FieldAppID:
		m.ResetAppID()
		return nil
	case approle.FieldDefault:
		m.ResetDefault()
		return nil
	case approle.FieldGenesis:
		m.ResetGenesis()
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppRole edge %s", name)
}

// AppRoleUserMutation represents an operation that mutates the AppRoleUser nodes in the graph.
type AppRoleUserMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	role_id       *uuid.UUID
	user_id       *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppRoleUser, error)
	predicates    []predicate.AppRoleUser
}

var _ ent.Mutation = (*AppRoleUserMutation)(nil)

// approleuserOption allows management of the mutation configuration using functional options.
type approleuserOption func(*AppRoleUserMutation)

// newAppRoleUserMutation creates new mutation for the AppRoleUser entity.
func newAppRoleUserMutation(c config, op Op, opts ...approleuserOption) *AppRoleUserMutation {
	m := &AppRoleUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRoleUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleUserID sets the ID field of the mutation.
func withAppRoleUserID(id uint32) approleuserOption {
	return func(m *AppRoleUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRoleUser
		)
		m.oldValue = func(ctx context.Context) (*AppRoleUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRoleUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRoleUser sets the old AppRoleUser of the mutation.
func withAppRoleUser(node *AppRoleUser) approleuserOption {
	return func(m *AppRoleUserMutation) {
		m.oldValue = func(context.Context) (*AppRoleUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRoleUser entities.
func (m *AppRoleUserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleUserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleUserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRoleUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppRoleUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppRoleUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppRoleUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppRoleUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppRoleUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppRoleUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppRoleUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppRoleUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppRoleUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppRoleUserMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppRoleUserMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppRoleUserMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppRoleUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppRoleUserMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[approleuser.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppRoleUserMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[approleuser.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleUserMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, approleuser.FieldAppID)
}

// SetRoleID sets the "role_id" field.
func (m *AppRoleUserMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AppRoleUserMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *AppRoleUserMutation) ClearRoleID() {
	m.role_id = nil
	m.clearedFields[approleuser.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *AppRoleUserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[approleuser.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AppRoleUserMutation) ResetRoleID() {
	m.role_id = nil
	delete(m.clearedFields, approleuser.FieldRoleID)
}

// SetUserID sets the "user_id" field.
func (m *AppRoleUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppRoleUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AppRoleUserMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[approleuser.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AppRoleUserMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[approleuser.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppRoleUserMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, approleuser.FieldUserID)
}

// Where appends a list predicates to the AppRoleUserMutation builder.
func (m *AppRoleUserMutation) Where(ps ...predicate.AppRoleUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRoleUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRoleUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRoleUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRoleUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRoleUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRoleUser).
func (m *AppRoleUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, approleuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approleuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, approleuser.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, approleuser.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, approleuser.FieldAppID)
	}
	if m.role_id != nil {
		fields = append(fields, approleuser.FieldRoleID)
	}
	if m.user_id != nil {
		fields = append(fields, approleuser.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.CreatedAt()
	case approleuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case approleuser.FieldDeletedAt:
		return m.DeletedAt()
	case approleuser.FieldEntID:
		return m.EntID()
	case approleuser.FieldAppID:
		return m.AppID()
	case approleuser.FieldRoleID:
		return m.RoleID()
	case approleuser.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approleuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approleuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case approleuser.FieldEntID:
		return m.OldEntID(ctx)
	case approleuser.FieldAppID:
		return m.OldAppID(ctx)
	case approleuser.FieldRoleID:
		return m.OldRoleID(ctx)
	case approleuser.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown AppRoleUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approleuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approleuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approleuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case approleuser.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case approleuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approleuser.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case approleuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, approleuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, approleuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, approleuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case approleuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case approleuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approleuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case approleuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case approleuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approleuser.FieldAppID) {
		fields = append(fields, approleuser.FieldAppID)
	}
	if m.FieldCleared(approleuser.FieldRoleID) {
		fields = append(fields, approleuser.FieldRoleID)
	}
	if m.FieldCleared(approleuser.FieldUserID) {
		fields = append(fields, approleuser.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleUserMutation) ClearField(name string) error {
	switch name {
	case approleuser.FieldAppID:
		m.ClearAppID()
		return nil
	case approleuser.FieldRoleID:
		m.ClearRoleID()
		return nil
	case approleuser.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleUserMutation) ResetField(name string) error {
	switch name {
	case approleuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approleuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approleuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case approleuser.FieldEntID:
		m.ResetEntID()
		return nil
	case approleuser.FieldAppID:
		m.ResetAppID()
		return nil
	case approleuser.FieldRoleID:
		m.ResetRoleID()
		return nil
	case approleuser.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppRoleUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppRoleUser edge %s", name)
}

// AppSubscribeMutation represents an operation that mutates the AppSubscribe nodes in the graph.
type AppSubscribeMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	ent_id           *uuid.UUID
	app_id           *uuid.UUID
	subscribe_app_id *uuid.UUID
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AppSubscribe, error)
	predicates       []predicate.AppSubscribe
}

var _ ent.Mutation = (*AppSubscribeMutation)(nil)

// appsubscribeOption allows management of the mutation configuration using functional options.
type appsubscribeOption func(*AppSubscribeMutation)

// newAppSubscribeMutation creates new mutation for the AppSubscribe entity.
func newAppSubscribeMutation(c config, op Op, opts ...appsubscribeOption) *AppSubscribeMutation {
	m := &AppSubscribeMutation{
		config:        c,
		op:            op,
		typ:           TypeAppSubscribe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppSubscribeID sets the ID field of the mutation.
func withAppSubscribeID(id uint32) appsubscribeOption {
	return func(m *AppSubscribeMutation) {
		var (
			err   error
			once  sync.Once
			value *AppSubscribe
		)
		m.oldValue = func(ctx context.Context) (*AppSubscribe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppSubscribe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppSubscribe sets the old AppSubscribe of the mutation.
func withAppSubscribe(node *AppSubscribe) appsubscribeOption {
	return func(m *AppSubscribeMutation) {
		m.oldValue = func(context.Context) (*AppSubscribe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppSubscribeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppSubscribeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppSubscribe entities.
func (m *AppSubscribeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppSubscribeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppSubscribeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppSubscribe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppSubscribeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppSubscribeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppSubscribe entity.
// If the AppSubscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscribeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppSubscribeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppSubscribeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppSubscribeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppSubscribeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppSubscribeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppSubscribe entity.
// If the AppSubscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscribeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppSubscribeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppSubscribeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppSubscribeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppSubscribeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppSubscribeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppSubscribe entity.
// If the AppSubscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscribeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppSubscribeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppSubscribeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppSubscribeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppSubscribeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppSubscribeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppSubscribe entity.
// If the AppSubscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscribeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppSubscribeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppSubscribeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppSubscribeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppSubscribe entity.
// If the AppSubscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscribeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppSubscribeMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appsubscribe.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppSubscribeMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appsubscribe.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppSubscribeMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appsubscribe.FieldAppID)
}

// SetSubscribeAppID sets the "subscribe_app_id" field.
func (m *AppSubscribeMutation) SetSubscribeAppID(u uuid.UUID) {
	m.subscribe_app_id = &u
}

// SubscribeAppID returns the value of the "subscribe_app_id" field in the mutation.
func (m *AppSubscribeMutation) SubscribeAppID() (r uuid.UUID, exists bool) {
	v := m.subscribe_app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeAppID returns the old "subscribe_app_id" field's value of the AppSubscribe entity.
// If the AppSubscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSubscribeMutation) OldSubscribeAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeAppID: %w", err)
	}
	return oldValue.SubscribeAppID, nil
}

// ClearSubscribeAppID clears the value of the "subscribe_app_id" field.
func (m *AppSubscribeMutation) ClearSubscribeAppID() {
	m.subscribe_app_id = nil
	m.clearedFields[appsubscribe.FieldSubscribeAppID] = struct{}{}
}

// SubscribeAppIDCleared returns if the "subscribe_app_id" field was cleared in this mutation.
func (m *AppSubscribeMutation) SubscribeAppIDCleared() bool {
	_, ok := m.clearedFields[appsubscribe.FieldSubscribeAppID]
	return ok
}

// ResetSubscribeAppID resets all changes to the "subscribe_app_id" field.
func (m *AppSubscribeMutation) ResetSubscribeAppID() {
	m.subscribe_app_id = nil
	delete(m.clearedFields, appsubscribe.FieldSubscribeAppID)
}

// Where appends a list predicates to the AppSubscribeMutation builder.
func (m *AppSubscribeMutation) Where(ps ...predicate.AppSubscribe) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppSubscribeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppSubscribeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppSubscribe, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppSubscribeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppSubscribeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppSubscribe).
func (m *AppSubscribeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppSubscribeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, appsubscribe.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appsubscribe.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appsubscribe.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appsubscribe.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appsubscribe.FieldAppID)
	}
	if m.subscribe_app_id != nil {
		fields = append(fields, appsubscribe.FieldSubscribeAppID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppSubscribeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appsubscribe.FieldCreatedAt:
		return m.CreatedAt()
	case appsubscribe.FieldUpdatedAt:
		return m.UpdatedAt()
	case appsubscribe.FieldDeletedAt:
		return m.DeletedAt()
	case appsubscribe.FieldEntID:
		return m.EntID()
	case appsubscribe.FieldAppID:
		return m.AppID()
	case appsubscribe.FieldSubscribeAppID:
		return m.SubscribeAppID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppSubscribeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appsubscribe.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appsubscribe.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appsubscribe.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appsubscribe.FieldEntID:
		return m.OldEntID(ctx)
	case appsubscribe.FieldAppID:
		return m.OldAppID(ctx)
	case appsubscribe.FieldSubscribeAppID:
		return m.OldSubscribeAppID(ctx)
	}
	return nil, fmt.Errorf("unknown AppSubscribe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSubscribeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appsubscribe.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appsubscribe.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appsubscribe.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appsubscribe.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appsubscribe.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appsubscribe.FieldSubscribeAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeAppID(v)
		return nil
	}
	return fmt.Errorf("unknown AppSubscribe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppSubscribeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appsubscribe.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appsubscribe.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appsubscribe.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppSubscribeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appsubscribe.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appsubscribe.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appsubscribe.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSubscribeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appsubscribe.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appsubscribe.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appsubscribe.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppSubscribe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppSubscribeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appsubscribe.FieldAppID) {
		fields = append(fields, appsubscribe.FieldAppID)
	}
	if m.FieldCleared(appsubscribe.FieldSubscribeAppID) {
		fields = append(fields, appsubscribe.FieldSubscribeAppID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppSubscribeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppSubscribeMutation) ClearField(name string) error {
	switch name {
	case appsubscribe.FieldAppID:
		m.ClearAppID()
		return nil
	case appsubscribe.FieldSubscribeAppID:
		m.ClearSubscribeAppID()
		return nil
	}
	return fmt.Errorf("unknown AppSubscribe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppSubscribeMutation) ResetField(name string) error {
	switch name {
	case appsubscribe.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appsubscribe.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appsubscribe.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appsubscribe.FieldEntID:
		m.ResetEntID()
		return nil
	case appsubscribe.FieldAppID:
		m.ResetAppID()
		return nil
	case appsubscribe.FieldSubscribeAppID:
		m.ResetSubscribeAppID()
		return nil
	}
	return fmt.Errorf("unknown AppSubscribe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppSubscribeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppSubscribeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppSubscribeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppSubscribeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppSubscribeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppSubscribeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppSubscribeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppSubscribe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppSubscribeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppSubscribe edge %s", name)
}

// AppUserMutation represents an operation that mutates the AppUser nodes in the graph.
type AppUserMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	ent_id          *uuid.UUID
	app_id          *uuid.UUID
	email_address   *string
	phone_no        *string
	import_from_app *uuid.UUID
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AppUser, error)
	predicates      []predicate.AppUser
}

var _ ent.Mutation = (*AppUserMutation)(nil)

// appuserOption allows management of the mutation configuration using functional options.
type appuserOption func(*AppUserMutation)

// newAppUserMutation creates new mutation for the AppUser entity.
func newAppUserMutation(c config, op Op, opts ...appuserOption) *AppUserMutation {
	m := &AppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserID sets the ID field of the mutation.
func withAppUserID(id uint32) appuserOption {
	return func(m *AppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUser
		)
		m.oldValue = func(ctx context.Context) (*AppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUser sets the old AppUser of the mutation.
func withAppUser(node *AppUser) appuserOption {
	return func(m *AppUserMutation) {
		m.oldValue = func(context.Context) (*AppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUser entities.
func (m *AppUserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppUserMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppUserMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppUserMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppUserMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appuser.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppUserMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appuser.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appuser.FieldAppID)
}

// SetEmailAddress sets the "email_address" field.
func (m *AppUserMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *AppUserMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ClearEmailAddress clears the value of the "email_address" field.
func (m *AppUserMutation) ClearEmailAddress() {
	m.email_address = nil
	m.clearedFields[appuser.FieldEmailAddress] = struct{}{}
}

// EmailAddressCleared returns if the "email_address" field was cleared in this mutation.
func (m *AppUserMutation) EmailAddressCleared() bool {
	_, ok := m.clearedFields[appuser.FieldEmailAddress]
	return ok
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *AppUserMutation) ResetEmailAddress() {
	m.email_address = nil
	delete(m.clearedFields, appuser.FieldEmailAddress)
}

// SetPhoneNo sets the "phone_no" field.
func (m *AppUserMutation) SetPhoneNo(s string) {
	m.phone_no = &s
}

// PhoneNo returns the value of the "phone_no" field in the mutation.
func (m *AppUserMutation) PhoneNo() (r string, exists bool) {
	v := m.phone_no
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNo returns the old "phone_no" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldPhoneNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNo: %w", err)
	}
	return oldValue.PhoneNo, nil
}

// ClearPhoneNo clears the value of the "phone_no" field.
func (m *AppUserMutation) ClearPhoneNo() {
	m.phone_no = nil
	m.clearedFields[appuser.FieldPhoneNo] = struct{}{}
}

// PhoneNoCleared returns if the "phone_no" field was cleared in this mutation.
func (m *AppUserMutation) PhoneNoCleared() bool {
	_, ok := m.clearedFields[appuser.FieldPhoneNo]
	return ok
}

// ResetPhoneNo resets all changes to the "phone_no" field.
func (m *AppUserMutation) ResetPhoneNo() {
	m.phone_no = nil
	delete(m.clearedFields, appuser.FieldPhoneNo)
}

// SetImportFromApp sets the "import_from_app" field.
func (m *AppUserMutation) SetImportFromApp(u uuid.UUID) {
	m.import_from_app = &u
}

// ImportFromApp returns the value of the "import_from_app" field in the mutation.
func (m *AppUserMutation) ImportFromApp() (r uuid.UUID, exists bool) {
	v := m.import_from_app
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFromApp returns the old "import_from_app" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldImportFromApp(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFromApp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFromApp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFromApp: %w", err)
	}
	return oldValue.ImportFromApp, nil
}

// ClearImportFromApp clears the value of the "import_from_app" field.
func (m *AppUserMutation) ClearImportFromApp() {
	m.import_from_app = nil
	m.clearedFields[appuser.FieldImportFromApp] = struct{}{}
}

// ImportFromAppCleared returns if the "import_from_app" field was cleared in this mutation.
func (m *AppUserMutation) ImportFromAppCleared() bool {
	_, ok := m.clearedFields[appuser.FieldImportFromApp]
	return ok
}

// ResetImportFromApp resets all changes to the "import_from_app" field.
func (m *AppUserMutation) ResetImportFromApp() {
	m.import_from_app = nil
	delete(m.clearedFields, appuser.FieldImportFromApp)
}

// Where appends a list predicates to the AppUserMutation builder.
func (m *AppUserMutation) Where(ps ...predicate.AppUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppUser).
func (m *AppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, appuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuser.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appuser.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appuser.FieldAppID)
	}
	if m.email_address != nil {
		fields = append(fields, appuser.FieldEmailAddress)
	}
	if m.phone_no != nil {
		fields = append(fields, appuser.FieldPhoneNo)
	}
	if m.import_from_app != nil {
		fields = append(fields, appuser.FieldImportFromApp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.CreatedAt()
	case appuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuser.FieldDeletedAt:
		return m.DeletedAt()
	case appuser.FieldEntID:
		return m.EntID()
	case appuser.FieldAppID:
		return m.AppID()
	case appuser.FieldEmailAddress:
		return m.EmailAddress()
	case appuser.FieldPhoneNo:
		return m.PhoneNo()
	case appuser.FieldImportFromApp:
		return m.ImportFromApp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuser.FieldEntID:
		return m.OldEntID(ctx)
	case appuser.FieldAppID:
		return m.OldAppID(ctx)
	case appuser.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case appuser.FieldPhoneNo:
		return m.OldPhoneNo(ctx)
	case appuser.FieldImportFromApp:
		return m.OldImportFromApp(ctx)
	}
	return nil, fmt.Errorf("unknown AppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuser.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuser.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case appuser.FieldPhoneNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNo(v)
		return nil
	case appuser.FieldImportFromApp:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFromApp(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appuser.FieldAppID) {
		fields = append(fields, appuser.FieldAppID)
	}
	if m.FieldCleared(appuser.FieldEmailAddress) {
		fields = append(fields, appuser.FieldEmailAddress)
	}
	if m.FieldCleared(appuser.FieldPhoneNo) {
		fields = append(fields, appuser.FieldPhoneNo)
	}
	if m.FieldCleared(appuser.FieldImportFromApp) {
		fields = append(fields, appuser.FieldImportFromApp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserMutation) ClearField(name string) error {
	switch name {
	case appuser.FieldAppID:
		m.ClearAppID()
		return nil
	case appuser.FieldEmailAddress:
		m.ClearEmailAddress()
		return nil
	case appuser.FieldPhoneNo:
		m.ClearPhoneNo()
		return nil
	case appuser.FieldImportFromApp:
		m.ClearImportFromApp()
		return nil
	}
	return fmt.Errorf("unknown AppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserMutation) ResetField(name string) error {
	switch name {
	case appuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuser.FieldEntID:
		m.ResetEntID()
		return nil
	case appuser.FieldAppID:
		m.ResetAppID()
		return nil
	case appuser.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case appuser.FieldPhoneNo:
		m.ResetPhoneNo()
		return nil
	case appuser.FieldImportFromApp:
		m.ResetImportFromApp()
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUser edge %s", name)
}

// AppUserControlMutation represents an operation that mutates the AppUserControl nodes in the graph.
type AppUserControlMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *uint32
	created_at                             *uint32
	addcreated_at                          *int32
	updated_at                             *uint32
	addupdated_at                          *int32
	deleted_at                             *uint32
	adddeleted_at                          *int32
	ent_id                                 *uuid.UUID
	app_id                                 *uuid.UUID
	user_id                                *uuid.UUID
	signin_verify_by_google_authentication *bool
	google_authentication_verified         *bool
	signin_verify_type                     *string
	kol                                    *bool
	kol_confirmed                          *bool
	selected_lang_id                       *uuid.UUID
	clearedFields                          map[string]struct{}
	done                                   bool
	oldValue                               func(context.Context) (*AppUserControl, error)
	predicates                             []predicate.AppUserControl
}

var _ ent.Mutation = (*AppUserControlMutation)(nil)

// appusercontrolOption allows management of the mutation configuration using functional options.
type appusercontrolOption func(*AppUserControlMutation)

// newAppUserControlMutation creates new mutation for the AppUserControl entity.
func newAppUserControlMutation(c config, op Op, opts ...appusercontrolOption) *AppUserControlMutation {
	m := &AppUserControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserControlID sets the ID field of the mutation.
func withAppUserControlID(id uint32) appusercontrolOption {
	return func(m *AppUserControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserControl
		)
		m.oldValue = func(ctx context.Context) (*AppUserControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserControl sets the old AppUserControl of the mutation.
func withAppUserControl(node *AppUserControl) appusercontrolOption {
	return func(m *AppUserControlMutation) {
		m.oldValue = func(context.Context) (*AppUserControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserControl entities.
func (m *AppUserControlMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserControlMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserControlMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserControlMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserControlMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserControlMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserControlMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserControlMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserControlMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserControlMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserControlMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserControlMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserControlMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserControlMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserControlMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserControlMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserControlMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppUserControlMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppUserControlMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppUserControlMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserControlMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserControlMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppUserControlMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appusercontrol.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppUserControlMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserControlMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appusercontrol.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AppUserControlMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserControlMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AppUserControlMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[appusercontrol.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AppUserControlMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserControlMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, appusercontrol.FieldUserID)
}

// SetSigninVerifyByGoogleAuthentication sets the "signin_verify_by_google_authentication" field.
func (m *AppUserControlMutation) SetSigninVerifyByGoogleAuthentication(b bool) {
	m.signin_verify_by_google_authentication = &b
}

// SigninVerifyByGoogleAuthentication returns the value of the "signin_verify_by_google_authentication" field in the mutation.
func (m *AppUserControlMutation) SigninVerifyByGoogleAuthentication() (r bool, exists bool) {
	v := m.signin_verify_by_google_authentication
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyByGoogleAuthentication returns the old "signin_verify_by_google_authentication" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldSigninVerifyByGoogleAuthentication(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyByGoogleAuthentication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyByGoogleAuthentication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyByGoogleAuthentication: %w", err)
	}
	return oldValue.SigninVerifyByGoogleAuthentication, nil
}

// ClearSigninVerifyByGoogleAuthentication clears the value of the "signin_verify_by_google_authentication" field.
func (m *AppUserControlMutation) ClearSigninVerifyByGoogleAuthentication() {
	m.signin_verify_by_google_authentication = nil
	m.clearedFields[appusercontrol.FieldSigninVerifyByGoogleAuthentication] = struct{}{}
}

// SigninVerifyByGoogleAuthenticationCleared returns if the "signin_verify_by_google_authentication" field was cleared in this mutation.
func (m *AppUserControlMutation) SigninVerifyByGoogleAuthenticationCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldSigninVerifyByGoogleAuthentication]
	return ok
}

// ResetSigninVerifyByGoogleAuthentication resets all changes to the "signin_verify_by_google_authentication" field.
func (m *AppUserControlMutation) ResetSigninVerifyByGoogleAuthentication() {
	m.signin_verify_by_google_authentication = nil
	delete(m.clearedFields, appusercontrol.FieldSigninVerifyByGoogleAuthentication)
}

// SetGoogleAuthenticationVerified sets the "google_authentication_verified" field.
func (m *AppUserControlMutation) SetGoogleAuthenticationVerified(b bool) {
	m.google_authentication_verified = &b
}

// GoogleAuthenticationVerified returns the value of the "google_authentication_verified" field in the mutation.
func (m *AppUserControlMutation) GoogleAuthenticationVerified() (r bool, exists bool) {
	v := m.google_authentication_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleAuthenticationVerified returns the old "google_authentication_verified" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldGoogleAuthenticationVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleAuthenticationVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleAuthenticationVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleAuthenticationVerified: %w", err)
	}
	return oldValue.GoogleAuthenticationVerified, nil
}

// ClearGoogleAuthenticationVerified clears the value of the "google_authentication_verified" field.
func (m *AppUserControlMutation) ClearGoogleAuthenticationVerified() {
	m.google_authentication_verified = nil
	m.clearedFields[appusercontrol.FieldGoogleAuthenticationVerified] = struct{}{}
}

// GoogleAuthenticationVerifiedCleared returns if the "google_authentication_verified" field was cleared in this mutation.
func (m *AppUserControlMutation) GoogleAuthenticationVerifiedCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldGoogleAuthenticationVerified]
	return ok
}

// ResetGoogleAuthenticationVerified resets all changes to the "google_authentication_verified" field.
func (m *AppUserControlMutation) ResetGoogleAuthenticationVerified() {
	m.google_authentication_verified = nil
	delete(m.clearedFields, appusercontrol.FieldGoogleAuthenticationVerified)
}

// SetSigninVerifyType sets the "signin_verify_type" field.
func (m *AppUserControlMutation) SetSigninVerifyType(s string) {
	m.signin_verify_type = &s
}

// SigninVerifyType returns the value of the "signin_verify_type" field in the mutation.
func (m *AppUserControlMutation) SigninVerifyType() (r string, exists bool) {
	v := m.signin_verify_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyType returns the old "signin_verify_type" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldSigninVerifyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyType: %w", err)
	}
	return oldValue.SigninVerifyType, nil
}

// ClearSigninVerifyType clears the value of the "signin_verify_type" field.
func (m *AppUserControlMutation) ClearSigninVerifyType() {
	m.signin_verify_type = nil
	m.clearedFields[appusercontrol.FieldSigninVerifyType] = struct{}{}
}

// SigninVerifyTypeCleared returns if the "signin_verify_type" field was cleared in this mutation.
func (m *AppUserControlMutation) SigninVerifyTypeCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldSigninVerifyType]
	return ok
}

// ResetSigninVerifyType resets all changes to the "signin_verify_type" field.
func (m *AppUserControlMutation) ResetSigninVerifyType() {
	m.signin_verify_type = nil
	delete(m.clearedFields, appusercontrol.FieldSigninVerifyType)
}

// SetKol sets the "kol" field.
func (m *AppUserControlMutation) SetKol(b bool) {
	m.kol = &b
}

// Kol returns the value of the "kol" field in the mutation.
func (m *AppUserControlMutation) Kol() (r bool, exists bool) {
	v := m.kol
	if v == nil {
		return
	}
	return *v, true
}

// OldKol returns the old "kol" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldKol(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKol: %w", err)
	}
	return oldValue.Kol, nil
}

// ResetKol resets all changes to the "kol" field.
func (m *AppUserControlMutation) ResetKol() {
	m.kol = nil
}

// SetKolConfirmed sets the "kol_confirmed" field.
func (m *AppUserControlMutation) SetKolConfirmed(b bool) {
	m.kol_confirmed = &b
}

// KolConfirmed returns the value of the "kol_confirmed" field in the mutation.
func (m *AppUserControlMutation) KolConfirmed() (r bool, exists bool) {
	v := m.kol_confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldKolConfirmed returns the old "kol_confirmed" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldKolConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKolConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKolConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKolConfirmed: %w", err)
	}
	return oldValue.KolConfirmed, nil
}

// ResetKolConfirmed resets all changes to the "kol_confirmed" field.
func (m *AppUserControlMutation) ResetKolConfirmed() {
	m.kol_confirmed = nil
}

// SetSelectedLangID sets the "selected_lang_id" field.
func (m *AppUserControlMutation) SetSelectedLangID(u uuid.UUID) {
	m.selected_lang_id = &u
}

// SelectedLangID returns the value of the "selected_lang_id" field in the mutation.
func (m *AppUserControlMutation) SelectedLangID() (r uuid.UUID, exists bool) {
	v := m.selected_lang_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedLangID returns the old "selected_lang_id" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldSelectedLangID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectedLangID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectedLangID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedLangID: %w", err)
	}
	return oldValue.SelectedLangID, nil
}

// ClearSelectedLangID clears the value of the "selected_lang_id" field.
func (m *AppUserControlMutation) ClearSelectedLangID() {
	m.selected_lang_id = nil
	m.clearedFields[appusercontrol.FieldSelectedLangID] = struct{}{}
}

// SelectedLangIDCleared returns if the "selected_lang_id" field was cleared in this mutation.
func (m *AppUserControlMutation) SelectedLangIDCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldSelectedLangID]
	return ok
}

// ResetSelectedLangID resets all changes to the "selected_lang_id" field.
func (m *AppUserControlMutation) ResetSelectedLangID() {
	m.selected_lang_id = nil
	delete(m.clearedFields, appusercontrol.FieldSelectedLangID)
}

// Where appends a list predicates to the AppUserControlMutation builder.
func (m *AppUserControlMutation) Where(ps ...predicate.AppUserControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppUserControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppUserControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppUserControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppUserControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppUserControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppUserControl).
func (m *AppUserControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserControlMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, appusercontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appusercontrol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appusercontrol.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appusercontrol.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appusercontrol.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appusercontrol.FieldUserID)
	}
	if m.signin_verify_by_google_authentication != nil {
		fields = append(fields, appusercontrol.FieldSigninVerifyByGoogleAuthentication)
	}
	if m.google_authentication_verified != nil {
		fields = append(fields, appusercontrol.FieldGoogleAuthenticationVerified)
	}
	if m.signin_verify_type != nil {
		fields = append(fields, appusercontrol.FieldSigninVerifyType)
	}
	if m.kol != nil {
		fields = append(fields, appusercontrol.FieldKol)
	}
	if m.kol_confirmed != nil {
		fields = append(fields, appusercontrol.FieldKolConfirmed)
	}
	if m.selected_lang_id != nil {
		fields = append(fields, appusercontrol.FieldSelectedLangID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.CreatedAt()
	case appusercontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case appusercontrol.FieldDeletedAt:
		return m.DeletedAt()
	case appusercontrol.FieldEntID:
		return m.EntID()
	case appusercontrol.FieldAppID:
		return m.AppID()
	case appusercontrol.FieldUserID:
		return m.UserID()
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		return m.SigninVerifyByGoogleAuthentication()
	case appusercontrol.FieldGoogleAuthenticationVerified:
		return m.GoogleAuthenticationVerified()
	case appusercontrol.FieldSigninVerifyType:
		return m.SigninVerifyType()
	case appusercontrol.FieldKol:
		return m.Kol()
	case appusercontrol.FieldKolConfirmed:
		return m.KolConfirmed()
	case appusercontrol.FieldSelectedLangID:
		return m.SelectedLangID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appusercontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appusercontrol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appusercontrol.FieldEntID:
		return m.OldEntID(ctx)
	case appusercontrol.FieldAppID:
		return m.OldAppID(ctx)
	case appusercontrol.FieldUserID:
		return m.OldUserID(ctx)
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		return m.OldSigninVerifyByGoogleAuthentication(ctx)
	case appusercontrol.FieldGoogleAuthenticationVerified:
		return m.OldGoogleAuthenticationVerified(ctx)
	case appusercontrol.FieldSigninVerifyType:
		return m.OldSigninVerifyType(ctx)
	case appusercontrol.FieldKol:
		return m.OldKol(ctx)
	case appusercontrol.FieldKolConfirmed:
		return m.OldKolConfirmed(ctx)
	case appusercontrol.FieldSelectedLangID:
		return m.OldSelectedLangID(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appusercontrol.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appusercontrol.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appusercontrol.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appusercontrol.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appusercontrol.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyByGoogleAuthentication(v)
		return nil
	case appusercontrol.FieldGoogleAuthenticationVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleAuthenticationVerified(v)
		return nil
	case appusercontrol.FieldSigninVerifyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyType(v)
		return nil
	case appusercontrol.FieldKol:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKol(v)
		return nil
	case appusercontrol.FieldKolConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKolConfirmed(v)
		return nil
	case appusercontrol.FieldSelectedLangID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedLangID(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserControlMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appusercontrol.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appusercontrol.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appusercontrol.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appusercontrol.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appusercontrol.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appusercontrol.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appusercontrol.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appusercontrol.FieldAppID) {
		fields = append(fields, appusercontrol.FieldAppID)
	}
	if m.FieldCleared(appusercontrol.FieldUserID) {
		fields = append(fields, appusercontrol.FieldUserID)
	}
	if m.FieldCleared(appusercontrol.FieldSigninVerifyByGoogleAuthentication) {
		fields = append(fields, appusercontrol.FieldSigninVerifyByGoogleAuthentication)
	}
	if m.FieldCleared(appusercontrol.FieldGoogleAuthenticationVerified) {
		fields = append(fields, appusercontrol.FieldGoogleAuthenticationVerified)
	}
	if m.FieldCleared(appusercontrol.FieldSigninVerifyType) {
		fields = append(fields, appusercontrol.FieldSigninVerifyType)
	}
	if m.FieldCleared(appusercontrol.FieldSelectedLangID) {
		fields = append(fields, appusercontrol.FieldSelectedLangID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserControlMutation) ClearField(name string) error {
	switch name {
	case appusercontrol.FieldAppID:
		m.ClearAppID()
		return nil
	case appusercontrol.FieldUserID:
		m.ClearUserID()
		return nil
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		m.ClearSigninVerifyByGoogleAuthentication()
		return nil
	case appusercontrol.FieldGoogleAuthenticationVerified:
		m.ClearGoogleAuthenticationVerified()
		return nil
	case appusercontrol.FieldSigninVerifyType:
		m.ClearSigninVerifyType()
		return nil
	case appusercontrol.FieldSelectedLangID:
		m.ClearSelectedLangID()
		return nil
	}
	return fmt.Errorf("unknown AppUserControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserControlMutation) ResetField(name string) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appusercontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appusercontrol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appusercontrol.FieldEntID:
		m.ResetEntID()
		return nil
	case appusercontrol.FieldAppID:
		m.ResetAppID()
		return nil
	case appusercontrol.FieldUserID:
		m.ResetUserID()
		return nil
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		m.ResetSigninVerifyByGoogleAuthentication()
		return nil
	case appusercontrol.FieldGoogleAuthenticationVerified:
		m.ResetGoogleAuthenticationVerified()
		return nil
	case appusercontrol.FieldSigninVerifyType:
		m.ResetSigninVerifyType()
		return nil
	case appusercontrol.FieldKol:
		m.ResetKol()
		return nil
	case appusercontrol.FieldKolConfirmed:
		m.ResetKolConfirmed()
		return nil
	case appusercontrol.FieldSelectedLangID:
		m.ResetSelectedLangID()
		return nil
	}
	return fmt.Errorf("unknown AppUserControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserControl edge %s", name)
}

// AppUserExtraMutation represents an operation that mutates the AppUserExtra nodes in the graph.
type AppUserExtraMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	ent_id               *uuid.UUID
	app_id               *uuid.UUID
	user_id              *uuid.UUID
	username             *string
	first_name           *string
	last_name            *string
	address_fields       *[]string
	appendaddress_fields []string
	gender               *string
	postal_code          *string
	age                  *uint32
	addage               *int32
	birthday             *uint32
	addbirthday          *int32
	avatar               *string
	organization         *string
	id_number            *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AppUserExtra, error)
	predicates           []predicate.AppUserExtra
}

var _ ent.Mutation = (*AppUserExtraMutation)(nil)

// appuserextraOption allows management of the mutation configuration using functional options.
type appuserextraOption func(*AppUserExtraMutation)

// newAppUserExtraMutation creates new mutation for the AppUserExtra entity.
func newAppUserExtraMutation(c config, op Op, opts ...appuserextraOption) *AppUserExtraMutation {
	m := &AppUserExtraMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserExtra,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserExtraID sets the ID field of the mutation.
func withAppUserExtraID(id uint32) appuserextraOption {
	return func(m *AppUserExtraMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserExtra
		)
		m.oldValue = func(ctx context.Context) (*AppUserExtra, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserExtra.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserExtra sets the old AppUserExtra of the mutation.
func withAppUserExtra(node *AppUserExtra) appuserextraOption {
	return func(m *AppUserExtraMutation) {
		m.oldValue = func(context.Context) (*AppUserExtra, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserExtraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserExtraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserExtra entities.
func (m *AppUserExtraMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserExtraMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserExtraMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserExtra.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserExtraMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserExtraMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserExtraMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserExtraMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserExtraMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserExtraMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserExtraMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserExtraMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserExtraMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserExtraMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserExtraMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserExtraMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserExtraMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserExtraMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserExtraMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppUserExtraMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppUserExtraMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppUserExtraMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserExtraMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserExtraMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserExtraMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserExtraMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserExtraMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserExtraMutation) ResetUserID() {
	m.user_id = nil
}

// SetUsername sets the "username" field.
func (m *AppUserExtraMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AppUserExtraMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AppUserExtraMutation) ResetUsername() {
	m.username = nil
}

// SetFirstName sets the "first_name" field.
func (m *AppUserExtraMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AppUserExtraMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AppUserExtraMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *AppUserExtraMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AppUserExtraMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AppUserExtraMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddressFields sets the "address_fields" field.
func (m *AppUserExtraMutation) SetAddressFields(s []string) {
	m.address_fields = &s
	m.appendaddress_fields = nil
}

// AddressFields returns the value of the "address_fields" field in the mutation.
func (m *AppUserExtraMutation) AddressFields() (r []string, exists bool) {
	v := m.address_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressFields returns the old "address_fields" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAddressFields(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressFields: %w", err)
	}
	return oldValue.AddressFields, nil
}

// AppendAddressFields adds s to the "address_fields" field.
func (m *AppUserExtraMutation) AppendAddressFields(s []string) {
	m.appendaddress_fields = append(m.appendaddress_fields, s...)
}

// AppendedAddressFields returns the list of values that were appended to the "address_fields" field in this mutation.
func (m *AppUserExtraMutation) AppendedAddressFields() ([]string, bool) {
	if len(m.appendaddress_fields) == 0 {
		return nil, false
	}
	return m.appendaddress_fields, true
}

// ResetAddressFields resets all changes to the "address_fields" field.
func (m *AppUserExtraMutation) ResetAddressFields() {
	m.address_fields = nil
	m.appendaddress_fields = nil
}

// SetGender sets the "gender" field.
func (m *AppUserExtraMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *AppUserExtraMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *AppUserExtraMutation) ResetGender() {
	m.gender = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *AppUserExtraMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *AppUserExtraMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *AppUserExtraMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetAge sets the "age" field.
func (m *AppUserExtraMutation) SetAge(u uint32) {
	m.age = &u
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *AppUserExtraMutation) Age() (r uint32, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAge(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds u to the "age" field.
func (m *AppUserExtraMutation) AddAge(u int32) {
	if m.addage != nil {
		*m.addage += u
	} else {
		m.addage = &u
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *AppUserExtraMutation) AddedAge() (r int32, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *AppUserExtraMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetBirthday sets the "birthday" field.
func (m *AppUserExtraMutation) SetBirthday(u uint32) {
	m.birthday = &u
	m.addbirthday = nil
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *AppUserExtraMutation) Birthday() (r uint32, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldBirthday(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// AddBirthday adds u to the "birthday" field.
func (m *AppUserExtraMutation) AddBirthday(u int32) {
	if m.addbirthday != nil {
		*m.addbirthday += u
	} else {
		m.addbirthday = &u
	}
}

// AddedBirthday returns the value that was added to the "birthday" field in this mutation.
func (m *AppUserExtraMutation) AddedBirthday() (r int32, exists bool) {
	v := m.addbirthday
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *AppUserExtraMutation) ResetBirthday() {
	m.birthday = nil
	m.addbirthday = nil
}

// SetAvatar sets the "avatar" field.
func (m *AppUserExtraMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AppUserExtraMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AppUserExtraMutation) ResetAvatar() {
	m.avatar = nil
}

// SetOrganization sets the "organization" field.
func (m *AppUserExtraMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *AppUserExtraMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ResetOrganization resets all changes to the "organization" field.
func (m *AppUserExtraMutation) ResetOrganization() {
	m.organization = nil
}

// SetIDNumber sets the "id_number" field.
func (m *AppUserExtraMutation) SetIDNumber(s string) {
	m.id_number = &s
}

// IDNumber returns the value of the "id_number" field in the mutation.
func (m *AppUserExtraMutation) IDNumber() (r string, exists bool) {
	v := m.id_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDNumber returns the old "id_number" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldIDNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDNumber: %w", err)
	}
	return oldValue.IDNumber, nil
}

// ResetIDNumber resets all changes to the "id_number" field.
func (m *AppUserExtraMutation) ResetIDNumber() {
	m.id_number = nil
}

// Where appends a list predicates to the AppUserExtraMutation builder.
func (m *AppUserExtraMutation) Where(ps ...predicate.AppUserExtra) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppUserExtraMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppUserExtraMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppUserExtra, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppUserExtraMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppUserExtraMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppUserExtra).
func (m *AppUserExtraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserExtraMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, appuserextra.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuserextra.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuserextra.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appuserextra.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appuserextra.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appuserextra.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, appuserextra.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, appuserextra.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, appuserextra.FieldLastName)
	}
	if m.address_fields != nil {
		fields = append(fields, appuserextra.FieldAddressFields)
	}
	if m.gender != nil {
		fields = append(fields, appuserextra.FieldGender)
	}
	if m.postal_code != nil {
		fields = append(fields, appuserextra.FieldPostalCode)
	}
	if m.age != nil {
		fields = append(fields, appuserextra.FieldAge)
	}
	if m.birthday != nil {
		fields = append(fields, appuserextra.FieldBirthday)
	}
	if m.avatar != nil {
		fields = append(fields, appuserextra.FieldAvatar)
	}
	if m.organization != nil {
		fields = append(fields, appuserextra.FieldOrganization)
	}
	if m.id_number != nil {
		fields = append(fields, appuserextra.FieldIDNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserExtraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.CreatedAt()
	case appuserextra.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuserextra.FieldDeletedAt:
		return m.DeletedAt()
	case appuserextra.FieldEntID:
		return m.EntID()
	case appuserextra.FieldAppID:
		return m.AppID()
	case appuserextra.FieldUserID:
		return m.UserID()
	case appuserextra.FieldUsername:
		return m.Username()
	case appuserextra.FieldFirstName:
		return m.FirstName()
	case appuserextra.FieldLastName:
		return m.LastName()
	case appuserextra.FieldAddressFields:
		return m.AddressFields()
	case appuserextra.FieldGender:
		return m.Gender()
	case appuserextra.FieldPostalCode:
		return m.PostalCode()
	case appuserextra.FieldAge:
		return m.Age()
	case appuserextra.FieldBirthday:
		return m.Birthday()
	case appuserextra.FieldAvatar:
		return m.Avatar()
	case appuserextra.FieldOrganization:
		return m.Organization()
	case appuserextra.FieldIDNumber:
		return m.IDNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserExtraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuserextra.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuserextra.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuserextra.FieldEntID:
		return m.OldEntID(ctx)
	case appuserextra.FieldAppID:
		return m.OldAppID(ctx)
	case appuserextra.FieldUserID:
		return m.OldUserID(ctx)
	case appuserextra.FieldUsername:
		return m.OldUsername(ctx)
	case appuserextra.FieldFirstName:
		return m.OldFirstName(ctx)
	case appuserextra.FieldLastName:
		return m.OldLastName(ctx)
	case appuserextra.FieldAddressFields:
		return m.OldAddressFields(ctx)
	case appuserextra.FieldGender:
		return m.OldGender(ctx)
	case appuserextra.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case appuserextra.FieldAge:
		return m.OldAge(ctx)
	case appuserextra.FieldBirthday:
		return m.OldBirthday(ctx)
	case appuserextra.FieldAvatar:
		return m.OldAvatar(ctx)
	case appuserextra.FieldOrganization:
		return m.OldOrganization(ctx)
	case appuserextra.FieldIDNumber:
		return m.OldIDNumber(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserExtra field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserExtraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuserextra.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuserextra.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuserextra.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appuserextra.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuserextra.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuserextra.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case appuserextra.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case appuserextra.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case appuserextra.FieldAddressFields:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressFields(v)
		return nil
	case appuserextra.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case appuserextra.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case appuserextra.FieldAge:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case appuserextra.FieldBirthday:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case appuserextra.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case appuserextra.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case appuserextra.FieldIDNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDNumber(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserExtraMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuserextra.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuserextra.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuserextra.FieldDeletedAt)
	}
	if m.addage != nil {
		fields = append(fields, appuserextra.FieldAge)
	}
	if m.addbirthday != nil {
		fields = append(fields, appuserextra.FieldBirthday)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserExtraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuserextra.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuserextra.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appuserextra.FieldAge:
		return m.AddedAge()
	case appuserextra.FieldBirthday:
		return m.AddedBirthday()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserExtraMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuserextra.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuserextra.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appuserextra.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case appuserextra.FieldBirthday:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthday(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserExtraMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserExtraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserExtraMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserExtra nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserExtraMutation) ResetField(name string) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuserextra.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuserextra.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuserextra.FieldEntID:
		m.ResetEntID()
		return nil
	case appuserextra.FieldAppID:
		m.ResetAppID()
		return nil
	case appuserextra.FieldUserID:
		m.ResetUserID()
		return nil
	case appuserextra.FieldUsername:
		m.ResetUsername()
		return nil
	case appuserextra.FieldFirstName:
		m.ResetFirstName()
		return nil
	case appuserextra.FieldLastName:
		m.ResetLastName()
		return nil
	case appuserextra.FieldAddressFields:
		m.ResetAddressFields()
		return nil
	case appuserextra.FieldGender:
		m.ResetGender()
		return nil
	case appuserextra.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case appuserextra.FieldAge:
		m.ResetAge()
		return nil
	case appuserextra.FieldBirthday:
		m.ResetBirthday()
		return nil
	case appuserextra.FieldAvatar:
		m.ResetAvatar()
		return nil
	case appuserextra.FieldOrganization:
		m.ResetOrganization()
		return nil
	case appuserextra.FieldIDNumber:
		m.ResetIDNumber()
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserExtraMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserExtraMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserExtraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserExtraMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserExtraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserExtraMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserExtraMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserExtra unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserExtraMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserExtra edge %s", name)
}

// AppUserSecretMutation represents an operation that mutates the AppUserSecret nodes in the graph.
type AppUserSecretMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	password_hash *string
	salt          *string
	google_secret *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppUserSecret, error)
	predicates    []predicate.AppUserSecret
}

var _ ent.Mutation = (*AppUserSecretMutation)(nil)

// appusersecretOption allows management of the mutation configuration using functional options.
type appusersecretOption func(*AppUserSecretMutation)

// newAppUserSecretMutation creates new mutation for the AppUserSecret entity.
func newAppUserSecretMutation(c config, op Op, opts ...appusersecretOption) *AppUserSecretMutation {
	m := &AppUserSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserSecretID sets the ID field of the mutation.
func withAppUserSecretID(id uint32) appusersecretOption {
	return func(m *AppUserSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserSecret
		)
		m.oldValue = func(ctx context.Context) (*AppUserSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserSecret sets the old AppUserSecret of the mutation.
func withAppUserSecret(node *AppUserSecret) appusersecretOption {
	return func(m *AppUserSecretMutation) {
		m.oldValue = func(context.Context) (*AppUserSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserSecret entities.
func (m *AppUserSecretMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserSecretMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserSecretMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserSecretMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserSecretMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserSecretMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserSecretMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserSecretMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserSecretMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserSecretMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserSecretMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserSecretMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserSecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserSecretMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserSecretMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserSecretMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserSecretMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserSecretMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppUserSecretMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppUserSecretMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppUserSecretMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserSecretMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserSecretMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserSecretMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserSecretMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserSecretMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserSecretMutation) ResetUserID() {
	m.user_id = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AppUserSecretMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AppUserSecretMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AppUserSecretMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetSalt sets the "salt" field.
func (m *AppUserSecretMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *AppUserSecretMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *AppUserSecretMutation) ResetSalt() {
	m.salt = nil
}

// SetGoogleSecret sets the "google_secret" field.
func (m *AppUserSecretMutation) SetGoogleSecret(s string) {
	m.google_secret = &s
}

// GoogleSecret returns the value of the "google_secret" field in the mutation.
func (m *AppUserSecretMutation) GoogleSecret() (r string, exists bool) {
	v := m.google_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleSecret returns the old "google_secret" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldGoogleSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleSecret: %w", err)
	}
	return oldValue.GoogleSecret, nil
}

// ResetGoogleSecret resets all changes to the "google_secret" field.
func (m *AppUserSecretMutation) ResetGoogleSecret() {
	m.google_secret = nil
}

// Where appends a list predicates to the AppUserSecretMutation builder.
func (m *AppUserSecretMutation) Where(ps ...predicate.AppUserSecret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppUserSecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppUserSecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppUserSecret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppUserSecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppUserSecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppUserSecret).
func (m *AppUserSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserSecretMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, appusersecret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appusersecret.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appusersecret.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appusersecret.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appusersecret.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appusersecret.FieldUserID)
	}
	if m.password_hash != nil {
		fields = append(fields, appusersecret.FieldPasswordHash)
	}
	if m.salt != nil {
		fields = append(fields, appusersecret.FieldSalt)
	}
	if m.google_secret != nil {
		fields = append(fields, appusersecret.FieldGoogleSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.CreatedAt()
	case appusersecret.FieldUpdatedAt:
		return m.UpdatedAt()
	case appusersecret.FieldDeletedAt:
		return m.DeletedAt()
	case appusersecret.FieldEntID:
		return m.EntID()
	case appusersecret.FieldAppID:
		return m.AppID()
	case appusersecret.FieldUserID:
		return m.UserID()
	case appusersecret.FieldPasswordHash:
		return m.PasswordHash()
	case appusersecret.FieldSalt:
		return m.Salt()
	case appusersecret.FieldGoogleSecret:
		return m.GoogleSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appusersecret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appusersecret.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appusersecret.FieldEntID:
		return m.OldEntID(ctx)
	case appusersecret.FieldAppID:
		return m.OldAppID(ctx)
	case appusersecret.FieldUserID:
		return m.OldUserID(ctx)
	case appusersecret.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case appusersecret.FieldSalt:
		return m.OldSalt(ctx)
	case appusersecret.FieldGoogleSecret:
		return m.OldGoogleSecret(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appusersecret.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appusersecret.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appusersecret.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appusersecret.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appusersecret.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appusersecret.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case appusersecret.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case appusersecret.FieldGoogleSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleSecret(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserSecretMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appusersecret.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appusersecret.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appusersecret.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appusersecret.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appusersecret.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appusersecret.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appusersecret.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserSecretMutation) ResetField(name string) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appusersecret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appusersecret.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appusersecret.FieldEntID:
		m.ResetEntID()
		return nil
	case appusersecret.FieldAppID:
		m.ResetAppID()
		return nil
	case appusersecret.FieldUserID:
		m.ResetUserID()
		return nil
	case appusersecret.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case appusersecret.FieldSalt:
		m.ResetSalt()
		return nil
	case appusersecret.FieldGoogleSecret:
		m.ResetGoogleSecret()
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserSecretMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserSecretMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserSecretMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserSecretMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserSecret edge %s", name)
}

// AppUserThirdPartyMutation represents an operation that mutates the AppUserThirdParty nodes in the graph.
type AppUserThirdPartyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	ent_id               *uuid.UUID
	app_id               *uuid.UUID
	user_id              *uuid.UUID
	third_party_user_id  *string
	third_party_id       *uuid.UUID
	third_party_username *string
	third_party_avatar   *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AppUserThirdParty, error)
	predicates           []predicate.AppUserThirdParty
}

var _ ent.Mutation = (*AppUserThirdPartyMutation)(nil)

// appuserthirdpartyOption allows management of the mutation configuration using functional options.
type appuserthirdpartyOption func(*AppUserThirdPartyMutation)

// newAppUserThirdPartyMutation creates new mutation for the AppUserThirdParty entity.
func newAppUserThirdPartyMutation(c config, op Op, opts ...appuserthirdpartyOption) *AppUserThirdPartyMutation {
	m := &AppUserThirdPartyMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserThirdParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserThirdPartyID sets the ID field of the mutation.
func withAppUserThirdPartyID(id uint32) appuserthirdpartyOption {
	return func(m *AppUserThirdPartyMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserThirdParty
		)
		m.oldValue = func(ctx context.Context) (*AppUserThirdParty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserThirdParty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserThirdParty sets the old AppUserThirdParty of the mutation.
func withAppUserThirdParty(node *AppUserThirdParty) appuserthirdpartyOption {
	return func(m *AppUserThirdPartyMutation) {
		m.oldValue = func(context.Context) (*AppUserThirdParty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserThirdPartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserThirdPartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserThirdParty entities.
func (m *AppUserThirdPartyMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserThirdPartyMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserThirdPartyMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserThirdParty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserThirdPartyMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserThirdPartyMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserThirdPartyMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserThirdPartyMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserThirdPartyMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserThirdPartyMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserThirdPartyMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserThirdPartyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserThirdPartyMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserThirdPartyMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserThirdPartyMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserThirdPartyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppUserThirdPartyMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppUserThirdPartyMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppUserThirdPartyMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserThirdPartyMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserThirdPartyMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppUserThirdPartyMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appuserthirdparty.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserThirdPartyMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appuserthirdparty.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AppUserThirdPartyMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserThirdPartyMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AppUserThirdPartyMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[appuserthirdparty.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserThirdPartyMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, appuserthirdparty.FieldUserID)
}

// SetThirdPartyUserID sets the "third_party_user_id" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyUserID(s string) {
	m.third_party_user_id = &s
}

// ThirdPartyUserID returns the value of the "third_party_user_id" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUserID() (r string, exists bool) {
	v := m.third_party_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyUserID returns the old "third_party_user_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyUserID: %w", err)
	}
	return oldValue.ThirdPartyUserID, nil
}

// ClearThirdPartyUserID clears the value of the "third_party_user_id" field.
func (m *AppUserThirdPartyMutation) ClearThirdPartyUserID() {
	m.third_party_user_id = nil
	m.clearedFields[appuserthirdparty.FieldThirdPartyUserID] = struct{}{}
}

// ThirdPartyUserIDCleared returns if the "third_party_user_id" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUserIDCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldThirdPartyUserID]
	return ok
}

// ResetThirdPartyUserID resets all changes to the "third_party_user_id" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyUserID() {
	m.third_party_user_id = nil
	delete(m.clearedFields, appuserthirdparty.FieldThirdPartyUserID)
}

// SetThirdPartyID sets the "third_party_id" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyID(u uuid.UUID) {
	m.third_party_id = &u
}

// ThirdPartyID returns the value of the "third_party_id" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyID() (r uuid.UUID, exists bool) {
	v := m.third_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyID returns the old "third_party_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyID: %w", err)
	}
	return oldValue.ThirdPartyID, nil
}

// ClearThirdPartyID clears the value of the "third_party_id" field.
func (m *AppUserThirdPartyMutation) ClearThirdPartyID() {
	m.third_party_id = nil
	m.clearedFields[appuserthirdparty.FieldThirdPartyID] = struct{}{}
}

// ThirdPartyIDCleared returns if the "third_party_id" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyIDCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldThirdPartyID]
	return ok
}

// ResetThirdPartyID resets all changes to the "third_party_id" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyID() {
	m.third_party_id = nil
	delete(m.clearedFields, appuserthirdparty.FieldThirdPartyID)
}

// SetThirdPartyUsername sets the "third_party_username" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyUsername(s string) {
	m.third_party_username = &s
}

// ThirdPartyUsername returns the value of the "third_party_username" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUsername() (r string, exists bool) {
	v := m.third_party_username
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyUsername returns the old "third_party_username" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyUsername: %w", err)
	}
	return oldValue.ThirdPartyUsername, nil
}

// ClearThirdPartyUsername clears the value of the "third_party_username" field.
func (m *AppUserThirdPartyMutation) ClearThirdPartyUsername() {
	m.third_party_username = nil
	m.clearedFields[appuserthirdparty.FieldThirdPartyUsername] = struct{}{}
}

// ThirdPartyUsernameCleared returns if the "third_party_username" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUsernameCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldThirdPartyUsername]
	return ok
}

// ResetThirdPartyUsername resets all changes to the "third_party_username" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyUsername() {
	m.third_party_username = nil
	delete(m.clearedFields, appuserthirdparty.FieldThirdPartyUsername)
}

// SetThirdPartyAvatar sets the "third_party_avatar" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyAvatar(s string) {
	m.third_party_avatar = &s
}

// ThirdPartyAvatar returns the value of the "third_party_avatar" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyAvatar() (r string, exists bool) {
	v := m.third_party_avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyAvatar returns the old "third_party_avatar" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyAvatar: %w", err)
	}
	return oldValue.ThirdPartyAvatar, nil
}

// ClearThirdPartyAvatar clears the value of the "third_party_avatar" field.
func (m *AppUserThirdPartyMutation) ClearThirdPartyAvatar() {
	m.third_party_avatar = nil
	m.clearedFields[appuserthirdparty.FieldThirdPartyAvatar] = struct{}{}
}

// ThirdPartyAvatarCleared returns if the "third_party_avatar" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyAvatarCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldThirdPartyAvatar]
	return ok
}

// ResetThirdPartyAvatar resets all changes to the "third_party_avatar" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyAvatar() {
	m.third_party_avatar = nil
	delete(m.clearedFields, appuserthirdparty.FieldThirdPartyAvatar)
}

// Where appends a list predicates to the AppUserThirdPartyMutation builder.
func (m *AppUserThirdPartyMutation) Where(ps ...predicate.AppUserThirdParty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppUserThirdPartyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppUserThirdPartyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppUserThirdParty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppUserThirdPartyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppUserThirdPartyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppUserThirdParty).
func (m *AppUserThirdPartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserThirdPartyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, appuserthirdparty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuserthirdparty.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuserthirdparty.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, appuserthirdparty.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, appuserthirdparty.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appuserthirdparty.FieldUserID)
	}
	if m.third_party_user_id != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUserID)
	}
	if m.third_party_id != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyID)
	}
	if m.third_party_username != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUsername)
	}
	if m.third_party_avatar != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserThirdPartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.CreatedAt()
	case appuserthirdparty.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuserthirdparty.FieldDeletedAt:
		return m.DeletedAt()
	case appuserthirdparty.FieldEntID:
		return m.EntID()
	case appuserthirdparty.FieldAppID:
		return m.AppID()
	case appuserthirdparty.FieldUserID:
		return m.UserID()
	case appuserthirdparty.FieldThirdPartyUserID:
		return m.ThirdPartyUserID()
	case appuserthirdparty.FieldThirdPartyID:
		return m.ThirdPartyID()
	case appuserthirdparty.FieldThirdPartyUsername:
		return m.ThirdPartyUsername()
	case appuserthirdparty.FieldThirdPartyAvatar:
		return m.ThirdPartyAvatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserThirdPartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuserthirdparty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuserthirdparty.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuserthirdparty.FieldEntID:
		return m.OldEntID(ctx)
	case appuserthirdparty.FieldAppID:
		return m.OldAppID(ctx)
	case appuserthirdparty.FieldUserID:
		return m.OldUserID(ctx)
	case appuserthirdparty.FieldThirdPartyUserID:
		return m.OldThirdPartyUserID(ctx)
	case appuserthirdparty.FieldThirdPartyID:
		return m.OldThirdPartyID(ctx)
	case appuserthirdparty.FieldThirdPartyUsername:
		return m.OldThirdPartyUsername(ctx)
	case appuserthirdparty.FieldThirdPartyAvatar:
		return m.OldThirdPartyAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserThirdPartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuserthirdparty.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuserthirdparty.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case appuserthirdparty.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuserthirdparty.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyUserID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyUsername(v)
		return nil
	case appuserthirdparty.FieldThirdPartyAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserThirdPartyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuserthirdparty.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuserthirdparty.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuserthirdparty.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserThirdPartyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuserthirdparty.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuserthirdparty.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserThirdPartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuserthirdparty.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserThirdPartyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appuserthirdparty.FieldAppID) {
		fields = append(fields, appuserthirdparty.FieldAppID)
	}
	if m.FieldCleared(appuserthirdparty.FieldUserID) {
		fields = append(fields, appuserthirdparty.FieldUserID)
	}
	if m.FieldCleared(appuserthirdparty.FieldThirdPartyUserID) {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUserID)
	}
	if m.FieldCleared(appuserthirdparty.FieldThirdPartyID) {
		fields = append(fields, appuserthirdparty.FieldThirdPartyID)
	}
	if m.FieldCleared(appuserthirdparty.FieldThirdPartyUsername) {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUsername)
	}
	if m.FieldCleared(appuserthirdparty.FieldThirdPartyAvatar) {
		fields = append(fields, appuserthirdparty.FieldThirdPartyAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserThirdPartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserThirdPartyMutation) ClearField(name string) error {
	switch name {
	case appuserthirdparty.FieldAppID:
		m.ClearAppID()
		return nil
	case appuserthirdparty.FieldUserID:
		m.ClearUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyUserID:
		m.ClearThirdPartyUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyID:
		m.ClearThirdPartyID()
		return nil
	case appuserthirdparty.FieldThirdPartyUsername:
		m.ClearThirdPartyUsername()
		return nil
	case appuserthirdparty.FieldThirdPartyAvatar:
		m.ClearThirdPartyAvatar()
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserThirdPartyMutation) ResetField(name string) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuserthirdparty.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuserthirdparty.FieldEntID:
		m.ResetEntID()
		return nil
	case appuserthirdparty.FieldAppID:
		m.ResetAppID()
		return nil
	case appuserthirdparty.FieldUserID:
		m.ResetUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyUserID:
		m.ResetThirdPartyUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyID:
		m.ResetThirdPartyID()
		return nil
	case appuserthirdparty.FieldThirdPartyUsername:
		m.ResetThirdPartyUsername()
		return nil
	case appuserthirdparty.FieldThirdPartyAvatar:
		m.ResetThirdPartyAvatar()
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserThirdPartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserThirdPartyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserThirdPartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserThirdPartyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserThirdPartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserThirdPartyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserThirdPartyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserThirdParty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserThirdPartyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserThirdParty edge %s", name)
}

// AuthMutation represents an operation that mutates the Auth nodes in the graph.
type AuthMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	role_id       *uuid.UUID
	user_id       *uuid.UUID
	resource      *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Auth, error)
	predicates    []predicate.Auth
}

var _ ent.Mutation = (*AuthMutation)(nil)

// authOption allows management of the mutation configuration using functional options.
type authOption func(*AuthMutation)

// newAuthMutation creates new mutation for the Auth entity.
func newAuthMutation(c config, op Op, opts ...authOption) *AuthMutation {
	m := &AuthMutation{
		config:        c,
		op:            op,
		typ:           TypeAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthID sets the ID field of the mutation.
func withAuthID(id uint32) authOption {
	return func(m *AuthMutation) {
		var (
			err   error
			once  sync.Once
			value *Auth
		)
		m.oldValue = func(ctx context.Context) (*Auth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuth sets the old Auth of the mutation.
func withAuth(node *Auth) authOption {
	return func(m *AuthMutation) {
		m.oldValue = func(context.Context) (*Auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Auth entities.
func (m *AuthMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Auth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AuthMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AuthMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AuthMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AuthMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AuthMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AuthMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AuthMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AuthMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AuthMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AuthMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AuthMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AuthMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[auth.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AuthMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[auth.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AuthMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, auth.FieldAppID)
}

// SetRoleID sets the "role_id" field.
func (m *AuthMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AuthMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *AuthMutation) ClearRoleID() {
	m.role_id = nil
	m.clearedFields[auth.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *AuthMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[auth.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AuthMutation) ResetRoleID() {
	m.role_id = nil
	delete(m.clearedFields, auth.FieldRoleID)
}

// SetUserID sets the "user_id" field.
func (m *AuthMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuthMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuthMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[auth.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuthMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[auth.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuthMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, auth.FieldUserID)
}

// SetResource sets the "resource" field.
func (m *AuthMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *AuthMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ClearResource clears the value of the "resource" field.
func (m *AuthMutation) ClearResource() {
	m.resource = nil
	m.clearedFields[auth.FieldResource] = struct{}{}
}

// ResourceCleared returns if the "resource" field was cleared in this mutation.
func (m *AuthMutation) ResourceCleared() bool {
	_, ok := m.clearedFields[auth.FieldResource]
	return ok
}

// ResetResource resets all changes to the "resource" field.
func (m *AuthMutation) ResetResource() {
	m.resource = nil
	delete(m.clearedFields, auth.FieldResource)
}

// SetMethod sets the "method" field.
func (m *AuthMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AuthMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *AuthMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[auth.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *AuthMutation) MethodCleared() bool {
	_, ok := m.clearedFields[auth.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *AuthMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, auth.FieldMethod)
}

// Where appends a list predicates to the AuthMutation builder.
func (m *AuthMutation) Where(ps ...predicate.Auth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Auth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Auth).
func (m *AuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, auth.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, auth.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, auth.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, auth.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, auth.FieldAppID)
	}
	if m.role_id != nil {
		fields = append(fields, auth.FieldRoleID)
	}
	if m.user_id != nil {
		fields = append(fields, auth.FieldUserID)
	}
	if m.resource != nil {
		fields = append(fields, auth.FieldResource)
	}
	if m.method != nil {
		fields = append(fields, auth.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldCreatedAt:
		return m.CreatedAt()
	case auth.FieldUpdatedAt:
		return m.UpdatedAt()
	case auth.FieldDeletedAt:
		return m.DeletedAt()
	case auth.FieldEntID:
		return m.EntID()
	case auth.FieldAppID:
		return m.AppID()
	case auth.FieldRoleID:
		return m.RoleID()
	case auth.FieldUserID:
		return m.UserID()
	case auth.FieldResource:
		return m.Resource()
	case auth.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auth.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case auth.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case auth.FieldEntID:
		return m.OldEntID(ctx)
	case auth.FieldAppID:
		return m.OldAppID(ctx)
	case auth.FieldRoleID:
		return m.OldRoleID(ctx)
	case auth.FieldUserID:
		return m.OldUserID(ctx)
	case auth.FieldResource:
		return m.OldResource(ctx)
	case auth.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown Auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auth.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auth.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case auth.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case auth.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case auth.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case auth.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case auth.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auth.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case auth.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, auth.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, auth.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, auth.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldCreatedAt:
		return m.AddedCreatedAt()
	case auth.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case auth.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auth.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case auth.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case auth.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auth.FieldAppID) {
		fields = append(fields, auth.FieldAppID)
	}
	if m.FieldCleared(auth.FieldRoleID) {
		fields = append(fields, auth.FieldRoleID)
	}
	if m.FieldCleared(auth.FieldUserID) {
		fields = append(fields, auth.FieldUserID)
	}
	if m.FieldCleared(auth.FieldResource) {
		fields = append(fields, auth.FieldResource)
	}
	if m.FieldCleared(auth.FieldMethod) {
		fields = append(fields, auth.FieldMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMutation) ClearField(name string) error {
	switch name {
	case auth.FieldAppID:
		m.ClearAppID()
		return nil
	case auth.FieldRoleID:
		m.ClearRoleID()
		return nil
	case auth.FieldUserID:
		m.ClearUserID()
		return nil
	case auth.FieldResource:
		m.ClearResource()
		return nil
	case auth.FieldMethod:
		m.ClearMethod()
		return nil
	}
	return fmt.Errorf("unknown Auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMutation) ResetField(name string) error {
	switch name {
	case auth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auth.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case auth.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case auth.FieldEntID:
		m.ResetEntID()
		return nil
	case auth.FieldAppID:
		m.ResetAppID()
		return nil
	case auth.FieldRoleID:
		m.ResetRoleID()
		return nil
	case auth.FieldUserID:
		m.ResetUserID()
		return nil
	case auth.FieldResource:
		m.ResetResource()
		return nil
	case auth.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Auth edge %s", name)
}

// AuthHistoryMutation represents an operation that mutates the AuthHistory nodes in the graph.
type AuthHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	resource      *string
	method        *string
	allowed       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthHistory, error)
	predicates    []predicate.AuthHistory
}

var _ ent.Mutation = (*AuthHistoryMutation)(nil)

// authhistoryOption allows management of the mutation configuration using functional options.
type authhistoryOption func(*AuthHistoryMutation)

// newAuthHistoryMutation creates new mutation for the AuthHistory entity.
func newAuthHistoryMutation(c config, op Op, opts ...authhistoryOption) *AuthHistoryMutation {
	m := &AuthHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthHistoryID sets the ID field of the mutation.
func withAuthHistoryID(id uint32) authhistoryOption {
	return func(m *AuthHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthHistory
		)
		m.oldValue = func(ctx context.Context) (*AuthHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthHistory sets the old AuthHistory of the mutation.
func withAuthHistory(node *AuthHistory) authhistoryOption {
	return func(m *AuthHistoryMutation) {
		m.oldValue = func(context.Context) (*AuthHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthHistory entities.
func (m *AuthHistoryMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthHistoryMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthHistoryMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthHistoryMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthHistoryMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AuthHistoryMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AuthHistoryMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthHistoryMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthHistoryMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AuthHistoryMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AuthHistoryMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthHistoryMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthHistoryMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AuthHistoryMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AuthHistoryMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AuthHistoryMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AuthHistoryMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AuthHistoryMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AuthHistoryMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AuthHistoryMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AuthHistoryMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[authhistory.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AuthHistoryMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AuthHistoryMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, authhistory.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AuthHistoryMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuthHistoryMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuthHistoryMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[authhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuthHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuthHistoryMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, authhistory.FieldUserID)
}

// SetResource sets the "resource" field.
func (m *AuthHistoryMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *AuthHistoryMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ClearResource clears the value of the "resource" field.
func (m *AuthHistoryMutation) ClearResource() {
	m.resource = nil
	m.clearedFields[authhistory.FieldResource] = struct{}{}
}

// ResourceCleared returns if the "resource" field was cleared in this mutation.
func (m *AuthHistoryMutation) ResourceCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldResource]
	return ok
}

// ResetResource resets all changes to the "resource" field.
func (m *AuthHistoryMutation) ResetResource() {
	m.resource = nil
	delete(m.clearedFields, authhistory.FieldResource)
}

// SetMethod sets the "method" field.
func (m *AuthHistoryMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AuthHistoryMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *AuthHistoryMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[authhistory.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *AuthHistoryMutation) MethodCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *AuthHistoryMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, authhistory.FieldMethod)
}

// SetAllowed sets the "allowed" field.
func (m *AuthHistoryMutation) SetAllowed(b bool) {
	m.allowed = &b
}

// Allowed returns the value of the "allowed" field in the mutation.
func (m *AuthHistoryMutation) Allowed() (r bool, exists bool) {
	v := m.allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowed returns the old "allowed" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowed: %w", err)
	}
	return oldValue.Allowed, nil
}

// ClearAllowed clears the value of the "allowed" field.
func (m *AuthHistoryMutation) ClearAllowed() {
	m.allowed = nil
	m.clearedFields[authhistory.FieldAllowed] = struct{}{}
}

// AllowedCleared returns if the "allowed" field was cleared in this mutation.
func (m *AuthHistoryMutation) AllowedCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldAllowed]
	return ok
}

// ResetAllowed resets all changes to the "allowed" field.
func (m *AuthHistoryMutation) ResetAllowed() {
	m.allowed = nil
	delete(m.clearedFields, authhistory.FieldAllowed)
}

// Where appends a list predicates to the AuthHistoryMutation builder.
func (m *AuthHistoryMutation) Where(ps ...predicate.AuthHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthHistory).
func (m *AuthHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthHistoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, authhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authhistory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, authhistory.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, authhistory.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, authhistory.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, authhistory.FieldUserID)
	}
	if m.resource != nil {
		fields = append(fields, authhistory.FieldResource)
	}
	if m.method != nil {
		fields = append(fields, authhistory.FieldMethod)
	}
	if m.allowed != nil {
		fields = append(fields, authhistory.FieldAllowed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authhistory.FieldCreatedAt:
		return m.CreatedAt()
	case authhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case authhistory.FieldDeletedAt:
		return m.DeletedAt()
	case authhistory.FieldEntID:
		return m.EntID()
	case authhistory.FieldAppID:
		return m.AppID()
	case authhistory.FieldUserID:
		return m.UserID()
	case authhistory.FieldResource:
		return m.Resource()
	case authhistory.FieldMethod:
		return m.Method()
	case authhistory.FieldAllowed:
		return m.Allowed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case authhistory.FieldEntID:
		return m.OldEntID(ctx)
	case authhistory.FieldAppID:
		return m.OldAppID(ctx)
	case authhistory.FieldUserID:
		return m.OldUserID(ctx)
	case authhistory.FieldResource:
		return m.OldResource(ctx)
	case authhistory.FieldMethod:
		return m.OldMethod(ctx)
	case authhistory.FieldAllowed:
		return m.OldAllowed(ctx)
	}
	return nil, fmt.Errorf("unknown AuthHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authhistory.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authhistory.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authhistory.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case authhistory.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case authhistory.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case authhistory.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case authhistory.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case authhistory.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case authhistory.FieldAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowed(v)
		return nil
	}
	return fmt.Errorf("unknown AuthHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, authhistory.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, authhistory.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, authhistory.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authhistory.FieldCreatedAt:
		return m.AddedCreatedAt()
	case authhistory.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case authhistory.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authhistory.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case authhistory.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case authhistory.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authhistory.FieldAppID) {
		fields = append(fields, authhistory.FieldAppID)
	}
	if m.FieldCleared(authhistory.FieldUserID) {
		fields = append(fields, authhistory.FieldUserID)
	}
	if m.FieldCleared(authhistory.FieldResource) {
		fields = append(fields, authhistory.FieldResource)
	}
	if m.FieldCleared(authhistory.FieldMethod) {
		fields = append(fields, authhistory.FieldMethod)
	}
	if m.FieldCleared(authhistory.FieldAllowed) {
		fields = append(fields, authhistory.FieldAllowed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthHistoryMutation) ClearField(name string) error {
	switch name {
	case authhistory.FieldAppID:
		m.ClearAppID()
		return nil
	case authhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case authhistory.FieldResource:
		m.ClearResource()
		return nil
	case authhistory.FieldMethod:
		m.ClearMethod()
		return nil
	case authhistory.FieldAllowed:
		m.ClearAllowed()
		return nil
	}
	return fmt.Errorf("unknown AuthHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthHistoryMutation) ResetField(name string) error {
	switch name {
	case authhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case authhistory.FieldEntID:
		m.ResetEntID()
		return nil
	case authhistory.FieldAppID:
		m.ResetAppID()
		return nil
	case authhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case authhistory.FieldResource:
		m.ResetResource()
		return nil
	case authhistory.FieldMethod:
		m.ResetMethod()
		return nil
	case authhistory.FieldAllowed:
		m.ResetAllowed()
		return nil
	}
	return fmt.Errorf("unknown AuthHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthHistory edge %s", name)
}

// BanAppMutation represents an operation that mutates the BanApp nodes in the graph.
type BanAppMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	message       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BanApp, error)
	predicates    []predicate.BanApp
}

var _ ent.Mutation = (*BanAppMutation)(nil)

// banappOption allows management of the mutation configuration using functional options.
type banappOption func(*BanAppMutation)

// newBanAppMutation creates new mutation for the BanApp entity.
func newBanAppMutation(c config, op Op, opts ...banappOption) *BanAppMutation {
	m := &BanAppMutation{
		config:        c,
		op:            op,
		typ:           TypeBanApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanAppID sets the ID field of the mutation.
func withBanAppID(id uint32) banappOption {
	return func(m *BanAppMutation) {
		var (
			err   error
			once  sync.Once
			value *BanApp
		)
		m.oldValue = func(ctx context.Context) (*BanApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BanApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanApp sets the old BanApp of the mutation.
func withBanApp(node *BanApp) banappOption {
	return func(m *BanAppMutation) {
		m.oldValue = func(context.Context) (*BanApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BanApp entities.
func (m *BanAppMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanAppMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanAppMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BanApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BanAppMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BanAppMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *BanAppMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BanAppMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BanAppMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BanAppMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BanAppMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *BanAppMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BanAppMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BanAppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BanAppMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BanAppMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *BanAppMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BanAppMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BanAppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *BanAppMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *BanAppMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *BanAppMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *BanAppMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *BanAppMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *BanAppMutation) ResetAppID() {
	m.app_id = nil
}

// SetMessage sets the "message" field.
func (m *BanAppMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BanAppMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BanAppMutation) ResetMessage() {
	m.message = nil
}

// Where appends a list predicates to the BanAppMutation builder.
func (m *BanAppMutation) Where(ps ...predicate.BanApp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BanAppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BanAppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BanApp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BanAppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BanAppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BanApp).
func (m *BanAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanAppMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, banapp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banapp.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, banapp.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, banapp.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, banapp.FieldAppID)
	}
	if m.message != nil {
		fields = append(fields, banapp.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.CreatedAt()
	case banapp.FieldUpdatedAt:
		return m.UpdatedAt()
	case banapp.FieldDeletedAt:
		return m.DeletedAt()
	case banapp.FieldEntID:
		return m.EntID()
	case banapp.FieldAppID:
		return m.AppID()
	case banapp.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banapp.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case banapp.FieldEntID:
		return m.OldEntID(ctx)
	case banapp.FieldAppID:
		return m.OldAppID(ctx)
	case banapp.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown BanApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banapp.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banapp.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banapp.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case banapp.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case banapp.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case banapp.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown BanApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanAppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, banapp.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, banapp.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, banapp.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.AddedCreatedAt()
	case banapp.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case banapp.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banapp.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case banapp.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case banapp.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanAppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanAppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BanApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanAppMutation) ResetField(name string) error {
	switch name {
	case banapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banapp.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case banapp.FieldEntID:
		m.ResetEntID()
		return nil
	case banapp.FieldAppID:
		m.ResetAppID()
		return nil
	case banapp.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown BanApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanAppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanAppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanAppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BanApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanAppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BanApp edge %s", name)
}

// BanAppUserMutation represents an operation that mutates the BanAppUser nodes in the graph.
type BanAppUserMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	message       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BanAppUser, error)
	predicates    []predicate.BanAppUser
}

var _ ent.Mutation = (*BanAppUserMutation)(nil)

// banappuserOption allows management of the mutation configuration using functional options.
type banappuserOption func(*BanAppUserMutation)

// newBanAppUserMutation creates new mutation for the BanAppUser entity.
func newBanAppUserMutation(c config, op Op, opts ...banappuserOption) *BanAppUserMutation {
	m := &BanAppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBanAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanAppUserID sets the ID field of the mutation.
func withBanAppUserID(id uint32) banappuserOption {
	return func(m *BanAppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BanAppUser
		)
		m.oldValue = func(ctx context.Context) (*BanAppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BanAppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanAppUser sets the old BanAppUser of the mutation.
func withBanAppUser(node *BanAppUser) banappuserOption {
	return func(m *BanAppUserMutation) {
		m.oldValue = func(context.Context) (*BanAppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanAppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanAppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BanAppUser entities.
func (m *BanAppUserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanAppUserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanAppUserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BanAppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BanAppUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BanAppUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *BanAppUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BanAppUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BanAppUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BanAppUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BanAppUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *BanAppUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BanAppUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BanAppUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BanAppUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BanAppUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *BanAppUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BanAppUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BanAppUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *BanAppUserMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *BanAppUserMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *BanAppUserMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *BanAppUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *BanAppUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *BanAppUserMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *BanAppUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BanAppUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BanAppUserMutation) ResetUserID() {
	m.user_id = nil
}

// SetMessage sets the "message" field.
func (m *BanAppUserMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BanAppUserMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BanAppUserMutation) ResetMessage() {
	m.message = nil
}

// Where appends a list predicates to the BanAppUserMutation builder.
func (m *BanAppUserMutation) Where(ps ...predicate.BanAppUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BanAppUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BanAppUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BanAppUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BanAppUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BanAppUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BanAppUser).
func (m *BanAppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanAppUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, banappuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banappuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, banappuser.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, banappuser.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, banappuser.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, banappuser.FieldUserID)
	}
	if m.message != nil {
		fields = append(fields, banappuser.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanAppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.CreatedAt()
	case banappuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case banappuser.FieldDeletedAt:
		return m.DeletedAt()
	case banappuser.FieldEntID:
		return m.EntID()
	case banappuser.FieldAppID:
		return m.AppID()
	case banappuser.FieldUserID:
		return m.UserID()
	case banappuser.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanAppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banappuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banappuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case banappuser.FieldEntID:
		return m.OldEntID(ctx)
	case banappuser.FieldAppID:
		return m.OldAppID(ctx)
	case banappuser.FieldUserID:
		return m.OldUserID(ctx)
	case banappuser.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown BanAppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banappuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banappuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banappuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case banappuser.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case banappuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case banappuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case banappuser.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown BanAppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanAppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, banappuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, banappuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, banappuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanAppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case banappuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case banappuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banappuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case banappuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case banappuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanAppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanAppUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanAppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanAppUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BanAppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanAppUserMutation) ResetField(name string) error {
	switch name {
	case banappuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banappuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banappuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case banappuser.FieldEntID:
		m.ResetEntID()
		return nil
	case banappuser.FieldAppID:
		m.ResetAppID()
		return nil
	case banappuser.FieldUserID:
		m.ResetUserID()
		return nil
	case banappuser.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown BanAppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanAppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanAppUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanAppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanAppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanAppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanAppUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanAppUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BanAppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanAppUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BanAppUser edge %s", name)
}

// KycMutation represents an operation that mutates the Kyc nodes in the graph.
type KycMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	document_type *string
	id_number     *string
	front_img     *string
	back_img      *string
	selfie_img    *string
	entity_type   *string
	review_id     *uuid.UUID
	state         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Kyc, error)
	predicates    []predicate.Kyc
}

var _ ent.Mutation = (*KycMutation)(nil)

// kycOption allows management of the mutation configuration using functional options.
type kycOption func(*KycMutation)

// newKycMutation creates new mutation for the Kyc entity.
func newKycMutation(c config, op Op, opts ...kycOption) *KycMutation {
	m := &KycMutation{
		config:        c,
		op:            op,
		typ:           TypeKyc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKycID sets the ID field of the mutation.
func withKycID(id uint32) kycOption {
	return func(m *KycMutation) {
		var (
			err   error
			once  sync.Once
			value *Kyc
		)
		m.oldValue = func(ctx context.Context) (*Kyc, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Kyc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKyc sets the old Kyc of the mutation.
func withKyc(node *Kyc) kycOption {
	return func(m *KycMutation) {
		m.oldValue = func(context.Context) (*Kyc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KycMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KycMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Kyc entities.
func (m *KycMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KycMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KycMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Kyc.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *KycMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KycMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *KycMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *KycMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KycMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KycMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KycMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *KycMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *KycMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KycMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KycMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KycMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *KycMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *KycMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KycMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *KycMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *KycMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *KycMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *KycMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *KycMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *KycMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[kyc.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *KycMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[kyc.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *KycMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, kyc.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *KycMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *KycMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *KycMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[kyc.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *KycMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[kyc.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *KycMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, kyc.FieldUserID)
}

// SetDocumentType sets the "document_type" field.
func (m *KycMutation) SetDocumentType(s string) {
	m.document_type = &s
}

// DocumentType returns the value of the "document_type" field in the mutation.
func (m *KycMutation) DocumentType() (r string, exists bool) {
	v := m.document_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentType returns the old "document_type" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldDocumentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentType: %w", err)
	}
	return oldValue.DocumentType, nil
}

// ClearDocumentType clears the value of the "document_type" field.
func (m *KycMutation) ClearDocumentType() {
	m.document_type = nil
	m.clearedFields[kyc.FieldDocumentType] = struct{}{}
}

// DocumentTypeCleared returns if the "document_type" field was cleared in this mutation.
func (m *KycMutation) DocumentTypeCleared() bool {
	_, ok := m.clearedFields[kyc.FieldDocumentType]
	return ok
}

// ResetDocumentType resets all changes to the "document_type" field.
func (m *KycMutation) ResetDocumentType() {
	m.document_type = nil
	delete(m.clearedFields, kyc.FieldDocumentType)
}

// SetIDNumber sets the "id_number" field.
func (m *KycMutation) SetIDNumber(s string) {
	m.id_number = &s
}

// IDNumber returns the value of the "id_number" field in the mutation.
func (m *KycMutation) IDNumber() (r string, exists bool) {
	v := m.id_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDNumber returns the old "id_number" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldIDNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDNumber: %w", err)
	}
	return oldValue.IDNumber, nil
}

// ClearIDNumber clears the value of the "id_number" field.
func (m *KycMutation) ClearIDNumber() {
	m.id_number = nil
	m.clearedFields[kyc.FieldIDNumber] = struct{}{}
}

// IDNumberCleared returns if the "id_number" field was cleared in this mutation.
func (m *KycMutation) IDNumberCleared() bool {
	_, ok := m.clearedFields[kyc.FieldIDNumber]
	return ok
}

// ResetIDNumber resets all changes to the "id_number" field.
func (m *KycMutation) ResetIDNumber() {
	m.id_number = nil
	delete(m.clearedFields, kyc.FieldIDNumber)
}

// SetFrontImg sets the "front_img" field.
func (m *KycMutation) SetFrontImg(s string) {
	m.front_img = &s
}

// FrontImg returns the value of the "front_img" field in the mutation.
func (m *KycMutation) FrontImg() (r string, exists bool) {
	v := m.front_img
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontImg returns the old "front_img" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldFrontImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontImg: %w", err)
	}
	return oldValue.FrontImg, nil
}

// ClearFrontImg clears the value of the "front_img" field.
func (m *KycMutation) ClearFrontImg() {
	m.front_img = nil
	m.clearedFields[kyc.FieldFrontImg] = struct{}{}
}

// FrontImgCleared returns if the "front_img" field was cleared in this mutation.
func (m *KycMutation) FrontImgCleared() bool {
	_, ok := m.clearedFields[kyc.FieldFrontImg]
	return ok
}

// ResetFrontImg resets all changes to the "front_img" field.
func (m *KycMutation) ResetFrontImg() {
	m.front_img = nil
	delete(m.clearedFields, kyc.FieldFrontImg)
}

// SetBackImg sets the "back_img" field.
func (m *KycMutation) SetBackImg(s string) {
	m.back_img = &s
}

// BackImg returns the value of the "back_img" field in the mutation.
func (m *KycMutation) BackImg() (r string, exists bool) {
	v := m.back_img
	if v == nil {
		return
	}
	return *v, true
}

// OldBackImg returns the old "back_img" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldBackImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackImg: %w", err)
	}
	return oldValue.BackImg, nil
}

// ClearBackImg clears the value of the "back_img" field.
func (m *KycMutation) ClearBackImg() {
	m.back_img = nil
	m.clearedFields[kyc.FieldBackImg] = struct{}{}
}

// BackImgCleared returns if the "back_img" field was cleared in this mutation.
func (m *KycMutation) BackImgCleared() bool {
	_, ok := m.clearedFields[kyc.FieldBackImg]
	return ok
}

// ResetBackImg resets all changes to the "back_img" field.
func (m *KycMutation) ResetBackImg() {
	m.back_img = nil
	delete(m.clearedFields, kyc.FieldBackImg)
}

// SetSelfieImg sets the "selfie_img" field.
func (m *KycMutation) SetSelfieImg(s string) {
	m.selfie_img = &s
}

// SelfieImg returns the value of the "selfie_img" field in the mutation.
func (m *KycMutation) SelfieImg() (r string, exists bool) {
	v := m.selfie_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfieImg returns the old "selfie_img" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldSelfieImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfieImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfieImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfieImg: %w", err)
	}
	return oldValue.SelfieImg, nil
}

// ClearSelfieImg clears the value of the "selfie_img" field.
func (m *KycMutation) ClearSelfieImg() {
	m.selfie_img = nil
	m.clearedFields[kyc.FieldSelfieImg] = struct{}{}
}

// SelfieImgCleared returns if the "selfie_img" field was cleared in this mutation.
func (m *KycMutation) SelfieImgCleared() bool {
	_, ok := m.clearedFields[kyc.FieldSelfieImg]
	return ok
}

// ResetSelfieImg resets all changes to the "selfie_img" field.
func (m *KycMutation) ResetSelfieImg() {
	m.selfie_img = nil
	delete(m.clearedFields, kyc.FieldSelfieImg)
}

// SetEntityType sets the "entity_type" field.
func (m *KycMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *KycMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ClearEntityType clears the value of the "entity_type" field.
func (m *KycMutation) ClearEntityType() {
	m.entity_type = nil
	m.clearedFields[kyc.FieldEntityType] = struct{}{}
}

// EntityTypeCleared returns if the "entity_type" field was cleared in this mutation.
func (m *KycMutation) EntityTypeCleared() bool {
	_, ok := m.clearedFields[kyc.FieldEntityType]
	return ok
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *KycMutation) ResetEntityType() {
	m.entity_type = nil
	delete(m.clearedFields, kyc.FieldEntityType)
}

// SetReviewID sets the "review_id" field.
func (m *KycMutation) SetReviewID(u uuid.UUID) {
	m.review_id = &u
}

// ReviewID returns the value of the "review_id" field in the mutation.
func (m *KycMutation) ReviewID() (r uuid.UUID, exists bool) {
	v := m.review_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewID returns the old "review_id" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldReviewID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewID: %w", err)
	}
	return oldValue.ReviewID, nil
}

// ClearReviewID clears the value of the "review_id" field.
func (m *KycMutation) ClearReviewID() {
	m.review_id = nil
	m.clearedFields[kyc.FieldReviewID] = struct{}{}
}

// ReviewIDCleared returns if the "review_id" field was cleared in this mutation.
func (m *KycMutation) ReviewIDCleared() bool {
	_, ok := m.clearedFields[kyc.FieldReviewID]
	return ok
}

// ResetReviewID resets all changes to the "review_id" field.
func (m *KycMutation) ResetReviewID() {
	m.review_id = nil
	delete(m.clearedFields, kyc.FieldReviewID)
}

// SetState sets the "state" field.
func (m *KycMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *KycMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *KycMutation) ClearState() {
	m.state = nil
	m.clearedFields[kyc.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *KycMutation) StateCleared() bool {
	_, ok := m.clearedFields[kyc.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *KycMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, kyc.FieldState)
}

// Where appends a list predicates to the KycMutation builder.
func (m *KycMutation) Where(ps ...predicate.Kyc) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KycMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KycMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Kyc, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KycMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KycMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Kyc).
func (m *KycMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KycMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, kyc.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kyc.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kyc.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, kyc.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, kyc.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, kyc.FieldUserID)
	}
	if m.document_type != nil {
		fields = append(fields, kyc.FieldDocumentType)
	}
	if m.id_number != nil {
		fields = append(fields, kyc.FieldIDNumber)
	}
	if m.front_img != nil {
		fields = append(fields, kyc.FieldFrontImg)
	}
	if m.back_img != nil {
		fields = append(fields, kyc.FieldBackImg)
	}
	if m.selfie_img != nil {
		fields = append(fields, kyc.FieldSelfieImg)
	}
	if m.entity_type != nil {
		fields = append(fields, kyc.FieldEntityType)
	}
	if m.review_id != nil {
		fields = append(fields, kyc.FieldReviewID)
	}
	if m.state != nil {
		fields = append(fields, kyc.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KycMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kyc.FieldCreatedAt:
		return m.CreatedAt()
	case kyc.FieldUpdatedAt:
		return m.UpdatedAt()
	case kyc.FieldDeletedAt:
		return m.DeletedAt()
	case kyc.FieldEntID:
		return m.EntID()
	case kyc.FieldAppID:
		return m.AppID()
	case kyc.FieldUserID:
		return m.UserID()
	case kyc.FieldDocumentType:
		return m.DocumentType()
	case kyc.FieldIDNumber:
		return m.IDNumber()
	case kyc.FieldFrontImg:
		return m.FrontImg()
	case kyc.FieldBackImg:
		return m.BackImg()
	case kyc.FieldSelfieImg:
		return m.SelfieImg()
	case kyc.FieldEntityType:
		return m.EntityType()
	case kyc.FieldReviewID:
		return m.ReviewID()
	case kyc.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KycMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kyc.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kyc.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kyc.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kyc.FieldEntID:
		return m.OldEntID(ctx)
	case kyc.FieldAppID:
		return m.OldAppID(ctx)
	case kyc.FieldUserID:
		return m.OldUserID(ctx)
	case kyc.FieldDocumentType:
		return m.OldDocumentType(ctx)
	case kyc.FieldIDNumber:
		return m.OldIDNumber(ctx)
	case kyc.FieldFrontImg:
		return m.OldFrontImg(ctx)
	case kyc.FieldBackImg:
		return m.OldBackImg(ctx)
	case kyc.FieldSelfieImg:
		return m.OldSelfieImg(ctx)
	case kyc.FieldEntityType:
		return m.OldEntityType(ctx)
	case kyc.FieldReviewID:
		return m.OldReviewID(ctx)
	case kyc.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Kyc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KycMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kyc.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kyc.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kyc.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kyc.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case kyc.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case kyc.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case kyc.FieldDocumentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentType(v)
		return nil
	case kyc.FieldIDNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDNumber(v)
		return nil
	case kyc.FieldFrontImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontImg(v)
		return nil
	case kyc.FieldBackImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackImg(v)
		return nil
	case kyc.FieldSelfieImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfieImg(v)
		return nil
	case kyc.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case kyc.FieldReviewID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewID(v)
		return nil
	case kyc.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Kyc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KycMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, kyc.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, kyc.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, kyc.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KycMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kyc.FieldCreatedAt:
		return m.AddedCreatedAt()
	case kyc.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case kyc.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KycMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kyc.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case kyc.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case kyc.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Kyc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KycMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kyc.FieldAppID) {
		fields = append(fields, kyc.FieldAppID)
	}
	if m.FieldCleared(kyc.FieldUserID) {
		fields = append(fields, kyc.FieldUserID)
	}
	if m.FieldCleared(kyc.FieldDocumentType) {
		fields = append(fields, kyc.FieldDocumentType)
	}
	if m.FieldCleared(kyc.FieldIDNumber) {
		fields = append(fields, kyc.FieldIDNumber)
	}
	if m.FieldCleared(kyc.FieldFrontImg) {
		fields = append(fields, kyc.FieldFrontImg)
	}
	if m.FieldCleared(kyc.FieldBackImg) {
		fields = append(fields, kyc.FieldBackImg)
	}
	if m.FieldCleared(kyc.FieldSelfieImg) {
		fields = append(fields, kyc.FieldSelfieImg)
	}
	if m.FieldCleared(kyc.FieldEntityType) {
		fields = append(fields, kyc.FieldEntityType)
	}
	if m.FieldCleared(kyc.FieldReviewID) {
		fields = append(fields, kyc.FieldReviewID)
	}
	if m.FieldCleared(kyc.FieldState) {
		fields = append(fields, kyc.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KycMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KycMutation) ClearField(name string) error {
	switch name {
	case kyc.FieldAppID:
		m.ClearAppID()
		return nil
	case kyc.FieldUserID:
		m.ClearUserID()
		return nil
	case kyc.FieldDocumentType:
		m.ClearDocumentType()
		return nil
	case kyc.FieldIDNumber:
		m.ClearIDNumber()
		return nil
	case kyc.FieldFrontImg:
		m.ClearFrontImg()
		return nil
	case kyc.FieldBackImg:
		m.ClearBackImg()
		return nil
	case kyc.FieldSelfieImg:
		m.ClearSelfieImg()
		return nil
	case kyc.FieldEntityType:
		m.ClearEntityType()
		return nil
	case kyc.FieldReviewID:
		m.ClearReviewID()
		return nil
	case kyc.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown Kyc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KycMutation) ResetField(name string) error {
	switch name {
	case kyc.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kyc.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kyc.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kyc.FieldEntID:
		m.ResetEntID()
		return nil
	case kyc.FieldAppID:
		m.ResetAppID()
		return nil
	case kyc.FieldUserID:
		m.ResetUserID()
		return nil
	case kyc.FieldDocumentType:
		m.ResetDocumentType()
		return nil
	case kyc.FieldIDNumber:
		m.ResetIDNumber()
		return nil
	case kyc.FieldFrontImg:
		m.ResetFrontImg()
		return nil
	case kyc.FieldBackImg:
		m.ResetBackImg()
		return nil
	case kyc.FieldSelfieImg:
		m.ResetSelfieImg()
		return nil
	case kyc.FieldEntityType:
		m.ResetEntityType()
		return nil
	case kyc.FieldReviewID:
		m.ResetReviewID()
		return nil
	case kyc.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Kyc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KycMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KycMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KycMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KycMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KycMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KycMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KycMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Kyc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KycMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Kyc edge %s", name)
}

// LoginHistoryMutation represents an operation that mutates the LoginHistory nodes in the graph.
type LoginHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	client_ip     *string
	user_agent    *string
	location      *string
	login_type    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LoginHistory, error)
	predicates    []predicate.LoginHistory
}

var _ ent.Mutation = (*LoginHistoryMutation)(nil)

// loginhistoryOption allows management of the mutation configuration using functional options.
type loginhistoryOption func(*LoginHistoryMutation)

// newLoginHistoryMutation creates new mutation for the LoginHistory entity.
func newLoginHistoryMutation(c config, op Op, opts ...loginhistoryOption) *LoginHistoryMutation {
	m := &LoginHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginHistoryID sets the ID field of the mutation.
func withLoginHistoryID(id uint32) loginhistoryOption {
	return func(m *LoginHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginHistory
		)
		m.oldValue = func(ctx context.Context) (*LoginHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginHistory sets the old LoginHistory of the mutation.
func withLoginHistory(node *LoginHistory) loginhistoryOption {
	return func(m *LoginHistoryMutation) {
		m.oldValue = func(context.Context) (*LoginHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginHistory entities.
func (m *LoginHistoryMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginHistoryMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginHistoryMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginHistoryMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginHistoryMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *LoginHistoryMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *LoginHistoryMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoginHistoryMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoginHistoryMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *LoginHistoryMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *LoginHistoryMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoginHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LoginHistoryMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LoginHistoryMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *LoginHistoryMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *LoginHistoryMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LoginHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *LoginHistoryMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *LoginHistoryMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *LoginHistoryMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *LoginHistoryMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *LoginHistoryMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *LoginHistoryMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[loginhistory.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *LoginHistoryMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *LoginHistoryMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, loginhistory.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *LoginHistoryMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LoginHistoryMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *LoginHistoryMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[loginhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *LoginHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LoginHistoryMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, loginhistory.FieldUserID)
}

// SetClientIP sets the "client_ip" field.
func (m *LoginHistoryMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *LoginHistoryMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ClearClientIP clears the value of the "client_ip" field.
func (m *LoginHistoryMutation) ClearClientIP() {
	m.client_ip = nil
	m.clearedFields[loginhistory.FieldClientIP] = struct{}{}
}

// ClientIPCleared returns if the "client_ip" field was cleared in this mutation.
func (m *LoginHistoryMutation) ClientIPCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldClientIP]
	return ok
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *LoginHistoryMutation) ResetClientIP() {
	m.client_ip = nil
	delete(m.clearedFields, loginhistory.FieldClientIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LoginHistoryMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LoginHistoryMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LoginHistoryMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[loginhistory.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LoginHistoryMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LoginHistoryMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, loginhistory.FieldUserAgent)
}

// SetLocation sets the "location" field.
func (m *LoginHistoryMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *LoginHistoryMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *LoginHistoryMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[loginhistory.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *LoginHistoryMutation) LocationCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *LoginHistoryMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, loginhistory.FieldLocation)
}

// SetLoginType sets the "login_type" field.
func (m *LoginHistoryMutation) SetLoginType(s string) {
	m.login_type = &s
}

// LoginType returns the value of the "login_type" field in the mutation.
func (m *LoginHistoryMutation) LoginType() (r string, exists bool) {
	v := m.login_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginType returns the old "login_type" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldLoginType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginType: %w", err)
	}
	return oldValue.LoginType, nil
}

// ClearLoginType clears the value of the "login_type" field.
func (m *LoginHistoryMutation) ClearLoginType() {
	m.login_type = nil
	m.clearedFields[loginhistory.FieldLoginType] = struct{}{}
}

// LoginTypeCleared returns if the "login_type" field was cleared in this mutation.
func (m *LoginHistoryMutation) LoginTypeCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldLoginType]
	return ok
}

// ResetLoginType resets all changes to the "login_type" field.
func (m *LoginHistoryMutation) ResetLoginType() {
	m.login_type = nil
	delete(m.clearedFields, loginhistory.FieldLoginType)
}

// Where appends a list predicates to the LoginHistoryMutation builder.
func (m *LoginHistoryMutation) Where(ps ...predicate.LoginHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginHistory).
func (m *LoginHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, loginhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loginhistory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, loginhistory.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, loginhistory.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, loginhistory.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, loginhistory.FieldUserID)
	}
	if m.client_ip != nil {
		fields = append(fields, loginhistory.FieldClientIP)
	}
	if m.user_agent != nil {
		fields = append(fields, loginhistory.FieldUserAgent)
	}
	if m.location != nil {
		fields = append(fields, loginhistory.FieldLocation)
	}
	if m.login_type != nil {
		fields = append(fields, loginhistory.FieldLoginType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginhistory.FieldCreatedAt:
		return m.CreatedAt()
	case loginhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case loginhistory.FieldDeletedAt:
		return m.DeletedAt()
	case loginhistory.FieldEntID:
		return m.EntID()
	case loginhistory.FieldAppID:
		return m.AppID()
	case loginhistory.FieldUserID:
		return m.UserID()
	case loginhistory.FieldClientIP:
		return m.ClientIP()
	case loginhistory.FieldUserAgent:
		return m.UserAgent()
	case loginhistory.FieldLocation:
		return m.Location()
	case loginhistory.FieldLoginType:
		return m.LoginType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loginhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case loginhistory.FieldEntID:
		return m.OldEntID(ctx)
	case loginhistory.FieldAppID:
		return m.OldAppID(ctx)
	case loginhistory.FieldUserID:
		return m.OldUserID(ctx)
	case loginhistory.FieldClientIP:
		return m.OldClientIP(ctx)
	case loginhistory.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case loginhistory.FieldLocation:
		return m.OldLocation(ctx)
	case loginhistory.FieldLoginType:
		return m.OldLoginType(ctx)
	}
	return nil, fmt.Errorf("unknown LoginHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginhistory.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginhistory.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loginhistory.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case loginhistory.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case loginhistory.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case loginhistory.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case loginhistory.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case loginhistory.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case loginhistory.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case loginhistory.FieldLoginType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginType(v)
		return nil
	}
	return fmt.Errorf("unknown LoginHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, loginhistory.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, loginhistory.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, loginhistory.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loginhistory.FieldCreatedAt:
		return m.AddedCreatedAt()
	case loginhistory.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case loginhistory.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loginhistory.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case loginhistory.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case loginhistory.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LoginHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginhistory.FieldAppID) {
		fields = append(fields, loginhistory.FieldAppID)
	}
	if m.FieldCleared(loginhistory.FieldUserID) {
		fields = append(fields, loginhistory.FieldUserID)
	}
	if m.FieldCleared(loginhistory.FieldClientIP) {
		fields = append(fields, loginhistory.FieldClientIP)
	}
	if m.FieldCleared(loginhistory.FieldUserAgent) {
		fields = append(fields, loginhistory.FieldUserAgent)
	}
	if m.FieldCleared(loginhistory.FieldLocation) {
		fields = append(fields, loginhistory.FieldLocation)
	}
	if m.FieldCleared(loginhistory.FieldLoginType) {
		fields = append(fields, loginhistory.FieldLoginType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginHistoryMutation) ClearField(name string) error {
	switch name {
	case loginhistory.FieldAppID:
		m.ClearAppID()
		return nil
	case loginhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case loginhistory.FieldClientIP:
		m.ClearClientIP()
		return nil
	case loginhistory.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case loginhistory.FieldLocation:
		m.ClearLocation()
		return nil
	case loginhistory.FieldLoginType:
		m.ClearLoginType()
		return nil
	}
	return fmt.Errorf("unknown LoginHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginHistoryMutation) ResetField(name string) error {
	switch name {
	case loginhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loginhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case loginhistory.FieldEntID:
		m.ResetEntID()
		return nil
	case loginhistory.FieldAppID:
		m.ResetAppID()
		return nil
	case loginhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case loginhistory.FieldClientIP:
		m.ResetClientIP()
		return nil
	case loginhistory.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case loginhistory.FieldLocation:
		m.ResetLocation()
		return nil
	case loginhistory.FieldLoginType:
		m.ResetLoginType()
		return nil
	}
	return fmt.Errorf("unknown LoginHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoginHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoginHistory edge %s", name)
}

// OAuthThirdPartyMutation represents an operation that mutates the OAuthThirdParty nodes in the graph.
type OAuthThirdPartyMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	ent_id           *uuid.UUID
	client_name      *string
	client_tag       *string
	client_logo_url  *string
	client_oauth_url *string
	response_type    *string
	scope            *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*OAuthThirdParty, error)
	predicates       []predicate.OAuthThirdParty
}

var _ ent.Mutation = (*OAuthThirdPartyMutation)(nil)

// oauththirdpartyOption allows management of the mutation configuration using functional options.
type oauththirdpartyOption func(*OAuthThirdPartyMutation)

// newOAuthThirdPartyMutation creates new mutation for the OAuthThirdParty entity.
func newOAuthThirdPartyMutation(c config, op Op, opts ...oauththirdpartyOption) *OAuthThirdPartyMutation {
	m := &OAuthThirdPartyMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthThirdParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthThirdPartyID sets the ID field of the mutation.
func withOAuthThirdPartyID(id uint32) oauththirdpartyOption {
	return func(m *OAuthThirdPartyMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthThirdParty
		)
		m.oldValue = func(ctx context.Context) (*OAuthThirdParty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthThirdParty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthThirdParty sets the old OAuthThirdParty of the mutation.
func withOAuthThirdParty(node *OAuthThirdParty) oauththirdpartyOption {
	return func(m *OAuthThirdPartyMutation) {
		m.oldValue = func(context.Context) (*OAuthThirdParty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthThirdPartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthThirdPartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthThirdParty entities.
func (m *OAuthThirdPartyMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthThirdPartyMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthThirdPartyMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthThirdParty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthThirdPartyMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthThirdPartyMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *OAuthThirdPartyMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *OAuthThirdPartyMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthThirdPartyMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthThirdPartyMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthThirdPartyMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *OAuthThirdPartyMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *OAuthThirdPartyMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthThirdPartyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OAuthThirdPartyMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OAuthThirdPartyMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *OAuthThirdPartyMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OAuthThirdPartyMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OAuthThirdPartyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *OAuthThirdPartyMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *OAuthThirdPartyMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *OAuthThirdPartyMutation) ResetEntID() {
	m.ent_id = nil
}

// SetClientName sets the "client_name" field.
func (m *OAuthThirdPartyMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *OAuthThirdPartyMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ClearClientName clears the value of the "client_name" field.
func (m *OAuthThirdPartyMutation) ClearClientName() {
	m.client_name = nil
	m.clearedFields[oauththirdparty.FieldClientName] = struct{}{}
}

// ClientNameCleared returns if the "client_name" field was cleared in this mutation.
func (m *OAuthThirdPartyMutation) ClientNameCleared() bool {
	_, ok := m.clearedFields[oauththirdparty.FieldClientName]
	return ok
}

// ResetClientName resets all changes to the "client_name" field.
func (m *OAuthThirdPartyMutation) ResetClientName() {
	m.client_name = nil
	delete(m.clearedFields, oauththirdparty.FieldClientName)
}

// SetClientTag sets the "client_tag" field.
func (m *OAuthThirdPartyMutation) SetClientTag(s string) {
	m.client_tag = &s
}

// ClientTag returns the value of the "client_tag" field in the mutation.
func (m *OAuthThirdPartyMutation) ClientTag() (r string, exists bool) {
	v := m.client_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTag returns the old "client_tag" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldClientTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTag: %w", err)
	}
	return oldValue.ClientTag, nil
}

// ClearClientTag clears the value of the "client_tag" field.
func (m *OAuthThirdPartyMutation) ClearClientTag() {
	m.client_tag = nil
	m.clearedFields[oauththirdparty.FieldClientTag] = struct{}{}
}

// ClientTagCleared returns if the "client_tag" field was cleared in this mutation.
func (m *OAuthThirdPartyMutation) ClientTagCleared() bool {
	_, ok := m.clearedFields[oauththirdparty.FieldClientTag]
	return ok
}

// ResetClientTag resets all changes to the "client_tag" field.
func (m *OAuthThirdPartyMutation) ResetClientTag() {
	m.client_tag = nil
	delete(m.clearedFields, oauththirdparty.FieldClientTag)
}

// SetClientLogoURL sets the "client_logo_url" field.
func (m *OAuthThirdPartyMutation) SetClientLogoURL(s string) {
	m.client_logo_url = &s
}

// ClientLogoURL returns the value of the "client_logo_url" field in the mutation.
func (m *OAuthThirdPartyMutation) ClientLogoURL() (r string, exists bool) {
	v := m.client_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldClientLogoURL returns the old "client_logo_url" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldClientLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientLogoURL: %w", err)
	}
	return oldValue.ClientLogoURL, nil
}

// ClearClientLogoURL clears the value of the "client_logo_url" field.
func (m *OAuthThirdPartyMutation) ClearClientLogoURL() {
	m.client_logo_url = nil
	m.clearedFields[oauththirdparty.FieldClientLogoURL] = struct{}{}
}

// ClientLogoURLCleared returns if the "client_logo_url" field was cleared in this mutation.
func (m *OAuthThirdPartyMutation) ClientLogoURLCleared() bool {
	_, ok := m.clearedFields[oauththirdparty.FieldClientLogoURL]
	return ok
}

// ResetClientLogoURL resets all changes to the "client_logo_url" field.
func (m *OAuthThirdPartyMutation) ResetClientLogoURL() {
	m.client_logo_url = nil
	delete(m.clearedFields, oauththirdparty.FieldClientLogoURL)
}

// SetClientOauthURL sets the "client_oauth_url" field.
func (m *OAuthThirdPartyMutation) SetClientOauthURL(s string) {
	m.client_oauth_url = &s
}

// ClientOauthURL returns the value of the "client_oauth_url" field in the mutation.
func (m *OAuthThirdPartyMutation) ClientOauthURL() (r string, exists bool) {
	v := m.client_oauth_url
	if v == nil {
		return
	}
	return *v, true
}

// OldClientOauthURL returns the old "client_oauth_url" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldClientOauthURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientOauthURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientOauthURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientOauthURL: %w", err)
	}
	return oldValue.ClientOauthURL, nil
}

// ClearClientOauthURL clears the value of the "client_oauth_url" field.
func (m *OAuthThirdPartyMutation) ClearClientOauthURL() {
	m.client_oauth_url = nil
	m.clearedFields[oauththirdparty.FieldClientOauthURL] = struct{}{}
}

// ClientOauthURLCleared returns if the "client_oauth_url" field was cleared in this mutation.
func (m *OAuthThirdPartyMutation) ClientOauthURLCleared() bool {
	_, ok := m.clearedFields[oauththirdparty.FieldClientOauthURL]
	return ok
}

// ResetClientOauthURL resets all changes to the "client_oauth_url" field.
func (m *OAuthThirdPartyMutation) ResetClientOauthURL() {
	m.client_oauth_url = nil
	delete(m.clearedFields, oauththirdparty.FieldClientOauthURL)
}

// SetResponseType sets the "response_type" field.
func (m *OAuthThirdPartyMutation) SetResponseType(s string) {
	m.response_type = &s
}

// ResponseType returns the value of the "response_type" field in the mutation.
func (m *OAuthThirdPartyMutation) ResponseType() (r string, exists bool) {
	v := m.response_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseType returns the old "response_type" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldResponseType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseType: %w", err)
	}
	return oldValue.ResponseType, nil
}

// ClearResponseType clears the value of the "response_type" field.
func (m *OAuthThirdPartyMutation) ClearResponseType() {
	m.response_type = nil
	m.clearedFields[oauththirdparty.FieldResponseType] = struct{}{}
}

// ResponseTypeCleared returns if the "response_type" field was cleared in this mutation.
func (m *OAuthThirdPartyMutation) ResponseTypeCleared() bool {
	_, ok := m.clearedFields[oauththirdparty.FieldResponseType]
	return ok
}

// ResetResponseType resets all changes to the "response_type" field.
func (m *OAuthThirdPartyMutation) ResetResponseType() {
	m.response_type = nil
	delete(m.clearedFields, oauththirdparty.FieldResponseType)
}

// SetScope sets the "scope" field.
func (m *OAuthThirdPartyMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *OAuthThirdPartyMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the OAuthThirdParty entity.
// If the OAuthThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthThirdPartyMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ClearScope clears the value of the "scope" field.
func (m *OAuthThirdPartyMutation) ClearScope() {
	m.scope = nil
	m.clearedFields[oauththirdparty.FieldScope] = struct{}{}
}

// ScopeCleared returns if the "scope" field was cleared in this mutation.
func (m *OAuthThirdPartyMutation) ScopeCleared() bool {
	_, ok := m.clearedFields[oauththirdparty.FieldScope]
	return ok
}

// ResetScope resets all changes to the "scope" field.
func (m *OAuthThirdPartyMutation) ResetScope() {
	m.scope = nil
	delete(m.clearedFields, oauththirdparty.FieldScope)
}

// Where appends a list predicates to the OAuthThirdPartyMutation builder.
func (m *OAuthThirdPartyMutation) Where(ps ...predicate.OAuthThirdParty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthThirdPartyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthThirdPartyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthThirdParty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthThirdPartyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthThirdPartyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthThirdParty).
func (m *OAuthThirdPartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthThirdPartyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, oauththirdparty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauththirdparty.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, oauththirdparty.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, oauththirdparty.FieldEntID)
	}
	if m.client_name != nil {
		fields = append(fields, oauththirdparty.FieldClientName)
	}
	if m.client_tag != nil {
		fields = append(fields, oauththirdparty.FieldClientTag)
	}
	if m.client_logo_url != nil {
		fields = append(fields, oauththirdparty.FieldClientLogoURL)
	}
	if m.client_oauth_url != nil {
		fields = append(fields, oauththirdparty.FieldClientOauthURL)
	}
	if m.response_type != nil {
		fields = append(fields, oauththirdparty.FieldResponseType)
	}
	if m.scope != nil {
		fields = append(fields, oauththirdparty.FieldScope)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthThirdPartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauththirdparty.FieldCreatedAt:
		return m.CreatedAt()
	case oauththirdparty.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauththirdparty.FieldDeletedAt:
		return m.DeletedAt()
	case oauththirdparty.FieldEntID:
		return m.EntID()
	case oauththirdparty.FieldClientName:
		return m.ClientName()
	case oauththirdparty.FieldClientTag:
		return m.ClientTag()
	case oauththirdparty.FieldClientLogoURL:
		return m.ClientLogoURL()
	case oauththirdparty.FieldClientOauthURL:
		return m.ClientOauthURL()
	case oauththirdparty.FieldResponseType:
		return m.ResponseType()
	case oauththirdparty.FieldScope:
		return m.Scope()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthThirdPartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauththirdparty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauththirdparty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauththirdparty.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case oauththirdparty.FieldEntID:
		return m.OldEntID(ctx)
	case oauththirdparty.FieldClientName:
		return m.OldClientName(ctx)
	case oauththirdparty.FieldClientTag:
		return m.OldClientTag(ctx)
	case oauththirdparty.FieldClientLogoURL:
		return m.OldClientLogoURL(ctx)
	case oauththirdparty.FieldClientOauthURL:
		return m.OldClientOauthURL(ctx)
	case oauththirdparty.FieldResponseType:
		return m.OldResponseType(ctx)
	case oauththirdparty.FieldScope:
		return m.OldScope(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthThirdParty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthThirdPartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauththirdparty.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauththirdparty.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauththirdparty.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case oauththirdparty.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case oauththirdparty.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case oauththirdparty.FieldClientTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTag(v)
		return nil
	case oauththirdparty.FieldClientLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientLogoURL(v)
		return nil
	case oauththirdparty.FieldClientOauthURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientOauthURL(v)
		return nil
	case oauththirdparty.FieldResponseType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseType(v)
		return nil
	case oauththirdparty.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthThirdParty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthThirdPartyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, oauththirdparty.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, oauththirdparty.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, oauththirdparty.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthThirdPartyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauththirdparty.FieldCreatedAt:
		return m.AddedCreatedAt()
	case oauththirdparty.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case oauththirdparty.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthThirdPartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauththirdparty.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case oauththirdparty.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case oauththirdparty.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthThirdParty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthThirdPartyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauththirdparty.FieldClientName) {
		fields = append(fields, oauththirdparty.FieldClientName)
	}
	if m.FieldCleared(oauththirdparty.FieldClientTag) {
		fields = append(fields, oauththirdparty.FieldClientTag)
	}
	if m.FieldCleared(oauththirdparty.FieldClientLogoURL) {
		fields = append(fields, oauththirdparty.FieldClientLogoURL)
	}
	if m.FieldCleared(oauththirdparty.FieldClientOauthURL) {
		fields = append(fields, oauththirdparty.FieldClientOauthURL)
	}
	if m.FieldCleared(oauththirdparty.FieldResponseType) {
		fields = append(fields, oauththirdparty.FieldResponseType)
	}
	if m.FieldCleared(oauththirdparty.FieldScope) {
		fields = append(fields, oauththirdparty.FieldScope)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthThirdPartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthThirdPartyMutation) ClearField(name string) error {
	switch name {
	case oauththirdparty.FieldClientName:
		m.ClearClientName()
		return nil
	case oauththirdparty.FieldClientTag:
		m.ClearClientTag()
		return nil
	case oauththirdparty.FieldClientLogoURL:
		m.ClearClientLogoURL()
		return nil
	case oauththirdparty.FieldClientOauthURL:
		m.ClearClientOauthURL()
		return nil
	case oauththirdparty.FieldResponseType:
		m.ClearResponseType()
		return nil
	case oauththirdparty.FieldScope:
		m.ClearScope()
		return nil
	}
	return fmt.Errorf("unknown OAuthThirdParty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthThirdPartyMutation) ResetField(name string) error {
	switch name {
	case oauththirdparty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauththirdparty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauththirdparty.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case oauththirdparty.FieldEntID:
		m.ResetEntID()
		return nil
	case oauththirdparty.FieldClientName:
		m.ResetClientName()
		return nil
	case oauththirdparty.FieldClientTag:
		m.ResetClientTag()
		return nil
	case oauththirdparty.FieldClientLogoURL:
		m.ResetClientLogoURL()
		return nil
	case oauththirdparty.FieldClientOauthURL:
		m.ResetClientOauthURL()
		return nil
	case oauththirdparty.FieldResponseType:
		m.ResetResponseType()
		return nil
	case oauththirdparty.FieldScope:
		m.ResetScope()
		return nil
	}
	return fmt.Errorf("unknown OAuthThirdParty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthThirdPartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthThirdPartyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthThirdPartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthThirdPartyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthThirdPartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthThirdPartyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthThirdPartyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OAuthThirdParty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthThirdPartyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OAuthThirdParty edge %s", name)
}

// RecoveryCodeMutation represents an operation that mutates the RecoveryCode nodes in the graph.
type RecoveryCodeMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	code          *string
	used          *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RecoveryCode, error)
	predicates    []predicate.RecoveryCode
}

var _ ent.Mutation = (*RecoveryCodeMutation)(nil)

// recoverycodeOption allows management of the mutation configuration using functional options.
type recoverycodeOption func(*RecoveryCodeMutation)

// newRecoveryCodeMutation creates new mutation for the RecoveryCode entity.
func newRecoveryCodeMutation(c config, op Op, opts ...recoverycodeOption) *RecoveryCodeMutation {
	m := &RecoveryCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeRecoveryCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecoveryCodeID sets the ID field of the mutation.
func withRecoveryCodeID(id uint32) recoverycodeOption {
	return func(m *RecoveryCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *RecoveryCode
		)
		m.oldValue = func(ctx context.Context) (*RecoveryCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecoveryCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecoveryCode sets the old RecoveryCode of the mutation.
func withRecoveryCode(node *RecoveryCode) recoverycodeOption {
	return func(m *RecoveryCodeMutation) {
		m.oldValue = func(context.Context) (*RecoveryCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecoveryCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecoveryCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RecoveryCode entities.
func (m *RecoveryCodeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecoveryCodeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecoveryCodeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecoveryCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RecoveryCodeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecoveryCodeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RecoveryCodeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RecoveryCodeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecoveryCodeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecoveryCodeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecoveryCodeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RecoveryCodeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RecoveryCodeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecoveryCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RecoveryCodeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RecoveryCodeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RecoveryCodeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RecoveryCodeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RecoveryCodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *RecoveryCodeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *RecoveryCodeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *RecoveryCodeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *RecoveryCodeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *RecoveryCodeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *RecoveryCodeMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[recoverycode.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *RecoveryCodeMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[recoverycode.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *RecoveryCodeMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, recoverycode.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *RecoveryCodeMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RecoveryCodeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *RecoveryCodeMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[recoverycode.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *RecoveryCodeMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[recoverycode.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RecoveryCodeMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, recoverycode.FieldUserID)
}

// SetCode sets the "code" field.
func (m *RecoveryCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RecoveryCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *RecoveryCodeMutation) ClearCode() {
	m.code = nil
	m.clearedFields[recoverycode.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *RecoveryCodeMutation) CodeCleared() bool {
	_, ok := m.clearedFields[recoverycode.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *RecoveryCodeMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, recoverycode.FieldCode)
}

// SetUsed sets the "used" field.
func (m *RecoveryCodeMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *RecoveryCodeMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ClearUsed clears the value of the "used" field.
func (m *RecoveryCodeMutation) ClearUsed() {
	m.used = nil
	m.clearedFields[recoverycode.FieldUsed] = struct{}{}
}

// UsedCleared returns if the "used" field was cleared in this mutation.
func (m *RecoveryCodeMutation) UsedCleared() bool {
	_, ok := m.clearedFields[recoverycode.FieldUsed]
	return ok
}

// ResetUsed resets all changes to the "used" field.
func (m *RecoveryCodeMutation) ResetUsed() {
	m.used = nil
	delete(m.clearedFields, recoverycode.FieldUsed)
}

// Where appends a list predicates to the RecoveryCodeMutation builder.
func (m *RecoveryCodeMutation) Where(ps ...predicate.RecoveryCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecoveryCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecoveryCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecoveryCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecoveryCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecoveryCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecoveryCode).
func (m *RecoveryCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecoveryCodeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, recoverycode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recoverycode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, recoverycode.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, recoverycode.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, recoverycode.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, recoverycode.FieldUserID)
	}
	if m.code != nil {
		fields = append(fields, recoverycode.FieldCode)
	}
	if m.used != nil {
		fields = append(fields, recoverycode.FieldUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecoveryCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recoverycode.FieldCreatedAt:
		return m.CreatedAt()
	case recoverycode.FieldUpdatedAt:
		return m.UpdatedAt()
	case recoverycode.FieldDeletedAt:
		return m.DeletedAt()
	case recoverycode.FieldEntID:
		return m.EntID()
	case recoverycode.FieldAppID:
		return m.AppID()
	case recoverycode.FieldUserID:
		return m.UserID()
	case recoverycode.FieldCode:
		return m.Code()
	case recoverycode.FieldUsed:
		return m.Used()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecoveryCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recoverycode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recoverycode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recoverycode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case recoverycode.FieldEntID:
		return m.OldEntID(ctx)
	case recoverycode.FieldAppID:
		return m.OldAppID(ctx)
	case recoverycode.FieldUserID:
		return m.OldUserID(ctx)
	case recoverycode.FieldCode:
		return m.OldCode(ctx)
	case recoverycode.FieldUsed:
		return m.OldUsed(ctx)
	}
	return nil, fmt.Errorf("unknown RecoveryCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecoveryCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recoverycode.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recoverycode.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recoverycode.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case recoverycode.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case recoverycode.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case recoverycode.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case recoverycode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case recoverycode.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	}
	return fmt.Errorf("unknown RecoveryCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecoveryCodeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, recoverycode.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, recoverycode.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, recoverycode.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecoveryCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recoverycode.FieldCreatedAt:
		return m.AddedCreatedAt()
	case recoverycode.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case recoverycode.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecoveryCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recoverycode.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case recoverycode.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case recoverycode.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecoveryCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecoveryCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recoverycode.FieldAppID) {
		fields = append(fields, recoverycode.FieldAppID)
	}
	if m.FieldCleared(recoverycode.FieldUserID) {
		fields = append(fields, recoverycode.FieldUserID)
	}
	if m.FieldCleared(recoverycode.FieldCode) {
		fields = append(fields, recoverycode.FieldCode)
	}
	if m.FieldCleared(recoverycode.FieldUsed) {
		fields = append(fields, recoverycode.FieldUsed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecoveryCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecoveryCodeMutation) ClearField(name string) error {
	switch name {
	case recoverycode.FieldAppID:
		m.ClearAppID()
		return nil
	case recoverycode.FieldUserID:
		m.ClearUserID()
		return nil
	case recoverycode.FieldCode:
		m.ClearCode()
		return nil
	case recoverycode.FieldUsed:
		m.ClearUsed()
		return nil
	}
	return fmt.Errorf("unknown RecoveryCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecoveryCodeMutation) ResetField(name string) error {
	switch name {
	case recoverycode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recoverycode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recoverycode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case recoverycode.FieldEntID:
		m.ResetEntID()
		return nil
	case recoverycode.FieldAppID:
		m.ResetAppID()
		return nil
	case recoverycode.FieldUserID:
		m.ResetUserID()
		return nil
	case recoverycode.FieldCode:
		m.ResetCode()
		return nil
	case recoverycode.FieldUsed:
		m.ResetUsed()
		return nil
	}
	return fmt.Errorf("unknown RecoveryCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecoveryCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecoveryCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecoveryCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecoveryCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecoveryCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecoveryCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecoveryCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RecoveryCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecoveryCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RecoveryCode edge %s", name)
}

// SubscriberMutation represents an operation that mutates the Subscriber nodes in the graph.
type SubscriberMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	email_address *string
	registered    *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Subscriber, error)
	predicates    []predicate.Subscriber
}

var _ ent.Mutation = (*SubscriberMutation)(nil)

// subscriberOption allows management of the mutation configuration using functional options.
type subscriberOption func(*SubscriberMutation)

// newSubscriberMutation creates new mutation for the Subscriber entity.
func newSubscriberMutation(c config, op Op, opts ...subscriberOption) *SubscriberMutation {
	m := &SubscriberMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriber,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriberID sets the ID field of the mutation.
func withSubscriberID(id uint32) subscriberOption {
	return func(m *SubscriberMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscriber
		)
		m.oldValue = func(ctx context.Context) (*Subscriber, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscriber.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriber sets the old Subscriber of the mutation.
func withSubscriber(node *Subscriber) subscriberOption {
	return func(m *SubscriberMutation) {
		m.oldValue = func(context.Context) (*Subscriber, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscriber entities.
func (m *SubscriberMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriberMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriberMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscriber.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriberMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriberMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *SubscriberMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SubscriberMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriberMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriberMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriberMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *SubscriberMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SubscriberMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriberMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriberMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriberMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *SubscriberMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SubscriberMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriberMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *SubscriberMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *SubscriberMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *SubscriberMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *SubscriberMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *SubscriberMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *SubscriberMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[subscriber.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *SubscriberMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *SubscriberMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, subscriber.FieldAppID)
}

// SetEmailAddress sets the "email_address" field.
func (m *SubscriberMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *SubscriberMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ClearEmailAddress clears the value of the "email_address" field.
func (m *SubscriberMutation) ClearEmailAddress() {
	m.email_address = nil
	m.clearedFields[subscriber.FieldEmailAddress] = struct{}{}
}

// EmailAddressCleared returns if the "email_address" field was cleared in this mutation.
func (m *SubscriberMutation) EmailAddressCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldEmailAddress]
	return ok
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *SubscriberMutation) ResetEmailAddress() {
	m.email_address = nil
	delete(m.clearedFields, subscriber.FieldEmailAddress)
}

// SetRegistered sets the "registered" field.
func (m *SubscriberMutation) SetRegistered(b bool) {
	m.registered = &b
}

// Registered returns the value of the "registered" field in the mutation.
func (m *SubscriberMutation) Registered() (r bool, exists bool) {
	v := m.registered
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistered returns the old "registered" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldRegistered(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistered: %w", err)
	}
	return oldValue.Registered, nil
}

// ClearRegistered clears the value of the "registered" field.
func (m *SubscriberMutation) ClearRegistered() {
	m.registered = nil
	m.clearedFields[subscriber.FieldRegistered] = struct{}{}
}

// RegisteredCleared returns if the "registered" field was cleared in this mutation.
func (m *SubscriberMutation) RegisteredCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldRegistered]
	return ok
}

// ResetRegistered resets all changes to the "registered" field.
func (m *SubscriberMutation) ResetRegistered() {
	m.registered = nil
	delete(m.clearedFields, subscriber.FieldRegistered)
}

// Where appends a list predicates to the SubscriberMutation builder.
func (m *SubscriberMutation) Where(ps ...predicate.Subscriber) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscriber, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscriber).
func (m *SubscriberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriberMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, subscriber.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriber.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriber.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, subscriber.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, subscriber.FieldAppID)
	}
	if m.email_address != nil {
		fields = append(fields, subscriber.FieldEmailAddress)
	}
	if m.registered != nil {
		fields = append(fields, subscriber.FieldRegistered)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriber.FieldCreatedAt:
		return m.CreatedAt()
	case subscriber.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriber.FieldDeletedAt:
		return m.DeletedAt()
	case subscriber.FieldEntID:
		return m.EntID()
	case subscriber.FieldAppID:
		return m.AppID()
	case subscriber.FieldEmailAddress:
		return m.EmailAddress()
	case subscriber.FieldRegistered:
		return m.Registered()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriber.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriber.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriber.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriber.FieldEntID:
		return m.OldEntID(ctx)
	case subscriber.FieldAppID:
		return m.OldAppID(ctx)
	case subscriber.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case subscriber.FieldRegistered:
		return m.OldRegistered(ctx)
	}
	return nil, fmt.Errorf("unknown Subscriber field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriber.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriber.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriber.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriber.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case subscriber.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case subscriber.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case subscriber.FieldRegistered:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistered(v)
		return nil
	}
	return fmt.Errorf("unknown Subscriber field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriberMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, subscriber.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, subscriber.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, subscriber.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscriber.FieldCreatedAt:
		return m.AddedCreatedAt()
	case subscriber.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case subscriber.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscriber.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case subscriber.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case subscriber.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Subscriber numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriber.FieldAppID) {
		fields = append(fields, subscriber.FieldAppID)
	}
	if m.FieldCleared(subscriber.FieldEmailAddress) {
		fields = append(fields, subscriber.FieldEmailAddress)
	}
	if m.FieldCleared(subscriber.FieldRegistered) {
		fields = append(fields, subscriber.FieldRegistered)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriberMutation) ClearField(name string) error {
	switch name {
	case subscriber.FieldAppID:
		m.ClearAppID()
		return nil
	case subscriber.FieldEmailAddress:
		m.ClearEmailAddress()
		return nil
	case subscriber.FieldRegistered:
		m.ClearRegistered()
		return nil
	}
	return fmt.Errorf("unknown Subscriber nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriberMutation) ResetField(name string) error {
	switch name {
	case subscriber.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriber.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriber.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriber.FieldEntID:
		m.ResetEntID()
		return nil
	case subscriber.FieldAppID:
		m.ResetAppID()
		return nil
	case subscriber.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case subscriber.FieldRegistered:
		m.ResetRegistered()
		return nil
	}
	return fmt.Errorf("unknown Subscriber field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriberMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriberMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriberMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriberMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Subscriber unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriberMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Subscriber edge %s", name)
}
