// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/app"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appcontrol"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appoauththirdparty"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/approle"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/approleuser"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appsubscribe"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appuser"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appusercontrol"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appuserextra"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appusersecret"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/appuserthirdparty"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/auth"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/authhistory"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/banapp"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/banappuser"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/kyc"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/loginhistory"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/oauththirdparty"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/recoverycode"
	"github.com/NpoolPlatform/kunman/middleware/appuser/db/ent/generated/subscriber"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// App is the client for interacting with the App builders.
	App *AppClient
	// AppControl is the client for interacting with the AppControl builders.
	AppControl *AppControlClient
	// AppOAuthThirdParty is the client for interacting with the AppOAuthThirdParty builders.
	AppOAuthThirdParty *AppOAuthThirdPartyClient
	// AppRole is the client for interacting with the AppRole builders.
	AppRole *AppRoleClient
	// AppRoleUser is the client for interacting with the AppRoleUser builders.
	AppRoleUser *AppRoleUserClient
	// AppSubscribe is the client for interacting with the AppSubscribe builders.
	AppSubscribe *AppSubscribeClient
	// AppUser is the client for interacting with the AppUser builders.
	AppUser *AppUserClient
	// AppUserControl is the client for interacting with the AppUserControl builders.
	AppUserControl *AppUserControlClient
	// AppUserExtra is the client for interacting with the AppUserExtra builders.
	AppUserExtra *AppUserExtraClient
	// AppUserSecret is the client for interacting with the AppUserSecret builders.
	AppUserSecret *AppUserSecretClient
	// AppUserThirdParty is the client for interacting with the AppUserThirdParty builders.
	AppUserThirdParty *AppUserThirdPartyClient
	// Auth is the client for interacting with the Auth builders.
	Auth *AuthClient
	// AuthHistory is the client for interacting with the AuthHistory builders.
	AuthHistory *AuthHistoryClient
	// BanApp is the client for interacting with the BanApp builders.
	BanApp *BanAppClient
	// BanAppUser is the client for interacting with the BanAppUser builders.
	BanAppUser *BanAppUserClient
	// Kyc is the client for interacting with the Kyc builders.
	Kyc *KycClient
	// LoginHistory is the client for interacting with the LoginHistory builders.
	LoginHistory *LoginHistoryClient
	// OAuthThirdParty is the client for interacting with the OAuthThirdParty builders.
	OAuthThirdParty *OAuthThirdPartyClient
	// RecoveryCode is the client for interacting with the RecoveryCode builders.
	RecoveryCode *RecoveryCodeClient
	// Subscriber is the client for interacting with the Subscriber builders.
	Subscriber *SubscriberClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.App = NewAppClient(c.config)
	c.AppControl = NewAppControlClient(c.config)
	c.AppOAuthThirdParty = NewAppOAuthThirdPartyClient(c.config)
	c.AppRole = NewAppRoleClient(c.config)
	c.AppRoleUser = NewAppRoleUserClient(c.config)
	c.AppSubscribe = NewAppSubscribeClient(c.config)
	c.AppUser = NewAppUserClient(c.config)
	c.AppUserControl = NewAppUserControlClient(c.config)
	c.AppUserExtra = NewAppUserExtraClient(c.config)
	c.AppUserSecret = NewAppUserSecretClient(c.config)
	c.AppUserThirdParty = NewAppUserThirdPartyClient(c.config)
	c.Auth = NewAuthClient(c.config)
	c.AuthHistory = NewAuthHistoryClient(c.config)
	c.BanApp = NewBanAppClient(c.config)
	c.BanAppUser = NewBanAppUserClient(c.config)
	c.Kyc = NewKycClient(c.config)
	c.LoginHistory = NewLoginHistoryClient(c.config)
	c.OAuthThirdParty = NewOAuthThirdPartyClient(c.config)
	c.RecoveryCode = NewRecoveryCodeClient(c.config)
	c.Subscriber = NewSubscriberClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("generated: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("generated: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		App:                NewAppClient(cfg),
		AppControl:         NewAppControlClient(cfg),
		AppOAuthThirdParty: NewAppOAuthThirdPartyClient(cfg),
		AppRole:            NewAppRoleClient(cfg),
		AppRoleUser:        NewAppRoleUserClient(cfg),
		AppSubscribe:       NewAppSubscribeClient(cfg),
		AppUser:            NewAppUserClient(cfg),
		AppUserControl:     NewAppUserControlClient(cfg),
		AppUserExtra:       NewAppUserExtraClient(cfg),
		AppUserSecret:      NewAppUserSecretClient(cfg),
		AppUserThirdParty:  NewAppUserThirdPartyClient(cfg),
		Auth:               NewAuthClient(cfg),
		AuthHistory:        NewAuthHistoryClient(cfg),
		BanApp:             NewBanAppClient(cfg),
		BanAppUser:         NewBanAppUserClient(cfg),
		Kyc:                NewKycClient(cfg),
		LoginHistory:       NewLoginHistoryClient(cfg),
		OAuthThirdParty:    NewOAuthThirdPartyClient(cfg),
		RecoveryCode:       NewRecoveryCodeClient(cfg),
		Subscriber:         NewSubscriberClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		App:                NewAppClient(cfg),
		AppControl:         NewAppControlClient(cfg),
		AppOAuthThirdParty: NewAppOAuthThirdPartyClient(cfg),
		AppRole:            NewAppRoleClient(cfg),
		AppRoleUser:        NewAppRoleUserClient(cfg),
		AppSubscribe:       NewAppSubscribeClient(cfg),
		AppUser:            NewAppUserClient(cfg),
		AppUserControl:     NewAppUserControlClient(cfg),
		AppUserExtra:       NewAppUserExtraClient(cfg),
		AppUserSecret:      NewAppUserSecretClient(cfg),
		AppUserThirdParty:  NewAppUserThirdPartyClient(cfg),
		Auth:               NewAuthClient(cfg),
		AuthHistory:        NewAuthHistoryClient(cfg),
		BanApp:             NewBanAppClient(cfg),
		BanAppUser:         NewBanAppUserClient(cfg),
		Kyc:                NewKycClient(cfg),
		LoginHistory:       NewLoginHistoryClient(cfg),
		OAuthThirdParty:    NewOAuthThirdPartyClient(cfg),
		RecoveryCode:       NewRecoveryCodeClient(cfg),
		Subscriber:         NewSubscriberClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		App.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.App, c.AppControl, c.AppOAuthThirdParty, c.AppRole, c.AppRoleUser,
		c.AppSubscribe, c.AppUser, c.AppUserControl, c.AppUserExtra, c.AppUserSecret,
		c.AppUserThirdParty, c.Auth, c.AuthHistory, c.BanApp, c.BanAppUser, c.Kyc,
		c.LoginHistory, c.OAuthThirdParty, c.RecoveryCode, c.Subscriber,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.App, c.AppControl, c.AppOAuthThirdParty, c.AppRole, c.AppRoleUser,
		c.AppSubscribe, c.AppUser, c.AppUserControl, c.AppUserExtra, c.AppUserSecret,
		c.AppUserThirdParty, c.Auth, c.AuthHistory, c.BanApp, c.BanAppUser, c.Kyc,
		c.LoginHistory, c.OAuthThirdParty, c.RecoveryCode, c.Subscriber,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AppMutation:
		return c.App.mutate(ctx, m)
	case *AppControlMutation:
		return c.AppControl.mutate(ctx, m)
	case *AppOAuthThirdPartyMutation:
		return c.AppOAuthThirdParty.mutate(ctx, m)
	case *AppRoleMutation:
		return c.AppRole.mutate(ctx, m)
	case *AppRoleUserMutation:
		return c.AppRoleUser.mutate(ctx, m)
	case *AppSubscribeMutation:
		return c.AppSubscribe.mutate(ctx, m)
	case *AppUserMutation:
		return c.AppUser.mutate(ctx, m)
	case *AppUserControlMutation:
		return c.AppUserControl.mutate(ctx, m)
	case *AppUserExtraMutation:
		return c.AppUserExtra.mutate(ctx, m)
	case *AppUserSecretMutation:
		return c.AppUserSecret.mutate(ctx, m)
	case *AppUserThirdPartyMutation:
		return c.AppUserThirdParty.mutate(ctx, m)
	case *AuthMutation:
		return c.Auth.mutate(ctx, m)
	case *AuthHistoryMutation:
		return c.AuthHistory.mutate(ctx, m)
	case *BanAppMutation:
		return c.BanApp.mutate(ctx, m)
	case *BanAppUserMutation:
		return c.BanAppUser.mutate(ctx, m)
	case *KycMutation:
		return c.Kyc.mutate(ctx, m)
	case *LoginHistoryMutation:
		return c.LoginHistory.mutate(ctx, m)
	case *OAuthThirdPartyMutation:
		return c.OAuthThirdParty.mutate(ctx, m)
	case *RecoveryCodeMutation:
		return c.RecoveryCode.mutate(ctx, m)
	case *SubscriberMutation:
		return c.Subscriber.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("generated: unknown mutation type %T", m)
	}
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `app.Intercept(f(g(h())))`.
func (c *AppClient) Intercept(interceptors ...Interceptor) {
	c.inters.App = append(c.inters.App, interceptors...)
}

// Create returns a builder for creating a App entity.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppClient) MapCreateBulk(slice any, setFunc func(*AppCreate, int)) *AppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppCreateBulk{err: fmt.Errorf("calling to AppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id uint32) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppClient) DeleteOneID(id uint32) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApp},
		inters: c.Interceptors(),
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id uint32) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id uint32) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// Interceptors returns the client interceptors.
func (c *AppClient) Interceptors() []Interceptor {
	return c.inters.App
}

func (c *AppClient) mutate(ctx context.Context, m *AppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown App mutation op: %q", m.Op())
	}
}

// AppControlClient is a client for the AppControl schema.
type AppControlClient struct {
	config
}

// NewAppControlClient returns a client for the AppControl from the given config.
func NewAppControlClient(c config) *AppControlClient {
	return &AppControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appcontrol.Hooks(f(g(h())))`.
func (c *AppControlClient) Use(hooks ...Hook) {
	c.hooks.AppControl = append(c.hooks.AppControl, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appcontrol.Intercept(f(g(h())))`.
func (c *AppControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppControl = append(c.inters.AppControl, interceptors...)
}

// Create returns a builder for creating a AppControl entity.
func (c *AppControlClient) Create() *AppControlCreate {
	mutation := newAppControlMutation(c.config, OpCreate)
	return &AppControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppControl entities.
func (c *AppControlClient) CreateBulk(builders ...*AppControlCreate) *AppControlCreateBulk {
	return &AppControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppControlClient) MapCreateBulk(slice any, setFunc func(*AppControlCreate, int)) *AppControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppControlCreateBulk{err: fmt.Errorf("calling to AppControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppControl.
func (c *AppControlClient) Update() *AppControlUpdate {
	mutation := newAppControlMutation(c.config, OpUpdate)
	return &AppControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppControlClient) UpdateOne(ac *AppControl) *AppControlUpdateOne {
	mutation := newAppControlMutation(c.config, OpUpdateOne, withAppControl(ac))
	return &AppControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppControlClient) UpdateOneID(id uint32) *AppControlUpdateOne {
	mutation := newAppControlMutation(c.config, OpUpdateOne, withAppControlID(id))
	return &AppControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppControl.
func (c *AppControlClient) Delete() *AppControlDelete {
	mutation := newAppControlMutation(c.config, OpDelete)
	return &AppControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppControlClient) DeleteOne(ac *AppControl) *AppControlDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppControlClient) DeleteOneID(id uint32) *AppControlDeleteOne {
	builder := c.Delete().Where(appcontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppControlDeleteOne{builder}
}

// Query returns a query builder for AppControl.
func (c *AppControlClient) Query() *AppControlQuery {
	return &AppControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppControl},
		inters: c.Interceptors(),
	}
}

// Get returns a AppControl entity by its id.
func (c *AppControlClient) Get(ctx context.Context, id uint32) (*AppControl, error) {
	return c.Query().Where(appcontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppControlClient) GetX(ctx context.Context, id uint32) *AppControl {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppControlClient) Hooks() []Hook {
	return c.hooks.AppControl
}

// Interceptors returns the client interceptors.
func (c *AppControlClient) Interceptors() []Interceptor {
	return c.inters.AppControl
}

func (c *AppControlClient) mutate(ctx context.Context, m *AppControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppControl mutation op: %q", m.Op())
	}
}

// AppOAuthThirdPartyClient is a client for the AppOAuthThirdParty schema.
type AppOAuthThirdPartyClient struct {
	config
}

// NewAppOAuthThirdPartyClient returns a client for the AppOAuthThirdParty from the given config.
func NewAppOAuthThirdPartyClient(c config) *AppOAuthThirdPartyClient {
	return &AppOAuthThirdPartyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appoauththirdparty.Hooks(f(g(h())))`.
func (c *AppOAuthThirdPartyClient) Use(hooks ...Hook) {
	c.hooks.AppOAuthThirdParty = append(c.hooks.AppOAuthThirdParty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appoauththirdparty.Intercept(f(g(h())))`.
func (c *AppOAuthThirdPartyClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppOAuthThirdParty = append(c.inters.AppOAuthThirdParty, interceptors...)
}

// Create returns a builder for creating a AppOAuthThirdParty entity.
func (c *AppOAuthThirdPartyClient) Create() *AppOAuthThirdPartyCreate {
	mutation := newAppOAuthThirdPartyMutation(c.config, OpCreate)
	return &AppOAuthThirdPartyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppOAuthThirdParty entities.
func (c *AppOAuthThirdPartyClient) CreateBulk(builders ...*AppOAuthThirdPartyCreate) *AppOAuthThirdPartyCreateBulk {
	return &AppOAuthThirdPartyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppOAuthThirdPartyClient) MapCreateBulk(slice any, setFunc func(*AppOAuthThirdPartyCreate, int)) *AppOAuthThirdPartyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppOAuthThirdPartyCreateBulk{err: fmt.Errorf("calling to AppOAuthThirdPartyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppOAuthThirdPartyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppOAuthThirdPartyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppOAuthThirdParty.
func (c *AppOAuthThirdPartyClient) Update() *AppOAuthThirdPartyUpdate {
	mutation := newAppOAuthThirdPartyMutation(c.config, OpUpdate)
	return &AppOAuthThirdPartyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppOAuthThirdPartyClient) UpdateOne(aotp *AppOAuthThirdParty) *AppOAuthThirdPartyUpdateOne {
	mutation := newAppOAuthThirdPartyMutation(c.config, OpUpdateOne, withAppOAuthThirdParty(aotp))
	return &AppOAuthThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppOAuthThirdPartyClient) UpdateOneID(id uint32) *AppOAuthThirdPartyUpdateOne {
	mutation := newAppOAuthThirdPartyMutation(c.config, OpUpdateOne, withAppOAuthThirdPartyID(id))
	return &AppOAuthThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppOAuthThirdParty.
func (c *AppOAuthThirdPartyClient) Delete() *AppOAuthThirdPartyDelete {
	mutation := newAppOAuthThirdPartyMutation(c.config, OpDelete)
	return &AppOAuthThirdPartyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppOAuthThirdPartyClient) DeleteOne(aotp *AppOAuthThirdParty) *AppOAuthThirdPartyDeleteOne {
	return c.DeleteOneID(aotp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppOAuthThirdPartyClient) DeleteOneID(id uint32) *AppOAuthThirdPartyDeleteOne {
	builder := c.Delete().Where(appoauththirdparty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppOAuthThirdPartyDeleteOne{builder}
}

// Query returns a query builder for AppOAuthThirdParty.
func (c *AppOAuthThirdPartyClient) Query() *AppOAuthThirdPartyQuery {
	return &AppOAuthThirdPartyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppOAuthThirdParty},
		inters: c.Interceptors(),
	}
}

// Get returns a AppOAuthThirdParty entity by its id.
func (c *AppOAuthThirdPartyClient) Get(ctx context.Context, id uint32) (*AppOAuthThirdParty, error) {
	return c.Query().Where(appoauththirdparty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppOAuthThirdPartyClient) GetX(ctx context.Context, id uint32) *AppOAuthThirdParty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppOAuthThirdPartyClient) Hooks() []Hook {
	return c.hooks.AppOAuthThirdParty
}

// Interceptors returns the client interceptors.
func (c *AppOAuthThirdPartyClient) Interceptors() []Interceptor {
	return c.inters.AppOAuthThirdParty
}

func (c *AppOAuthThirdPartyClient) mutate(ctx context.Context, m *AppOAuthThirdPartyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppOAuthThirdPartyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppOAuthThirdPartyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppOAuthThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppOAuthThirdPartyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppOAuthThirdParty mutation op: %q", m.Op())
	}
}

// AppRoleClient is a client for the AppRole schema.
type AppRoleClient struct {
	config
}

// NewAppRoleClient returns a client for the AppRole from the given config.
func NewAppRoleClient(c config) *AppRoleClient {
	return &AppRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `approle.Hooks(f(g(h())))`.
func (c *AppRoleClient) Use(hooks ...Hook) {
	c.hooks.AppRole = append(c.hooks.AppRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `approle.Intercept(f(g(h())))`.
func (c *AppRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppRole = append(c.inters.AppRole, interceptors...)
}

// Create returns a builder for creating a AppRole entity.
func (c *AppRoleClient) Create() *AppRoleCreate {
	mutation := newAppRoleMutation(c.config, OpCreate)
	return &AppRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppRole entities.
func (c *AppRoleClient) CreateBulk(builders ...*AppRoleCreate) *AppRoleCreateBulk {
	return &AppRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppRoleClient) MapCreateBulk(slice any, setFunc func(*AppRoleCreate, int)) *AppRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppRoleCreateBulk{err: fmt.Errorf("calling to AppRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppRole.
func (c *AppRoleClient) Update() *AppRoleUpdate {
	mutation := newAppRoleMutation(c.config, OpUpdate)
	return &AppRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppRoleClient) UpdateOne(ar *AppRole) *AppRoleUpdateOne {
	mutation := newAppRoleMutation(c.config, OpUpdateOne, withAppRole(ar))
	return &AppRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppRoleClient) UpdateOneID(id uint32) *AppRoleUpdateOne {
	mutation := newAppRoleMutation(c.config, OpUpdateOne, withAppRoleID(id))
	return &AppRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppRole.
func (c *AppRoleClient) Delete() *AppRoleDelete {
	mutation := newAppRoleMutation(c.config, OpDelete)
	return &AppRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppRoleClient) DeleteOne(ar *AppRole) *AppRoleDeleteOne {
	return c.DeleteOneID(ar.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppRoleClient) DeleteOneID(id uint32) *AppRoleDeleteOne {
	builder := c.Delete().Where(approle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppRoleDeleteOne{builder}
}

// Query returns a query builder for AppRole.
func (c *AppRoleClient) Query() *AppRoleQuery {
	return &AppRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppRole},
		inters: c.Interceptors(),
	}
}

// Get returns a AppRole entity by its id.
func (c *AppRoleClient) Get(ctx context.Context, id uint32) (*AppRole, error) {
	return c.Query().Where(approle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppRoleClient) GetX(ctx context.Context, id uint32) *AppRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppRoleClient) Hooks() []Hook {
	return c.hooks.AppRole
}

// Interceptors returns the client interceptors.
func (c *AppRoleClient) Interceptors() []Interceptor {
	return c.inters.AppRole
}

func (c *AppRoleClient) mutate(ctx context.Context, m *AppRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppRole mutation op: %q", m.Op())
	}
}

// AppRoleUserClient is a client for the AppRoleUser schema.
type AppRoleUserClient struct {
	config
}

// NewAppRoleUserClient returns a client for the AppRoleUser from the given config.
func NewAppRoleUserClient(c config) *AppRoleUserClient {
	return &AppRoleUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `approleuser.Hooks(f(g(h())))`.
func (c *AppRoleUserClient) Use(hooks ...Hook) {
	c.hooks.AppRoleUser = append(c.hooks.AppRoleUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `approleuser.Intercept(f(g(h())))`.
func (c *AppRoleUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppRoleUser = append(c.inters.AppRoleUser, interceptors...)
}

// Create returns a builder for creating a AppRoleUser entity.
func (c *AppRoleUserClient) Create() *AppRoleUserCreate {
	mutation := newAppRoleUserMutation(c.config, OpCreate)
	return &AppRoleUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppRoleUser entities.
func (c *AppRoleUserClient) CreateBulk(builders ...*AppRoleUserCreate) *AppRoleUserCreateBulk {
	return &AppRoleUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppRoleUserClient) MapCreateBulk(slice any, setFunc func(*AppRoleUserCreate, int)) *AppRoleUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppRoleUserCreateBulk{err: fmt.Errorf("calling to AppRoleUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppRoleUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppRoleUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppRoleUser.
func (c *AppRoleUserClient) Update() *AppRoleUserUpdate {
	mutation := newAppRoleUserMutation(c.config, OpUpdate)
	return &AppRoleUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppRoleUserClient) UpdateOne(aru *AppRoleUser) *AppRoleUserUpdateOne {
	mutation := newAppRoleUserMutation(c.config, OpUpdateOne, withAppRoleUser(aru))
	return &AppRoleUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppRoleUserClient) UpdateOneID(id uint32) *AppRoleUserUpdateOne {
	mutation := newAppRoleUserMutation(c.config, OpUpdateOne, withAppRoleUserID(id))
	return &AppRoleUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppRoleUser.
func (c *AppRoleUserClient) Delete() *AppRoleUserDelete {
	mutation := newAppRoleUserMutation(c.config, OpDelete)
	return &AppRoleUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppRoleUserClient) DeleteOne(aru *AppRoleUser) *AppRoleUserDeleteOne {
	return c.DeleteOneID(aru.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppRoleUserClient) DeleteOneID(id uint32) *AppRoleUserDeleteOne {
	builder := c.Delete().Where(approleuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppRoleUserDeleteOne{builder}
}

// Query returns a query builder for AppRoleUser.
func (c *AppRoleUserClient) Query() *AppRoleUserQuery {
	return &AppRoleUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppRoleUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AppRoleUser entity by its id.
func (c *AppRoleUserClient) Get(ctx context.Context, id uint32) (*AppRoleUser, error) {
	return c.Query().Where(approleuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppRoleUserClient) GetX(ctx context.Context, id uint32) *AppRoleUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppRoleUserClient) Hooks() []Hook {
	return c.hooks.AppRoleUser
}

// Interceptors returns the client interceptors.
func (c *AppRoleUserClient) Interceptors() []Interceptor {
	return c.inters.AppRoleUser
}

func (c *AppRoleUserClient) mutate(ctx context.Context, m *AppRoleUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppRoleUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppRoleUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppRoleUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppRoleUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppRoleUser mutation op: %q", m.Op())
	}
}

// AppSubscribeClient is a client for the AppSubscribe schema.
type AppSubscribeClient struct {
	config
}

// NewAppSubscribeClient returns a client for the AppSubscribe from the given config.
func NewAppSubscribeClient(c config) *AppSubscribeClient {
	return &AppSubscribeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appsubscribe.Hooks(f(g(h())))`.
func (c *AppSubscribeClient) Use(hooks ...Hook) {
	c.hooks.AppSubscribe = append(c.hooks.AppSubscribe, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appsubscribe.Intercept(f(g(h())))`.
func (c *AppSubscribeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppSubscribe = append(c.inters.AppSubscribe, interceptors...)
}

// Create returns a builder for creating a AppSubscribe entity.
func (c *AppSubscribeClient) Create() *AppSubscribeCreate {
	mutation := newAppSubscribeMutation(c.config, OpCreate)
	return &AppSubscribeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppSubscribe entities.
func (c *AppSubscribeClient) CreateBulk(builders ...*AppSubscribeCreate) *AppSubscribeCreateBulk {
	return &AppSubscribeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppSubscribeClient) MapCreateBulk(slice any, setFunc func(*AppSubscribeCreate, int)) *AppSubscribeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppSubscribeCreateBulk{err: fmt.Errorf("calling to AppSubscribeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppSubscribeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppSubscribeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppSubscribe.
func (c *AppSubscribeClient) Update() *AppSubscribeUpdate {
	mutation := newAppSubscribeMutation(c.config, OpUpdate)
	return &AppSubscribeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppSubscribeClient) UpdateOne(as *AppSubscribe) *AppSubscribeUpdateOne {
	mutation := newAppSubscribeMutation(c.config, OpUpdateOne, withAppSubscribe(as))
	return &AppSubscribeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppSubscribeClient) UpdateOneID(id uint32) *AppSubscribeUpdateOne {
	mutation := newAppSubscribeMutation(c.config, OpUpdateOne, withAppSubscribeID(id))
	return &AppSubscribeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppSubscribe.
func (c *AppSubscribeClient) Delete() *AppSubscribeDelete {
	mutation := newAppSubscribeMutation(c.config, OpDelete)
	return &AppSubscribeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppSubscribeClient) DeleteOne(as *AppSubscribe) *AppSubscribeDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppSubscribeClient) DeleteOneID(id uint32) *AppSubscribeDeleteOne {
	builder := c.Delete().Where(appsubscribe.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppSubscribeDeleteOne{builder}
}

// Query returns a query builder for AppSubscribe.
func (c *AppSubscribeClient) Query() *AppSubscribeQuery {
	return &AppSubscribeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppSubscribe},
		inters: c.Interceptors(),
	}
}

// Get returns a AppSubscribe entity by its id.
func (c *AppSubscribeClient) Get(ctx context.Context, id uint32) (*AppSubscribe, error) {
	return c.Query().Where(appsubscribe.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppSubscribeClient) GetX(ctx context.Context, id uint32) *AppSubscribe {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppSubscribeClient) Hooks() []Hook {
	return c.hooks.AppSubscribe
}

// Interceptors returns the client interceptors.
func (c *AppSubscribeClient) Interceptors() []Interceptor {
	return c.inters.AppSubscribe
}

func (c *AppSubscribeClient) mutate(ctx context.Context, m *AppSubscribeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppSubscribeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppSubscribeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppSubscribeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppSubscribeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppSubscribe mutation op: %q", m.Op())
	}
}

// AppUserClient is a client for the AppUser schema.
type AppUserClient struct {
	config
}

// NewAppUserClient returns a client for the AppUser from the given config.
func NewAppUserClient(c config) *AppUserClient {
	return &AppUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appuser.Hooks(f(g(h())))`.
func (c *AppUserClient) Use(hooks ...Hook) {
	c.hooks.AppUser = append(c.hooks.AppUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appuser.Intercept(f(g(h())))`.
func (c *AppUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppUser = append(c.inters.AppUser, interceptors...)
}

// Create returns a builder for creating a AppUser entity.
func (c *AppUserClient) Create() *AppUserCreate {
	mutation := newAppUserMutation(c.config, OpCreate)
	return &AppUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppUser entities.
func (c *AppUserClient) CreateBulk(builders ...*AppUserCreate) *AppUserCreateBulk {
	return &AppUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppUserClient) MapCreateBulk(slice any, setFunc func(*AppUserCreate, int)) *AppUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppUserCreateBulk{err: fmt.Errorf("calling to AppUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppUser.
func (c *AppUserClient) Update() *AppUserUpdate {
	mutation := newAppUserMutation(c.config, OpUpdate)
	return &AppUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppUserClient) UpdateOne(au *AppUser) *AppUserUpdateOne {
	mutation := newAppUserMutation(c.config, OpUpdateOne, withAppUser(au))
	return &AppUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppUserClient) UpdateOneID(id uint32) *AppUserUpdateOne {
	mutation := newAppUserMutation(c.config, OpUpdateOne, withAppUserID(id))
	return &AppUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppUser.
func (c *AppUserClient) Delete() *AppUserDelete {
	mutation := newAppUserMutation(c.config, OpDelete)
	return &AppUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppUserClient) DeleteOne(au *AppUser) *AppUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppUserClient) DeleteOneID(id uint32) *AppUserDeleteOne {
	builder := c.Delete().Where(appuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppUserDeleteOne{builder}
}

// Query returns a query builder for AppUser.
func (c *AppUserClient) Query() *AppUserQuery {
	return &AppUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AppUser entity by its id.
func (c *AppUserClient) Get(ctx context.Context, id uint32) (*AppUser, error) {
	return c.Query().Where(appuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppUserClient) GetX(ctx context.Context, id uint32) *AppUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppUserClient) Hooks() []Hook {
	return c.hooks.AppUser
}

// Interceptors returns the client interceptors.
func (c *AppUserClient) Interceptors() []Interceptor {
	return c.inters.AppUser
}

func (c *AppUserClient) mutate(ctx context.Context, m *AppUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppUser mutation op: %q", m.Op())
	}
}

// AppUserControlClient is a client for the AppUserControl schema.
type AppUserControlClient struct {
	config
}

// NewAppUserControlClient returns a client for the AppUserControl from the given config.
func NewAppUserControlClient(c config) *AppUserControlClient {
	return &AppUserControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appusercontrol.Hooks(f(g(h())))`.
func (c *AppUserControlClient) Use(hooks ...Hook) {
	c.hooks.AppUserControl = append(c.hooks.AppUserControl, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appusercontrol.Intercept(f(g(h())))`.
func (c *AppUserControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppUserControl = append(c.inters.AppUserControl, interceptors...)
}

// Create returns a builder for creating a AppUserControl entity.
func (c *AppUserControlClient) Create() *AppUserControlCreate {
	mutation := newAppUserControlMutation(c.config, OpCreate)
	return &AppUserControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppUserControl entities.
func (c *AppUserControlClient) CreateBulk(builders ...*AppUserControlCreate) *AppUserControlCreateBulk {
	return &AppUserControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppUserControlClient) MapCreateBulk(slice any, setFunc func(*AppUserControlCreate, int)) *AppUserControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppUserControlCreateBulk{err: fmt.Errorf("calling to AppUserControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppUserControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppUserControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppUserControl.
func (c *AppUserControlClient) Update() *AppUserControlUpdate {
	mutation := newAppUserControlMutation(c.config, OpUpdate)
	return &AppUserControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppUserControlClient) UpdateOne(auc *AppUserControl) *AppUserControlUpdateOne {
	mutation := newAppUserControlMutation(c.config, OpUpdateOne, withAppUserControl(auc))
	return &AppUserControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppUserControlClient) UpdateOneID(id uint32) *AppUserControlUpdateOne {
	mutation := newAppUserControlMutation(c.config, OpUpdateOne, withAppUserControlID(id))
	return &AppUserControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppUserControl.
func (c *AppUserControlClient) Delete() *AppUserControlDelete {
	mutation := newAppUserControlMutation(c.config, OpDelete)
	return &AppUserControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppUserControlClient) DeleteOne(auc *AppUserControl) *AppUserControlDeleteOne {
	return c.DeleteOneID(auc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppUserControlClient) DeleteOneID(id uint32) *AppUserControlDeleteOne {
	builder := c.Delete().Where(appusercontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppUserControlDeleteOne{builder}
}

// Query returns a query builder for AppUserControl.
func (c *AppUserControlClient) Query() *AppUserControlQuery {
	return &AppUserControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppUserControl},
		inters: c.Interceptors(),
	}
}

// Get returns a AppUserControl entity by its id.
func (c *AppUserControlClient) Get(ctx context.Context, id uint32) (*AppUserControl, error) {
	return c.Query().Where(appusercontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppUserControlClient) GetX(ctx context.Context, id uint32) *AppUserControl {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppUserControlClient) Hooks() []Hook {
	return c.hooks.AppUserControl
}

// Interceptors returns the client interceptors.
func (c *AppUserControlClient) Interceptors() []Interceptor {
	return c.inters.AppUserControl
}

func (c *AppUserControlClient) mutate(ctx context.Context, m *AppUserControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppUserControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUserControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUserControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppUserControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppUserControl mutation op: %q", m.Op())
	}
}

// AppUserExtraClient is a client for the AppUserExtra schema.
type AppUserExtraClient struct {
	config
}

// NewAppUserExtraClient returns a client for the AppUserExtra from the given config.
func NewAppUserExtraClient(c config) *AppUserExtraClient {
	return &AppUserExtraClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appuserextra.Hooks(f(g(h())))`.
func (c *AppUserExtraClient) Use(hooks ...Hook) {
	c.hooks.AppUserExtra = append(c.hooks.AppUserExtra, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appuserextra.Intercept(f(g(h())))`.
func (c *AppUserExtraClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppUserExtra = append(c.inters.AppUserExtra, interceptors...)
}

// Create returns a builder for creating a AppUserExtra entity.
func (c *AppUserExtraClient) Create() *AppUserExtraCreate {
	mutation := newAppUserExtraMutation(c.config, OpCreate)
	return &AppUserExtraCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppUserExtra entities.
func (c *AppUserExtraClient) CreateBulk(builders ...*AppUserExtraCreate) *AppUserExtraCreateBulk {
	return &AppUserExtraCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppUserExtraClient) MapCreateBulk(slice any, setFunc func(*AppUserExtraCreate, int)) *AppUserExtraCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppUserExtraCreateBulk{err: fmt.Errorf("calling to AppUserExtraClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppUserExtraCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppUserExtraCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppUserExtra.
func (c *AppUserExtraClient) Update() *AppUserExtraUpdate {
	mutation := newAppUserExtraMutation(c.config, OpUpdate)
	return &AppUserExtraUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppUserExtraClient) UpdateOne(aue *AppUserExtra) *AppUserExtraUpdateOne {
	mutation := newAppUserExtraMutation(c.config, OpUpdateOne, withAppUserExtra(aue))
	return &AppUserExtraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppUserExtraClient) UpdateOneID(id uint32) *AppUserExtraUpdateOne {
	mutation := newAppUserExtraMutation(c.config, OpUpdateOne, withAppUserExtraID(id))
	return &AppUserExtraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppUserExtra.
func (c *AppUserExtraClient) Delete() *AppUserExtraDelete {
	mutation := newAppUserExtraMutation(c.config, OpDelete)
	return &AppUserExtraDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppUserExtraClient) DeleteOne(aue *AppUserExtra) *AppUserExtraDeleteOne {
	return c.DeleteOneID(aue.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppUserExtraClient) DeleteOneID(id uint32) *AppUserExtraDeleteOne {
	builder := c.Delete().Where(appuserextra.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppUserExtraDeleteOne{builder}
}

// Query returns a query builder for AppUserExtra.
func (c *AppUserExtraClient) Query() *AppUserExtraQuery {
	return &AppUserExtraQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppUserExtra},
		inters: c.Interceptors(),
	}
}

// Get returns a AppUserExtra entity by its id.
func (c *AppUserExtraClient) Get(ctx context.Context, id uint32) (*AppUserExtra, error) {
	return c.Query().Where(appuserextra.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppUserExtraClient) GetX(ctx context.Context, id uint32) *AppUserExtra {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppUserExtraClient) Hooks() []Hook {
	return c.hooks.AppUserExtra
}

// Interceptors returns the client interceptors.
func (c *AppUserExtraClient) Interceptors() []Interceptor {
	return c.inters.AppUserExtra
}

func (c *AppUserExtraClient) mutate(ctx context.Context, m *AppUserExtraMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppUserExtraCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUserExtraUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUserExtraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppUserExtraDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppUserExtra mutation op: %q", m.Op())
	}
}

// AppUserSecretClient is a client for the AppUserSecret schema.
type AppUserSecretClient struct {
	config
}

// NewAppUserSecretClient returns a client for the AppUserSecret from the given config.
func NewAppUserSecretClient(c config) *AppUserSecretClient {
	return &AppUserSecretClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appusersecret.Hooks(f(g(h())))`.
func (c *AppUserSecretClient) Use(hooks ...Hook) {
	c.hooks.AppUserSecret = append(c.hooks.AppUserSecret, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appusersecret.Intercept(f(g(h())))`.
func (c *AppUserSecretClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppUserSecret = append(c.inters.AppUserSecret, interceptors...)
}

// Create returns a builder for creating a AppUserSecret entity.
func (c *AppUserSecretClient) Create() *AppUserSecretCreate {
	mutation := newAppUserSecretMutation(c.config, OpCreate)
	return &AppUserSecretCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppUserSecret entities.
func (c *AppUserSecretClient) CreateBulk(builders ...*AppUserSecretCreate) *AppUserSecretCreateBulk {
	return &AppUserSecretCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppUserSecretClient) MapCreateBulk(slice any, setFunc func(*AppUserSecretCreate, int)) *AppUserSecretCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppUserSecretCreateBulk{err: fmt.Errorf("calling to AppUserSecretClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppUserSecretCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppUserSecretCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppUserSecret.
func (c *AppUserSecretClient) Update() *AppUserSecretUpdate {
	mutation := newAppUserSecretMutation(c.config, OpUpdate)
	return &AppUserSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppUserSecretClient) UpdateOne(aus *AppUserSecret) *AppUserSecretUpdateOne {
	mutation := newAppUserSecretMutation(c.config, OpUpdateOne, withAppUserSecret(aus))
	return &AppUserSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppUserSecretClient) UpdateOneID(id uint32) *AppUserSecretUpdateOne {
	mutation := newAppUserSecretMutation(c.config, OpUpdateOne, withAppUserSecretID(id))
	return &AppUserSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppUserSecret.
func (c *AppUserSecretClient) Delete() *AppUserSecretDelete {
	mutation := newAppUserSecretMutation(c.config, OpDelete)
	return &AppUserSecretDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppUserSecretClient) DeleteOne(aus *AppUserSecret) *AppUserSecretDeleteOne {
	return c.DeleteOneID(aus.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppUserSecretClient) DeleteOneID(id uint32) *AppUserSecretDeleteOne {
	builder := c.Delete().Where(appusersecret.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppUserSecretDeleteOne{builder}
}

// Query returns a query builder for AppUserSecret.
func (c *AppUserSecretClient) Query() *AppUserSecretQuery {
	return &AppUserSecretQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppUserSecret},
		inters: c.Interceptors(),
	}
}

// Get returns a AppUserSecret entity by its id.
func (c *AppUserSecretClient) Get(ctx context.Context, id uint32) (*AppUserSecret, error) {
	return c.Query().Where(appusersecret.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppUserSecretClient) GetX(ctx context.Context, id uint32) *AppUserSecret {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppUserSecretClient) Hooks() []Hook {
	return c.hooks.AppUserSecret
}

// Interceptors returns the client interceptors.
func (c *AppUserSecretClient) Interceptors() []Interceptor {
	return c.inters.AppUserSecret
}

func (c *AppUserSecretClient) mutate(ctx context.Context, m *AppUserSecretMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppUserSecretCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUserSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUserSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppUserSecretDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppUserSecret mutation op: %q", m.Op())
	}
}

// AppUserThirdPartyClient is a client for the AppUserThirdParty schema.
type AppUserThirdPartyClient struct {
	config
}

// NewAppUserThirdPartyClient returns a client for the AppUserThirdParty from the given config.
func NewAppUserThirdPartyClient(c config) *AppUserThirdPartyClient {
	return &AppUserThirdPartyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appuserthirdparty.Hooks(f(g(h())))`.
func (c *AppUserThirdPartyClient) Use(hooks ...Hook) {
	c.hooks.AppUserThirdParty = append(c.hooks.AppUserThirdParty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appuserthirdparty.Intercept(f(g(h())))`.
func (c *AppUserThirdPartyClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppUserThirdParty = append(c.inters.AppUserThirdParty, interceptors...)
}

// Create returns a builder for creating a AppUserThirdParty entity.
func (c *AppUserThirdPartyClient) Create() *AppUserThirdPartyCreate {
	mutation := newAppUserThirdPartyMutation(c.config, OpCreate)
	return &AppUserThirdPartyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppUserThirdParty entities.
func (c *AppUserThirdPartyClient) CreateBulk(builders ...*AppUserThirdPartyCreate) *AppUserThirdPartyCreateBulk {
	return &AppUserThirdPartyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppUserThirdPartyClient) MapCreateBulk(slice any, setFunc func(*AppUserThirdPartyCreate, int)) *AppUserThirdPartyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppUserThirdPartyCreateBulk{err: fmt.Errorf("calling to AppUserThirdPartyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppUserThirdPartyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppUserThirdPartyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppUserThirdParty.
func (c *AppUserThirdPartyClient) Update() *AppUserThirdPartyUpdate {
	mutation := newAppUserThirdPartyMutation(c.config, OpUpdate)
	return &AppUserThirdPartyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppUserThirdPartyClient) UpdateOne(autp *AppUserThirdParty) *AppUserThirdPartyUpdateOne {
	mutation := newAppUserThirdPartyMutation(c.config, OpUpdateOne, withAppUserThirdParty(autp))
	return &AppUserThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppUserThirdPartyClient) UpdateOneID(id uint32) *AppUserThirdPartyUpdateOne {
	mutation := newAppUserThirdPartyMutation(c.config, OpUpdateOne, withAppUserThirdPartyID(id))
	return &AppUserThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppUserThirdParty.
func (c *AppUserThirdPartyClient) Delete() *AppUserThirdPartyDelete {
	mutation := newAppUserThirdPartyMutation(c.config, OpDelete)
	return &AppUserThirdPartyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppUserThirdPartyClient) DeleteOne(autp *AppUserThirdParty) *AppUserThirdPartyDeleteOne {
	return c.DeleteOneID(autp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppUserThirdPartyClient) DeleteOneID(id uint32) *AppUserThirdPartyDeleteOne {
	builder := c.Delete().Where(appuserthirdparty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppUserThirdPartyDeleteOne{builder}
}

// Query returns a query builder for AppUserThirdParty.
func (c *AppUserThirdPartyClient) Query() *AppUserThirdPartyQuery {
	return &AppUserThirdPartyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppUserThirdParty},
		inters: c.Interceptors(),
	}
}

// Get returns a AppUserThirdParty entity by its id.
func (c *AppUserThirdPartyClient) Get(ctx context.Context, id uint32) (*AppUserThirdParty, error) {
	return c.Query().Where(appuserthirdparty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppUserThirdPartyClient) GetX(ctx context.Context, id uint32) *AppUserThirdParty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppUserThirdPartyClient) Hooks() []Hook {
	return c.hooks.AppUserThirdParty
}

// Interceptors returns the client interceptors.
func (c *AppUserThirdPartyClient) Interceptors() []Interceptor {
	return c.inters.AppUserThirdParty
}

func (c *AppUserThirdPartyClient) mutate(ctx context.Context, m *AppUserThirdPartyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppUserThirdPartyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUserThirdPartyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUserThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppUserThirdPartyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AppUserThirdParty mutation op: %q", m.Op())
	}
}

// AuthClient is a client for the Auth schema.
type AuthClient struct {
	config
}

// NewAuthClient returns a client for the Auth from the given config.
func NewAuthClient(c config) *AuthClient {
	return &AuthClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auth.Hooks(f(g(h())))`.
func (c *AuthClient) Use(hooks ...Hook) {
	c.hooks.Auth = append(c.hooks.Auth, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auth.Intercept(f(g(h())))`.
func (c *AuthClient) Intercept(interceptors ...Interceptor) {
	c.inters.Auth = append(c.inters.Auth, interceptors...)
}

// Create returns a builder for creating a Auth entity.
func (c *AuthClient) Create() *AuthCreate {
	mutation := newAuthMutation(c.config, OpCreate)
	return &AuthCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Auth entities.
func (c *AuthClient) CreateBulk(builders ...*AuthCreate) *AuthCreateBulk {
	return &AuthCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthClient) MapCreateBulk(slice any, setFunc func(*AuthCreate, int)) *AuthCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthCreateBulk{err: fmt.Errorf("calling to AuthClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Auth.
func (c *AuthClient) Update() *AuthUpdate {
	mutation := newAuthMutation(c.config, OpUpdate)
	return &AuthUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthClient) UpdateOne(a *Auth) *AuthUpdateOne {
	mutation := newAuthMutation(c.config, OpUpdateOne, withAuth(a))
	return &AuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthClient) UpdateOneID(id uint32) *AuthUpdateOne {
	mutation := newAuthMutation(c.config, OpUpdateOne, withAuthID(id))
	return &AuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Auth.
func (c *AuthClient) Delete() *AuthDelete {
	mutation := newAuthMutation(c.config, OpDelete)
	return &AuthDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthClient) DeleteOne(a *Auth) *AuthDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthClient) DeleteOneID(id uint32) *AuthDeleteOne {
	builder := c.Delete().Where(auth.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthDeleteOne{builder}
}

// Query returns a query builder for Auth.
func (c *AuthClient) Query() *AuthQuery {
	return &AuthQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuth},
		inters: c.Interceptors(),
	}
}

// Get returns a Auth entity by its id.
func (c *AuthClient) Get(ctx context.Context, id uint32) (*Auth, error) {
	return c.Query().Where(auth.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthClient) GetX(ctx context.Context, id uint32) *Auth {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthClient) Hooks() []Hook {
	return c.hooks.Auth
}

// Interceptors returns the client interceptors.
func (c *AuthClient) Interceptors() []Interceptor {
	return c.inters.Auth
}

func (c *AuthClient) mutate(ctx context.Context, m *AuthMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Auth mutation op: %q", m.Op())
	}
}

// AuthHistoryClient is a client for the AuthHistory schema.
type AuthHistoryClient struct {
	config
}

// NewAuthHistoryClient returns a client for the AuthHistory from the given config.
func NewAuthHistoryClient(c config) *AuthHistoryClient {
	return &AuthHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authhistory.Hooks(f(g(h())))`.
func (c *AuthHistoryClient) Use(hooks ...Hook) {
	c.hooks.AuthHistory = append(c.hooks.AuthHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authhistory.Intercept(f(g(h())))`.
func (c *AuthHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthHistory = append(c.inters.AuthHistory, interceptors...)
}

// Create returns a builder for creating a AuthHistory entity.
func (c *AuthHistoryClient) Create() *AuthHistoryCreate {
	mutation := newAuthHistoryMutation(c.config, OpCreate)
	return &AuthHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthHistory entities.
func (c *AuthHistoryClient) CreateBulk(builders ...*AuthHistoryCreate) *AuthHistoryCreateBulk {
	return &AuthHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthHistoryClient) MapCreateBulk(slice any, setFunc func(*AuthHistoryCreate, int)) *AuthHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthHistoryCreateBulk{err: fmt.Errorf("calling to AuthHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthHistory.
func (c *AuthHistoryClient) Update() *AuthHistoryUpdate {
	mutation := newAuthHistoryMutation(c.config, OpUpdate)
	return &AuthHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthHistoryClient) UpdateOne(ah *AuthHistory) *AuthHistoryUpdateOne {
	mutation := newAuthHistoryMutation(c.config, OpUpdateOne, withAuthHistory(ah))
	return &AuthHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthHistoryClient) UpdateOneID(id uint32) *AuthHistoryUpdateOne {
	mutation := newAuthHistoryMutation(c.config, OpUpdateOne, withAuthHistoryID(id))
	return &AuthHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthHistory.
func (c *AuthHistoryClient) Delete() *AuthHistoryDelete {
	mutation := newAuthHistoryMutation(c.config, OpDelete)
	return &AuthHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthHistoryClient) DeleteOne(ah *AuthHistory) *AuthHistoryDeleteOne {
	return c.DeleteOneID(ah.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthHistoryClient) DeleteOneID(id uint32) *AuthHistoryDeleteOne {
	builder := c.Delete().Where(authhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthHistoryDeleteOne{builder}
}

// Query returns a query builder for AuthHistory.
func (c *AuthHistoryClient) Query() *AuthHistoryQuery {
	return &AuthHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthHistory entity by its id.
func (c *AuthHistoryClient) Get(ctx context.Context, id uint32) (*AuthHistory, error) {
	return c.Query().Where(authhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthHistoryClient) GetX(ctx context.Context, id uint32) *AuthHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthHistoryClient) Hooks() []Hook {
	return c.hooks.AuthHistory
}

// Interceptors returns the client interceptors.
func (c *AuthHistoryClient) Interceptors() []Interceptor {
	return c.inters.AuthHistory
}

func (c *AuthHistoryClient) mutate(ctx context.Context, m *AuthHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AuthHistory mutation op: %q", m.Op())
	}
}

// BanAppClient is a client for the BanApp schema.
type BanAppClient struct {
	config
}

// NewBanAppClient returns a client for the BanApp from the given config.
func NewBanAppClient(c config) *BanAppClient {
	return &BanAppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `banapp.Hooks(f(g(h())))`.
func (c *BanAppClient) Use(hooks ...Hook) {
	c.hooks.BanApp = append(c.hooks.BanApp, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `banapp.Intercept(f(g(h())))`.
func (c *BanAppClient) Intercept(interceptors ...Interceptor) {
	c.inters.BanApp = append(c.inters.BanApp, interceptors...)
}

// Create returns a builder for creating a BanApp entity.
func (c *BanAppClient) Create() *BanAppCreate {
	mutation := newBanAppMutation(c.config, OpCreate)
	return &BanAppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BanApp entities.
func (c *BanAppClient) CreateBulk(builders ...*BanAppCreate) *BanAppCreateBulk {
	return &BanAppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BanAppClient) MapCreateBulk(slice any, setFunc func(*BanAppCreate, int)) *BanAppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BanAppCreateBulk{err: fmt.Errorf("calling to BanAppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BanAppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BanAppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BanApp.
func (c *BanAppClient) Update() *BanAppUpdate {
	mutation := newBanAppMutation(c.config, OpUpdate)
	return &BanAppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BanAppClient) UpdateOne(ba *BanApp) *BanAppUpdateOne {
	mutation := newBanAppMutation(c.config, OpUpdateOne, withBanApp(ba))
	return &BanAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BanAppClient) UpdateOneID(id uint32) *BanAppUpdateOne {
	mutation := newBanAppMutation(c.config, OpUpdateOne, withBanAppID(id))
	return &BanAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BanApp.
func (c *BanAppClient) Delete() *BanAppDelete {
	mutation := newBanAppMutation(c.config, OpDelete)
	return &BanAppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BanAppClient) DeleteOne(ba *BanApp) *BanAppDeleteOne {
	return c.DeleteOneID(ba.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BanAppClient) DeleteOneID(id uint32) *BanAppDeleteOne {
	builder := c.Delete().Where(banapp.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BanAppDeleteOne{builder}
}

// Query returns a query builder for BanApp.
func (c *BanAppClient) Query() *BanAppQuery {
	return &BanAppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBanApp},
		inters: c.Interceptors(),
	}
}

// Get returns a BanApp entity by its id.
func (c *BanAppClient) Get(ctx context.Context, id uint32) (*BanApp, error) {
	return c.Query().Where(banapp.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BanAppClient) GetX(ctx context.Context, id uint32) *BanApp {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BanAppClient) Hooks() []Hook {
	return c.hooks.BanApp
}

// Interceptors returns the client interceptors.
func (c *BanAppClient) Interceptors() []Interceptor {
	return c.inters.BanApp
}

func (c *BanAppClient) mutate(ctx context.Context, m *BanAppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BanAppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BanAppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BanAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BanAppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown BanApp mutation op: %q", m.Op())
	}
}

// BanAppUserClient is a client for the BanAppUser schema.
type BanAppUserClient struct {
	config
}

// NewBanAppUserClient returns a client for the BanAppUser from the given config.
func NewBanAppUserClient(c config) *BanAppUserClient {
	return &BanAppUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `banappuser.Hooks(f(g(h())))`.
func (c *BanAppUserClient) Use(hooks ...Hook) {
	c.hooks.BanAppUser = append(c.hooks.BanAppUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `banappuser.Intercept(f(g(h())))`.
func (c *BanAppUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.BanAppUser = append(c.inters.BanAppUser, interceptors...)
}

// Create returns a builder for creating a BanAppUser entity.
func (c *BanAppUserClient) Create() *BanAppUserCreate {
	mutation := newBanAppUserMutation(c.config, OpCreate)
	return &BanAppUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BanAppUser entities.
func (c *BanAppUserClient) CreateBulk(builders ...*BanAppUserCreate) *BanAppUserCreateBulk {
	return &BanAppUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BanAppUserClient) MapCreateBulk(slice any, setFunc func(*BanAppUserCreate, int)) *BanAppUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BanAppUserCreateBulk{err: fmt.Errorf("calling to BanAppUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BanAppUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BanAppUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BanAppUser.
func (c *BanAppUserClient) Update() *BanAppUserUpdate {
	mutation := newBanAppUserMutation(c.config, OpUpdate)
	return &BanAppUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BanAppUserClient) UpdateOne(bau *BanAppUser) *BanAppUserUpdateOne {
	mutation := newBanAppUserMutation(c.config, OpUpdateOne, withBanAppUser(bau))
	return &BanAppUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BanAppUserClient) UpdateOneID(id uint32) *BanAppUserUpdateOne {
	mutation := newBanAppUserMutation(c.config, OpUpdateOne, withBanAppUserID(id))
	return &BanAppUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BanAppUser.
func (c *BanAppUserClient) Delete() *BanAppUserDelete {
	mutation := newBanAppUserMutation(c.config, OpDelete)
	return &BanAppUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BanAppUserClient) DeleteOne(bau *BanAppUser) *BanAppUserDeleteOne {
	return c.DeleteOneID(bau.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BanAppUserClient) DeleteOneID(id uint32) *BanAppUserDeleteOne {
	builder := c.Delete().Where(banappuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BanAppUserDeleteOne{builder}
}

// Query returns a query builder for BanAppUser.
func (c *BanAppUserClient) Query() *BanAppUserQuery {
	return &BanAppUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBanAppUser},
		inters: c.Interceptors(),
	}
}

// Get returns a BanAppUser entity by its id.
func (c *BanAppUserClient) Get(ctx context.Context, id uint32) (*BanAppUser, error) {
	return c.Query().Where(banappuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BanAppUserClient) GetX(ctx context.Context, id uint32) *BanAppUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BanAppUserClient) Hooks() []Hook {
	return c.hooks.BanAppUser
}

// Interceptors returns the client interceptors.
func (c *BanAppUserClient) Interceptors() []Interceptor {
	return c.inters.BanAppUser
}

func (c *BanAppUserClient) mutate(ctx context.Context, m *BanAppUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BanAppUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BanAppUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BanAppUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BanAppUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown BanAppUser mutation op: %q", m.Op())
	}
}

// KycClient is a client for the Kyc schema.
type KycClient struct {
	config
}

// NewKycClient returns a client for the Kyc from the given config.
func NewKycClient(c config) *KycClient {
	return &KycClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `kyc.Hooks(f(g(h())))`.
func (c *KycClient) Use(hooks ...Hook) {
	c.hooks.Kyc = append(c.hooks.Kyc, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `kyc.Intercept(f(g(h())))`.
func (c *KycClient) Intercept(interceptors ...Interceptor) {
	c.inters.Kyc = append(c.inters.Kyc, interceptors...)
}

// Create returns a builder for creating a Kyc entity.
func (c *KycClient) Create() *KycCreate {
	mutation := newKycMutation(c.config, OpCreate)
	return &KycCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Kyc entities.
func (c *KycClient) CreateBulk(builders ...*KycCreate) *KycCreateBulk {
	return &KycCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KycClient) MapCreateBulk(slice any, setFunc func(*KycCreate, int)) *KycCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KycCreateBulk{err: fmt.Errorf("calling to KycClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KycCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KycCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Kyc.
func (c *KycClient) Update() *KycUpdate {
	mutation := newKycMutation(c.config, OpUpdate)
	return &KycUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KycClient) UpdateOne(k *Kyc) *KycUpdateOne {
	mutation := newKycMutation(c.config, OpUpdateOne, withKyc(k))
	return &KycUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KycClient) UpdateOneID(id uint32) *KycUpdateOne {
	mutation := newKycMutation(c.config, OpUpdateOne, withKycID(id))
	return &KycUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Kyc.
func (c *KycClient) Delete() *KycDelete {
	mutation := newKycMutation(c.config, OpDelete)
	return &KycDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KycClient) DeleteOne(k *Kyc) *KycDeleteOne {
	return c.DeleteOneID(k.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KycClient) DeleteOneID(id uint32) *KycDeleteOne {
	builder := c.Delete().Where(kyc.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KycDeleteOne{builder}
}

// Query returns a query builder for Kyc.
func (c *KycClient) Query() *KycQuery {
	return &KycQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKyc},
		inters: c.Interceptors(),
	}
}

// Get returns a Kyc entity by its id.
func (c *KycClient) Get(ctx context.Context, id uint32) (*Kyc, error) {
	return c.Query().Where(kyc.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KycClient) GetX(ctx context.Context, id uint32) *Kyc {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *KycClient) Hooks() []Hook {
	return c.hooks.Kyc
}

// Interceptors returns the client interceptors.
func (c *KycClient) Interceptors() []Interceptor {
	return c.inters.Kyc
}

func (c *KycClient) mutate(ctx context.Context, m *KycMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KycCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KycUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KycUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KycDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Kyc mutation op: %q", m.Op())
	}
}

// LoginHistoryClient is a client for the LoginHistory schema.
type LoginHistoryClient struct {
	config
}

// NewLoginHistoryClient returns a client for the LoginHistory from the given config.
func NewLoginHistoryClient(c config) *LoginHistoryClient {
	return &LoginHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginhistory.Hooks(f(g(h())))`.
func (c *LoginHistoryClient) Use(hooks ...Hook) {
	c.hooks.LoginHistory = append(c.hooks.LoginHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginhistory.Intercept(f(g(h())))`.
func (c *LoginHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginHistory = append(c.inters.LoginHistory, interceptors...)
}

// Create returns a builder for creating a LoginHistory entity.
func (c *LoginHistoryClient) Create() *LoginHistoryCreate {
	mutation := newLoginHistoryMutation(c.config, OpCreate)
	return &LoginHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginHistory entities.
func (c *LoginHistoryClient) CreateBulk(builders ...*LoginHistoryCreate) *LoginHistoryCreateBulk {
	return &LoginHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginHistoryClient) MapCreateBulk(slice any, setFunc func(*LoginHistoryCreate, int)) *LoginHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginHistoryCreateBulk{err: fmt.Errorf("calling to LoginHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginHistory.
func (c *LoginHistoryClient) Update() *LoginHistoryUpdate {
	mutation := newLoginHistoryMutation(c.config, OpUpdate)
	return &LoginHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginHistoryClient) UpdateOne(lh *LoginHistory) *LoginHistoryUpdateOne {
	mutation := newLoginHistoryMutation(c.config, OpUpdateOne, withLoginHistory(lh))
	return &LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginHistoryClient) UpdateOneID(id uint32) *LoginHistoryUpdateOne {
	mutation := newLoginHistoryMutation(c.config, OpUpdateOne, withLoginHistoryID(id))
	return &LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginHistory.
func (c *LoginHistoryClient) Delete() *LoginHistoryDelete {
	mutation := newLoginHistoryMutation(c.config, OpDelete)
	return &LoginHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginHistoryClient) DeleteOne(lh *LoginHistory) *LoginHistoryDeleteOne {
	return c.DeleteOneID(lh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginHistoryClient) DeleteOneID(id uint32) *LoginHistoryDeleteOne {
	builder := c.Delete().Where(loginhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginHistoryDeleteOne{builder}
}

// Query returns a query builder for LoginHistory.
func (c *LoginHistoryClient) Query() *LoginHistoryQuery {
	return &LoginHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginHistory entity by its id.
func (c *LoginHistoryClient) Get(ctx context.Context, id uint32) (*LoginHistory, error) {
	return c.Query().Where(loginhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginHistoryClient) GetX(ctx context.Context, id uint32) *LoginHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LoginHistoryClient) Hooks() []Hook {
	return c.hooks.LoginHistory
}

// Interceptors returns the client interceptors.
func (c *LoginHistoryClient) Interceptors() []Interceptor {
	return c.inters.LoginHistory
}

func (c *LoginHistoryClient) mutate(ctx context.Context, m *LoginHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown LoginHistory mutation op: %q", m.Op())
	}
}

// OAuthThirdPartyClient is a client for the OAuthThirdParty schema.
type OAuthThirdPartyClient struct {
	config
}

// NewOAuthThirdPartyClient returns a client for the OAuthThirdParty from the given config.
func NewOAuthThirdPartyClient(c config) *OAuthThirdPartyClient {
	return &OAuthThirdPartyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauththirdparty.Hooks(f(g(h())))`.
func (c *OAuthThirdPartyClient) Use(hooks ...Hook) {
	c.hooks.OAuthThirdParty = append(c.hooks.OAuthThirdParty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauththirdparty.Intercept(f(g(h())))`.
func (c *OAuthThirdPartyClient) Intercept(interceptors ...Interceptor) {
	c.inters.OAuthThirdParty = append(c.inters.OAuthThirdParty, interceptors...)
}

// Create returns a builder for creating a OAuthThirdParty entity.
func (c *OAuthThirdPartyClient) Create() *OAuthThirdPartyCreate {
	mutation := newOAuthThirdPartyMutation(c.config, OpCreate)
	return &OAuthThirdPartyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OAuthThirdParty entities.
func (c *OAuthThirdPartyClient) CreateBulk(builders ...*OAuthThirdPartyCreate) *OAuthThirdPartyCreateBulk {
	return &OAuthThirdPartyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OAuthThirdPartyClient) MapCreateBulk(slice any, setFunc func(*OAuthThirdPartyCreate, int)) *OAuthThirdPartyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OAuthThirdPartyCreateBulk{err: fmt.Errorf("calling to OAuthThirdPartyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OAuthThirdPartyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OAuthThirdPartyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OAuthThirdParty.
func (c *OAuthThirdPartyClient) Update() *OAuthThirdPartyUpdate {
	mutation := newOAuthThirdPartyMutation(c.config, OpUpdate)
	return &OAuthThirdPartyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OAuthThirdPartyClient) UpdateOne(otp *OAuthThirdParty) *OAuthThirdPartyUpdateOne {
	mutation := newOAuthThirdPartyMutation(c.config, OpUpdateOne, withOAuthThirdParty(otp))
	return &OAuthThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OAuthThirdPartyClient) UpdateOneID(id uint32) *OAuthThirdPartyUpdateOne {
	mutation := newOAuthThirdPartyMutation(c.config, OpUpdateOne, withOAuthThirdPartyID(id))
	return &OAuthThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OAuthThirdParty.
func (c *OAuthThirdPartyClient) Delete() *OAuthThirdPartyDelete {
	mutation := newOAuthThirdPartyMutation(c.config, OpDelete)
	return &OAuthThirdPartyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OAuthThirdPartyClient) DeleteOne(otp *OAuthThirdParty) *OAuthThirdPartyDeleteOne {
	return c.DeleteOneID(otp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OAuthThirdPartyClient) DeleteOneID(id uint32) *OAuthThirdPartyDeleteOne {
	builder := c.Delete().Where(oauththirdparty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OAuthThirdPartyDeleteOne{builder}
}

// Query returns a query builder for OAuthThirdParty.
func (c *OAuthThirdPartyClient) Query() *OAuthThirdPartyQuery {
	return &OAuthThirdPartyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOAuthThirdParty},
		inters: c.Interceptors(),
	}
}

// Get returns a OAuthThirdParty entity by its id.
func (c *OAuthThirdPartyClient) Get(ctx context.Context, id uint32) (*OAuthThirdParty, error) {
	return c.Query().Where(oauththirdparty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OAuthThirdPartyClient) GetX(ctx context.Context, id uint32) *OAuthThirdParty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OAuthThirdPartyClient) Hooks() []Hook {
	return c.hooks.OAuthThirdParty
}

// Interceptors returns the client interceptors.
func (c *OAuthThirdPartyClient) Interceptors() []Interceptor {
	return c.inters.OAuthThirdParty
}

func (c *OAuthThirdPartyClient) mutate(ctx context.Context, m *OAuthThirdPartyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OAuthThirdPartyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OAuthThirdPartyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OAuthThirdPartyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OAuthThirdPartyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OAuthThirdParty mutation op: %q", m.Op())
	}
}

// RecoveryCodeClient is a client for the RecoveryCode schema.
type RecoveryCodeClient struct {
	config
}

// NewRecoveryCodeClient returns a client for the RecoveryCode from the given config.
func NewRecoveryCodeClient(c config) *RecoveryCodeClient {
	return &RecoveryCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `recoverycode.Hooks(f(g(h())))`.
func (c *RecoveryCodeClient) Use(hooks ...Hook) {
	c.hooks.RecoveryCode = append(c.hooks.RecoveryCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `recoverycode.Intercept(f(g(h())))`.
func (c *RecoveryCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.RecoveryCode = append(c.inters.RecoveryCode, interceptors...)
}

// Create returns a builder for creating a RecoveryCode entity.
func (c *RecoveryCodeClient) Create() *RecoveryCodeCreate {
	mutation := newRecoveryCodeMutation(c.config, OpCreate)
	return &RecoveryCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RecoveryCode entities.
func (c *RecoveryCodeClient) CreateBulk(builders ...*RecoveryCodeCreate) *RecoveryCodeCreateBulk {
	return &RecoveryCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RecoveryCodeClient) MapCreateBulk(slice any, setFunc func(*RecoveryCodeCreate, int)) *RecoveryCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RecoveryCodeCreateBulk{err: fmt.Errorf("calling to RecoveryCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RecoveryCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RecoveryCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RecoveryCode.
func (c *RecoveryCodeClient) Update() *RecoveryCodeUpdate {
	mutation := newRecoveryCodeMutation(c.config, OpUpdate)
	return &RecoveryCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RecoveryCodeClient) UpdateOne(rc *RecoveryCode) *RecoveryCodeUpdateOne {
	mutation := newRecoveryCodeMutation(c.config, OpUpdateOne, withRecoveryCode(rc))
	return &RecoveryCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RecoveryCodeClient) UpdateOneID(id uint32) *RecoveryCodeUpdateOne {
	mutation := newRecoveryCodeMutation(c.config, OpUpdateOne, withRecoveryCodeID(id))
	return &RecoveryCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RecoveryCode.
func (c *RecoveryCodeClient) Delete() *RecoveryCodeDelete {
	mutation := newRecoveryCodeMutation(c.config, OpDelete)
	return &RecoveryCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RecoveryCodeClient) DeleteOne(rc *RecoveryCode) *RecoveryCodeDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RecoveryCodeClient) DeleteOneID(id uint32) *RecoveryCodeDeleteOne {
	builder := c.Delete().Where(recoverycode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RecoveryCodeDeleteOne{builder}
}

// Query returns a query builder for RecoveryCode.
func (c *RecoveryCodeClient) Query() *RecoveryCodeQuery {
	return &RecoveryCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRecoveryCode},
		inters: c.Interceptors(),
	}
}

// Get returns a RecoveryCode entity by its id.
func (c *RecoveryCodeClient) Get(ctx context.Context, id uint32) (*RecoveryCode, error) {
	return c.Query().Where(recoverycode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RecoveryCodeClient) GetX(ctx context.Context, id uint32) *RecoveryCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RecoveryCodeClient) Hooks() []Hook {
	return c.hooks.RecoveryCode
}

// Interceptors returns the client interceptors.
func (c *RecoveryCodeClient) Interceptors() []Interceptor {
	return c.inters.RecoveryCode
}

func (c *RecoveryCodeClient) mutate(ctx context.Context, m *RecoveryCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RecoveryCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RecoveryCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RecoveryCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RecoveryCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown RecoveryCode mutation op: %q", m.Op())
	}
}

// SubscriberClient is a client for the Subscriber schema.
type SubscriberClient struct {
	config
}

// NewSubscriberClient returns a client for the Subscriber from the given config.
func NewSubscriberClient(c config) *SubscriberClient {
	return &SubscriberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscriber.Hooks(f(g(h())))`.
func (c *SubscriberClient) Use(hooks ...Hook) {
	c.hooks.Subscriber = append(c.hooks.Subscriber, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscriber.Intercept(f(g(h())))`.
func (c *SubscriberClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscriber = append(c.inters.Subscriber, interceptors...)
}

// Create returns a builder for creating a Subscriber entity.
func (c *SubscriberClient) Create() *SubscriberCreate {
	mutation := newSubscriberMutation(c.config, OpCreate)
	return &SubscriberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscriber entities.
func (c *SubscriberClient) CreateBulk(builders ...*SubscriberCreate) *SubscriberCreateBulk {
	return &SubscriberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriberClient) MapCreateBulk(slice any, setFunc func(*SubscriberCreate, int)) *SubscriberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriberCreateBulk{err: fmt.Errorf("calling to SubscriberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscriber.
func (c *SubscriberClient) Update() *SubscriberUpdate {
	mutation := newSubscriberMutation(c.config, OpUpdate)
	return &SubscriberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriberClient) UpdateOne(s *Subscriber) *SubscriberUpdateOne {
	mutation := newSubscriberMutation(c.config, OpUpdateOne, withSubscriber(s))
	return &SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriberClient) UpdateOneID(id uint32) *SubscriberUpdateOne {
	mutation := newSubscriberMutation(c.config, OpUpdateOne, withSubscriberID(id))
	return &SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscriber.
func (c *SubscriberClient) Delete() *SubscriberDelete {
	mutation := newSubscriberMutation(c.config, OpDelete)
	return &SubscriberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriberClient) DeleteOne(s *Subscriber) *SubscriberDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriberClient) DeleteOneID(id uint32) *SubscriberDeleteOne {
	builder := c.Delete().Where(subscriber.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriberDeleteOne{builder}
}

// Query returns a query builder for Subscriber.
func (c *SubscriberClient) Query() *SubscriberQuery {
	return &SubscriberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscriber},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscriber entity by its id.
func (c *SubscriberClient) Get(ctx context.Context, id uint32) (*Subscriber, error) {
	return c.Query().Where(subscriber.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriberClient) GetX(ctx context.Context, id uint32) *Subscriber {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SubscriberClient) Hooks() []Hook {
	return c.hooks.Subscriber
}

// Interceptors returns the client interceptors.
func (c *SubscriberClient) Interceptors() []Interceptor {
	return c.inters.Subscriber
}

func (c *SubscriberClient) mutate(ctx context.Context, m *SubscriberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Subscriber mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		App, AppControl, AppOAuthThirdParty, AppRole, AppRoleUser, AppSubscribe,
		AppUser, AppUserControl, AppUserExtra, AppUserSecret, AppUserThirdParty, Auth,
		AuthHistory, BanApp, BanAppUser, Kyc, LoginHistory, OAuthThirdParty,
		RecoveryCode, Subscriber []ent.Hook
	}
	inters struct {
		App, AppControl, AppOAuthThirdParty, AppRole, AppRoleUser, AppSubscribe,
		AppUser, AppUserControl, AppUserExtra, AppUserSecret, AppUserThirdParty, Auth,
		AuthHistory, BanApp, BanAppUser, Kyc, LoginHistory, OAuthThirdParty,
		RecoveryCode, Subscriber []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
